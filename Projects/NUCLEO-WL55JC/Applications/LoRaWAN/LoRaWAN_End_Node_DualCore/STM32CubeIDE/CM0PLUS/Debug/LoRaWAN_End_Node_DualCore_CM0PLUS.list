
LoRaWAN_End_Node_DualCore_CM0PLUS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08020000  08020000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000147b8  080200c0  080200c0  000100c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000105c  08034878  08034878  00024878  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .USER_embedded_Keys 000001d0  080358d4  080358d4  000258d4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  08035aa4  08035aa4  00039680  2**0
                  CONTENTS
  5 .ARM          00000008  08035aa4  08035aa4  00025aa4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  08035aac  08035aac  00039680  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  08035aac  08035aac  00025aac  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000004  08035ab0  08035ab0  00025ab0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .data         000000f8  2000a000  08035ab4  0002a000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 10 .MB_MEM2      00000680  20009000  08035bac  00039000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .bss          00001c9c  2000a0f8  2000a0f8  0003a0f8  2**2
                  ALLOC
 12 ._user_heap_stack 00001404  2000bd94  2000bd94  0003a0f8  2**0
                  ALLOC
 13 .ARM.attributes 00000028  00000000  00000000  00039680  2**0
                  CONTENTS, READONLY
 14 .debug_info   00085e18  00000000  00000000  000396a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000f651  00000000  00000000  000bf4c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00003040  00000000  00000000  000ceb18  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00003220  00000000  00000000  000d1b58  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  000338de  00000000  00000000  000d4d78  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00066e1b  00000000  00000000  00108656  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000dd607  00000000  00000000  0016f471  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000053  00000000  00000000  0024ca78  2**0
                  CONTENTS, READONLY
 22 .debug_frame  000081cc  00000000  00000000  0024cacc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_loc    0002c41d  00000000  00000000  00254c98  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080200c0 <__do_global_dtors_aux>:
 80200c0:	b510      	push	{r4, lr}
 80200c2:	4c06      	ldr	r4, [pc, #24]	; (80200dc <__do_global_dtors_aux+0x1c>)
 80200c4:	7823      	ldrb	r3, [r4, #0]
 80200c6:	2b00      	cmp	r3, #0
 80200c8:	d107      	bne.n	80200da <__do_global_dtors_aux+0x1a>
 80200ca:	4b05      	ldr	r3, [pc, #20]	; (80200e0 <__do_global_dtors_aux+0x20>)
 80200cc:	2b00      	cmp	r3, #0
 80200ce:	d002      	beq.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d0:	4804      	ldr	r0, [pc, #16]	; (80200e4 <__do_global_dtors_aux+0x24>)
 80200d2:	e000      	b.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d4:	bf00      	nop
 80200d6:	2301      	movs	r3, #1
 80200d8:	7023      	strb	r3, [r4, #0]
 80200da:	bd10      	pop	{r4, pc}
 80200dc:	2000a0f8 	.word	0x2000a0f8
 80200e0:	00000000 	.word	0x00000000
 80200e4:	0803484c 	.word	0x0803484c

080200e8 <frame_dummy>:
 80200e8:	4b04      	ldr	r3, [pc, #16]	; (80200fc <frame_dummy+0x14>)
 80200ea:	b510      	push	{r4, lr}
 80200ec:	2b00      	cmp	r3, #0
 80200ee:	d003      	beq.n	80200f8 <frame_dummy+0x10>
 80200f0:	4903      	ldr	r1, [pc, #12]	; (8020100 <frame_dummy+0x18>)
 80200f2:	4804      	ldr	r0, [pc, #16]	; (8020104 <frame_dummy+0x1c>)
 80200f4:	e000      	b.n	80200f8 <frame_dummy+0x10>
 80200f6:	bf00      	nop
 80200f8:	bd10      	pop	{r4, pc}
 80200fa:	46c0      	nop			; (mov r8, r8)
 80200fc:	00000000 	.word	0x00000000
 8020100:	2000a0fc 	.word	0x2000a0fc
 8020104:	0803484c 	.word	0x0803484c

08020108 <strlen>:
 8020108:	2300      	movs	r3, #0
 802010a:	5cc2      	ldrb	r2, [r0, r3]
 802010c:	3301      	adds	r3, #1
 802010e:	2a00      	cmp	r2, #0
 8020110:	d1fb      	bne.n	802010a <strlen+0x2>
 8020112:	1e58      	subs	r0, r3, #1
 8020114:	4770      	bx	lr
	...

08020118 <__udivsi3>:
 8020118:	2200      	movs	r2, #0
 802011a:	0843      	lsrs	r3, r0, #1
 802011c:	428b      	cmp	r3, r1
 802011e:	d374      	bcc.n	802020a <__udivsi3+0xf2>
 8020120:	0903      	lsrs	r3, r0, #4
 8020122:	428b      	cmp	r3, r1
 8020124:	d35f      	bcc.n	80201e6 <__udivsi3+0xce>
 8020126:	0a03      	lsrs	r3, r0, #8
 8020128:	428b      	cmp	r3, r1
 802012a:	d344      	bcc.n	80201b6 <__udivsi3+0x9e>
 802012c:	0b03      	lsrs	r3, r0, #12
 802012e:	428b      	cmp	r3, r1
 8020130:	d328      	bcc.n	8020184 <__udivsi3+0x6c>
 8020132:	0c03      	lsrs	r3, r0, #16
 8020134:	428b      	cmp	r3, r1
 8020136:	d30d      	bcc.n	8020154 <__udivsi3+0x3c>
 8020138:	22ff      	movs	r2, #255	; 0xff
 802013a:	0209      	lsls	r1, r1, #8
 802013c:	ba12      	rev	r2, r2
 802013e:	0c03      	lsrs	r3, r0, #16
 8020140:	428b      	cmp	r3, r1
 8020142:	d302      	bcc.n	802014a <__udivsi3+0x32>
 8020144:	1212      	asrs	r2, r2, #8
 8020146:	0209      	lsls	r1, r1, #8
 8020148:	d065      	beq.n	8020216 <__udivsi3+0xfe>
 802014a:	0b03      	lsrs	r3, r0, #12
 802014c:	428b      	cmp	r3, r1
 802014e:	d319      	bcc.n	8020184 <__udivsi3+0x6c>
 8020150:	e000      	b.n	8020154 <__udivsi3+0x3c>
 8020152:	0a09      	lsrs	r1, r1, #8
 8020154:	0bc3      	lsrs	r3, r0, #15
 8020156:	428b      	cmp	r3, r1
 8020158:	d301      	bcc.n	802015e <__udivsi3+0x46>
 802015a:	03cb      	lsls	r3, r1, #15
 802015c:	1ac0      	subs	r0, r0, r3
 802015e:	4152      	adcs	r2, r2
 8020160:	0b83      	lsrs	r3, r0, #14
 8020162:	428b      	cmp	r3, r1
 8020164:	d301      	bcc.n	802016a <__udivsi3+0x52>
 8020166:	038b      	lsls	r3, r1, #14
 8020168:	1ac0      	subs	r0, r0, r3
 802016a:	4152      	adcs	r2, r2
 802016c:	0b43      	lsrs	r3, r0, #13
 802016e:	428b      	cmp	r3, r1
 8020170:	d301      	bcc.n	8020176 <__udivsi3+0x5e>
 8020172:	034b      	lsls	r3, r1, #13
 8020174:	1ac0      	subs	r0, r0, r3
 8020176:	4152      	adcs	r2, r2
 8020178:	0b03      	lsrs	r3, r0, #12
 802017a:	428b      	cmp	r3, r1
 802017c:	d301      	bcc.n	8020182 <__udivsi3+0x6a>
 802017e:	030b      	lsls	r3, r1, #12
 8020180:	1ac0      	subs	r0, r0, r3
 8020182:	4152      	adcs	r2, r2
 8020184:	0ac3      	lsrs	r3, r0, #11
 8020186:	428b      	cmp	r3, r1
 8020188:	d301      	bcc.n	802018e <__udivsi3+0x76>
 802018a:	02cb      	lsls	r3, r1, #11
 802018c:	1ac0      	subs	r0, r0, r3
 802018e:	4152      	adcs	r2, r2
 8020190:	0a83      	lsrs	r3, r0, #10
 8020192:	428b      	cmp	r3, r1
 8020194:	d301      	bcc.n	802019a <__udivsi3+0x82>
 8020196:	028b      	lsls	r3, r1, #10
 8020198:	1ac0      	subs	r0, r0, r3
 802019a:	4152      	adcs	r2, r2
 802019c:	0a43      	lsrs	r3, r0, #9
 802019e:	428b      	cmp	r3, r1
 80201a0:	d301      	bcc.n	80201a6 <__udivsi3+0x8e>
 80201a2:	024b      	lsls	r3, r1, #9
 80201a4:	1ac0      	subs	r0, r0, r3
 80201a6:	4152      	adcs	r2, r2
 80201a8:	0a03      	lsrs	r3, r0, #8
 80201aa:	428b      	cmp	r3, r1
 80201ac:	d301      	bcc.n	80201b2 <__udivsi3+0x9a>
 80201ae:	020b      	lsls	r3, r1, #8
 80201b0:	1ac0      	subs	r0, r0, r3
 80201b2:	4152      	adcs	r2, r2
 80201b4:	d2cd      	bcs.n	8020152 <__udivsi3+0x3a>
 80201b6:	09c3      	lsrs	r3, r0, #7
 80201b8:	428b      	cmp	r3, r1
 80201ba:	d301      	bcc.n	80201c0 <__udivsi3+0xa8>
 80201bc:	01cb      	lsls	r3, r1, #7
 80201be:	1ac0      	subs	r0, r0, r3
 80201c0:	4152      	adcs	r2, r2
 80201c2:	0983      	lsrs	r3, r0, #6
 80201c4:	428b      	cmp	r3, r1
 80201c6:	d301      	bcc.n	80201cc <__udivsi3+0xb4>
 80201c8:	018b      	lsls	r3, r1, #6
 80201ca:	1ac0      	subs	r0, r0, r3
 80201cc:	4152      	adcs	r2, r2
 80201ce:	0943      	lsrs	r3, r0, #5
 80201d0:	428b      	cmp	r3, r1
 80201d2:	d301      	bcc.n	80201d8 <__udivsi3+0xc0>
 80201d4:	014b      	lsls	r3, r1, #5
 80201d6:	1ac0      	subs	r0, r0, r3
 80201d8:	4152      	adcs	r2, r2
 80201da:	0903      	lsrs	r3, r0, #4
 80201dc:	428b      	cmp	r3, r1
 80201de:	d301      	bcc.n	80201e4 <__udivsi3+0xcc>
 80201e0:	010b      	lsls	r3, r1, #4
 80201e2:	1ac0      	subs	r0, r0, r3
 80201e4:	4152      	adcs	r2, r2
 80201e6:	08c3      	lsrs	r3, r0, #3
 80201e8:	428b      	cmp	r3, r1
 80201ea:	d301      	bcc.n	80201f0 <__udivsi3+0xd8>
 80201ec:	00cb      	lsls	r3, r1, #3
 80201ee:	1ac0      	subs	r0, r0, r3
 80201f0:	4152      	adcs	r2, r2
 80201f2:	0883      	lsrs	r3, r0, #2
 80201f4:	428b      	cmp	r3, r1
 80201f6:	d301      	bcc.n	80201fc <__udivsi3+0xe4>
 80201f8:	008b      	lsls	r3, r1, #2
 80201fa:	1ac0      	subs	r0, r0, r3
 80201fc:	4152      	adcs	r2, r2
 80201fe:	0843      	lsrs	r3, r0, #1
 8020200:	428b      	cmp	r3, r1
 8020202:	d301      	bcc.n	8020208 <__udivsi3+0xf0>
 8020204:	004b      	lsls	r3, r1, #1
 8020206:	1ac0      	subs	r0, r0, r3
 8020208:	4152      	adcs	r2, r2
 802020a:	1a41      	subs	r1, r0, r1
 802020c:	d200      	bcs.n	8020210 <__udivsi3+0xf8>
 802020e:	4601      	mov	r1, r0
 8020210:	4152      	adcs	r2, r2
 8020212:	4610      	mov	r0, r2
 8020214:	4770      	bx	lr
 8020216:	e7ff      	b.n	8020218 <__udivsi3+0x100>
 8020218:	b501      	push	{r0, lr}
 802021a:	2000      	movs	r0, #0
 802021c:	f000 f8f0 	bl	8020400 <__aeabi_idiv0>
 8020220:	bd02      	pop	{r1, pc}
 8020222:	46c0      	nop			; (mov r8, r8)

08020224 <__aeabi_uidivmod>:
 8020224:	2900      	cmp	r1, #0
 8020226:	d0f7      	beq.n	8020218 <__udivsi3+0x100>
 8020228:	e776      	b.n	8020118 <__udivsi3>
 802022a:	4770      	bx	lr

0802022c <__divsi3>:
 802022c:	4603      	mov	r3, r0
 802022e:	430b      	orrs	r3, r1
 8020230:	d47f      	bmi.n	8020332 <__divsi3+0x106>
 8020232:	2200      	movs	r2, #0
 8020234:	0843      	lsrs	r3, r0, #1
 8020236:	428b      	cmp	r3, r1
 8020238:	d374      	bcc.n	8020324 <__divsi3+0xf8>
 802023a:	0903      	lsrs	r3, r0, #4
 802023c:	428b      	cmp	r3, r1
 802023e:	d35f      	bcc.n	8020300 <__divsi3+0xd4>
 8020240:	0a03      	lsrs	r3, r0, #8
 8020242:	428b      	cmp	r3, r1
 8020244:	d344      	bcc.n	80202d0 <__divsi3+0xa4>
 8020246:	0b03      	lsrs	r3, r0, #12
 8020248:	428b      	cmp	r3, r1
 802024a:	d328      	bcc.n	802029e <__divsi3+0x72>
 802024c:	0c03      	lsrs	r3, r0, #16
 802024e:	428b      	cmp	r3, r1
 8020250:	d30d      	bcc.n	802026e <__divsi3+0x42>
 8020252:	22ff      	movs	r2, #255	; 0xff
 8020254:	0209      	lsls	r1, r1, #8
 8020256:	ba12      	rev	r2, r2
 8020258:	0c03      	lsrs	r3, r0, #16
 802025a:	428b      	cmp	r3, r1
 802025c:	d302      	bcc.n	8020264 <__divsi3+0x38>
 802025e:	1212      	asrs	r2, r2, #8
 8020260:	0209      	lsls	r1, r1, #8
 8020262:	d065      	beq.n	8020330 <__divsi3+0x104>
 8020264:	0b03      	lsrs	r3, r0, #12
 8020266:	428b      	cmp	r3, r1
 8020268:	d319      	bcc.n	802029e <__divsi3+0x72>
 802026a:	e000      	b.n	802026e <__divsi3+0x42>
 802026c:	0a09      	lsrs	r1, r1, #8
 802026e:	0bc3      	lsrs	r3, r0, #15
 8020270:	428b      	cmp	r3, r1
 8020272:	d301      	bcc.n	8020278 <__divsi3+0x4c>
 8020274:	03cb      	lsls	r3, r1, #15
 8020276:	1ac0      	subs	r0, r0, r3
 8020278:	4152      	adcs	r2, r2
 802027a:	0b83      	lsrs	r3, r0, #14
 802027c:	428b      	cmp	r3, r1
 802027e:	d301      	bcc.n	8020284 <__divsi3+0x58>
 8020280:	038b      	lsls	r3, r1, #14
 8020282:	1ac0      	subs	r0, r0, r3
 8020284:	4152      	adcs	r2, r2
 8020286:	0b43      	lsrs	r3, r0, #13
 8020288:	428b      	cmp	r3, r1
 802028a:	d301      	bcc.n	8020290 <__divsi3+0x64>
 802028c:	034b      	lsls	r3, r1, #13
 802028e:	1ac0      	subs	r0, r0, r3
 8020290:	4152      	adcs	r2, r2
 8020292:	0b03      	lsrs	r3, r0, #12
 8020294:	428b      	cmp	r3, r1
 8020296:	d301      	bcc.n	802029c <__divsi3+0x70>
 8020298:	030b      	lsls	r3, r1, #12
 802029a:	1ac0      	subs	r0, r0, r3
 802029c:	4152      	adcs	r2, r2
 802029e:	0ac3      	lsrs	r3, r0, #11
 80202a0:	428b      	cmp	r3, r1
 80202a2:	d301      	bcc.n	80202a8 <__divsi3+0x7c>
 80202a4:	02cb      	lsls	r3, r1, #11
 80202a6:	1ac0      	subs	r0, r0, r3
 80202a8:	4152      	adcs	r2, r2
 80202aa:	0a83      	lsrs	r3, r0, #10
 80202ac:	428b      	cmp	r3, r1
 80202ae:	d301      	bcc.n	80202b4 <__divsi3+0x88>
 80202b0:	028b      	lsls	r3, r1, #10
 80202b2:	1ac0      	subs	r0, r0, r3
 80202b4:	4152      	adcs	r2, r2
 80202b6:	0a43      	lsrs	r3, r0, #9
 80202b8:	428b      	cmp	r3, r1
 80202ba:	d301      	bcc.n	80202c0 <__divsi3+0x94>
 80202bc:	024b      	lsls	r3, r1, #9
 80202be:	1ac0      	subs	r0, r0, r3
 80202c0:	4152      	adcs	r2, r2
 80202c2:	0a03      	lsrs	r3, r0, #8
 80202c4:	428b      	cmp	r3, r1
 80202c6:	d301      	bcc.n	80202cc <__divsi3+0xa0>
 80202c8:	020b      	lsls	r3, r1, #8
 80202ca:	1ac0      	subs	r0, r0, r3
 80202cc:	4152      	adcs	r2, r2
 80202ce:	d2cd      	bcs.n	802026c <__divsi3+0x40>
 80202d0:	09c3      	lsrs	r3, r0, #7
 80202d2:	428b      	cmp	r3, r1
 80202d4:	d301      	bcc.n	80202da <__divsi3+0xae>
 80202d6:	01cb      	lsls	r3, r1, #7
 80202d8:	1ac0      	subs	r0, r0, r3
 80202da:	4152      	adcs	r2, r2
 80202dc:	0983      	lsrs	r3, r0, #6
 80202de:	428b      	cmp	r3, r1
 80202e0:	d301      	bcc.n	80202e6 <__divsi3+0xba>
 80202e2:	018b      	lsls	r3, r1, #6
 80202e4:	1ac0      	subs	r0, r0, r3
 80202e6:	4152      	adcs	r2, r2
 80202e8:	0943      	lsrs	r3, r0, #5
 80202ea:	428b      	cmp	r3, r1
 80202ec:	d301      	bcc.n	80202f2 <__divsi3+0xc6>
 80202ee:	014b      	lsls	r3, r1, #5
 80202f0:	1ac0      	subs	r0, r0, r3
 80202f2:	4152      	adcs	r2, r2
 80202f4:	0903      	lsrs	r3, r0, #4
 80202f6:	428b      	cmp	r3, r1
 80202f8:	d301      	bcc.n	80202fe <__divsi3+0xd2>
 80202fa:	010b      	lsls	r3, r1, #4
 80202fc:	1ac0      	subs	r0, r0, r3
 80202fe:	4152      	adcs	r2, r2
 8020300:	08c3      	lsrs	r3, r0, #3
 8020302:	428b      	cmp	r3, r1
 8020304:	d301      	bcc.n	802030a <__divsi3+0xde>
 8020306:	00cb      	lsls	r3, r1, #3
 8020308:	1ac0      	subs	r0, r0, r3
 802030a:	4152      	adcs	r2, r2
 802030c:	0883      	lsrs	r3, r0, #2
 802030e:	428b      	cmp	r3, r1
 8020310:	d301      	bcc.n	8020316 <__divsi3+0xea>
 8020312:	008b      	lsls	r3, r1, #2
 8020314:	1ac0      	subs	r0, r0, r3
 8020316:	4152      	adcs	r2, r2
 8020318:	0843      	lsrs	r3, r0, #1
 802031a:	428b      	cmp	r3, r1
 802031c:	d301      	bcc.n	8020322 <__divsi3+0xf6>
 802031e:	004b      	lsls	r3, r1, #1
 8020320:	1ac0      	subs	r0, r0, r3
 8020322:	4152      	adcs	r2, r2
 8020324:	1a41      	subs	r1, r0, r1
 8020326:	d200      	bcs.n	802032a <__divsi3+0xfe>
 8020328:	4601      	mov	r1, r0
 802032a:	4152      	adcs	r2, r2
 802032c:	4610      	mov	r0, r2
 802032e:	4770      	bx	lr
 8020330:	e05d      	b.n	80203ee <__divsi3+0x1c2>
 8020332:	0fca      	lsrs	r2, r1, #31
 8020334:	d000      	beq.n	8020338 <__divsi3+0x10c>
 8020336:	4249      	negs	r1, r1
 8020338:	1003      	asrs	r3, r0, #32
 802033a:	d300      	bcc.n	802033e <__divsi3+0x112>
 802033c:	4240      	negs	r0, r0
 802033e:	4053      	eors	r3, r2
 8020340:	2200      	movs	r2, #0
 8020342:	469c      	mov	ip, r3
 8020344:	0903      	lsrs	r3, r0, #4
 8020346:	428b      	cmp	r3, r1
 8020348:	d32d      	bcc.n	80203a6 <__divsi3+0x17a>
 802034a:	0a03      	lsrs	r3, r0, #8
 802034c:	428b      	cmp	r3, r1
 802034e:	d312      	bcc.n	8020376 <__divsi3+0x14a>
 8020350:	22fc      	movs	r2, #252	; 0xfc
 8020352:	0189      	lsls	r1, r1, #6
 8020354:	ba12      	rev	r2, r2
 8020356:	0a03      	lsrs	r3, r0, #8
 8020358:	428b      	cmp	r3, r1
 802035a:	d30c      	bcc.n	8020376 <__divsi3+0x14a>
 802035c:	0189      	lsls	r1, r1, #6
 802035e:	1192      	asrs	r2, r2, #6
 8020360:	428b      	cmp	r3, r1
 8020362:	d308      	bcc.n	8020376 <__divsi3+0x14a>
 8020364:	0189      	lsls	r1, r1, #6
 8020366:	1192      	asrs	r2, r2, #6
 8020368:	428b      	cmp	r3, r1
 802036a:	d304      	bcc.n	8020376 <__divsi3+0x14a>
 802036c:	0189      	lsls	r1, r1, #6
 802036e:	d03a      	beq.n	80203e6 <__divsi3+0x1ba>
 8020370:	1192      	asrs	r2, r2, #6
 8020372:	e000      	b.n	8020376 <__divsi3+0x14a>
 8020374:	0989      	lsrs	r1, r1, #6
 8020376:	09c3      	lsrs	r3, r0, #7
 8020378:	428b      	cmp	r3, r1
 802037a:	d301      	bcc.n	8020380 <__divsi3+0x154>
 802037c:	01cb      	lsls	r3, r1, #7
 802037e:	1ac0      	subs	r0, r0, r3
 8020380:	4152      	adcs	r2, r2
 8020382:	0983      	lsrs	r3, r0, #6
 8020384:	428b      	cmp	r3, r1
 8020386:	d301      	bcc.n	802038c <__divsi3+0x160>
 8020388:	018b      	lsls	r3, r1, #6
 802038a:	1ac0      	subs	r0, r0, r3
 802038c:	4152      	adcs	r2, r2
 802038e:	0943      	lsrs	r3, r0, #5
 8020390:	428b      	cmp	r3, r1
 8020392:	d301      	bcc.n	8020398 <__divsi3+0x16c>
 8020394:	014b      	lsls	r3, r1, #5
 8020396:	1ac0      	subs	r0, r0, r3
 8020398:	4152      	adcs	r2, r2
 802039a:	0903      	lsrs	r3, r0, #4
 802039c:	428b      	cmp	r3, r1
 802039e:	d301      	bcc.n	80203a4 <__divsi3+0x178>
 80203a0:	010b      	lsls	r3, r1, #4
 80203a2:	1ac0      	subs	r0, r0, r3
 80203a4:	4152      	adcs	r2, r2
 80203a6:	08c3      	lsrs	r3, r0, #3
 80203a8:	428b      	cmp	r3, r1
 80203aa:	d301      	bcc.n	80203b0 <__divsi3+0x184>
 80203ac:	00cb      	lsls	r3, r1, #3
 80203ae:	1ac0      	subs	r0, r0, r3
 80203b0:	4152      	adcs	r2, r2
 80203b2:	0883      	lsrs	r3, r0, #2
 80203b4:	428b      	cmp	r3, r1
 80203b6:	d301      	bcc.n	80203bc <__divsi3+0x190>
 80203b8:	008b      	lsls	r3, r1, #2
 80203ba:	1ac0      	subs	r0, r0, r3
 80203bc:	4152      	adcs	r2, r2
 80203be:	d2d9      	bcs.n	8020374 <__divsi3+0x148>
 80203c0:	0843      	lsrs	r3, r0, #1
 80203c2:	428b      	cmp	r3, r1
 80203c4:	d301      	bcc.n	80203ca <__divsi3+0x19e>
 80203c6:	004b      	lsls	r3, r1, #1
 80203c8:	1ac0      	subs	r0, r0, r3
 80203ca:	4152      	adcs	r2, r2
 80203cc:	1a41      	subs	r1, r0, r1
 80203ce:	d200      	bcs.n	80203d2 <__divsi3+0x1a6>
 80203d0:	4601      	mov	r1, r0
 80203d2:	4663      	mov	r3, ip
 80203d4:	4152      	adcs	r2, r2
 80203d6:	105b      	asrs	r3, r3, #1
 80203d8:	4610      	mov	r0, r2
 80203da:	d301      	bcc.n	80203e0 <__divsi3+0x1b4>
 80203dc:	4240      	negs	r0, r0
 80203de:	2b00      	cmp	r3, #0
 80203e0:	d500      	bpl.n	80203e4 <__divsi3+0x1b8>
 80203e2:	4249      	negs	r1, r1
 80203e4:	4770      	bx	lr
 80203e6:	4663      	mov	r3, ip
 80203e8:	105b      	asrs	r3, r3, #1
 80203ea:	d300      	bcc.n	80203ee <__divsi3+0x1c2>
 80203ec:	4240      	negs	r0, r0
 80203ee:	b501      	push	{r0, lr}
 80203f0:	2000      	movs	r0, #0
 80203f2:	f000 f805 	bl	8020400 <__aeabi_idiv0>
 80203f6:	bd02      	pop	{r1, pc}

080203f8 <__aeabi_idivmod>:
 80203f8:	2900      	cmp	r1, #0
 80203fa:	d0f8      	beq.n	80203ee <__divsi3+0x1c2>
 80203fc:	e716      	b.n	802022c <__divsi3>
 80203fe:	4770      	bx	lr

08020400 <__aeabi_idiv0>:
 8020400:	4770      	bx	lr
 8020402:	46c0      	nop			; (mov r8, r8)

08020404 <__aeabi_cdrcmple>:
 8020404:	4684      	mov	ip, r0
 8020406:	1c10      	adds	r0, r2, #0
 8020408:	4662      	mov	r2, ip
 802040a:	468c      	mov	ip, r1
 802040c:	1c19      	adds	r1, r3, #0
 802040e:	4663      	mov	r3, ip
 8020410:	e000      	b.n	8020414 <__aeabi_cdcmpeq>
 8020412:	46c0      	nop			; (mov r8, r8)

08020414 <__aeabi_cdcmpeq>:
 8020414:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8020416:	f000 ff63 	bl	80212e0 <__ledf2>
 802041a:	2800      	cmp	r0, #0
 802041c:	d401      	bmi.n	8020422 <__aeabi_cdcmpeq+0xe>
 802041e:	2100      	movs	r1, #0
 8020420:	42c8      	cmn	r0, r1
 8020422:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08020424 <__aeabi_dcmpeq>:
 8020424:	b510      	push	{r4, lr}
 8020426:	f000 fead 	bl	8021184 <__eqdf2>
 802042a:	4240      	negs	r0, r0
 802042c:	3001      	adds	r0, #1
 802042e:	bd10      	pop	{r4, pc}

08020430 <__aeabi_dcmplt>:
 8020430:	b510      	push	{r4, lr}
 8020432:	f000 ff55 	bl	80212e0 <__ledf2>
 8020436:	2800      	cmp	r0, #0
 8020438:	db01      	blt.n	802043e <__aeabi_dcmplt+0xe>
 802043a:	2000      	movs	r0, #0
 802043c:	bd10      	pop	{r4, pc}
 802043e:	2001      	movs	r0, #1
 8020440:	bd10      	pop	{r4, pc}
 8020442:	46c0      	nop			; (mov r8, r8)

08020444 <__aeabi_dcmple>:
 8020444:	b510      	push	{r4, lr}
 8020446:	f000 ff4b 	bl	80212e0 <__ledf2>
 802044a:	2800      	cmp	r0, #0
 802044c:	dd01      	ble.n	8020452 <__aeabi_dcmple+0xe>
 802044e:	2000      	movs	r0, #0
 8020450:	bd10      	pop	{r4, pc}
 8020452:	2001      	movs	r0, #1
 8020454:	bd10      	pop	{r4, pc}
 8020456:	46c0      	nop			; (mov r8, r8)

08020458 <__aeabi_dcmpgt>:
 8020458:	b510      	push	{r4, lr}
 802045a:	f000 fecf 	bl	80211fc <__gedf2>
 802045e:	2800      	cmp	r0, #0
 8020460:	dc01      	bgt.n	8020466 <__aeabi_dcmpgt+0xe>
 8020462:	2000      	movs	r0, #0
 8020464:	bd10      	pop	{r4, pc}
 8020466:	2001      	movs	r0, #1
 8020468:	bd10      	pop	{r4, pc}
 802046a:	46c0      	nop			; (mov r8, r8)

0802046c <__aeabi_dcmpge>:
 802046c:	b510      	push	{r4, lr}
 802046e:	f000 fec5 	bl	80211fc <__gedf2>
 8020472:	2800      	cmp	r0, #0
 8020474:	da01      	bge.n	802047a <__aeabi_dcmpge+0xe>
 8020476:	2000      	movs	r0, #0
 8020478:	bd10      	pop	{r4, pc}
 802047a:	2001      	movs	r0, #1
 802047c:	bd10      	pop	{r4, pc}
 802047e:	46c0      	nop			; (mov r8, r8)

08020480 <__aeabi_uldivmod>:
 8020480:	2b00      	cmp	r3, #0
 8020482:	d111      	bne.n	80204a8 <__aeabi_uldivmod+0x28>
 8020484:	2a00      	cmp	r2, #0
 8020486:	d10f      	bne.n	80204a8 <__aeabi_uldivmod+0x28>
 8020488:	2900      	cmp	r1, #0
 802048a:	d100      	bne.n	802048e <__aeabi_uldivmod+0xe>
 802048c:	2800      	cmp	r0, #0
 802048e:	d002      	beq.n	8020496 <__aeabi_uldivmod+0x16>
 8020490:	2100      	movs	r1, #0
 8020492:	43c9      	mvns	r1, r1
 8020494:	1c08      	adds	r0, r1, #0
 8020496:	b407      	push	{r0, r1, r2}
 8020498:	4802      	ldr	r0, [pc, #8]	; (80204a4 <__aeabi_uldivmod+0x24>)
 802049a:	a102      	add	r1, pc, #8	; (adr r1, 80204a4 <__aeabi_uldivmod+0x24>)
 802049c:	1840      	adds	r0, r0, r1
 802049e:	9002      	str	r0, [sp, #8]
 80204a0:	bd03      	pop	{r0, r1, pc}
 80204a2:	46c0      	nop			; (mov r8, r8)
 80204a4:	ffffff5d 	.word	0xffffff5d
 80204a8:	b403      	push	{r0, r1}
 80204aa:	4668      	mov	r0, sp
 80204ac:	b501      	push	{r0, lr}
 80204ae:	9802      	ldr	r0, [sp, #8]
 80204b0:	f000 f82e 	bl	8020510 <__udivmoddi4>
 80204b4:	9b01      	ldr	r3, [sp, #4]
 80204b6:	469e      	mov	lr, r3
 80204b8:	b002      	add	sp, #8
 80204ba:	bc0c      	pop	{r2, r3}
 80204bc:	4770      	bx	lr
 80204be:	46c0      	nop			; (mov r8, r8)

080204c0 <__aeabi_lmul>:
 80204c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80204c2:	0415      	lsls	r5, r2, #16
 80204c4:	0c2d      	lsrs	r5, r5, #16
 80204c6:	000f      	movs	r7, r1
 80204c8:	0001      	movs	r1, r0
 80204ca:	002e      	movs	r6, r5
 80204cc:	46c6      	mov	lr, r8
 80204ce:	4684      	mov	ip, r0
 80204d0:	0400      	lsls	r0, r0, #16
 80204d2:	0c14      	lsrs	r4, r2, #16
 80204d4:	0c00      	lsrs	r0, r0, #16
 80204d6:	0c09      	lsrs	r1, r1, #16
 80204d8:	4346      	muls	r6, r0
 80204da:	434d      	muls	r5, r1
 80204dc:	4360      	muls	r0, r4
 80204de:	4361      	muls	r1, r4
 80204e0:	1940      	adds	r0, r0, r5
 80204e2:	0c34      	lsrs	r4, r6, #16
 80204e4:	1824      	adds	r4, r4, r0
 80204e6:	b500      	push	{lr}
 80204e8:	42a5      	cmp	r5, r4
 80204ea:	d903      	bls.n	80204f4 <__aeabi_lmul+0x34>
 80204ec:	2080      	movs	r0, #128	; 0x80
 80204ee:	0240      	lsls	r0, r0, #9
 80204f0:	4680      	mov	r8, r0
 80204f2:	4441      	add	r1, r8
 80204f4:	0c25      	lsrs	r5, r4, #16
 80204f6:	186d      	adds	r5, r5, r1
 80204f8:	4661      	mov	r1, ip
 80204fa:	4359      	muls	r1, r3
 80204fc:	437a      	muls	r2, r7
 80204fe:	0430      	lsls	r0, r6, #16
 8020500:	1949      	adds	r1, r1, r5
 8020502:	0424      	lsls	r4, r4, #16
 8020504:	0c00      	lsrs	r0, r0, #16
 8020506:	1820      	adds	r0, r4, r0
 8020508:	1889      	adds	r1, r1, r2
 802050a:	bc80      	pop	{r7}
 802050c:	46b8      	mov	r8, r7
 802050e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08020510 <__udivmoddi4>:
 8020510:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020512:	4657      	mov	r7, sl
 8020514:	464e      	mov	r6, r9
 8020516:	4645      	mov	r5, r8
 8020518:	46de      	mov	lr, fp
 802051a:	b5e0      	push	{r5, r6, r7, lr}
 802051c:	0004      	movs	r4, r0
 802051e:	000d      	movs	r5, r1
 8020520:	4692      	mov	sl, r2
 8020522:	4699      	mov	r9, r3
 8020524:	b083      	sub	sp, #12
 8020526:	428b      	cmp	r3, r1
 8020528:	d830      	bhi.n	802058c <__udivmoddi4+0x7c>
 802052a:	d02d      	beq.n	8020588 <__udivmoddi4+0x78>
 802052c:	4649      	mov	r1, r9
 802052e:	4650      	mov	r0, sl
 8020530:	f000 ffe2 	bl	80214f8 <__clzdi2>
 8020534:	0029      	movs	r1, r5
 8020536:	0006      	movs	r6, r0
 8020538:	0020      	movs	r0, r4
 802053a:	f000 ffdd 	bl	80214f8 <__clzdi2>
 802053e:	1a33      	subs	r3, r6, r0
 8020540:	4698      	mov	r8, r3
 8020542:	3b20      	subs	r3, #32
 8020544:	469b      	mov	fp, r3
 8020546:	d433      	bmi.n	80205b0 <__udivmoddi4+0xa0>
 8020548:	465a      	mov	r2, fp
 802054a:	4653      	mov	r3, sl
 802054c:	4093      	lsls	r3, r2
 802054e:	4642      	mov	r2, r8
 8020550:	001f      	movs	r7, r3
 8020552:	4653      	mov	r3, sl
 8020554:	4093      	lsls	r3, r2
 8020556:	001e      	movs	r6, r3
 8020558:	42af      	cmp	r7, r5
 802055a:	d83a      	bhi.n	80205d2 <__udivmoddi4+0xc2>
 802055c:	42af      	cmp	r7, r5
 802055e:	d100      	bne.n	8020562 <__udivmoddi4+0x52>
 8020560:	e078      	b.n	8020654 <__udivmoddi4+0x144>
 8020562:	465b      	mov	r3, fp
 8020564:	1ba4      	subs	r4, r4, r6
 8020566:	41bd      	sbcs	r5, r7
 8020568:	2b00      	cmp	r3, #0
 802056a:	da00      	bge.n	802056e <__udivmoddi4+0x5e>
 802056c:	e075      	b.n	802065a <__udivmoddi4+0x14a>
 802056e:	2200      	movs	r2, #0
 8020570:	2300      	movs	r3, #0
 8020572:	9200      	str	r2, [sp, #0]
 8020574:	9301      	str	r3, [sp, #4]
 8020576:	2301      	movs	r3, #1
 8020578:	465a      	mov	r2, fp
 802057a:	4093      	lsls	r3, r2
 802057c:	9301      	str	r3, [sp, #4]
 802057e:	2301      	movs	r3, #1
 8020580:	4642      	mov	r2, r8
 8020582:	4093      	lsls	r3, r2
 8020584:	9300      	str	r3, [sp, #0]
 8020586:	e028      	b.n	80205da <__udivmoddi4+0xca>
 8020588:	4282      	cmp	r2, r0
 802058a:	d9cf      	bls.n	802052c <__udivmoddi4+0x1c>
 802058c:	2200      	movs	r2, #0
 802058e:	2300      	movs	r3, #0
 8020590:	9200      	str	r2, [sp, #0]
 8020592:	9301      	str	r3, [sp, #4]
 8020594:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020596:	2b00      	cmp	r3, #0
 8020598:	d001      	beq.n	802059e <__udivmoddi4+0x8e>
 802059a:	601c      	str	r4, [r3, #0]
 802059c:	605d      	str	r5, [r3, #4]
 802059e:	9800      	ldr	r0, [sp, #0]
 80205a0:	9901      	ldr	r1, [sp, #4]
 80205a2:	b003      	add	sp, #12
 80205a4:	bcf0      	pop	{r4, r5, r6, r7}
 80205a6:	46bb      	mov	fp, r7
 80205a8:	46b2      	mov	sl, r6
 80205aa:	46a9      	mov	r9, r5
 80205ac:	46a0      	mov	r8, r4
 80205ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80205b0:	4642      	mov	r2, r8
 80205b2:	2320      	movs	r3, #32
 80205b4:	1a9b      	subs	r3, r3, r2
 80205b6:	4652      	mov	r2, sl
 80205b8:	40da      	lsrs	r2, r3
 80205ba:	4641      	mov	r1, r8
 80205bc:	0013      	movs	r3, r2
 80205be:	464a      	mov	r2, r9
 80205c0:	408a      	lsls	r2, r1
 80205c2:	0017      	movs	r7, r2
 80205c4:	4642      	mov	r2, r8
 80205c6:	431f      	orrs	r7, r3
 80205c8:	4653      	mov	r3, sl
 80205ca:	4093      	lsls	r3, r2
 80205cc:	001e      	movs	r6, r3
 80205ce:	42af      	cmp	r7, r5
 80205d0:	d9c4      	bls.n	802055c <__udivmoddi4+0x4c>
 80205d2:	2200      	movs	r2, #0
 80205d4:	2300      	movs	r3, #0
 80205d6:	9200      	str	r2, [sp, #0]
 80205d8:	9301      	str	r3, [sp, #4]
 80205da:	4643      	mov	r3, r8
 80205dc:	2b00      	cmp	r3, #0
 80205de:	d0d9      	beq.n	8020594 <__udivmoddi4+0x84>
 80205e0:	07fb      	lsls	r3, r7, #31
 80205e2:	0872      	lsrs	r2, r6, #1
 80205e4:	431a      	orrs	r2, r3
 80205e6:	4646      	mov	r6, r8
 80205e8:	087b      	lsrs	r3, r7, #1
 80205ea:	e00e      	b.n	802060a <__udivmoddi4+0xfa>
 80205ec:	42ab      	cmp	r3, r5
 80205ee:	d101      	bne.n	80205f4 <__udivmoddi4+0xe4>
 80205f0:	42a2      	cmp	r2, r4
 80205f2:	d80c      	bhi.n	802060e <__udivmoddi4+0xfe>
 80205f4:	1aa4      	subs	r4, r4, r2
 80205f6:	419d      	sbcs	r5, r3
 80205f8:	2001      	movs	r0, #1
 80205fa:	1924      	adds	r4, r4, r4
 80205fc:	416d      	adcs	r5, r5
 80205fe:	2100      	movs	r1, #0
 8020600:	3e01      	subs	r6, #1
 8020602:	1824      	adds	r4, r4, r0
 8020604:	414d      	adcs	r5, r1
 8020606:	2e00      	cmp	r6, #0
 8020608:	d006      	beq.n	8020618 <__udivmoddi4+0x108>
 802060a:	42ab      	cmp	r3, r5
 802060c:	d9ee      	bls.n	80205ec <__udivmoddi4+0xdc>
 802060e:	3e01      	subs	r6, #1
 8020610:	1924      	adds	r4, r4, r4
 8020612:	416d      	adcs	r5, r5
 8020614:	2e00      	cmp	r6, #0
 8020616:	d1f8      	bne.n	802060a <__udivmoddi4+0xfa>
 8020618:	9800      	ldr	r0, [sp, #0]
 802061a:	9901      	ldr	r1, [sp, #4]
 802061c:	465b      	mov	r3, fp
 802061e:	1900      	adds	r0, r0, r4
 8020620:	4169      	adcs	r1, r5
 8020622:	2b00      	cmp	r3, #0
 8020624:	db24      	blt.n	8020670 <__udivmoddi4+0x160>
 8020626:	002b      	movs	r3, r5
 8020628:	465a      	mov	r2, fp
 802062a:	4644      	mov	r4, r8
 802062c:	40d3      	lsrs	r3, r2
 802062e:	002a      	movs	r2, r5
 8020630:	40e2      	lsrs	r2, r4
 8020632:	001c      	movs	r4, r3
 8020634:	465b      	mov	r3, fp
 8020636:	0015      	movs	r5, r2
 8020638:	2b00      	cmp	r3, #0
 802063a:	db2a      	blt.n	8020692 <__udivmoddi4+0x182>
 802063c:	0026      	movs	r6, r4
 802063e:	409e      	lsls	r6, r3
 8020640:	0033      	movs	r3, r6
 8020642:	0026      	movs	r6, r4
 8020644:	4647      	mov	r7, r8
 8020646:	40be      	lsls	r6, r7
 8020648:	0032      	movs	r2, r6
 802064a:	1a80      	subs	r0, r0, r2
 802064c:	4199      	sbcs	r1, r3
 802064e:	9000      	str	r0, [sp, #0]
 8020650:	9101      	str	r1, [sp, #4]
 8020652:	e79f      	b.n	8020594 <__udivmoddi4+0x84>
 8020654:	42a3      	cmp	r3, r4
 8020656:	d8bc      	bhi.n	80205d2 <__udivmoddi4+0xc2>
 8020658:	e783      	b.n	8020562 <__udivmoddi4+0x52>
 802065a:	4642      	mov	r2, r8
 802065c:	2320      	movs	r3, #32
 802065e:	2100      	movs	r1, #0
 8020660:	1a9b      	subs	r3, r3, r2
 8020662:	2200      	movs	r2, #0
 8020664:	9100      	str	r1, [sp, #0]
 8020666:	9201      	str	r2, [sp, #4]
 8020668:	2201      	movs	r2, #1
 802066a:	40da      	lsrs	r2, r3
 802066c:	9201      	str	r2, [sp, #4]
 802066e:	e786      	b.n	802057e <__udivmoddi4+0x6e>
 8020670:	4642      	mov	r2, r8
 8020672:	2320      	movs	r3, #32
 8020674:	1a9b      	subs	r3, r3, r2
 8020676:	002a      	movs	r2, r5
 8020678:	4646      	mov	r6, r8
 802067a:	409a      	lsls	r2, r3
 802067c:	0023      	movs	r3, r4
 802067e:	40f3      	lsrs	r3, r6
 8020680:	4644      	mov	r4, r8
 8020682:	4313      	orrs	r3, r2
 8020684:	002a      	movs	r2, r5
 8020686:	40e2      	lsrs	r2, r4
 8020688:	001c      	movs	r4, r3
 802068a:	465b      	mov	r3, fp
 802068c:	0015      	movs	r5, r2
 802068e:	2b00      	cmp	r3, #0
 8020690:	dad4      	bge.n	802063c <__udivmoddi4+0x12c>
 8020692:	4642      	mov	r2, r8
 8020694:	002f      	movs	r7, r5
 8020696:	2320      	movs	r3, #32
 8020698:	0026      	movs	r6, r4
 802069a:	4097      	lsls	r7, r2
 802069c:	1a9b      	subs	r3, r3, r2
 802069e:	40de      	lsrs	r6, r3
 80206a0:	003b      	movs	r3, r7
 80206a2:	4333      	orrs	r3, r6
 80206a4:	e7cd      	b.n	8020642 <__udivmoddi4+0x132>
 80206a6:	46c0      	nop			; (mov r8, r8)

080206a8 <__aeabi_fsub>:
 80206a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80206aa:	4646      	mov	r6, r8
 80206ac:	46d6      	mov	lr, sl
 80206ae:	464f      	mov	r7, r9
 80206b0:	0243      	lsls	r3, r0, #9
 80206b2:	0a5b      	lsrs	r3, r3, #9
 80206b4:	00da      	lsls	r2, r3, #3
 80206b6:	4694      	mov	ip, r2
 80206b8:	024a      	lsls	r2, r1, #9
 80206ba:	b5c0      	push	{r6, r7, lr}
 80206bc:	0044      	lsls	r4, r0, #1
 80206be:	0a56      	lsrs	r6, r2, #9
 80206c0:	1c05      	adds	r5, r0, #0
 80206c2:	46b0      	mov	r8, r6
 80206c4:	0e24      	lsrs	r4, r4, #24
 80206c6:	004e      	lsls	r6, r1, #1
 80206c8:	0992      	lsrs	r2, r2, #6
 80206ca:	001f      	movs	r7, r3
 80206cc:	0020      	movs	r0, r4
 80206ce:	4692      	mov	sl, r2
 80206d0:	0fed      	lsrs	r5, r5, #31
 80206d2:	0e36      	lsrs	r6, r6, #24
 80206d4:	0fc9      	lsrs	r1, r1, #31
 80206d6:	2eff      	cmp	r6, #255	; 0xff
 80206d8:	d100      	bne.n	80206dc <__aeabi_fsub+0x34>
 80206da:	e07f      	b.n	80207dc <__aeabi_fsub+0x134>
 80206dc:	2201      	movs	r2, #1
 80206de:	4051      	eors	r1, r2
 80206e0:	428d      	cmp	r5, r1
 80206e2:	d051      	beq.n	8020788 <__aeabi_fsub+0xe0>
 80206e4:	1ba2      	subs	r2, r4, r6
 80206e6:	4691      	mov	r9, r2
 80206e8:	2a00      	cmp	r2, #0
 80206ea:	dc00      	bgt.n	80206ee <__aeabi_fsub+0x46>
 80206ec:	e07e      	b.n	80207ec <__aeabi_fsub+0x144>
 80206ee:	2e00      	cmp	r6, #0
 80206f0:	d100      	bne.n	80206f4 <__aeabi_fsub+0x4c>
 80206f2:	e099      	b.n	8020828 <__aeabi_fsub+0x180>
 80206f4:	2cff      	cmp	r4, #255	; 0xff
 80206f6:	d100      	bne.n	80206fa <__aeabi_fsub+0x52>
 80206f8:	e08c      	b.n	8020814 <__aeabi_fsub+0x16c>
 80206fa:	2380      	movs	r3, #128	; 0x80
 80206fc:	4652      	mov	r2, sl
 80206fe:	04db      	lsls	r3, r3, #19
 8020700:	431a      	orrs	r2, r3
 8020702:	4692      	mov	sl, r2
 8020704:	464a      	mov	r2, r9
 8020706:	2301      	movs	r3, #1
 8020708:	2a1b      	cmp	r2, #27
 802070a:	dc08      	bgt.n	802071e <__aeabi_fsub+0x76>
 802070c:	4653      	mov	r3, sl
 802070e:	2120      	movs	r1, #32
 8020710:	40d3      	lsrs	r3, r2
 8020712:	1a89      	subs	r1, r1, r2
 8020714:	4652      	mov	r2, sl
 8020716:	408a      	lsls	r2, r1
 8020718:	1e51      	subs	r1, r2, #1
 802071a:	418a      	sbcs	r2, r1
 802071c:	4313      	orrs	r3, r2
 802071e:	4662      	mov	r2, ip
 8020720:	1ad3      	subs	r3, r2, r3
 8020722:	015a      	lsls	r2, r3, #5
 8020724:	d400      	bmi.n	8020728 <__aeabi_fsub+0x80>
 8020726:	e0f3      	b.n	8020910 <__aeabi_fsub+0x268>
 8020728:	019b      	lsls	r3, r3, #6
 802072a:	099e      	lsrs	r6, r3, #6
 802072c:	0030      	movs	r0, r6
 802072e:	f000 fec5 	bl	80214bc <__clzsi2>
 8020732:	3805      	subs	r0, #5
 8020734:	4086      	lsls	r6, r0
 8020736:	4284      	cmp	r4, r0
 8020738:	dd00      	ble.n	802073c <__aeabi_fsub+0x94>
 802073a:	e0f7      	b.n	802092c <__aeabi_fsub+0x284>
 802073c:	0032      	movs	r2, r6
 802073e:	1b04      	subs	r4, r0, r4
 8020740:	2020      	movs	r0, #32
 8020742:	3401      	adds	r4, #1
 8020744:	40e2      	lsrs	r2, r4
 8020746:	1b04      	subs	r4, r0, r4
 8020748:	40a6      	lsls	r6, r4
 802074a:	0033      	movs	r3, r6
 802074c:	1e5e      	subs	r6, r3, #1
 802074e:	41b3      	sbcs	r3, r6
 8020750:	2400      	movs	r4, #0
 8020752:	4313      	orrs	r3, r2
 8020754:	075a      	lsls	r2, r3, #29
 8020756:	d004      	beq.n	8020762 <__aeabi_fsub+0xba>
 8020758:	220f      	movs	r2, #15
 802075a:	401a      	ands	r2, r3
 802075c:	2a04      	cmp	r2, #4
 802075e:	d000      	beq.n	8020762 <__aeabi_fsub+0xba>
 8020760:	3304      	adds	r3, #4
 8020762:	015a      	lsls	r2, r3, #5
 8020764:	d400      	bmi.n	8020768 <__aeabi_fsub+0xc0>
 8020766:	e0d6      	b.n	8020916 <__aeabi_fsub+0x26e>
 8020768:	1c62      	adds	r2, r4, #1
 802076a:	2cfe      	cmp	r4, #254	; 0xfe
 802076c:	d100      	bne.n	8020770 <__aeabi_fsub+0xc8>
 802076e:	e0da      	b.n	8020926 <__aeabi_fsub+0x27e>
 8020770:	019b      	lsls	r3, r3, #6
 8020772:	0a5f      	lsrs	r7, r3, #9
 8020774:	b2d0      	uxtb	r0, r2
 8020776:	05c0      	lsls	r0, r0, #23
 8020778:	4338      	orrs	r0, r7
 802077a:	07ed      	lsls	r5, r5, #31
 802077c:	4328      	orrs	r0, r5
 802077e:	bce0      	pop	{r5, r6, r7}
 8020780:	46ba      	mov	sl, r7
 8020782:	46b1      	mov	r9, r6
 8020784:	46a8      	mov	r8, r5
 8020786:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020788:	1ba2      	subs	r2, r4, r6
 802078a:	4691      	mov	r9, r2
 802078c:	2a00      	cmp	r2, #0
 802078e:	dd63      	ble.n	8020858 <__aeabi_fsub+0x1b0>
 8020790:	2e00      	cmp	r6, #0
 8020792:	d100      	bne.n	8020796 <__aeabi_fsub+0xee>
 8020794:	e099      	b.n	80208ca <__aeabi_fsub+0x222>
 8020796:	2cff      	cmp	r4, #255	; 0xff
 8020798:	d03c      	beq.n	8020814 <__aeabi_fsub+0x16c>
 802079a:	2380      	movs	r3, #128	; 0x80
 802079c:	4652      	mov	r2, sl
 802079e:	04db      	lsls	r3, r3, #19
 80207a0:	431a      	orrs	r2, r3
 80207a2:	4692      	mov	sl, r2
 80207a4:	464a      	mov	r2, r9
 80207a6:	2301      	movs	r3, #1
 80207a8:	2a1b      	cmp	r2, #27
 80207aa:	dc08      	bgt.n	80207be <__aeabi_fsub+0x116>
 80207ac:	4653      	mov	r3, sl
 80207ae:	2120      	movs	r1, #32
 80207b0:	40d3      	lsrs	r3, r2
 80207b2:	1a89      	subs	r1, r1, r2
 80207b4:	4652      	mov	r2, sl
 80207b6:	408a      	lsls	r2, r1
 80207b8:	1e51      	subs	r1, r2, #1
 80207ba:	418a      	sbcs	r2, r1
 80207bc:	4313      	orrs	r3, r2
 80207be:	4463      	add	r3, ip
 80207c0:	015a      	lsls	r2, r3, #5
 80207c2:	d400      	bmi.n	80207c6 <__aeabi_fsub+0x11e>
 80207c4:	e0a4      	b.n	8020910 <__aeabi_fsub+0x268>
 80207c6:	3401      	adds	r4, #1
 80207c8:	2cff      	cmp	r4, #255	; 0xff
 80207ca:	d100      	bne.n	80207ce <__aeabi_fsub+0x126>
 80207cc:	e0ab      	b.n	8020926 <__aeabi_fsub+0x27e>
 80207ce:	2201      	movs	r2, #1
 80207d0:	4997      	ldr	r1, [pc, #604]	; (8020a30 <__aeabi_fsub+0x388>)
 80207d2:	401a      	ands	r2, r3
 80207d4:	085b      	lsrs	r3, r3, #1
 80207d6:	400b      	ands	r3, r1
 80207d8:	4313      	orrs	r3, r2
 80207da:	e7bb      	b.n	8020754 <__aeabi_fsub+0xac>
 80207dc:	2a00      	cmp	r2, #0
 80207de:	d032      	beq.n	8020846 <__aeabi_fsub+0x19e>
 80207e0:	428d      	cmp	r5, r1
 80207e2:	d035      	beq.n	8020850 <__aeabi_fsub+0x1a8>
 80207e4:	22ff      	movs	r2, #255	; 0xff
 80207e6:	4252      	negs	r2, r2
 80207e8:	4691      	mov	r9, r2
 80207ea:	44a1      	add	r9, r4
 80207ec:	464a      	mov	r2, r9
 80207ee:	2a00      	cmp	r2, #0
 80207f0:	d051      	beq.n	8020896 <__aeabi_fsub+0x1ee>
 80207f2:	1b30      	subs	r0, r6, r4
 80207f4:	2c00      	cmp	r4, #0
 80207f6:	d000      	beq.n	80207fa <__aeabi_fsub+0x152>
 80207f8:	e09c      	b.n	8020934 <__aeabi_fsub+0x28c>
 80207fa:	4663      	mov	r3, ip
 80207fc:	2b00      	cmp	r3, #0
 80207fe:	d100      	bne.n	8020802 <__aeabi_fsub+0x15a>
 8020800:	e0df      	b.n	80209c2 <__aeabi_fsub+0x31a>
 8020802:	3801      	subs	r0, #1
 8020804:	2800      	cmp	r0, #0
 8020806:	d100      	bne.n	802080a <__aeabi_fsub+0x162>
 8020808:	e0f7      	b.n	80209fa <__aeabi_fsub+0x352>
 802080a:	2eff      	cmp	r6, #255	; 0xff
 802080c:	d000      	beq.n	8020810 <__aeabi_fsub+0x168>
 802080e:	e099      	b.n	8020944 <__aeabi_fsub+0x29c>
 8020810:	000d      	movs	r5, r1
 8020812:	4643      	mov	r3, r8
 8020814:	2b00      	cmp	r3, #0
 8020816:	d100      	bne.n	802081a <__aeabi_fsub+0x172>
 8020818:	e085      	b.n	8020926 <__aeabi_fsub+0x27e>
 802081a:	2780      	movs	r7, #128	; 0x80
 802081c:	03ff      	lsls	r7, r7, #15
 802081e:	431f      	orrs	r7, r3
 8020820:	027f      	lsls	r7, r7, #9
 8020822:	20ff      	movs	r0, #255	; 0xff
 8020824:	0a7f      	lsrs	r7, r7, #9
 8020826:	e7a6      	b.n	8020776 <__aeabi_fsub+0xce>
 8020828:	4652      	mov	r2, sl
 802082a:	2a00      	cmp	r2, #0
 802082c:	d074      	beq.n	8020918 <__aeabi_fsub+0x270>
 802082e:	2201      	movs	r2, #1
 8020830:	4252      	negs	r2, r2
 8020832:	4690      	mov	r8, r2
 8020834:	44c1      	add	r9, r8
 8020836:	464a      	mov	r2, r9
 8020838:	2a00      	cmp	r2, #0
 802083a:	d100      	bne.n	802083e <__aeabi_fsub+0x196>
 802083c:	e0c8      	b.n	80209d0 <__aeabi_fsub+0x328>
 802083e:	2cff      	cmp	r4, #255	; 0xff
 8020840:	d000      	beq.n	8020844 <__aeabi_fsub+0x19c>
 8020842:	e75f      	b.n	8020704 <__aeabi_fsub+0x5c>
 8020844:	e7e6      	b.n	8020814 <__aeabi_fsub+0x16c>
 8020846:	2201      	movs	r2, #1
 8020848:	4051      	eors	r1, r2
 802084a:	42a9      	cmp	r1, r5
 802084c:	d000      	beq.n	8020850 <__aeabi_fsub+0x1a8>
 802084e:	e749      	b.n	80206e4 <__aeabi_fsub+0x3c>
 8020850:	22ff      	movs	r2, #255	; 0xff
 8020852:	4252      	negs	r2, r2
 8020854:	4691      	mov	r9, r2
 8020856:	44a1      	add	r9, r4
 8020858:	464a      	mov	r2, r9
 802085a:	2a00      	cmp	r2, #0
 802085c:	d043      	beq.n	80208e6 <__aeabi_fsub+0x23e>
 802085e:	1b31      	subs	r1, r6, r4
 8020860:	2c00      	cmp	r4, #0
 8020862:	d100      	bne.n	8020866 <__aeabi_fsub+0x1be>
 8020864:	e08c      	b.n	8020980 <__aeabi_fsub+0x2d8>
 8020866:	2eff      	cmp	r6, #255	; 0xff
 8020868:	d100      	bne.n	802086c <__aeabi_fsub+0x1c4>
 802086a:	e092      	b.n	8020992 <__aeabi_fsub+0x2ea>
 802086c:	2380      	movs	r3, #128	; 0x80
 802086e:	4662      	mov	r2, ip
 8020870:	04db      	lsls	r3, r3, #19
 8020872:	431a      	orrs	r2, r3
 8020874:	4694      	mov	ip, r2
 8020876:	2301      	movs	r3, #1
 8020878:	291b      	cmp	r1, #27
 802087a:	dc09      	bgt.n	8020890 <__aeabi_fsub+0x1e8>
 802087c:	2020      	movs	r0, #32
 802087e:	4663      	mov	r3, ip
 8020880:	4662      	mov	r2, ip
 8020882:	40cb      	lsrs	r3, r1
 8020884:	1a41      	subs	r1, r0, r1
 8020886:	408a      	lsls	r2, r1
 8020888:	0011      	movs	r1, r2
 802088a:	1e48      	subs	r0, r1, #1
 802088c:	4181      	sbcs	r1, r0
 802088e:	430b      	orrs	r3, r1
 8020890:	0034      	movs	r4, r6
 8020892:	4453      	add	r3, sl
 8020894:	e794      	b.n	80207c0 <__aeabi_fsub+0x118>
 8020896:	22fe      	movs	r2, #254	; 0xfe
 8020898:	1c66      	adds	r6, r4, #1
 802089a:	4232      	tst	r2, r6
 802089c:	d164      	bne.n	8020968 <__aeabi_fsub+0x2c0>
 802089e:	2c00      	cmp	r4, #0
 80208a0:	d000      	beq.n	80208a4 <__aeabi_fsub+0x1fc>
 80208a2:	e082      	b.n	80209aa <__aeabi_fsub+0x302>
 80208a4:	4663      	mov	r3, ip
 80208a6:	2b00      	cmp	r3, #0
 80208a8:	d100      	bne.n	80208ac <__aeabi_fsub+0x204>
 80208aa:	e0ab      	b.n	8020a04 <__aeabi_fsub+0x35c>
 80208ac:	4653      	mov	r3, sl
 80208ae:	2b00      	cmp	r3, #0
 80208b0:	d100      	bne.n	80208b4 <__aeabi_fsub+0x20c>
 80208b2:	e760      	b.n	8020776 <__aeabi_fsub+0xce>
 80208b4:	4663      	mov	r3, ip
 80208b6:	4652      	mov	r2, sl
 80208b8:	1a9b      	subs	r3, r3, r2
 80208ba:	015a      	lsls	r2, r3, #5
 80208bc:	d400      	bmi.n	80208c0 <__aeabi_fsub+0x218>
 80208be:	e0aa      	b.n	8020a16 <__aeabi_fsub+0x36e>
 80208c0:	4663      	mov	r3, ip
 80208c2:	4652      	mov	r2, sl
 80208c4:	000d      	movs	r5, r1
 80208c6:	1ad3      	subs	r3, r2, r3
 80208c8:	e744      	b.n	8020754 <__aeabi_fsub+0xac>
 80208ca:	4652      	mov	r2, sl
 80208cc:	2a00      	cmp	r2, #0
 80208ce:	d023      	beq.n	8020918 <__aeabi_fsub+0x270>
 80208d0:	2201      	movs	r2, #1
 80208d2:	4252      	negs	r2, r2
 80208d4:	4690      	mov	r8, r2
 80208d6:	44c1      	add	r9, r8
 80208d8:	464a      	mov	r2, r9
 80208da:	2a00      	cmp	r2, #0
 80208dc:	d075      	beq.n	80209ca <__aeabi_fsub+0x322>
 80208de:	2cff      	cmp	r4, #255	; 0xff
 80208e0:	d000      	beq.n	80208e4 <__aeabi_fsub+0x23c>
 80208e2:	e75f      	b.n	80207a4 <__aeabi_fsub+0xfc>
 80208e4:	e796      	b.n	8020814 <__aeabi_fsub+0x16c>
 80208e6:	26fe      	movs	r6, #254	; 0xfe
 80208e8:	3401      	adds	r4, #1
 80208ea:	4226      	tst	r6, r4
 80208ec:	d153      	bne.n	8020996 <__aeabi_fsub+0x2ee>
 80208ee:	2800      	cmp	r0, #0
 80208f0:	d172      	bne.n	80209d8 <__aeabi_fsub+0x330>
 80208f2:	4663      	mov	r3, ip
 80208f4:	2b00      	cmp	r3, #0
 80208f6:	d100      	bne.n	80208fa <__aeabi_fsub+0x252>
 80208f8:	e093      	b.n	8020a22 <__aeabi_fsub+0x37a>
 80208fa:	4653      	mov	r3, sl
 80208fc:	2b00      	cmp	r3, #0
 80208fe:	d100      	bne.n	8020902 <__aeabi_fsub+0x25a>
 8020900:	e739      	b.n	8020776 <__aeabi_fsub+0xce>
 8020902:	4463      	add	r3, ip
 8020904:	2400      	movs	r4, #0
 8020906:	015a      	lsls	r2, r3, #5
 8020908:	d502      	bpl.n	8020910 <__aeabi_fsub+0x268>
 802090a:	4a4a      	ldr	r2, [pc, #296]	; (8020a34 <__aeabi_fsub+0x38c>)
 802090c:	3401      	adds	r4, #1
 802090e:	4013      	ands	r3, r2
 8020910:	075a      	lsls	r2, r3, #29
 8020912:	d000      	beq.n	8020916 <__aeabi_fsub+0x26e>
 8020914:	e720      	b.n	8020758 <__aeabi_fsub+0xb0>
 8020916:	08db      	lsrs	r3, r3, #3
 8020918:	2cff      	cmp	r4, #255	; 0xff
 802091a:	d100      	bne.n	802091e <__aeabi_fsub+0x276>
 802091c:	e77a      	b.n	8020814 <__aeabi_fsub+0x16c>
 802091e:	025b      	lsls	r3, r3, #9
 8020920:	0a5f      	lsrs	r7, r3, #9
 8020922:	b2e0      	uxtb	r0, r4
 8020924:	e727      	b.n	8020776 <__aeabi_fsub+0xce>
 8020926:	20ff      	movs	r0, #255	; 0xff
 8020928:	2700      	movs	r7, #0
 802092a:	e724      	b.n	8020776 <__aeabi_fsub+0xce>
 802092c:	4b41      	ldr	r3, [pc, #260]	; (8020a34 <__aeabi_fsub+0x38c>)
 802092e:	1a24      	subs	r4, r4, r0
 8020930:	4033      	ands	r3, r6
 8020932:	e70f      	b.n	8020754 <__aeabi_fsub+0xac>
 8020934:	2eff      	cmp	r6, #255	; 0xff
 8020936:	d100      	bne.n	802093a <__aeabi_fsub+0x292>
 8020938:	e76a      	b.n	8020810 <__aeabi_fsub+0x168>
 802093a:	2380      	movs	r3, #128	; 0x80
 802093c:	4662      	mov	r2, ip
 802093e:	04db      	lsls	r3, r3, #19
 8020940:	431a      	orrs	r2, r3
 8020942:	4694      	mov	ip, r2
 8020944:	2301      	movs	r3, #1
 8020946:	281b      	cmp	r0, #27
 8020948:	dc09      	bgt.n	802095e <__aeabi_fsub+0x2b6>
 802094a:	2420      	movs	r4, #32
 802094c:	4663      	mov	r3, ip
 802094e:	4662      	mov	r2, ip
 8020950:	40c3      	lsrs	r3, r0
 8020952:	1a20      	subs	r0, r4, r0
 8020954:	4082      	lsls	r2, r0
 8020956:	0010      	movs	r0, r2
 8020958:	1e44      	subs	r4, r0, #1
 802095a:	41a0      	sbcs	r0, r4
 802095c:	4303      	orrs	r3, r0
 802095e:	4652      	mov	r2, sl
 8020960:	000d      	movs	r5, r1
 8020962:	0034      	movs	r4, r6
 8020964:	1ad3      	subs	r3, r2, r3
 8020966:	e6dc      	b.n	8020722 <__aeabi_fsub+0x7a>
 8020968:	4663      	mov	r3, ip
 802096a:	4652      	mov	r2, sl
 802096c:	1a9e      	subs	r6, r3, r2
 802096e:	0173      	lsls	r3, r6, #5
 8020970:	d417      	bmi.n	80209a2 <__aeabi_fsub+0x2fa>
 8020972:	2e00      	cmp	r6, #0
 8020974:	d000      	beq.n	8020978 <__aeabi_fsub+0x2d0>
 8020976:	e6d9      	b.n	802072c <__aeabi_fsub+0x84>
 8020978:	2500      	movs	r5, #0
 802097a:	2000      	movs	r0, #0
 802097c:	2700      	movs	r7, #0
 802097e:	e6fa      	b.n	8020776 <__aeabi_fsub+0xce>
 8020980:	4663      	mov	r3, ip
 8020982:	2b00      	cmp	r3, #0
 8020984:	d044      	beq.n	8020a10 <__aeabi_fsub+0x368>
 8020986:	3901      	subs	r1, #1
 8020988:	2900      	cmp	r1, #0
 802098a:	d04c      	beq.n	8020a26 <__aeabi_fsub+0x37e>
 802098c:	2eff      	cmp	r6, #255	; 0xff
 802098e:	d000      	beq.n	8020992 <__aeabi_fsub+0x2ea>
 8020990:	e771      	b.n	8020876 <__aeabi_fsub+0x1ce>
 8020992:	4643      	mov	r3, r8
 8020994:	e73e      	b.n	8020814 <__aeabi_fsub+0x16c>
 8020996:	2cff      	cmp	r4, #255	; 0xff
 8020998:	d0c5      	beq.n	8020926 <__aeabi_fsub+0x27e>
 802099a:	4652      	mov	r2, sl
 802099c:	4462      	add	r2, ip
 802099e:	0853      	lsrs	r3, r2, #1
 80209a0:	e7b6      	b.n	8020910 <__aeabi_fsub+0x268>
 80209a2:	4663      	mov	r3, ip
 80209a4:	000d      	movs	r5, r1
 80209a6:	1ad6      	subs	r6, r2, r3
 80209a8:	e6c0      	b.n	802072c <__aeabi_fsub+0x84>
 80209aa:	4662      	mov	r2, ip
 80209ac:	2a00      	cmp	r2, #0
 80209ae:	d116      	bne.n	80209de <__aeabi_fsub+0x336>
 80209b0:	4653      	mov	r3, sl
 80209b2:	2b00      	cmp	r3, #0
 80209b4:	d000      	beq.n	80209b8 <__aeabi_fsub+0x310>
 80209b6:	e72b      	b.n	8020810 <__aeabi_fsub+0x168>
 80209b8:	2780      	movs	r7, #128	; 0x80
 80209ba:	2500      	movs	r5, #0
 80209bc:	20ff      	movs	r0, #255	; 0xff
 80209be:	03ff      	lsls	r7, r7, #15
 80209c0:	e6d9      	b.n	8020776 <__aeabi_fsub+0xce>
 80209c2:	000d      	movs	r5, r1
 80209c4:	4643      	mov	r3, r8
 80209c6:	0034      	movs	r4, r6
 80209c8:	e7a6      	b.n	8020918 <__aeabi_fsub+0x270>
 80209ca:	4653      	mov	r3, sl
 80209cc:	4463      	add	r3, ip
 80209ce:	e6f7      	b.n	80207c0 <__aeabi_fsub+0x118>
 80209d0:	4663      	mov	r3, ip
 80209d2:	4652      	mov	r2, sl
 80209d4:	1a9b      	subs	r3, r3, r2
 80209d6:	e6a4      	b.n	8020722 <__aeabi_fsub+0x7a>
 80209d8:	4662      	mov	r2, ip
 80209da:	2a00      	cmp	r2, #0
 80209dc:	d0d9      	beq.n	8020992 <__aeabi_fsub+0x2ea>
 80209de:	4652      	mov	r2, sl
 80209e0:	2a00      	cmp	r2, #0
 80209e2:	d100      	bne.n	80209e6 <__aeabi_fsub+0x33e>
 80209e4:	e716      	b.n	8020814 <__aeabi_fsub+0x16c>
 80209e6:	2280      	movs	r2, #128	; 0x80
 80209e8:	03d2      	lsls	r2, r2, #15
 80209ea:	4213      	tst	r3, r2
 80209ec:	d100      	bne.n	80209f0 <__aeabi_fsub+0x348>
 80209ee:	e711      	b.n	8020814 <__aeabi_fsub+0x16c>
 80209f0:	4640      	mov	r0, r8
 80209f2:	4210      	tst	r0, r2
 80209f4:	d000      	beq.n	80209f8 <__aeabi_fsub+0x350>
 80209f6:	e70d      	b.n	8020814 <__aeabi_fsub+0x16c>
 80209f8:	e70a      	b.n	8020810 <__aeabi_fsub+0x168>
 80209fa:	4652      	mov	r2, sl
 80209fc:	000d      	movs	r5, r1
 80209fe:	0034      	movs	r4, r6
 8020a00:	1ad3      	subs	r3, r2, r3
 8020a02:	e68e      	b.n	8020722 <__aeabi_fsub+0x7a>
 8020a04:	4653      	mov	r3, sl
 8020a06:	2b00      	cmp	r3, #0
 8020a08:	d008      	beq.n	8020a1c <__aeabi_fsub+0x374>
 8020a0a:	000d      	movs	r5, r1
 8020a0c:	4647      	mov	r7, r8
 8020a0e:	e6b2      	b.n	8020776 <__aeabi_fsub+0xce>
 8020a10:	4643      	mov	r3, r8
 8020a12:	0034      	movs	r4, r6
 8020a14:	e780      	b.n	8020918 <__aeabi_fsub+0x270>
 8020a16:	2b00      	cmp	r3, #0
 8020a18:	d000      	beq.n	8020a1c <__aeabi_fsub+0x374>
 8020a1a:	e779      	b.n	8020910 <__aeabi_fsub+0x268>
 8020a1c:	2500      	movs	r5, #0
 8020a1e:	2700      	movs	r7, #0
 8020a20:	e6a9      	b.n	8020776 <__aeabi_fsub+0xce>
 8020a22:	4647      	mov	r7, r8
 8020a24:	e6a7      	b.n	8020776 <__aeabi_fsub+0xce>
 8020a26:	4653      	mov	r3, sl
 8020a28:	0034      	movs	r4, r6
 8020a2a:	4463      	add	r3, ip
 8020a2c:	e6c8      	b.n	80207c0 <__aeabi_fsub+0x118>
 8020a2e:	46c0      	nop			; (mov r8, r8)
 8020a30:	7dffffff 	.word	0x7dffffff
 8020a34:	fbffffff 	.word	0xfbffffff

08020a38 <__aeabi_ui2f>:
 8020a38:	b570      	push	{r4, r5, r6, lr}
 8020a3a:	1e05      	subs	r5, r0, #0
 8020a3c:	d00e      	beq.n	8020a5c <__aeabi_ui2f+0x24>
 8020a3e:	f000 fd3d 	bl	80214bc <__clzsi2>
 8020a42:	239e      	movs	r3, #158	; 0x9e
 8020a44:	0004      	movs	r4, r0
 8020a46:	1a1b      	subs	r3, r3, r0
 8020a48:	2b96      	cmp	r3, #150	; 0x96
 8020a4a:	dc0c      	bgt.n	8020a66 <__aeabi_ui2f+0x2e>
 8020a4c:	2808      	cmp	r0, #8
 8020a4e:	dd01      	ble.n	8020a54 <__aeabi_ui2f+0x1c>
 8020a50:	3c08      	subs	r4, #8
 8020a52:	40a5      	lsls	r5, r4
 8020a54:	026d      	lsls	r5, r5, #9
 8020a56:	0a6d      	lsrs	r5, r5, #9
 8020a58:	b2d8      	uxtb	r0, r3
 8020a5a:	e001      	b.n	8020a60 <__aeabi_ui2f+0x28>
 8020a5c:	2000      	movs	r0, #0
 8020a5e:	2500      	movs	r5, #0
 8020a60:	05c0      	lsls	r0, r0, #23
 8020a62:	4328      	orrs	r0, r5
 8020a64:	bd70      	pop	{r4, r5, r6, pc}
 8020a66:	2b99      	cmp	r3, #153	; 0x99
 8020a68:	dd09      	ble.n	8020a7e <__aeabi_ui2f+0x46>
 8020a6a:	0002      	movs	r2, r0
 8020a6c:	0029      	movs	r1, r5
 8020a6e:	321b      	adds	r2, #27
 8020a70:	4091      	lsls	r1, r2
 8020a72:	1e4a      	subs	r2, r1, #1
 8020a74:	4191      	sbcs	r1, r2
 8020a76:	2205      	movs	r2, #5
 8020a78:	1a12      	subs	r2, r2, r0
 8020a7a:	40d5      	lsrs	r5, r2
 8020a7c:	430d      	orrs	r5, r1
 8020a7e:	2c05      	cmp	r4, #5
 8020a80:	dd01      	ble.n	8020a86 <__aeabi_ui2f+0x4e>
 8020a82:	1f62      	subs	r2, r4, #5
 8020a84:	4095      	lsls	r5, r2
 8020a86:	0029      	movs	r1, r5
 8020a88:	4e08      	ldr	r6, [pc, #32]	; (8020aac <__aeabi_ui2f+0x74>)
 8020a8a:	4031      	ands	r1, r6
 8020a8c:	076a      	lsls	r2, r5, #29
 8020a8e:	d009      	beq.n	8020aa4 <__aeabi_ui2f+0x6c>
 8020a90:	200f      	movs	r0, #15
 8020a92:	4028      	ands	r0, r5
 8020a94:	2804      	cmp	r0, #4
 8020a96:	d005      	beq.n	8020aa4 <__aeabi_ui2f+0x6c>
 8020a98:	3104      	adds	r1, #4
 8020a9a:	014a      	lsls	r2, r1, #5
 8020a9c:	d502      	bpl.n	8020aa4 <__aeabi_ui2f+0x6c>
 8020a9e:	239f      	movs	r3, #159	; 0x9f
 8020aa0:	4031      	ands	r1, r6
 8020aa2:	1b1b      	subs	r3, r3, r4
 8020aa4:	0189      	lsls	r1, r1, #6
 8020aa6:	0a4d      	lsrs	r5, r1, #9
 8020aa8:	b2d8      	uxtb	r0, r3
 8020aaa:	e7d9      	b.n	8020a60 <__aeabi_ui2f+0x28>
 8020aac:	fbffffff 	.word	0xfbffffff

08020ab0 <__aeabi_dadd>:
 8020ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020ab2:	464f      	mov	r7, r9
 8020ab4:	46d6      	mov	lr, sl
 8020ab6:	4646      	mov	r6, r8
 8020ab8:	000d      	movs	r5, r1
 8020aba:	0001      	movs	r1, r0
 8020abc:	0018      	movs	r0, r3
 8020abe:	b5c0      	push	{r6, r7, lr}
 8020ac0:	0017      	movs	r7, r2
 8020ac2:	032b      	lsls	r3, r5, #12
 8020ac4:	0a5a      	lsrs	r2, r3, #9
 8020ac6:	0f4b      	lsrs	r3, r1, #29
 8020ac8:	4313      	orrs	r3, r2
 8020aca:	00ca      	lsls	r2, r1, #3
 8020acc:	4691      	mov	r9, r2
 8020ace:	0302      	lsls	r2, r0, #12
 8020ad0:	006e      	lsls	r6, r5, #1
 8020ad2:	0041      	lsls	r1, r0, #1
 8020ad4:	0a52      	lsrs	r2, r2, #9
 8020ad6:	0fec      	lsrs	r4, r5, #31
 8020ad8:	0f7d      	lsrs	r5, r7, #29
 8020ada:	4315      	orrs	r5, r2
 8020adc:	0d76      	lsrs	r6, r6, #21
 8020ade:	0d49      	lsrs	r1, r1, #21
 8020ae0:	0fc0      	lsrs	r0, r0, #31
 8020ae2:	4682      	mov	sl, r0
 8020ae4:	46ac      	mov	ip, r5
 8020ae6:	00ff      	lsls	r7, r7, #3
 8020ae8:	1a72      	subs	r2, r6, r1
 8020aea:	4284      	cmp	r4, r0
 8020aec:	d100      	bne.n	8020af0 <__aeabi_dadd+0x40>
 8020aee:	e098      	b.n	8020c22 <__aeabi_dadd+0x172>
 8020af0:	2a00      	cmp	r2, #0
 8020af2:	dc00      	bgt.n	8020af6 <__aeabi_dadd+0x46>
 8020af4:	e081      	b.n	8020bfa <__aeabi_dadd+0x14a>
 8020af6:	2900      	cmp	r1, #0
 8020af8:	d100      	bne.n	8020afc <__aeabi_dadd+0x4c>
 8020afa:	e0b6      	b.n	8020c6a <__aeabi_dadd+0x1ba>
 8020afc:	49c9      	ldr	r1, [pc, #804]	; (8020e24 <__aeabi_dadd+0x374>)
 8020afe:	428e      	cmp	r6, r1
 8020b00:	d100      	bne.n	8020b04 <__aeabi_dadd+0x54>
 8020b02:	e172      	b.n	8020dea <__aeabi_dadd+0x33a>
 8020b04:	2180      	movs	r1, #128	; 0x80
 8020b06:	0028      	movs	r0, r5
 8020b08:	0409      	lsls	r1, r1, #16
 8020b0a:	4308      	orrs	r0, r1
 8020b0c:	4684      	mov	ip, r0
 8020b0e:	2a38      	cmp	r2, #56	; 0x38
 8020b10:	dd00      	ble.n	8020b14 <__aeabi_dadd+0x64>
 8020b12:	e15e      	b.n	8020dd2 <__aeabi_dadd+0x322>
 8020b14:	2a1f      	cmp	r2, #31
 8020b16:	dd00      	ble.n	8020b1a <__aeabi_dadd+0x6a>
 8020b18:	e1ee      	b.n	8020ef8 <__aeabi_dadd+0x448>
 8020b1a:	2020      	movs	r0, #32
 8020b1c:	0039      	movs	r1, r7
 8020b1e:	4665      	mov	r5, ip
 8020b20:	1a80      	subs	r0, r0, r2
 8020b22:	4087      	lsls	r7, r0
 8020b24:	40d1      	lsrs	r1, r2
 8020b26:	4085      	lsls	r5, r0
 8020b28:	430d      	orrs	r5, r1
 8020b2a:	0039      	movs	r1, r7
 8020b2c:	1e4f      	subs	r7, r1, #1
 8020b2e:	41b9      	sbcs	r1, r7
 8020b30:	4667      	mov	r7, ip
 8020b32:	40d7      	lsrs	r7, r2
 8020b34:	4329      	orrs	r1, r5
 8020b36:	1bdb      	subs	r3, r3, r7
 8020b38:	464a      	mov	r2, r9
 8020b3a:	1a55      	subs	r5, r2, r1
 8020b3c:	45a9      	cmp	r9, r5
 8020b3e:	4189      	sbcs	r1, r1
 8020b40:	4249      	negs	r1, r1
 8020b42:	1a5b      	subs	r3, r3, r1
 8020b44:	4698      	mov	r8, r3
 8020b46:	4643      	mov	r3, r8
 8020b48:	021b      	lsls	r3, r3, #8
 8020b4a:	d400      	bmi.n	8020b4e <__aeabi_dadd+0x9e>
 8020b4c:	e0cc      	b.n	8020ce8 <__aeabi_dadd+0x238>
 8020b4e:	4643      	mov	r3, r8
 8020b50:	025b      	lsls	r3, r3, #9
 8020b52:	0a5b      	lsrs	r3, r3, #9
 8020b54:	4698      	mov	r8, r3
 8020b56:	4643      	mov	r3, r8
 8020b58:	2b00      	cmp	r3, #0
 8020b5a:	d100      	bne.n	8020b5e <__aeabi_dadd+0xae>
 8020b5c:	e12c      	b.n	8020db8 <__aeabi_dadd+0x308>
 8020b5e:	4640      	mov	r0, r8
 8020b60:	f000 fcac 	bl	80214bc <__clzsi2>
 8020b64:	0001      	movs	r1, r0
 8020b66:	3908      	subs	r1, #8
 8020b68:	2220      	movs	r2, #32
 8020b6a:	0028      	movs	r0, r5
 8020b6c:	4643      	mov	r3, r8
 8020b6e:	1a52      	subs	r2, r2, r1
 8020b70:	408b      	lsls	r3, r1
 8020b72:	40d0      	lsrs	r0, r2
 8020b74:	408d      	lsls	r5, r1
 8020b76:	4303      	orrs	r3, r0
 8020b78:	428e      	cmp	r6, r1
 8020b7a:	dd00      	ble.n	8020b7e <__aeabi_dadd+0xce>
 8020b7c:	e117      	b.n	8020dae <__aeabi_dadd+0x2fe>
 8020b7e:	1b8e      	subs	r6, r1, r6
 8020b80:	1c72      	adds	r2, r6, #1
 8020b82:	2a1f      	cmp	r2, #31
 8020b84:	dd00      	ble.n	8020b88 <__aeabi_dadd+0xd8>
 8020b86:	e1a7      	b.n	8020ed8 <__aeabi_dadd+0x428>
 8020b88:	2120      	movs	r1, #32
 8020b8a:	0018      	movs	r0, r3
 8020b8c:	002e      	movs	r6, r5
 8020b8e:	1a89      	subs	r1, r1, r2
 8020b90:	408d      	lsls	r5, r1
 8020b92:	4088      	lsls	r0, r1
 8020b94:	40d6      	lsrs	r6, r2
 8020b96:	40d3      	lsrs	r3, r2
 8020b98:	1e69      	subs	r1, r5, #1
 8020b9a:	418d      	sbcs	r5, r1
 8020b9c:	4330      	orrs	r0, r6
 8020b9e:	4698      	mov	r8, r3
 8020ba0:	2600      	movs	r6, #0
 8020ba2:	4305      	orrs	r5, r0
 8020ba4:	076b      	lsls	r3, r5, #29
 8020ba6:	d009      	beq.n	8020bbc <__aeabi_dadd+0x10c>
 8020ba8:	230f      	movs	r3, #15
 8020baa:	402b      	ands	r3, r5
 8020bac:	2b04      	cmp	r3, #4
 8020bae:	d005      	beq.n	8020bbc <__aeabi_dadd+0x10c>
 8020bb0:	1d2b      	adds	r3, r5, #4
 8020bb2:	42ab      	cmp	r3, r5
 8020bb4:	41ad      	sbcs	r5, r5
 8020bb6:	426d      	negs	r5, r5
 8020bb8:	44a8      	add	r8, r5
 8020bba:	001d      	movs	r5, r3
 8020bbc:	4643      	mov	r3, r8
 8020bbe:	021b      	lsls	r3, r3, #8
 8020bc0:	d400      	bmi.n	8020bc4 <__aeabi_dadd+0x114>
 8020bc2:	e094      	b.n	8020cee <__aeabi_dadd+0x23e>
 8020bc4:	4b97      	ldr	r3, [pc, #604]	; (8020e24 <__aeabi_dadd+0x374>)
 8020bc6:	1c72      	adds	r2, r6, #1
 8020bc8:	429a      	cmp	r2, r3
 8020bca:	d100      	bne.n	8020bce <__aeabi_dadd+0x11e>
 8020bcc:	e09d      	b.n	8020d0a <__aeabi_dadd+0x25a>
 8020bce:	4641      	mov	r1, r8
 8020bd0:	4b95      	ldr	r3, [pc, #596]	; (8020e28 <__aeabi_dadd+0x378>)
 8020bd2:	08ed      	lsrs	r5, r5, #3
 8020bd4:	4019      	ands	r1, r3
 8020bd6:	000b      	movs	r3, r1
 8020bd8:	0552      	lsls	r2, r2, #21
 8020bda:	0749      	lsls	r1, r1, #29
 8020bdc:	025b      	lsls	r3, r3, #9
 8020bde:	4329      	orrs	r1, r5
 8020be0:	0b1b      	lsrs	r3, r3, #12
 8020be2:	0d52      	lsrs	r2, r2, #21
 8020be4:	0512      	lsls	r2, r2, #20
 8020be6:	4313      	orrs	r3, r2
 8020be8:	07e4      	lsls	r4, r4, #31
 8020bea:	4323      	orrs	r3, r4
 8020bec:	0008      	movs	r0, r1
 8020bee:	0019      	movs	r1, r3
 8020bf0:	bce0      	pop	{r5, r6, r7}
 8020bf2:	46ba      	mov	sl, r7
 8020bf4:	46b1      	mov	r9, r6
 8020bf6:	46a8      	mov	r8, r5
 8020bf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020bfa:	2a00      	cmp	r2, #0
 8020bfc:	d043      	beq.n	8020c86 <__aeabi_dadd+0x1d6>
 8020bfe:	1b8a      	subs	r2, r1, r6
 8020c00:	2e00      	cmp	r6, #0
 8020c02:	d000      	beq.n	8020c06 <__aeabi_dadd+0x156>
 8020c04:	e12a      	b.n	8020e5c <__aeabi_dadd+0x3ac>
 8020c06:	464c      	mov	r4, r9
 8020c08:	431c      	orrs	r4, r3
 8020c0a:	d100      	bne.n	8020c0e <__aeabi_dadd+0x15e>
 8020c0c:	e1d1      	b.n	8020fb2 <__aeabi_dadd+0x502>
 8020c0e:	1e54      	subs	r4, r2, #1
 8020c10:	2a01      	cmp	r2, #1
 8020c12:	d100      	bne.n	8020c16 <__aeabi_dadd+0x166>
 8020c14:	e21f      	b.n	8021056 <__aeabi_dadd+0x5a6>
 8020c16:	4d83      	ldr	r5, [pc, #524]	; (8020e24 <__aeabi_dadd+0x374>)
 8020c18:	42aa      	cmp	r2, r5
 8020c1a:	d100      	bne.n	8020c1e <__aeabi_dadd+0x16e>
 8020c1c:	e272      	b.n	8021104 <__aeabi_dadd+0x654>
 8020c1e:	0022      	movs	r2, r4
 8020c20:	e123      	b.n	8020e6a <__aeabi_dadd+0x3ba>
 8020c22:	2a00      	cmp	r2, #0
 8020c24:	dc00      	bgt.n	8020c28 <__aeabi_dadd+0x178>
 8020c26:	e098      	b.n	8020d5a <__aeabi_dadd+0x2aa>
 8020c28:	2900      	cmp	r1, #0
 8020c2a:	d042      	beq.n	8020cb2 <__aeabi_dadd+0x202>
 8020c2c:	497d      	ldr	r1, [pc, #500]	; (8020e24 <__aeabi_dadd+0x374>)
 8020c2e:	428e      	cmp	r6, r1
 8020c30:	d100      	bne.n	8020c34 <__aeabi_dadd+0x184>
 8020c32:	e0da      	b.n	8020dea <__aeabi_dadd+0x33a>
 8020c34:	2180      	movs	r1, #128	; 0x80
 8020c36:	0028      	movs	r0, r5
 8020c38:	0409      	lsls	r1, r1, #16
 8020c3a:	4308      	orrs	r0, r1
 8020c3c:	4684      	mov	ip, r0
 8020c3e:	2a38      	cmp	r2, #56	; 0x38
 8020c40:	dd00      	ble.n	8020c44 <__aeabi_dadd+0x194>
 8020c42:	e129      	b.n	8020e98 <__aeabi_dadd+0x3e8>
 8020c44:	2a1f      	cmp	r2, #31
 8020c46:	dc00      	bgt.n	8020c4a <__aeabi_dadd+0x19a>
 8020c48:	e187      	b.n	8020f5a <__aeabi_dadd+0x4aa>
 8020c4a:	0011      	movs	r1, r2
 8020c4c:	4665      	mov	r5, ip
 8020c4e:	3920      	subs	r1, #32
 8020c50:	40cd      	lsrs	r5, r1
 8020c52:	2a20      	cmp	r2, #32
 8020c54:	d004      	beq.n	8020c60 <__aeabi_dadd+0x1b0>
 8020c56:	2040      	movs	r0, #64	; 0x40
 8020c58:	4661      	mov	r1, ip
 8020c5a:	1a82      	subs	r2, r0, r2
 8020c5c:	4091      	lsls	r1, r2
 8020c5e:	430f      	orrs	r7, r1
 8020c60:	0039      	movs	r1, r7
 8020c62:	1e4f      	subs	r7, r1, #1
 8020c64:	41b9      	sbcs	r1, r7
 8020c66:	430d      	orrs	r5, r1
 8020c68:	e11b      	b.n	8020ea2 <__aeabi_dadd+0x3f2>
 8020c6a:	0029      	movs	r1, r5
 8020c6c:	4339      	orrs	r1, r7
 8020c6e:	d100      	bne.n	8020c72 <__aeabi_dadd+0x1c2>
 8020c70:	e0b5      	b.n	8020dde <__aeabi_dadd+0x32e>
 8020c72:	1e51      	subs	r1, r2, #1
 8020c74:	2a01      	cmp	r2, #1
 8020c76:	d100      	bne.n	8020c7a <__aeabi_dadd+0x1ca>
 8020c78:	e1ab      	b.n	8020fd2 <__aeabi_dadd+0x522>
 8020c7a:	486a      	ldr	r0, [pc, #424]	; (8020e24 <__aeabi_dadd+0x374>)
 8020c7c:	4282      	cmp	r2, r0
 8020c7e:	d100      	bne.n	8020c82 <__aeabi_dadd+0x1d2>
 8020c80:	e1b2      	b.n	8020fe8 <__aeabi_dadd+0x538>
 8020c82:	000a      	movs	r2, r1
 8020c84:	e743      	b.n	8020b0e <__aeabi_dadd+0x5e>
 8020c86:	4969      	ldr	r1, [pc, #420]	; (8020e2c <__aeabi_dadd+0x37c>)
 8020c88:	1c75      	adds	r5, r6, #1
 8020c8a:	420d      	tst	r5, r1
 8020c8c:	d000      	beq.n	8020c90 <__aeabi_dadd+0x1e0>
 8020c8e:	e0cf      	b.n	8020e30 <__aeabi_dadd+0x380>
 8020c90:	2e00      	cmp	r6, #0
 8020c92:	d000      	beq.n	8020c96 <__aeabi_dadd+0x1e6>
 8020c94:	e193      	b.n	8020fbe <__aeabi_dadd+0x50e>
 8020c96:	4649      	mov	r1, r9
 8020c98:	4319      	orrs	r1, r3
 8020c9a:	d100      	bne.n	8020c9e <__aeabi_dadd+0x1ee>
 8020c9c:	e1d1      	b.n	8021042 <__aeabi_dadd+0x592>
 8020c9e:	4661      	mov	r1, ip
 8020ca0:	4339      	orrs	r1, r7
 8020ca2:	d000      	beq.n	8020ca6 <__aeabi_dadd+0x1f6>
 8020ca4:	e1e3      	b.n	802106e <__aeabi_dadd+0x5be>
 8020ca6:	4649      	mov	r1, r9
 8020ca8:	0758      	lsls	r0, r3, #29
 8020caa:	08c9      	lsrs	r1, r1, #3
 8020cac:	4301      	orrs	r1, r0
 8020cae:	08db      	lsrs	r3, r3, #3
 8020cb0:	e026      	b.n	8020d00 <__aeabi_dadd+0x250>
 8020cb2:	0029      	movs	r1, r5
 8020cb4:	4339      	orrs	r1, r7
 8020cb6:	d100      	bne.n	8020cba <__aeabi_dadd+0x20a>
 8020cb8:	e091      	b.n	8020dde <__aeabi_dadd+0x32e>
 8020cba:	1e51      	subs	r1, r2, #1
 8020cbc:	2a01      	cmp	r2, #1
 8020cbe:	d005      	beq.n	8020ccc <__aeabi_dadd+0x21c>
 8020cc0:	4858      	ldr	r0, [pc, #352]	; (8020e24 <__aeabi_dadd+0x374>)
 8020cc2:	4282      	cmp	r2, r0
 8020cc4:	d100      	bne.n	8020cc8 <__aeabi_dadd+0x218>
 8020cc6:	e18f      	b.n	8020fe8 <__aeabi_dadd+0x538>
 8020cc8:	000a      	movs	r2, r1
 8020cca:	e7b8      	b.n	8020c3e <__aeabi_dadd+0x18e>
 8020ccc:	003d      	movs	r5, r7
 8020cce:	444d      	add	r5, r9
 8020cd0:	454d      	cmp	r5, r9
 8020cd2:	4189      	sbcs	r1, r1
 8020cd4:	4463      	add	r3, ip
 8020cd6:	4698      	mov	r8, r3
 8020cd8:	4249      	negs	r1, r1
 8020cda:	4488      	add	r8, r1
 8020cdc:	4643      	mov	r3, r8
 8020cde:	2602      	movs	r6, #2
 8020ce0:	021b      	lsls	r3, r3, #8
 8020ce2:	d500      	bpl.n	8020ce6 <__aeabi_dadd+0x236>
 8020ce4:	e0eb      	b.n	8020ebe <__aeabi_dadd+0x40e>
 8020ce6:	3e01      	subs	r6, #1
 8020ce8:	076b      	lsls	r3, r5, #29
 8020cea:	d000      	beq.n	8020cee <__aeabi_dadd+0x23e>
 8020cec:	e75c      	b.n	8020ba8 <__aeabi_dadd+0xf8>
 8020cee:	4643      	mov	r3, r8
 8020cf0:	08e9      	lsrs	r1, r5, #3
 8020cf2:	075a      	lsls	r2, r3, #29
 8020cf4:	4311      	orrs	r1, r2
 8020cf6:	0032      	movs	r2, r6
 8020cf8:	08db      	lsrs	r3, r3, #3
 8020cfa:	484a      	ldr	r0, [pc, #296]	; (8020e24 <__aeabi_dadd+0x374>)
 8020cfc:	4282      	cmp	r2, r0
 8020cfe:	d021      	beq.n	8020d44 <__aeabi_dadd+0x294>
 8020d00:	031b      	lsls	r3, r3, #12
 8020d02:	0552      	lsls	r2, r2, #21
 8020d04:	0b1b      	lsrs	r3, r3, #12
 8020d06:	0d52      	lsrs	r2, r2, #21
 8020d08:	e76c      	b.n	8020be4 <__aeabi_dadd+0x134>
 8020d0a:	2300      	movs	r3, #0
 8020d0c:	2100      	movs	r1, #0
 8020d0e:	e769      	b.n	8020be4 <__aeabi_dadd+0x134>
 8020d10:	002a      	movs	r2, r5
 8020d12:	433a      	orrs	r2, r7
 8020d14:	d069      	beq.n	8020dea <__aeabi_dadd+0x33a>
 8020d16:	464a      	mov	r2, r9
 8020d18:	0758      	lsls	r0, r3, #29
 8020d1a:	08d1      	lsrs	r1, r2, #3
 8020d1c:	08da      	lsrs	r2, r3, #3
 8020d1e:	2380      	movs	r3, #128	; 0x80
 8020d20:	031b      	lsls	r3, r3, #12
 8020d22:	4308      	orrs	r0, r1
 8020d24:	421a      	tst	r2, r3
 8020d26:	d007      	beq.n	8020d38 <__aeabi_dadd+0x288>
 8020d28:	0029      	movs	r1, r5
 8020d2a:	08ed      	lsrs	r5, r5, #3
 8020d2c:	421d      	tst	r5, r3
 8020d2e:	d103      	bne.n	8020d38 <__aeabi_dadd+0x288>
 8020d30:	002a      	movs	r2, r5
 8020d32:	08ff      	lsrs	r7, r7, #3
 8020d34:	0748      	lsls	r0, r1, #29
 8020d36:	4338      	orrs	r0, r7
 8020d38:	0f43      	lsrs	r3, r0, #29
 8020d3a:	00c1      	lsls	r1, r0, #3
 8020d3c:	075b      	lsls	r3, r3, #29
 8020d3e:	08c9      	lsrs	r1, r1, #3
 8020d40:	4319      	orrs	r1, r3
 8020d42:	0013      	movs	r3, r2
 8020d44:	000a      	movs	r2, r1
 8020d46:	431a      	orrs	r2, r3
 8020d48:	d100      	bne.n	8020d4c <__aeabi_dadd+0x29c>
 8020d4a:	e213      	b.n	8021174 <__aeabi_dadd+0x6c4>
 8020d4c:	2280      	movs	r2, #128	; 0x80
 8020d4e:	0312      	lsls	r2, r2, #12
 8020d50:	4313      	orrs	r3, r2
 8020d52:	031b      	lsls	r3, r3, #12
 8020d54:	4a33      	ldr	r2, [pc, #204]	; (8020e24 <__aeabi_dadd+0x374>)
 8020d56:	0b1b      	lsrs	r3, r3, #12
 8020d58:	e744      	b.n	8020be4 <__aeabi_dadd+0x134>
 8020d5a:	2a00      	cmp	r2, #0
 8020d5c:	d04b      	beq.n	8020df6 <__aeabi_dadd+0x346>
 8020d5e:	1b8a      	subs	r2, r1, r6
 8020d60:	2e00      	cmp	r6, #0
 8020d62:	d100      	bne.n	8020d66 <__aeabi_dadd+0x2b6>
 8020d64:	e0e7      	b.n	8020f36 <__aeabi_dadd+0x486>
 8020d66:	482f      	ldr	r0, [pc, #188]	; (8020e24 <__aeabi_dadd+0x374>)
 8020d68:	4281      	cmp	r1, r0
 8020d6a:	d100      	bne.n	8020d6e <__aeabi_dadd+0x2be>
 8020d6c:	e195      	b.n	802109a <__aeabi_dadd+0x5ea>
 8020d6e:	2080      	movs	r0, #128	; 0x80
 8020d70:	0400      	lsls	r0, r0, #16
 8020d72:	4303      	orrs	r3, r0
 8020d74:	2a38      	cmp	r2, #56	; 0x38
 8020d76:	dd00      	ble.n	8020d7a <__aeabi_dadd+0x2ca>
 8020d78:	e143      	b.n	8021002 <__aeabi_dadd+0x552>
 8020d7a:	2a1f      	cmp	r2, #31
 8020d7c:	dd00      	ble.n	8020d80 <__aeabi_dadd+0x2d0>
 8020d7e:	e1db      	b.n	8021138 <__aeabi_dadd+0x688>
 8020d80:	2020      	movs	r0, #32
 8020d82:	001d      	movs	r5, r3
 8020d84:	464e      	mov	r6, r9
 8020d86:	1a80      	subs	r0, r0, r2
 8020d88:	4085      	lsls	r5, r0
 8020d8a:	40d6      	lsrs	r6, r2
 8020d8c:	4335      	orrs	r5, r6
 8020d8e:	464e      	mov	r6, r9
 8020d90:	4086      	lsls	r6, r0
 8020d92:	0030      	movs	r0, r6
 8020d94:	40d3      	lsrs	r3, r2
 8020d96:	1e46      	subs	r6, r0, #1
 8020d98:	41b0      	sbcs	r0, r6
 8020d9a:	449c      	add	ip, r3
 8020d9c:	4305      	orrs	r5, r0
 8020d9e:	19ed      	adds	r5, r5, r7
 8020da0:	42bd      	cmp	r5, r7
 8020da2:	419b      	sbcs	r3, r3
 8020da4:	425b      	negs	r3, r3
 8020da6:	4463      	add	r3, ip
 8020da8:	4698      	mov	r8, r3
 8020daa:	000e      	movs	r6, r1
 8020dac:	e07f      	b.n	8020eae <__aeabi_dadd+0x3fe>
 8020dae:	4a1e      	ldr	r2, [pc, #120]	; (8020e28 <__aeabi_dadd+0x378>)
 8020db0:	1a76      	subs	r6, r6, r1
 8020db2:	4013      	ands	r3, r2
 8020db4:	4698      	mov	r8, r3
 8020db6:	e6f5      	b.n	8020ba4 <__aeabi_dadd+0xf4>
 8020db8:	0028      	movs	r0, r5
 8020dba:	f000 fb7f 	bl	80214bc <__clzsi2>
 8020dbe:	0001      	movs	r1, r0
 8020dc0:	3118      	adds	r1, #24
 8020dc2:	291f      	cmp	r1, #31
 8020dc4:	dc00      	bgt.n	8020dc8 <__aeabi_dadd+0x318>
 8020dc6:	e6cf      	b.n	8020b68 <__aeabi_dadd+0xb8>
 8020dc8:	002b      	movs	r3, r5
 8020dca:	3808      	subs	r0, #8
 8020dcc:	4083      	lsls	r3, r0
 8020dce:	2500      	movs	r5, #0
 8020dd0:	e6d2      	b.n	8020b78 <__aeabi_dadd+0xc8>
 8020dd2:	4662      	mov	r2, ip
 8020dd4:	433a      	orrs	r2, r7
 8020dd6:	0011      	movs	r1, r2
 8020dd8:	1e4f      	subs	r7, r1, #1
 8020dda:	41b9      	sbcs	r1, r7
 8020ddc:	e6ac      	b.n	8020b38 <__aeabi_dadd+0x88>
 8020dde:	4649      	mov	r1, r9
 8020de0:	0758      	lsls	r0, r3, #29
 8020de2:	08c9      	lsrs	r1, r1, #3
 8020de4:	4301      	orrs	r1, r0
 8020de6:	08db      	lsrs	r3, r3, #3
 8020de8:	e787      	b.n	8020cfa <__aeabi_dadd+0x24a>
 8020dea:	4649      	mov	r1, r9
 8020dec:	075a      	lsls	r2, r3, #29
 8020dee:	08c9      	lsrs	r1, r1, #3
 8020df0:	4311      	orrs	r1, r2
 8020df2:	08db      	lsrs	r3, r3, #3
 8020df4:	e7a6      	b.n	8020d44 <__aeabi_dadd+0x294>
 8020df6:	490d      	ldr	r1, [pc, #52]	; (8020e2c <__aeabi_dadd+0x37c>)
 8020df8:	1c70      	adds	r0, r6, #1
 8020dfa:	4208      	tst	r0, r1
 8020dfc:	d000      	beq.n	8020e00 <__aeabi_dadd+0x350>
 8020dfe:	e0bb      	b.n	8020f78 <__aeabi_dadd+0x4c8>
 8020e00:	2e00      	cmp	r6, #0
 8020e02:	d000      	beq.n	8020e06 <__aeabi_dadd+0x356>
 8020e04:	e114      	b.n	8021030 <__aeabi_dadd+0x580>
 8020e06:	4649      	mov	r1, r9
 8020e08:	4319      	orrs	r1, r3
 8020e0a:	d100      	bne.n	8020e0e <__aeabi_dadd+0x35e>
 8020e0c:	e175      	b.n	80210fa <__aeabi_dadd+0x64a>
 8020e0e:	0029      	movs	r1, r5
 8020e10:	4339      	orrs	r1, r7
 8020e12:	d000      	beq.n	8020e16 <__aeabi_dadd+0x366>
 8020e14:	e17e      	b.n	8021114 <__aeabi_dadd+0x664>
 8020e16:	4649      	mov	r1, r9
 8020e18:	0758      	lsls	r0, r3, #29
 8020e1a:	08c9      	lsrs	r1, r1, #3
 8020e1c:	4301      	orrs	r1, r0
 8020e1e:	08db      	lsrs	r3, r3, #3
 8020e20:	e76e      	b.n	8020d00 <__aeabi_dadd+0x250>
 8020e22:	46c0      	nop			; (mov r8, r8)
 8020e24:	000007ff 	.word	0x000007ff
 8020e28:	ff7fffff 	.word	0xff7fffff
 8020e2c:	000007fe 	.word	0x000007fe
 8020e30:	4649      	mov	r1, r9
 8020e32:	1bcd      	subs	r5, r1, r7
 8020e34:	4661      	mov	r1, ip
 8020e36:	1a58      	subs	r0, r3, r1
 8020e38:	45a9      	cmp	r9, r5
 8020e3a:	4189      	sbcs	r1, r1
 8020e3c:	4249      	negs	r1, r1
 8020e3e:	4688      	mov	r8, r1
 8020e40:	0001      	movs	r1, r0
 8020e42:	4640      	mov	r0, r8
 8020e44:	1a09      	subs	r1, r1, r0
 8020e46:	4688      	mov	r8, r1
 8020e48:	0209      	lsls	r1, r1, #8
 8020e4a:	d500      	bpl.n	8020e4e <__aeabi_dadd+0x39e>
 8020e4c:	e0a6      	b.n	8020f9c <__aeabi_dadd+0x4ec>
 8020e4e:	4641      	mov	r1, r8
 8020e50:	4329      	orrs	r1, r5
 8020e52:	d000      	beq.n	8020e56 <__aeabi_dadd+0x3a6>
 8020e54:	e67f      	b.n	8020b56 <__aeabi_dadd+0xa6>
 8020e56:	2300      	movs	r3, #0
 8020e58:	2400      	movs	r4, #0
 8020e5a:	e751      	b.n	8020d00 <__aeabi_dadd+0x250>
 8020e5c:	4cc7      	ldr	r4, [pc, #796]	; (802117c <__aeabi_dadd+0x6cc>)
 8020e5e:	42a1      	cmp	r1, r4
 8020e60:	d100      	bne.n	8020e64 <__aeabi_dadd+0x3b4>
 8020e62:	e0c7      	b.n	8020ff4 <__aeabi_dadd+0x544>
 8020e64:	2480      	movs	r4, #128	; 0x80
 8020e66:	0424      	lsls	r4, r4, #16
 8020e68:	4323      	orrs	r3, r4
 8020e6a:	2a38      	cmp	r2, #56	; 0x38
 8020e6c:	dc54      	bgt.n	8020f18 <__aeabi_dadd+0x468>
 8020e6e:	2a1f      	cmp	r2, #31
 8020e70:	dd00      	ble.n	8020e74 <__aeabi_dadd+0x3c4>
 8020e72:	e0cc      	b.n	802100e <__aeabi_dadd+0x55e>
 8020e74:	2420      	movs	r4, #32
 8020e76:	4648      	mov	r0, r9
 8020e78:	1aa4      	subs	r4, r4, r2
 8020e7a:	001d      	movs	r5, r3
 8020e7c:	464e      	mov	r6, r9
 8020e7e:	40a0      	lsls	r0, r4
 8020e80:	40d6      	lsrs	r6, r2
 8020e82:	40a5      	lsls	r5, r4
 8020e84:	0004      	movs	r4, r0
 8020e86:	40d3      	lsrs	r3, r2
 8020e88:	4662      	mov	r2, ip
 8020e8a:	4335      	orrs	r5, r6
 8020e8c:	1e66      	subs	r6, r4, #1
 8020e8e:	41b4      	sbcs	r4, r6
 8020e90:	1ad3      	subs	r3, r2, r3
 8020e92:	469c      	mov	ip, r3
 8020e94:	4325      	orrs	r5, r4
 8020e96:	e044      	b.n	8020f22 <__aeabi_dadd+0x472>
 8020e98:	4662      	mov	r2, ip
 8020e9a:	433a      	orrs	r2, r7
 8020e9c:	0015      	movs	r5, r2
 8020e9e:	1e6f      	subs	r7, r5, #1
 8020ea0:	41bd      	sbcs	r5, r7
 8020ea2:	444d      	add	r5, r9
 8020ea4:	454d      	cmp	r5, r9
 8020ea6:	4189      	sbcs	r1, r1
 8020ea8:	4249      	negs	r1, r1
 8020eaa:	4688      	mov	r8, r1
 8020eac:	4498      	add	r8, r3
 8020eae:	4643      	mov	r3, r8
 8020eb0:	021b      	lsls	r3, r3, #8
 8020eb2:	d400      	bmi.n	8020eb6 <__aeabi_dadd+0x406>
 8020eb4:	e718      	b.n	8020ce8 <__aeabi_dadd+0x238>
 8020eb6:	4bb1      	ldr	r3, [pc, #708]	; (802117c <__aeabi_dadd+0x6cc>)
 8020eb8:	3601      	adds	r6, #1
 8020eba:	429e      	cmp	r6, r3
 8020ebc:	d049      	beq.n	8020f52 <__aeabi_dadd+0x4a2>
 8020ebe:	4642      	mov	r2, r8
 8020ec0:	4baf      	ldr	r3, [pc, #700]	; (8021180 <__aeabi_dadd+0x6d0>)
 8020ec2:	2101      	movs	r1, #1
 8020ec4:	401a      	ands	r2, r3
 8020ec6:	0013      	movs	r3, r2
 8020ec8:	086a      	lsrs	r2, r5, #1
 8020eca:	400d      	ands	r5, r1
 8020ecc:	4315      	orrs	r5, r2
 8020ece:	07d9      	lsls	r1, r3, #31
 8020ed0:	085b      	lsrs	r3, r3, #1
 8020ed2:	4698      	mov	r8, r3
 8020ed4:	430d      	orrs	r5, r1
 8020ed6:	e665      	b.n	8020ba4 <__aeabi_dadd+0xf4>
 8020ed8:	0018      	movs	r0, r3
 8020eda:	3e1f      	subs	r6, #31
 8020edc:	40f0      	lsrs	r0, r6
 8020ede:	2a20      	cmp	r2, #32
 8020ee0:	d003      	beq.n	8020eea <__aeabi_dadd+0x43a>
 8020ee2:	2140      	movs	r1, #64	; 0x40
 8020ee4:	1a8a      	subs	r2, r1, r2
 8020ee6:	4093      	lsls	r3, r2
 8020ee8:	431d      	orrs	r5, r3
 8020eea:	1e69      	subs	r1, r5, #1
 8020eec:	418d      	sbcs	r5, r1
 8020eee:	2300      	movs	r3, #0
 8020ef0:	2600      	movs	r6, #0
 8020ef2:	4698      	mov	r8, r3
 8020ef4:	4305      	orrs	r5, r0
 8020ef6:	e6f7      	b.n	8020ce8 <__aeabi_dadd+0x238>
 8020ef8:	0011      	movs	r1, r2
 8020efa:	4665      	mov	r5, ip
 8020efc:	3920      	subs	r1, #32
 8020efe:	40cd      	lsrs	r5, r1
 8020f00:	2a20      	cmp	r2, #32
 8020f02:	d004      	beq.n	8020f0e <__aeabi_dadd+0x45e>
 8020f04:	2040      	movs	r0, #64	; 0x40
 8020f06:	4661      	mov	r1, ip
 8020f08:	1a82      	subs	r2, r0, r2
 8020f0a:	4091      	lsls	r1, r2
 8020f0c:	430f      	orrs	r7, r1
 8020f0e:	0039      	movs	r1, r7
 8020f10:	1e4f      	subs	r7, r1, #1
 8020f12:	41b9      	sbcs	r1, r7
 8020f14:	4329      	orrs	r1, r5
 8020f16:	e60f      	b.n	8020b38 <__aeabi_dadd+0x88>
 8020f18:	464a      	mov	r2, r9
 8020f1a:	4313      	orrs	r3, r2
 8020f1c:	001d      	movs	r5, r3
 8020f1e:	1e6b      	subs	r3, r5, #1
 8020f20:	419d      	sbcs	r5, r3
 8020f22:	1b7d      	subs	r5, r7, r5
 8020f24:	42af      	cmp	r7, r5
 8020f26:	419b      	sbcs	r3, r3
 8020f28:	4662      	mov	r2, ip
 8020f2a:	425b      	negs	r3, r3
 8020f2c:	1ad3      	subs	r3, r2, r3
 8020f2e:	4698      	mov	r8, r3
 8020f30:	4654      	mov	r4, sl
 8020f32:	000e      	movs	r6, r1
 8020f34:	e607      	b.n	8020b46 <__aeabi_dadd+0x96>
 8020f36:	4648      	mov	r0, r9
 8020f38:	4318      	orrs	r0, r3
 8020f3a:	d100      	bne.n	8020f3e <__aeabi_dadd+0x48e>
 8020f3c:	e0b3      	b.n	80210a6 <__aeabi_dadd+0x5f6>
 8020f3e:	1e50      	subs	r0, r2, #1
 8020f40:	2a01      	cmp	r2, #1
 8020f42:	d100      	bne.n	8020f46 <__aeabi_dadd+0x496>
 8020f44:	e10d      	b.n	8021162 <__aeabi_dadd+0x6b2>
 8020f46:	4d8d      	ldr	r5, [pc, #564]	; (802117c <__aeabi_dadd+0x6cc>)
 8020f48:	42aa      	cmp	r2, r5
 8020f4a:	d100      	bne.n	8020f4e <__aeabi_dadd+0x49e>
 8020f4c:	e0a5      	b.n	802109a <__aeabi_dadd+0x5ea>
 8020f4e:	0002      	movs	r2, r0
 8020f50:	e710      	b.n	8020d74 <__aeabi_dadd+0x2c4>
 8020f52:	0032      	movs	r2, r6
 8020f54:	2300      	movs	r3, #0
 8020f56:	2100      	movs	r1, #0
 8020f58:	e644      	b.n	8020be4 <__aeabi_dadd+0x134>
 8020f5a:	2120      	movs	r1, #32
 8020f5c:	0038      	movs	r0, r7
 8020f5e:	1a89      	subs	r1, r1, r2
 8020f60:	4665      	mov	r5, ip
 8020f62:	408f      	lsls	r7, r1
 8020f64:	408d      	lsls	r5, r1
 8020f66:	40d0      	lsrs	r0, r2
 8020f68:	1e79      	subs	r1, r7, #1
 8020f6a:	418f      	sbcs	r7, r1
 8020f6c:	4305      	orrs	r5, r0
 8020f6e:	433d      	orrs	r5, r7
 8020f70:	4667      	mov	r7, ip
 8020f72:	40d7      	lsrs	r7, r2
 8020f74:	19db      	adds	r3, r3, r7
 8020f76:	e794      	b.n	8020ea2 <__aeabi_dadd+0x3f2>
 8020f78:	4a80      	ldr	r2, [pc, #512]	; (802117c <__aeabi_dadd+0x6cc>)
 8020f7a:	4290      	cmp	r0, r2
 8020f7c:	d100      	bne.n	8020f80 <__aeabi_dadd+0x4d0>
 8020f7e:	e0ec      	b.n	802115a <__aeabi_dadd+0x6aa>
 8020f80:	0039      	movs	r1, r7
 8020f82:	4449      	add	r1, r9
 8020f84:	4549      	cmp	r1, r9
 8020f86:	4192      	sbcs	r2, r2
 8020f88:	4463      	add	r3, ip
 8020f8a:	4252      	negs	r2, r2
 8020f8c:	189b      	adds	r3, r3, r2
 8020f8e:	07dd      	lsls	r5, r3, #31
 8020f90:	0849      	lsrs	r1, r1, #1
 8020f92:	085b      	lsrs	r3, r3, #1
 8020f94:	4698      	mov	r8, r3
 8020f96:	0006      	movs	r6, r0
 8020f98:	430d      	orrs	r5, r1
 8020f9a:	e6a5      	b.n	8020ce8 <__aeabi_dadd+0x238>
 8020f9c:	464a      	mov	r2, r9
 8020f9e:	1abd      	subs	r5, r7, r2
 8020fa0:	42af      	cmp	r7, r5
 8020fa2:	4189      	sbcs	r1, r1
 8020fa4:	4662      	mov	r2, ip
 8020fa6:	4249      	negs	r1, r1
 8020fa8:	1ad3      	subs	r3, r2, r3
 8020faa:	1a5b      	subs	r3, r3, r1
 8020fac:	4698      	mov	r8, r3
 8020fae:	4654      	mov	r4, sl
 8020fb0:	e5d1      	b.n	8020b56 <__aeabi_dadd+0xa6>
 8020fb2:	076c      	lsls	r4, r5, #29
 8020fb4:	08f9      	lsrs	r1, r7, #3
 8020fb6:	4321      	orrs	r1, r4
 8020fb8:	08eb      	lsrs	r3, r5, #3
 8020fba:	0004      	movs	r4, r0
 8020fbc:	e69d      	b.n	8020cfa <__aeabi_dadd+0x24a>
 8020fbe:	464a      	mov	r2, r9
 8020fc0:	431a      	orrs	r2, r3
 8020fc2:	d175      	bne.n	80210b0 <__aeabi_dadd+0x600>
 8020fc4:	4661      	mov	r1, ip
 8020fc6:	4339      	orrs	r1, r7
 8020fc8:	d114      	bne.n	8020ff4 <__aeabi_dadd+0x544>
 8020fca:	2380      	movs	r3, #128	; 0x80
 8020fcc:	2400      	movs	r4, #0
 8020fce:	031b      	lsls	r3, r3, #12
 8020fd0:	e6bc      	b.n	8020d4c <__aeabi_dadd+0x29c>
 8020fd2:	464a      	mov	r2, r9
 8020fd4:	1bd5      	subs	r5, r2, r7
 8020fd6:	45a9      	cmp	r9, r5
 8020fd8:	4189      	sbcs	r1, r1
 8020fda:	4662      	mov	r2, ip
 8020fdc:	4249      	negs	r1, r1
 8020fde:	1a9b      	subs	r3, r3, r2
 8020fe0:	1a5b      	subs	r3, r3, r1
 8020fe2:	4698      	mov	r8, r3
 8020fe4:	2601      	movs	r6, #1
 8020fe6:	e5ae      	b.n	8020b46 <__aeabi_dadd+0x96>
 8020fe8:	464a      	mov	r2, r9
 8020fea:	08d1      	lsrs	r1, r2, #3
 8020fec:	075a      	lsls	r2, r3, #29
 8020fee:	4311      	orrs	r1, r2
 8020ff0:	08db      	lsrs	r3, r3, #3
 8020ff2:	e6a7      	b.n	8020d44 <__aeabi_dadd+0x294>
 8020ff4:	4663      	mov	r3, ip
 8020ff6:	08f9      	lsrs	r1, r7, #3
 8020ff8:	075a      	lsls	r2, r3, #29
 8020ffa:	4654      	mov	r4, sl
 8020ffc:	4311      	orrs	r1, r2
 8020ffe:	08db      	lsrs	r3, r3, #3
 8021000:	e6a0      	b.n	8020d44 <__aeabi_dadd+0x294>
 8021002:	464a      	mov	r2, r9
 8021004:	4313      	orrs	r3, r2
 8021006:	001d      	movs	r5, r3
 8021008:	1e6b      	subs	r3, r5, #1
 802100a:	419d      	sbcs	r5, r3
 802100c:	e6c7      	b.n	8020d9e <__aeabi_dadd+0x2ee>
 802100e:	0014      	movs	r4, r2
 8021010:	001e      	movs	r6, r3
 8021012:	3c20      	subs	r4, #32
 8021014:	40e6      	lsrs	r6, r4
 8021016:	2a20      	cmp	r2, #32
 8021018:	d005      	beq.n	8021026 <__aeabi_dadd+0x576>
 802101a:	2440      	movs	r4, #64	; 0x40
 802101c:	1aa2      	subs	r2, r4, r2
 802101e:	4093      	lsls	r3, r2
 8021020:	464a      	mov	r2, r9
 8021022:	431a      	orrs	r2, r3
 8021024:	4691      	mov	r9, r2
 8021026:	464d      	mov	r5, r9
 8021028:	1e6b      	subs	r3, r5, #1
 802102a:	419d      	sbcs	r5, r3
 802102c:	4335      	orrs	r5, r6
 802102e:	e778      	b.n	8020f22 <__aeabi_dadd+0x472>
 8021030:	464a      	mov	r2, r9
 8021032:	431a      	orrs	r2, r3
 8021034:	d000      	beq.n	8021038 <__aeabi_dadd+0x588>
 8021036:	e66b      	b.n	8020d10 <__aeabi_dadd+0x260>
 8021038:	076b      	lsls	r3, r5, #29
 802103a:	08f9      	lsrs	r1, r7, #3
 802103c:	4319      	orrs	r1, r3
 802103e:	08eb      	lsrs	r3, r5, #3
 8021040:	e680      	b.n	8020d44 <__aeabi_dadd+0x294>
 8021042:	4661      	mov	r1, ip
 8021044:	4339      	orrs	r1, r7
 8021046:	d054      	beq.n	80210f2 <__aeabi_dadd+0x642>
 8021048:	4663      	mov	r3, ip
 802104a:	08f9      	lsrs	r1, r7, #3
 802104c:	075c      	lsls	r4, r3, #29
 802104e:	4321      	orrs	r1, r4
 8021050:	08db      	lsrs	r3, r3, #3
 8021052:	0004      	movs	r4, r0
 8021054:	e654      	b.n	8020d00 <__aeabi_dadd+0x250>
 8021056:	464a      	mov	r2, r9
 8021058:	1abd      	subs	r5, r7, r2
 802105a:	42af      	cmp	r7, r5
 802105c:	4189      	sbcs	r1, r1
 802105e:	4662      	mov	r2, ip
 8021060:	4249      	negs	r1, r1
 8021062:	1ad3      	subs	r3, r2, r3
 8021064:	1a5b      	subs	r3, r3, r1
 8021066:	4698      	mov	r8, r3
 8021068:	0004      	movs	r4, r0
 802106a:	2601      	movs	r6, #1
 802106c:	e56b      	b.n	8020b46 <__aeabi_dadd+0x96>
 802106e:	464a      	mov	r2, r9
 8021070:	1bd5      	subs	r5, r2, r7
 8021072:	45a9      	cmp	r9, r5
 8021074:	4189      	sbcs	r1, r1
 8021076:	4662      	mov	r2, ip
 8021078:	4249      	negs	r1, r1
 802107a:	1a9a      	subs	r2, r3, r2
 802107c:	1a52      	subs	r2, r2, r1
 802107e:	4690      	mov	r8, r2
 8021080:	0212      	lsls	r2, r2, #8
 8021082:	d532      	bpl.n	80210ea <__aeabi_dadd+0x63a>
 8021084:	464a      	mov	r2, r9
 8021086:	1abd      	subs	r5, r7, r2
 8021088:	42af      	cmp	r7, r5
 802108a:	4189      	sbcs	r1, r1
 802108c:	4662      	mov	r2, ip
 802108e:	4249      	negs	r1, r1
 8021090:	1ad3      	subs	r3, r2, r3
 8021092:	1a5b      	subs	r3, r3, r1
 8021094:	4698      	mov	r8, r3
 8021096:	0004      	movs	r4, r0
 8021098:	e584      	b.n	8020ba4 <__aeabi_dadd+0xf4>
 802109a:	4663      	mov	r3, ip
 802109c:	08f9      	lsrs	r1, r7, #3
 802109e:	075a      	lsls	r2, r3, #29
 80210a0:	4311      	orrs	r1, r2
 80210a2:	08db      	lsrs	r3, r3, #3
 80210a4:	e64e      	b.n	8020d44 <__aeabi_dadd+0x294>
 80210a6:	08f9      	lsrs	r1, r7, #3
 80210a8:	0768      	lsls	r0, r5, #29
 80210aa:	4301      	orrs	r1, r0
 80210ac:	08eb      	lsrs	r3, r5, #3
 80210ae:	e624      	b.n	8020cfa <__aeabi_dadd+0x24a>
 80210b0:	4662      	mov	r2, ip
 80210b2:	433a      	orrs	r2, r7
 80210b4:	d100      	bne.n	80210b8 <__aeabi_dadd+0x608>
 80210b6:	e698      	b.n	8020dea <__aeabi_dadd+0x33a>
 80210b8:	464a      	mov	r2, r9
 80210ba:	08d1      	lsrs	r1, r2, #3
 80210bc:	075a      	lsls	r2, r3, #29
 80210be:	4311      	orrs	r1, r2
 80210c0:	08da      	lsrs	r2, r3, #3
 80210c2:	2380      	movs	r3, #128	; 0x80
 80210c4:	031b      	lsls	r3, r3, #12
 80210c6:	421a      	tst	r2, r3
 80210c8:	d008      	beq.n	80210dc <__aeabi_dadd+0x62c>
 80210ca:	4660      	mov	r0, ip
 80210cc:	08c5      	lsrs	r5, r0, #3
 80210ce:	421d      	tst	r5, r3
 80210d0:	d104      	bne.n	80210dc <__aeabi_dadd+0x62c>
 80210d2:	4654      	mov	r4, sl
 80210d4:	002a      	movs	r2, r5
 80210d6:	08f9      	lsrs	r1, r7, #3
 80210d8:	0743      	lsls	r3, r0, #29
 80210da:	4319      	orrs	r1, r3
 80210dc:	0f4b      	lsrs	r3, r1, #29
 80210de:	00c9      	lsls	r1, r1, #3
 80210e0:	075b      	lsls	r3, r3, #29
 80210e2:	08c9      	lsrs	r1, r1, #3
 80210e4:	4319      	orrs	r1, r3
 80210e6:	0013      	movs	r3, r2
 80210e8:	e62c      	b.n	8020d44 <__aeabi_dadd+0x294>
 80210ea:	4641      	mov	r1, r8
 80210ec:	4329      	orrs	r1, r5
 80210ee:	d000      	beq.n	80210f2 <__aeabi_dadd+0x642>
 80210f0:	e5fa      	b.n	8020ce8 <__aeabi_dadd+0x238>
 80210f2:	2300      	movs	r3, #0
 80210f4:	000a      	movs	r2, r1
 80210f6:	2400      	movs	r4, #0
 80210f8:	e602      	b.n	8020d00 <__aeabi_dadd+0x250>
 80210fa:	076b      	lsls	r3, r5, #29
 80210fc:	08f9      	lsrs	r1, r7, #3
 80210fe:	4319      	orrs	r1, r3
 8021100:	08eb      	lsrs	r3, r5, #3
 8021102:	e5fd      	b.n	8020d00 <__aeabi_dadd+0x250>
 8021104:	4663      	mov	r3, ip
 8021106:	08f9      	lsrs	r1, r7, #3
 8021108:	075b      	lsls	r3, r3, #29
 802110a:	4319      	orrs	r1, r3
 802110c:	4663      	mov	r3, ip
 802110e:	0004      	movs	r4, r0
 8021110:	08db      	lsrs	r3, r3, #3
 8021112:	e617      	b.n	8020d44 <__aeabi_dadd+0x294>
 8021114:	003d      	movs	r5, r7
 8021116:	444d      	add	r5, r9
 8021118:	4463      	add	r3, ip
 802111a:	454d      	cmp	r5, r9
 802111c:	4189      	sbcs	r1, r1
 802111e:	4698      	mov	r8, r3
 8021120:	4249      	negs	r1, r1
 8021122:	4488      	add	r8, r1
 8021124:	4643      	mov	r3, r8
 8021126:	021b      	lsls	r3, r3, #8
 8021128:	d400      	bmi.n	802112c <__aeabi_dadd+0x67c>
 802112a:	e5dd      	b.n	8020ce8 <__aeabi_dadd+0x238>
 802112c:	4642      	mov	r2, r8
 802112e:	4b14      	ldr	r3, [pc, #80]	; (8021180 <__aeabi_dadd+0x6d0>)
 8021130:	2601      	movs	r6, #1
 8021132:	401a      	ands	r2, r3
 8021134:	4690      	mov	r8, r2
 8021136:	e5d7      	b.n	8020ce8 <__aeabi_dadd+0x238>
 8021138:	0010      	movs	r0, r2
 802113a:	001e      	movs	r6, r3
 802113c:	3820      	subs	r0, #32
 802113e:	40c6      	lsrs	r6, r0
 8021140:	2a20      	cmp	r2, #32
 8021142:	d005      	beq.n	8021150 <__aeabi_dadd+0x6a0>
 8021144:	2040      	movs	r0, #64	; 0x40
 8021146:	1a82      	subs	r2, r0, r2
 8021148:	4093      	lsls	r3, r2
 802114a:	464a      	mov	r2, r9
 802114c:	431a      	orrs	r2, r3
 802114e:	4691      	mov	r9, r2
 8021150:	464d      	mov	r5, r9
 8021152:	1e6b      	subs	r3, r5, #1
 8021154:	419d      	sbcs	r5, r3
 8021156:	4335      	orrs	r5, r6
 8021158:	e621      	b.n	8020d9e <__aeabi_dadd+0x2ee>
 802115a:	0002      	movs	r2, r0
 802115c:	2300      	movs	r3, #0
 802115e:	2100      	movs	r1, #0
 8021160:	e540      	b.n	8020be4 <__aeabi_dadd+0x134>
 8021162:	464a      	mov	r2, r9
 8021164:	19d5      	adds	r5, r2, r7
 8021166:	42bd      	cmp	r5, r7
 8021168:	4189      	sbcs	r1, r1
 802116a:	4463      	add	r3, ip
 802116c:	4698      	mov	r8, r3
 802116e:	4249      	negs	r1, r1
 8021170:	4488      	add	r8, r1
 8021172:	e5b3      	b.n	8020cdc <__aeabi_dadd+0x22c>
 8021174:	2100      	movs	r1, #0
 8021176:	4a01      	ldr	r2, [pc, #4]	; (802117c <__aeabi_dadd+0x6cc>)
 8021178:	000b      	movs	r3, r1
 802117a:	e533      	b.n	8020be4 <__aeabi_dadd+0x134>
 802117c:	000007ff 	.word	0x000007ff
 8021180:	ff7fffff 	.word	0xff7fffff

08021184 <__eqdf2>:
 8021184:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021186:	464f      	mov	r7, r9
 8021188:	4646      	mov	r6, r8
 802118a:	46d6      	mov	lr, sl
 802118c:	4694      	mov	ip, r2
 802118e:	4691      	mov	r9, r2
 8021190:	031a      	lsls	r2, r3, #12
 8021192:	0b12      	lsrs	r2, r2, #12
 8021194:	4d18      	ldr	r5, [pc, #96]	; (80211f8 <__eqdf2+0x74>)
 8021196:	b5c0      	push	{r6, r7, lr}
 8021198:	004c      	lsls	r4, r1, #1
 802119a:	030f      	lsls	r7, r1, #12
 802119c:	4692      	mov	sl, r2
 802119e:	005a      	lsls	r2, r3, #1
 80211a0:	0006      	movs	r6, r0
 80211a2:	4680      	mov	r8, r0
 80211a4:	0b3f      	lsrs	r7, r7, #12
 80211a6:	2001      	movs	r0, #1
 80211a8:	0d64      	lsrs	r4, r4, #21
 80211aa:	0fc9      	lsrs	r1, r1, #31
 80211ac:	0d52      	lsrs	r2, r2, #21
 80211ae:	0fdb      	lsrs	r3, r3, #31
 80211b0:	42ac      	cmp	r4, r5
 80211b2:	d00a      	beq.n	80211ca <__eqdf2+0x46>
 80211b4:	42aa      	cmp	r2, r5
 80211b6:	d003      	beq.n	80211c0 <__eqdf2+0x3c>
 80211b8:	4294      	cmp	r4, r2
 80211ba:	d101      	bne.n	80211c0 <__eqdf2+0x3c>
 80211bc:	4557      	cmp	r7, sl
 80211be:	d00d      	beq.n	80211dc <__eqdf2+0x58>
 80211c0:	bce0      	pop	{r5, r6, r7}
 80211c2:	46ba      	mov	sl, r7
 80211c4:	46b1      	mov	r9, r6
 80211c6:	46a8      	mov	r8, r5
 80211c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80211ca:	003d      	movs	r5, r7
 80211cc:	4335      	orrs	r5, r6
 80211ce:	d1f7      	bne.n	80211c0 <__eqdf2+0x3c>
 80211d0:	42a2      	cmp	r2, r4
 80211d2:	d1f5      	bne.n	80211c0 <__eqdf2+0x3c>
 80211d4:	4652      	mov	r2, sl
 80211d6:	4665      	mov	r5, ip
 80211d8:	432a      	orrs	r2, r5
 80211da:	d1f1      	bne.n	80211c0 <__eqdf2+0x3c>
 80211dc:	2001      	movs	r0, #1
 80211de:	45c8      	cmp	r8, r9
 80211e0:	d1ee      	bne.n	80211c0 <__eqdf2+0x3c>
 80211e2:	4299      	cmp	r1, r3
 80211e4:	d006      	beq.n	80211f4 <__eqdf2+0x70>
 80211e6:	2c00      	cmp	r4, #0
 80211e8:	d1ea      	bne.n	80211c0 <__eqdf2+0x3c>
 80211ea:	433e      	orrs	r6, r7
 80211ec:	0030      	movs	r0, r6
 80211ee:	1e46      	subs	r6, r0, #1
 80211f0:	41b0      	sbcs	r0, r6
 80211f2:	e7e5      	b.n	80211c0 <__eqdf2+0x3c>
 80211f4:	2000      	movs	r0, #0
 80211f6:	e7e3      	b.n	80211c0 <__eqdf2+0x3c>
 80211f8:	000007ff 	.word	0x000007ff

080211fc <__gedf2>:
 80211fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80211fe:	464e      	mov	r6, r9
 8021200:	4645      	mov	r5, r8
 8021202:	4657      	mov	r7, sl
 8021204:	46de      	mov	lr, fp
 8021206:	0004      	movs	r4, r0
 8021208:	0018      	movs	r0, r3
 802120a:	b5e0      	push	{r5, r6, r7, lr}
 802120c:	0016      	movs	r6, r2
 802120e:	031b      	lsls	r3, r3, #12
 8021210:	0b1b      	lsrs	r3, r3, #12
 8021212:	4d32      	ldr	r5, [pc, #200]	; (80212dc <__gedf2+0xe0>)
 8021214:	030f      	lsls	r7, r1, #12
 8021216:	004a      	lsls	r2, r1, #1
 8021218:	4699      	mov	r9, r3
 802121a:	0043      	lsls	r3, r0, #1
 802121c:	46a4      	mov	ip, r4
 802121e:	46b0      	mov	r8, r6
 8021220:	0b3f      	lsrs	r7, r7, #12
 8021222:	0d52      	lsrs	r2, r2, #21
 8021224:	0fc9      	lsrs	r1, r1, #31
 8021226:	0d5b      	lsrs	r3, r3, #21
 8021228:	0fc0      	lsrs	r0, r0, #31
 802122a:	42aa      	cmp	r2, r5
 802122c:	d029      	beq.n	8021282 <__gedf2+0x86>
 802122e:	42ab      	cmp	r3, r5
 8021230:	d018      	beq.n	8021264 <__gedf2+0x68>
 8021232:	2a00      	cmp	r2, #0
 8021234:	d12a      	bne.n	802128c <__gedf2+0x90>
 8021236:	433c      	orrs	r4, r7
 8021238:	46a3      	mov	fp, r4
 802123a:	4265      	negs	r5, r4
 802123c:	4165      	adcs	r5, r4
 802123e:	2b00      	cmp	r3, #0
 8021240:	d102      	bne.n	8021248 <__gedf2+0x4c>
 8021242:	464c      	mov	r4, r9
 8021244:	4326      	orrs	r6, r4
 8021246:	d027      	beq.n	8021298 <__gedf2+0x9c>
 8021248:	2d00      	cmp	r5, #0
 802124a:	d115      	bne.n	8021278 <__gedf2+0x7c>
 802124c:	4281      	cmp	r1, r0
 802124e:	d028      	beq.n	80212a2 <__gedf2+0xa6>
 8021250:	2002      	movs	r0, #2
 8021252:	3901      	subs	r1, #1
 8021254:	4008      	ands	r0, r1
 8021256:	3801      	subs	r0, #1
 8021258:	bcf0      	pop	{r4, r5, r6, r7}
 802125a:	46bb      	mov	fp, r7
 802125c:	46b2      	mov	sl, r6
 802125e:	46a9      	mov	r9, r5
 8021260:	46a0      	mov	r8, r4
 8021262:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021264:	464d      	mov	r5, r9
 8021266:	432e      	orrs	r6, r5
 8021268:	d12f      	bne.n	80212ca <__gedf2+0xce>
 802126a:	2a00      	cmp	r2, #0
 802126c:	d1ee      	bne.n	802124c <__gedf2+0x50>
 802126e:	433c      	orrs	r4, r7
 8021270:	4265      	negs	r5, r4
 8021272:	4165      	adcs	r5, r4
 8021274:	2d00      	cmp	r5, #0
 8021276:	d0e9      	beq.n	802124c <__gedf2+0x50>
 8021278:	2800      	cmp	r0, #0
 802127a:	d1ed      	bne.n	8021258 <__gedf2+0x5c>
 802127c:	2001      	movs	r0, #1
 802127e:	4240      	negs	r0, r0
 8021280:	e7ea      	b.n	8021258 <__gedf2+0x5c>
 8021282:	003d      	movs	r5, r7
 8021284:	4325      	orrs	r5, r4
 8021286:	d120      	bne.n	80212ca <__gedf2+0xce>
 8021288:	4293      	cmp	r3, r2
 802128a:	d0eb      	beq.n	8021264 <__gedf2+0x68>
 802128c:	2b00      	cmp	r3, #0
 802128e:	d1dd      	bne.n	802124c <__gedf2+0x50>
 8021290:	464c      	mov	r4, r9
 8021292:	4326      	orrs	r6, r4
 8021294:	d1da      	bne.n	802124c <__gedf2+0x50>
 8021296:	e7db      	b.n	8021250 <__gedf2+0x54>
 8021298:	465b      	mov	r3, fp
 802129a:	2000      	movs	r0, #0
 802129c:	2b00      	cmp	r3, #0
 802129e:	d0db      	beq.n	8021258 <__gedf2+0x5c>
 80212a0:	e7d6      	b.n	8021250 <__gedf2+0x54>
 80212a2:	429a      	cmp	r2, r3
 80212a4:	dc0a      	bgt.n	80212bc <__gedf2+0xc0>
 80212a6:	dbe7      	blt.n	8021278 <__gedf2+0x7c>
 80212a8:	454f      	cmp	r7, r9
 80212aa:	d8d1      	bhi.n	8021250 <__gedf2+0x54>
 80212ac:	d010      	beq.n	80212d0 <__gedf2+0xd4>
 80212ae:	2000      	movs	r0, #0
 80212b0:	454f      	cmp	r7, r9
 80212b2:	d2d1      	bcs.n	8021258 <__gedf2+0x5c>
 80212b4:	2900      	cmp	r1, #0
 80212b6:	d0e1      	beq.n	802127c <__gedf2+0x80>
 80212b8:	0008      	movs	r0, r1
 80212ba:	e7cd      	b.n	8021258 <__gedf2+0x5c>
 80212bc:	4243      	negs	r3, r0
 80212be:	4158      	adcs	r0, r3
 80212c0:	2302      	movs	r3, #2
 80212c2:	4240      	negs	r0, r0
 80212c4:	4018      	ands	r0, r3
 80212c6:	3801      	subs	r0, #1
 80212c8:	e7c6      	b.n	8021258 <__gedf2+0x5c>
 80212ca:	2002      	movs	r0, #2
 80212cc:	4240      	negs	r0, r0
 80212ce:	e7c3      	b.n	8021258 <__gedf2+0x5c>
 80212d0:	45c4      	cmp	ip, r8
 80212d2:	d8bd      	bhi.n	8021250 <__gedf2+0x54>
 80212d4:	2000      	movs	r0, #0
 80212d6:	45c4      	cmp	ip, r8
 80212d8:	d2be      	bcs.n	8021258 <__gedf2+0x5c>
 80212da:	e7eb      	b.n	80212b4 <__gedf2+0xb8>
 80212dc:	000007ff 	.word	0x000007ff

080212e0 <__ledf2>:
 80212e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80212e2:	464e      	mov	r6, r9
 80212e4:	4645      	mov	r5, r8
 80212e6:	4657      	mov	r7, sl
 80212e8:	46de      	mov	lr, fp
 80212ea:	0004      	movs	r4, r0
 80212ec:	0018      	movs	r0, r3
 80212ee:	b5e0      	push	{r5, r6, r7, lr}
 80212f0:	0016      	movs	r6, r2
 80212f2:	031b      	lsls	r3, r3, #12
 80212f4:	0b1b      	lsrs	r3, r3, #12
 80212f6:	4d31      	ldr	r5, [pc, #196]	; (80213bc <__ledf2+0xdc>)
 80212f8:	030f      	lsls	r7, r1, #12
 80212fa:	004a      	lsls	r2, r1, #1
 80212fc:	4699      	mov	r9, r3
 80212fe:	0043      	lsls	r3, r0, #1
 8021300:	46a4      	mov	ip, r4
 8021302:	46b0      	mov	r8, r6
 8021304:	0b3f      	lsrs	r7, r7, #12
 8021306:	0d52      	lsrs	r2, r2, #21
 8021308:	0fc9      	lsrs	r1, r1, #31
 802130a:	0d5b      	lsrs	r3, r3, #21
 802130c:	0fc0      	lsrs	r0, r0, #31
 802130e:	42aa      	cmp	r2, r5
 8021310:	d011      	beq.n	8021336 <__ledf2+0x56>
 8021312:	42ab      	cmp	r3, r5
 8021314:	d014      	beq.n	8021340 <__ledf2+0x60>
 8021316:	2a00      	cmp	r2, #0
 8021318:	d12f      	bne.n	802137a <__ledf2+0x9a>
 802131a:	433c      	orrs	r4, r7
 802131c:	46a3      	mov	fp, r4
 802131e:	4265      	negs	r5, r4
 8021320:	4165      	adcs	r5, r4
 8021322:	2b00      	cmp	r3, #0
 8021324:	d114      	bne.n	8021350 <__ledf2+0x70>
 8021326:	464c      	mov	r4, r9
 8021328:	4326      	orrs	r6, r4
 802132a:	d111      	bne.n	8021350 <__ledf2+0x70>
 802132c:	465b      	mov	r3, fp
 802132e:	2000      	movs	r0, #0
 8021330:	2b00      	cmp	r3, #0
 8021332:	d017      	beq.n	8021364 <__ledf2+0x84>
 8021334:	e010      	b.n	8021358 <__ledf2+0x78>
 8021336:	003d      	movs	r5, r7
 8021338:	4325      	orrs	r5, r4
 802133a:	d112      	bne.n	8021362 <__ledf2+0x82>
 802133c:	4293      	cmp	r3, r2
 802133e:	d11c      	bne.n	802137a <__ledf2+0x9a>
 8021340:	464d      	mov	r5, r9
 8021342:	432e      	orrs	r6, r5
 8021344:	d10d      	bne.n	8021362 <__ledf2+0x82>
 8021346:	2a00      	cmp	r2, #0
 8021348:	d104      	bne.n	8021354 <__ledf2+0x74>
 802134a:	433c      	orrs	r4, r7
 802134c:	4265      	negs	r5, r4
 802134e:	4165      	adcs	r5, r4
 8021350:	2d00      	cmp	r5, #0
 8021352:	d10d      	bne.n	8021370 <__ledf2+0x90>
 8021354:	4281      	cmp	r1, r0
 8021356:	d016      	beq.n	8021386 <__ledf2+0xa6>
 8021358:	2002      	movs	r0, #2
 802135a:	3901      	subs	r1, #1
 802135c:	4008      	ands	r0, r1
 802135e:	3801      	subs	r0, #1
 8021360:	e000      	b.n	8021364 <__ledf2+0x84>
 8021362:	2002      	movs	r0, #2
 8021364:	bcf0      	pop	{r4, r5, r6, r7}
 8021366:	46bb      	mov	fp, r7
 8021368:	46b2      	mov	sl, r6
 802136a:	46a9      	mov	r9, r5
 802136c:	46a0      	mov	r8, r4
 802136e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021370:	2800      	cmp	r0, #0
 8021372:	d1f7      	bne.n	8021364 <__ledf2+0x84>
 8021374:	2001      	movs	r0, #1
 8021376:	4240      	negs	r0, r0
 8021378:	e7f4      	b.n	8021364 <__ledf2+0x84>
 802137a:	2b00      	cmp	r3, #0
 802137c:	d1ea      	bne.n	8021354 <__ledf2+0x74>
 802137e:	464c      	mov	r4, r9
 8021380:	4326      	orrs	r6, r4
 8021382:	d1e7      	bne.n	8021354 <__ledf2+0x74>
 8021384:	e7e8      	b.n	8021358 <__ledf2+0x78>
 8021386:	429a      	cmp	r2, r3
 8021388:	dd06      	ble.n	8021398 <__ledf2+0xb8>
 802138a:	4243      	negs	r3, r0
 802138c:	4158      	adcs	r0, r3
 802138e:	2302      	movs	r3, #2
 8021390:	4240      	negs	r0, r0
 8021392:	4018      	ands	r0, r3
 8021394:	3801      	subs	r0, #1
 8021396:	e7e5      	b.n	8021364 <__ledf2+0x84>
 8021398:	429a      	cmp	r2, r3
 802139a:	dbe9      	blt.n	8021370 <__ledf2+0x90>
 802139c:	454f      	cmp	r7, r9
 802139e:	d8db      	bhi.n	8021358 <__ledf2+0x78>
 80213a0:	d006      	beq.n	80213b0 <__ledf2+0xd0>
 80213a2:	2000      	movs	r0, #0
 80213a4:	454f      	cmp	r7, r9
 80213a6:	d2dd      	bcs.n	8021364 <__ledf2+0x84>
 80213a8:	2900      	cmp	r1, #0
 80213aa:	d0e3      	beq.n	8021374 <__ledf2+0x94>
 80213ac:	0008      	movs	r0, r1
 80213ae:	e7d9      	b.n	8021364 <__ledf2+0x84>
 80213b0:	45c4      	cmp	ip, r8
 80213b2:	d8d1      	bhi.n	8021358 <__ledf2+0x78>
 80213b4:	2000      	movs	r0, #0
 80213b6:	45c4      	cmp	ip, r8
 80213b8:	d2d4      	bcs.n	8021364 <__ledf2+0x84>
 80213ba:	e7f5      	b.n	80213a8 <__ledf2+0xc8>
 80213bc:	000007ff 	.word	0x000007ff

080213c0 <__aeabi_d2iz>:
 80213c0:	000a      	movs	r2, r1
 80213c2:	b530      	push	{r4, r5, lr}
 80213c4:	4c13      	ldr	r4, [pc, #76]	; (8021414 <__aeabi_d2iz+0x54>)
 80213c6:	0053      	lsls	r3, r2, #1
 80213c8:	0309      	lsls	r1, r1, #12
 80213ca:	0005      	movs	r5, r0
 80213cc:	0b09      	lsrs	r1, r1, #12
 80213ce:	2000      	movs	r0, #0
 80213d0:	0d5b      	lsrs	r3, r3, #21
 80213d2:	0fd2      	lsrs	r2, r2, #31
 80213d4:	42a3      	cmp	r3, r4
 80213d6:	dd04      	ble.n	80213e2 <__aeabi_d2iz+0x22>
 80213d8:	480f      	ldr	r0, [pc, #60]	; (8021418 <__aeabi_d2iz+0x58>)
 80213da:	4283      	cmp	r3, r0
 80213dc:	dd02      	ble.n	80213e4 <__aeabi_d2iz+0x24>
 80213de:	4b0f      	ldr	r3, [pc, #60]	; (802141c <__aeabi_d2iz+0x5c>)
 80213e0:	18d0      	adds	r0, r2, r3
 80213e2:	bd30      	pop	{r4, r5, pc}
 80213e4:	2080      	movs	r0, #128	; 0x80
 80213e6:	0340      	lsls	r0, r0, #13
 80213e8:	4301      	orrs	r1, r0
 80213ea:	480d      	ldr	r0, [pc, #52]	; (8021420 <__aeabi_d2iz+0x60>)
 80213ec:	1ac0      	subs	r0, r0, r3
 80213ee:	281f      	cmp	r0, #31
 80213f0:	dd08      	ble.n	8021404 <__aeabi_d2iz+0x44>
 80213f2:	480c      	ldr	r0, [pc, #48]	; (8021424 <__aeabi_d2iz+0x64>)
 80213f4:	1ac3      	subs	r3, r0, r3
 80213f6:	40d9      	lsrs	r1, r3
 80213f8:	000b      	movs	r3, r1
 80213fa:	4258      	negs	r0, r3
 80213fc:	2a00      	cmp	r2, #0
 80213fe:	d1f0      	bne.n	80213e2 <__aeabi_d2iz+0x22>
 8021400:	0018      	movs	r0, r3
 8021402:	e7ee      	b.n	80213e2 <__aeabi_d2iz+0x22>
 8021404:	4c08      	ldr	r4, [pc, #32]	; (8021428 <__aeabi_d2iz+0x68>)
 8021406:	40c5      	lsrs	r5, r0
 8021408:	46a4      	mov	ip, r4
 802140a:	4463      	add	r3, ip
 802140c:	4099      	lsls	r1, r3
 802140e:	000b      	movs	r3, r1
 8021410:	432b      	orrs	r3, r5
 8021412:	e7f2      	b.n	80213fa <__aeabi_d2iz+0x3a>
 8021414:	000003fe 	.word	0x000003fe
 8021418:	0000041d 	.word	0x0000041d
 802141c:	7fffffff 	.word	0x7fffffff
 8021420:	00000433 	.word	0x00000433
 8021424:	00000413 	.word	0x00000413
 8021428:	fffffbed 	.word	0xfffffbed

0802142c <__aeabi_f2d>:
 802142c:	b570      	push	{r4, r5, r6, lr}
 802142e:	0043      	lsls	r3, r0, #1
 8021430:	0246      	lsls	r6, r0, #9
 8021432:	0fc4      	lsrs	r4, r0, #31
 8021434:	20fe      	movs	r0, #254	; 0xfe
 8021436:	0e1b      	lsrs	r3, r3, #24
 8021438:	1c59      	adds	r1, r3, #1
 802143a:	0a75      	lsrs	r5, r6, #9
 802143c:	4208      	tst	r0, r1
 802143e:	d00c      	beq.n	802145a <__aeabi_f2d+0x2e>
 8021440:	22e0      	movs	r2, #224	; 0xe0
 8021442:	0092      	lsls	r2, r2, #2
 8021444:	4694      	mov	ip, r2
 8021446:	076d      	lsls	r5, r5, #29
 8021448:	0b36      	lsrs	r6, r6, #12
 802144a:	4463      	add	r3, ip
 802144c:	051b      	lsls	r3, r3, #20
 802144e:	4333      	orrs	r3, r6
 8021450:	07e4      	lsls	r4, r4, #31
 8021452:	4323      	orrs	r3, r4
 8021454:	0028      	movs	r0, r5
 8021456:	0019      	movs	r1, r3
 8021458:	bd70      	pop	{r4, r5, r6, pc}
 802145a:	2b00      	cmp	r3, #0
 802145c:	d114      	bne.n	8021488 <__aeabi_f2d+0x5c>
 802145e:	2d00      	cmp	r5, #0
 8021460:	d01b      	beq.n	802149a <__aeabi_f2d+0x6e>
 8021462:	0028      	movs	r0, r5
 8021464:	f000 f82a 	bl	80214bc <__clzsi2>
 8021468:	280a      	cmp	r0, #10
 802146a:	dc1c      	bgt.n	80214a6 <__aeabi_f2d+0x7a>
 802146c:	230b      	movs	r3, #11
 802146e:	002a      	movs	r2, r5
 8021470:	1a1b      	subs	r3, r3, r0
 8021472:	40da      	lsrs	r2, r3
 8021474:	0003      	movs	r3, r0
 8021476:	3315      	adds	r3, #21
 8021478:	409d      	lsls	r5, r3
 802147a:	4b0e      	ldr	r3, [pc, #56]	; (80214b4 <__aeabi_f2d+0x88>)
 802147c:	0312      	lsls	r2, r2, #12
 802147e:	1a1b      	subs	r3, r3, r0
 8021480:	055b      	lsls	r3, r3, #21
 8021482:	0b16      	lsrs	r6, r2, #12
 8021484:	0d5b      	lsrs	r3, r3, #21
 8021486:	e7e1      	b.n	802144c <__aeabi_f2d+0x20>
 8021488:	2d00      	cmp	r5, #0
 802148a:	d009      	beq.n	80214a0 <__aeabi_f2d+0x74>
 802148c:	0b32      	lsrs	r2, r6, #12
 802148e:	2680      	movs	r6, #128	; 0x80
 8021490:	0336      	lsls	r6, r6, #12
 8021492:	4b09      	ldr	r3, [pc, #36]	; (80214b8 <__aeabi_f2d+0x8c>)
 8021494:	076d      	lsls	r5, r5, #29
 8021496:	4316      	orrs	r6, r2
 8021498:	e7d8      	b.n	802144c <__aeabi_f2d+0x20>
 802149a:	2300      	movs	r3, #0
 802149c:	2600      	movs	r6, #0
 802149e:	e7d5      	b.n	802144c <__aeabi_f2d+0x20>
 80214a0:	2600      	movs	r6, #0
 80214a2:	4b05      	ldr	r3, [pc, #20]	; (80214b8 <__aeabi_f2d+0x8c>)
 80214a4:	e7d2      	b.n	802144c <__aeabi_f2d+0x20>
 80214a6:	0003      	movs	r3, r0
 80214a8:	002a      	movs	r2, r5
 80214aa:	3b0b      	subs	r3, #11
 80214ac:	409a      	lsls	r2, r3
 80214ae:	2500      	movs	r5, #0
 80214b0:	e7e3      	b.n	802147a <__aeabi_f2d+0x4e>
 80214b2:	46c0      	nop			; (mov r8, r8)
 80214b4:	00000389 	.word	0x00000389
 80214b8:	000007ff 	.word	0x000007ff

080214bc <__clzsi2>:
 80214bc:	211c      	movs	r1, #28
 80214be:	2301      	movs	r3, #1
 80214c0:	041b      	lsls	r3, r3, #16
 80214c2:	4298      	cmp	r0, r3
 80214c4:	d301      	bcc.n	80214ca <__clzsi2+0xe>
 80214c6:	0c00      	lsrs	r0, r0, #16
 80214c8:	3910      	subs	r1, #16
 80214ca:	0a1b      	lsrs	r3, r3, #8
 80214cc:	4298      	cmp	r0, r3
 80214ce:	d301      	bcc.n	80214d4 <__clzsi2+0x18>
 80214d0:	0a00      	lsrs	r0, r0, #8
 80214d2:	3908      	subs	r1, #8
 80214d4:	091b      	lsrs	r3, r3, #4
 80214d6:	4298      	cmp	r0, r3
 80214d8:	d301      	bcc.n	80214de <__clzsi2+0x22>
 80214da:	0900      	lsrs	r0, r0, #4
 80214dc:	3904      	subs	r1, #4
 80214de:	a202      	add	r2, pc, #8	; (adr r2, 80214e8 <__clzsi2+0x2c>)
 80214e0:	5c10      	ldrb	r0, [r2, r0]
 80214e2:	1840      	adds	r0, r0, r1
 80214e4:	4770      	bx	lr
 80214e6:	46c0      	nop			; (mov r8, r8)
 80214e8:	02020304 	.word	0x02020304
 80214ec:	01010101 	.word	0x01010101
	...

080214f8 <__clzdi2>:
 80214f8:	b510      	push	{r4, lr}
 80214fa:	2900      	cmp	r1, #0
 80214fc:	d103      	bne.n	8021506 <__clzdi2+0xe>
 80214fe:	f7ff ffdd 	bl	80214bc <__clzsi2>
 8021502:	3020      	adds	r0, #32
 8021504:	e002      	b.n	802150c <__clzdi2+0x14>
 8021506:	1c08      	adds	r0, r1, #0
 8021508:	f7ff ffd8 	bl	80214bc <__clzsi2>
 802150c:	bd10      	pop	{r4, pc}
 802150e:	46c0      	nop			; (mov r8, r8)

08021510 <DBG_ProbesInit>:
#endif /* CORE_CM4 */

  /* USER CODE BEGIN DBG_ProbesInit_Last */

  /* USER CODE END DBG_ProbesInit_Last */
}
 8021510:	4770      	bx	lr
	...

08021514 <HAL_CRYP_MspInit>:
  * This function configures the hardware resources
  * @param hcryp: CRYP handle pointer
  * @retval None
  */
void HAL_CRYP_MspInit(CRYP_HandleTypeDef *hcryp)
{
 8021514:	b082      	sub	sp, #8
  /* USER CODE BEGIN HAL_CRYP_MspInit */
  if (hcryp->Instance == CA_AES_INSTANCE)
 8021516:	6802      	ldr	r2, [r0, #0]
 8021518:	4b0b      	ldr	r3, [pc, #44]	; (8021548 <HAL_CRYP_MspInit+0x34>)
 802151a:	429a      	cmp	r2, r3
 802151c:	d001      	beq.n	8021522 <HAL_CRYP_MspInit+0xe>
    __HAL_RCC_AES_RELEASE_RESET();
    /* Peripheral clock enable */
    __HAL_RCC_AES_CLK_ENABLE();
  }
  /* USER CODE END HAL_CRYP_MspInit */
}
 802151e:	b002      	add	sp, #8
 8021520:	4770      	bx	lr
  */

#endif /* DUAL_CORE */
__STATIC_INLINE void LL_AHB3_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->AHB3RSTR, Periphs);
 8021522:	23b0      	movs	r3, #176	; 0xb0
 8021524:	05db      	lsls	r3, r3, #23
 8021526:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8021528:	4908      	ldr	r1, [pc, #32]	; (802154c <HAL_CRYP_MspInit+0x38>)
 802152a:	400a      	ands	r2, r1
 802152c:	631a      	str	r2, [r3, #48]	; 0x30
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 802152e:	22a8      	movs	r2, #168	; 0xa8
 8021530:	0052      	lsls	r2, r2, #1
 8021532:	5899      	ldr	r1, [r3, r2]
 8021534:	2080      	movs	r0, #128	; 0x80
 8021536:	0280      	lsls	r0, r0, #10
 8021538:	4301      	orrs	r1, r0
 802153a:	5099      	str	r1, [r3, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 802153c:	589b      	ldr	r3, [r3, r2]
 802153e:	4003      	ands	r3, r0
 8021540:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8021542:	9b01      	ldr	r3, [sp, #4]
 8021544:	e7eb      	b.n	802151e <HAL_CRYP_MspInit+0xa>
 8021546:	46c0      	nop			; (mov r8, r8)
 8021548:	58001800 	.word	0x58001800
 802154c:	fffdffff 	.word	0xfffdffff

08021550 <HAL_CRYP_MspDeInit>:
  * @retval None
  */
void HAL_CRYP_MspDeInit(CRYP_HandleTypeDef *hcryp)
{
  /* USER CODE BEGIN HAL_CRYP_MspDeInit */
  if (hcryp->Instance == CA_AES_INSTANCE)
 8021550:	6802      	ldr	r2, [r0, #0]
 8021552:	4b09      	ldr	r3, [pc, #36]	; (8021578 <HAL_CRYP_MspDeInit+0x28>)
 8021554:	429a      	cmp	r2, r3
 8021556:	d000      	beq.n	802155a <HAL_CRYP_MspDeInit+0xa>
    __HAL_RCC_AES_CLK_DISABLE();
    /* Force AES/CRYP into reset state */
    __HAL_RCC_AES_FORCE_RESET();
  }
  /* USER CODE END HAL_CRYP_MspDeInit */
}
 8021558:	4770      	bx	lr
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_FLASH
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->C2AHB3ENR, Periphs);
 802155a:	23b0      	movs	r3, #176	; 0xb0
 802155c:	05db      	lsls	r3, r3, #23
 802155e:	21a8      	movs	r1, #168	; 0xa8
 8021560:	0049      	lsls	r1, r1, #1
 8021562:	585a      	ldr	r2, [r3, r1]
 8021564:	4805      	ldr	r0, [pc, #20]	; (802157c <HAL_CRYP_MspDeInit+0x2c>)
 8021566:	4002      	ands	r2, r0
 8021568:	505a      	str	r2, [r3, r1]
  SET_BIT(RCC->AHB3RSTR, Periphs);
 802156a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 802156c:	2280      	movs	r2, #128	; 0x80
 802156e:	0292      	lsls	r2, r2, #10
 8021570:	430a      	orrs	r2, r1
 8021572:	631a      	str	r2, [r3, #48]	; 0x30
 8021574:	e7f0      	b.n	8021558 <HAL_CRYP_MspDeInit+0x8>
 8021576:	46c0      	nop			; (mov r8, r8)
 8021578:	58001800 	.word	0x58001800
 802157c:	fffdffff 	.word	0xfffdffff

08021580 <MX_IPCC_Init>:

IPCC_HandleTypeDef hipcc;

/* IPCC init function */
void MX_IPCC_Init(void)
{
 8021580:	b510      	push	{r4, lr}
  /* USER CODE END IPCC_Init 0 */

  /* USER CODE BEGIN IPCC_Init 1 */

  /* USER CODE END IPCC_Init 1 */
  hipcc.Instance = IPCC;
 8021582:	4805      	ldr	r0, [pc, #20]	; (8021598 <MX_IPCC_Init+0x18>)
 8021584:	4b05      	ldr	r3, [pc, #20]	; (802159c <MX_IPCC_Init+0x1c>)
 8021586:	6003      	str	r3, [r0, #0]
  if (HAL_IPCC_Init(&hipcc) != HAL_OK)
 8021588:	f003 f874 	bl	8024674 <HAL_IPCC_Init>
 802158c:	2800      	cmp	r0, #0
 802158e:	d100      	bne.n	8021592 <MX_IPCC_Init+0x12>
  }
  /* USER CODE BEGIN IPCC_Init 2 */

  /* USER CODE END IPCC_Init 2 */

}
 8021590:	bd10      	pop	{r4, pc}
    Error_Handler();
 8021592:	f000 f8a0 	bl	80216d6 <Error_Handler>
}
 8021596:	e7fb      	b.n	8021590 <MX_IPCC_Init+0x10>
 8021598:	2000b7dc 	.word	0x2000b7dc
 802159c:	58000c00 	.word	0x58000c00

080215a0 <HAL_IPCC_MspInit>:

void HAL_IPCC_MspInit(IPCC_HandleTypeDef* ipccHandle)
{
 80215a0:	b510      	push	{r4, lr}
 80215a2:	b082      	sub	sp, #8

  if(ipccHandle->Instance==IPCC)
 80215a4:	6802      	ldr	r2, [r0, #0]
 80215a6:	4b0d      	ldr	r3, [pc, #52]	; (80215dc <HAL_IPCC_MspInit+0x3c>)
 80215a8:	429a      	cmp	r2, r3
 80215aa:	d001      	beq.n	80215b0 <HAL_IPCC_MspInit+0x10>
    HAL_NVIC_EnableIRQ(IPCC_C2_RX_C2_TX_IRQn);
  /* USER CODE BEGIN IPCC_MspInit 1 */

  /* USER CODE END IPCC_MspInit 1 */
  }
}
 80215ac:	b002      	add	sp, #8
 80215ae:	bd10      	pop	{r4, pc}
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 80215b0:	21b0      	movs	r1, #176	; 0xb0
 80215b2:	05c9      	lsls	r1, r1, #23
 80215b4:	22a8      	movs	r2, #168	; 0xa8
 80215b6:	0052      	lsls	r2, r2, #1
 80215b8:	5888      	ldr	r0, [r1, r2]
 80215ba:	2480      	movs	r4, #128	; 0x80
 80215bc:	0364      	lsls	r4, r4, #13
 80215be:	4320      	orrs	r0, r4
 80215c0:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 80215c2:	588b      	ldr	r3, [r1, r2]
 80215c4:	4023      	ands	r3, r4
 80215c6:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80215c8:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(IPCC_C2_RX_C2_TX_IRQn, 1, 0);
 80215ca:	2200      	movs	r2, #0
 80215cc:	2101      	movs	r1, #1
 80215ce:	2012      	movs	r0, #18
 80215d0:	f001 fdae 	bl	8023130 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(IPCC_C2_RX_C2_TX_IRQn);
 80215d4:	2012      	movs	r0, #18
 80215d6:	f001 fddb 	bl	8023190 <HAL_NVIC_EnableIRQ>
}
 80215da:	e7e7      	b.n	80215ac <HAL_IPCC_MspInit+0xc>
 80215dc:	58000c00 	.word	0x58000c00

080215e0 <IpccIfIsrTxCb>:
/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/

static void IpccIfIsrTxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 80215e0:	b510      	push	{r4, lr}
 80215e2:	0008      	movs	r0, r1

  /* USER CODE END IpccIfIsrTxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccAcknowledgeRcv(ChannelIndex);
 80215e4:	4b01      	ldr	r3, [pc, #4]	; (80215ec <IpccIfIsrTxCb+0xc>)
 80215e6:	681b      	ldr	r3, [r3, #0]
 80215e8:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrTxCb_2 */

  /* USER CODE END IpccIfIsrTxCb_2 */
}
 80215ea:	bd10      	pop	{r4, pc}
 80215ec:	2000a114 	.word	0x2000a114

080215f0 <IpccIfIsrRxCb>:

static void IpccIfIsrRxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 80215f0:	b510      	push	{r4, lr}
 80215f2:	0008      	movs	r0, r1

  /* USER CODE END IpccIfIsrRxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccCommandRcv(ChannelIndex);
 80215f4:	4b01      	ldr	r3, [pc, #4]	; (80215fc <IpccIfIsrRxCb+0xc>)
 80215f6:	681b      	ldr	r3, [r3, #0]
 80215f8:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrRxCb_2 */

  /* USER CODE END IpccIfIsrRxCb_2 */
}
 80215fa:	bd10      	pop	{r4, pc}
 80215fc:	2000a118 	.word	0x2000a118

08021600 <IPCC_IF_Init>:
{
 8021600:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021602:	b083      	sub	sp, #12
 8021604:	0007      	movs	r7, r0
 8021606:	000e      	movs	r6, r1
  MX_IPCC_Init();
 8021608:	f7ff ffba 	bl	8021580 <MX_IPCC_Init>
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 802160c:	21b0      	movs	r1, #176	; 0xb0
 802160e:	05c9      	lsls	r1, r1, #23
 8021610:	22a8      	movs	r2, #168	; 0xa8
 8021612:	0052      	lsls	r2, r2, #1
 8021614:	5888      	ldr	r0, [r1, r2]
 8021616:	2480      	movs	r4, #128	; 0x80
 8021618:	0364      	lsls	r4, r4, #13
 802161a:	4320      	orrs	r0, r4
 802161c:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 802161e:	588b      	ldr	r3, [r1, r2]
 8021620:	4023      	ands	r3, r4
 8021622:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8021624:	9b01      	ldr	r3, [sp, #4]
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_C2_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->C2IMR2, ExtiLine);
 8021626:	4b10      	ldr	r3, [pc, #64]	; (8021668 <IPCC_IF_Init+0x68>)
 8021628:	3a80      	subs	r2, #128	; 0x80
 802162a:	5899      	ldr	r1, [r3, r2]
 802162c:	2020      	movs	r0, #32
 802162e:	4301      	orrs	r1, r0
 8021630:	5099      	str	r1, [r3, r2]
  *         @arg @ref LL_EXTI_LINE_45
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->RTSR2, ExtiLine);
 8021632:	6a1a      	ldr	r2, [r3, #32]
 8021634:	4302      	orrs	r2, r0
 8021636:	621a      	str	r2, [r3, #32]
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8021638:	2400      	movs	r4, #0
 802163a:	2c05      	cmp	r4, #5
 802163c:	d80e      	bhi.n	802165c <IPCC_IF_Init+0x5c>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_TX, IpccIfIsrTxCb);
 802163e:	4d0b      	ldr	r5, [pc, #44]	; (802166c <IPCC_IF_Init+0x6c>)
 8021640:	4b0b      	ldr	r3, [pc, #44]	; (8021670 <IPCC_IF_Init+0x70>)
 8021642:	2200      	movs	r2, #0
 8021644:	0021      	movs	r1, r4
 8021646:	0028      	movs	r0, r5
 8021648:	f002 ffa2 	bl	8024590 <HAL_IPCC_ActivateNotification>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_RX, IpccIfIsrRxCb);
 802164c:	4b09      	ldr	r3, [pc, #36]	; (8021674 <IPCC_IF_Init+0x74>)
 802164e:	2201      	movs	r2, #1
 8021650:	0021      	movs	r1, r4
 8021652:	0028      	movs	r0, r5
 8021654:	f002 ff9c 	bl	8024590 <HAL_IPCC_ActivateNotification>
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8021658:	3401      	adds	r4, #1
 802165a:	e7ee      	b.n	802163a <IPCC_IF_Init+0x3a>
  IpccCommandRcv = IPCC_IF_CommandRcv_cb;
 802165c:	4b06      	ldr	r3, [pc, #24]	; (8021678 <IPCC_IF_Init+0x78>)
 802165e:	601f      	str	r7, [r3, #0]
  IpccAcknowledgeRcv = IPCC_IF_AcknowledgeRcv_cb;
 8021660:	4b06      	ldr	r3, [pc, #24]	; (802167c <IPCC_IF_Init+0x7c>)
 8021662:	601e      	str	r6, [r3, #0]
}
 8021664:	b003      	add	sp, #12
 8021666:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021668:	58000800 	.word	0x58000800
 802166c:	2000b7dc 	.word	0x2000b7dc
 8021670:	080215e1 	.word	0x080215e1
 8021674:	080215f1 	.word	0x080215f1
 8021678:	2000a118 	.word	0x2000a118
 802167c:	2000a114 	.word	0x2000a114

08021680 <IPCC_IF_NotificationSnd>:
{
 8021680:	b510      	push	{r4, lr}
 8021682:	0001      	movs	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_TX))
 8021684:	2200      	movs	r2, #0
 8021686:	4805      	ldr	r0, [pc, #20]	; (802169c <IPCC_IF_NotificationSnd+0x1c>)
 8021688:	f002 ffb2 	bl	80245f0 <HAL_IPCC_NotifyCPU>
 802168c:	2800      	cmp	r0, #0
 802168e:	d101      	bne.n	8021694 <IPCC_IF_NotificationSnd+0x14>
    return 0;
 8021690:	2000      	movs	r0, #0
}
 8021692:	bd10      	pop	{r4, pc}
    return -1;
 8021694:	2001      	movs	r0, #1
 8021696:	4240      	negs	r0, r0
 8021698:	e7fb      	b.n	8021692 <IPCC_IF_NotificationSnd+0x12>
 802169a:	46c0      	nop			; (mov r8, r8)
 802169c:	2000b7dc 	.word	0x2000b7dc

080216a0 <IPCC_IF_ResponseSnd>:
{
 80216a0:	b510      	push	{r4, lr}
 80216a2:	0001      	movs	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_RX))
 80216a4:	2201      	movs	r2, #1
 80216a6:	4805      	ldr	r0, [pc, #20]	; (80216bc <IPCC_IF_ResponseSnd+0x1c>)
 80216a8:	f002 ffa2 	bl	80245f0 <HAL_IPCC_NotifyCPU>
 80216ac:	2800      	cmp	r0, #0
 80216ae:	d101      	bne.n	80216b4 <IPCC_IF_ResponseSnd+0x14>
    return 0;
 80216b0:	2000      	movs	r0, #0
}
 80216b2:	bd10      	pop	{r4, pc}
    return -1;
 80216b4:	2001      	movs	r0, #1
 80216b6:	4240      	negs	r0, r0
 80216b8:	e7fb      	b.n	80216b2 <IPCC_IF_ResponseSnd+0x12>
 80216ba:	46c0      	nop			; (mov r8, r8)
 80216bc:	2000b7dc 	.word	0x2000b7dc

080216c0 <KMS_LL_ReportError>:
void KMS_LL_ReportError(uint32_t Error)
{
  /* USER CODE BEGIN KMS_LL_ReportError */

  /* USER CODE END KMS_LL_ReportError */
}
 80216c0:	4770      	bx	lr

080216c2 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80216c2:	b510      	push	{r4, lr}
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80216c4:	f001 fd00 	bl	80230c8 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_KMS_Init();
 80216c8:	f000 fbc1 	bl	8021e4e <MX_KMS_Init>
  MX_LoRaWAN_Init();
 80216cc:	f000 fbc4 	bl	8021e58 <MX_LoRaWAN_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
    MX_LoRaWAN_Process();
 80216d0:	f000 fbc6 	bl	8021e60 <MX_LoRaWAN_Process>
  while (1)
 80216d4:	e7fc      	b.n	80216d0 <main+0xe>

080216d6 <Error_Handler>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80216d6:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80216d8:	e7fe      	b.n	80216d8 <Error_Handler+0x2>

080216da <get_page>:
  */
static uint32_t get_page(uint32_t Addr)
{
  uint32_t page;

  page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 80216da:	23f8      	movs	r3, #248	; 0xf8
 80216dc:	061b      	lsls	r3, r3, #24
 80216de:	469c      	mov	ip, r3
 80216e0:	4460      	add	r0, ip
 80216e2:	0ac0      	lsrs	r0, r0, #11

  return page;
}
 80216e4:	4770      	bx	lr
	...

080216e8 <page_write>:
{
 80216e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80216ea:	b083      	sub	sp, #12
 80216ec:	0006      	movs	r6, r0
                     ((uint32_t) * destinationp & (NVMS_LL_PAGE_SIZE - 1UL)));
 80216ee:	680f      	ldr	r7, [r1, #0]
 80216f0:	2507      	movs	r5, #7
 80216f2:	403d      	ands	r5, r7
  maxsize = (size_t)(NVMS_LL_PAGE_SIZE -
 80216f4:	2308      	movs	r3, #8
 80216f6:	1b5d      	subs	r5, r3, r5
  if (maxsize > *sizep)
 80216f8:	6813      	ldr	r3, [r2, #0]
 80216fa:	42ab      	cmp	r3, r5
 80216fc:	d200      	bcs.n	8021700 <page_write+0x18>
    maxsize = *sizep;
 80216fe:	001d      	movs	r5, r3
  *sizep        -= maxsize;
 8021700:	1b5b      	subs	r3, r3, r5
 8021702:	6013      	str	r3, [r2, #0]
  *destinationp += maxsize;
 8021704:	680b      	ldr	r3, [r1, #0]
 8021706:	195b      	adds	r3, r3, r5
 8021708:	600b      	str	r3, [r1, #0]
  (void)HAL_FLASH_Unlock();
 802170a:	f002 fbc3 	bl	8023e94 <HAL_FLASH_Unlock>
  HAL_StatusTypeDef ret = HAL_OK;
 802170e:	2400      	movs	r4, #0
  while ((maxsize >= 8UL) && (ret == HAL_OK))
 8021710:	2d07      	cmp	r5, #7
 8021712:	d90f      	bls.n	8021734 <page_write+0x4c>
 8021714:	2c00      	cmp	r4, #0
 8021716:	d10d      	bne.n	8021734 <page_write+0x4c>
    ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (uint32_t)p, (uint64_t) * ((uint64_t *)(uint32_t) * sourcep));
 8021718:	6833      	ldr	r3, [r6, #0]
 802171a:	681a      	ldr	r2, [r3, #0]
 802171c:	685b      	ldr	r3, [r3, #4]
 802171e:	0039      	movs	r1, r7
 8021720:	2001      	movs	r0, #1
 8021722:	f002 fc1d 	bl	8023f60 <HAL_FLASH_Program>
 8021726:	0004      	movs	r4, r0
    p = &p[8];
 8021728:	3708      	adds	r7, #8
    *sourcep = &((*sourcep)[8]);
 802172a:	6833      	ldr	r3, [r6, #0]
 802172c:	3308      	adds	r3, #8
 802172e:	6033      	str	r3, [r6, #0]
    maxsize -= 8UL;
 8021730:	3d08      	subs	r5, #8
 8021732:	e7ed      	b.n	8021710 <page_write+0x28>
  if (maxsize != 0UL)
 8021734:	2d00      	cmp	r5, #0
 8021736:	d106      	bne.n	8021746 <page_write+0x5e>
  (void)HAL_FLASH_Lock();
 8021738:	f002 fbc4 	bl	8023ec4 <HAL_FLASH_Lock>
  if (ret == HAL_OK)
 802173c:	2c00      	cmp	r4, #0
 802173e:	d014      	beq.n	802176a <page_write+0x82>
  return true;
 8021740:	2001      	movs	r0, #1
}
 8021742:	b003      	add	sp, #12
 8021744:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t block[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 8021746:	4668      	mov	r0, sp
 8021748:	4b09      	ldr	r3, [pc, #36]	; (8021770 <page_write+0x88>)
 802174a:	0002      	movs	r2, r0
 802174c:	cb12      	ldmia	r3!, {r1, r4}
 802174e:	c212      	stmia	r2!, {r1, r4}
    (void)memcpy(block, *sourcep, maxsize);
 8021750:	002a      	movs	r2, r5
 8021752:	6831      	ldr	r1, [r6, #0]
 8021754:	f012 ffde 	bl	8034714 <memcpy>
    ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (uint32_t)p, (uint64_t) * ((uint64_t *)(uint32_t) * sourcep));
 8021758:	6833      	ldr	r3, [r6, #0]
 802175a:	681a      	ldr	r2, [r3, #0]
 802175c:	685b      	ldr	r3, [r3, #4]
 802175e:	0039      	movs	r1, r7
 8021760:	2001      	movs	r0, #1
 8021762:	f002 fbfd 	bl	8023f60 <HAL_FLASH_Program>
 8021766:	0004      	movs	r4, r0
 8021768:	e7e6      	b.n	8021738 <page_write+0x50>
    return false;
 802176a:	2000      	movs	r0, #0
 802176c:	e7e9      	b.n	8021742 <page_write+0x5a>
 802176e:	46c0      	nop			; (mov r8, r8)
 8021770:	08034878 	.word	0x08034878

08021774 <NVMS_LL_Init>:
  */
void NVMS_LL_Init(void)
{
  /* USER CODE BEGIN NVMS_LL_Init */
  /* USER CODE END NVMS_LL_Init */
}
 8021774:	4770      	bx	lr
	...

08021778 <NVMS_LL_IsBlockErased>:
/* Template version of the function */
bool NVMS_LL_IsBlockErased(nvms_block_t block)
{
  /* USER CODE BEGIN NVMS_LL_IsBlockErased */
  uint32_t i;
  uint32_t *p = (uint32_t *)((block == NVMS_BLOCK0) ? NVMS_LL_BLOCK0_ADDRESS :
 8021778:	2800      	cmp	r0, #0
 802177a:	d102      	bne.n	8021782 <NVMS_LL_IsBlockErased+0xa>
 802177c:	4a08      	ldr	r2, [pc, #32]	; (80217a0 <NVMS_LL_IsBlockErased+0x28>)
 802177e:	2300      	movs	r3, #0
 8021780:	e003      	b.n	802178a <NVMS_LL_IsBlockErased+0x12>
 8021782:	4a08      	ldr	r2, [pc, #32]	; (80217a4 <NVMS_LL_IsBlockErased+0x2c>)
 8021784:	e7fb      	b.n	802177e <NVMS_LL_IsBlockErased+0x6>
  {
    if (*p != NVMS_LL_ERASED)
    {
      return false;
    }
    p++;
 8021786:	3204      	adds	r2, #4
  for (i = 0; i < (NVMS_LL_BLOCK_SIZE / sizeof(uint32_t)); i++)
 8021788:	3301      	adds	r3, #1
 802178a:	2180      	movs	r1, #128	; 0x80
 802178c:	0089      	lsls	r1, r1, #2
 802178e:	428b      	cmp	r3, r1
 8021790:	d204      	bcs.n	802179c <NVMS_LL_IsBlockErased+0x24>
    if (*p != NVMS_LL_ERASED)
 8021792:	6811      	ldr	r1, [r2, #0]
 8021794:	3101      	adds	r1, #1
 8021796:	d0f6      	beq.n	8021786 <NVMS_LL_IsBlockErased+0xe>
      return false;
 8021798:	2000      	movs	r0, #0
  }
  return true;
  /* USER CODE END NVMS_LL_IsBlockErased */
}
 802179a:	4770      	bx	lr
  return true;
 802179c:	2001      	movs	r0, #1
 802179e:	e7fc      	b.n	802179a <NVMS_LL_IsBlockErased+0x22>
 80217a0:	0803d000 	.word	0x0803d000
 80217a4:	0803d800 	.word	0x0803d800

080217a8 <NVMS_LL_BlockErase>:
  * @retval false            if the operation is successful.
  * @retval true             if the erase operation failed.
  */
/* Template version of the function */
bool NVMS_LL_BlockErase(nvms_block_t block)
{
 80217a8:	b510      	push	{r4, lr}
 80217aa:	b084      	sub	sp, #16
 80217ac:	0004      	movs	r4, r0
  /* USER CODE BEGIN NVMS_LL_BlockErase */
  /* Erase First Flash sector */
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t SectorError = 0;
 80217ae:	2300      	movs	r3, #0
 80217b0:	9300      	str	r3, [sp, #0]

  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 80217b2:	3302      	adds	r3, #2
 80217b4:	9301      	str	r3, [sp, #4]
  EraseInitStruct.Page        = get_page((block == NVMS_BLOCK0) ? NVMS_LL_BLOCK0_ADDRESS : NVMS_LL_BLOCK1_ADDRESS);
 80217b6:	2800      	cmp	r0, #0
 80217b8:	d115      	bne.n	80217e6 <NVMS_LL_BlockErase+0x3e>
 80217ba:	480c      	ldr	r0, [pc, #48]	; (80217ec <NVMS_LL_BlockErase+0x44>)
 80217bc:	f7ff ff8d 	bl	80216da <get_page>
 80217c0:	9002      	str	r0, [sp, #8]
  EraseInitStruct.NbPages     = NVMS_LL_NB_PAGE_PER_BLOCK;
 80217c2:	2301      	movs	r3, #1
 80217c4:	9303      	str	r3, [sp, #12]

  /* Unlock the Flash to enable the flash control register access *************/
  (void)HAL_FLASH_Unlock();
 80217c6:	f002 fb65 	bl	8023e94 <HAL_FLASH_Unlock>

  if (HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK)
 80217ca:	4669      	mov	r1, sp
 80217cc:	a801      	add	r0, sp, #4
 80217ce:	f002 fd77 	bl	80242c0 <HAL_FLASHEx_Erase>
      FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
  }

  /* Lock the Flash to disable the flash control register access (recommended
  to protect the FLASH memory against possible unwanted operation) *********/
  (void)HAL_FLASH_Lock();
 80217d2:	f002 fb77 	bl	8023ec4 <HAL_FLASH_Lock>

  /* Operation verification.*/
  return !NVMS_LL_IsBlockErased(block);
 80217d6:	0020      	movs	r0, r4
 80217d8:	f7ff ffce 	bl	8021778 <NVMS_LL_IsBlockErased>
 80217dc:	2301      	movs	r3, #1
 80217de:	4058      	eors	r0, r3
 80217e0:	b2c0      	uxtb	r0, r0
  /* USER CODE END NVMS_LL_BlockErase */
}
 80217e2:	b004      	add	sp, #16
 80217e4:	bd10      	pop	{r4, pc}
  EraseInitStruct.Page        = get_page((block == NVMS_BLOCK0) ? NVMS_LL_BLOCK0_ADDRESS : NVMS_LL_BLOCK1_ADDRESS);
 80217e6:	4802      	ldr	r0, [pc, #8]	; (80217f0 <NVMS_LL_BlockErase+0x48>)
 80217e8:	e7e8      	b.n	80217bc <NVMS_LL_BlockErase+0x14>
 80217ea:	46c0      	nop			; (mov r8, r8)
 80217ec:	0803d000 	.word	0x0803d000
 80217f0:	0803d800 	.word	0x0803d800

080217f4 <NVMS_LL_Write>:
  * @retval false            if the operation is successful.
  * @retval true             if the write operation failed.
  */
/* Template version of the function */
bool NVMS_LL_Write(const uint8_t *source, uint8_t *destination, size_t size)
{
 80217f4:	b570      	push	{r4, r5, r6, lr}
 80217f6:	b084      	sub	sp, #16
 80217f8:	0004      	movs	r4, r0
 80217fa:	000d      	movs	r5, r1
 80217fc:	0016      	movs	r6, r2
  /* USER CODE BEGIN NVMS_LL_Write */
  const uint8_t *s = source;
 80217fe:	9003      	str	r0, [sp, #12]
  uint8_t *d = destination;
 8021800:	9102      	str	r1, [sp, #8]
  size_t sz = size;
 8021802:	9201      	str	r2, [sp, #4]

  while (sz > 0UL)
 8021804:	9b01      	ldr	r3, [sp, #4]
 8021806:	2b00      	cmp	r3, #0
 8021808:	d007      	beq.n	802181a <NVMS_LL_Write+0x26>
  {
    /* Writes as much as a single operation allows.*/
    if (page_write(&s, &d, &sz))
 802180a:	aa01      	add	r2, sp, #4
 802180c:	a902      	add	r1, sp, #8
 802180e:	a803      	add	r0, sp, #12
 8021810:	f7ff ff6a 	bl	80216e8 <page_write>
 8021814:	2800      	cmp	r0, #0
 8021816:	d0f5      	beq.n	8021804 <NVMS_LL_Write+0x10>
 8021818:	e007      	b.n	802182a <NVMS_LL_Write+0x36>
      return true;
    }
  }

  /* Operation verification.*/
  return (bool)(memcmp(source, destination, size) != 0);
 802181a:	0032      	movs	r2, r6
 802181c:	0029      	movs	r1, r5
 802181e:	0020      	movs	r0, r4
 8021820:	f012 ff6a 	bl	80346f8 <memcmp>
 8021824:	1e43      	subs	r3, r0, #1
 8021826:	4198      	sbcs	r0, r3
 8021828:	b2c0      	uxtb	r0, r0
  /* USER CODE END NVMS_LL_Write */
}
 802182a:	b004      	add	sp, #16
 802182c:	bd70      	pop	{r4, r5, r6, pc}
	...

08021830 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 8021830:	b500      	push	{lr}
 8021832:	b08d      	sub	sp, #52	; 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 8021834:	222c      	movs	r2, #44	; 0x2c
 8021836:	2100      	movs	r1, #0
 8021838:	a801      	add	r0, sp, #4
 802183a:	f012 ff74 	bl	8034726 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 802183e:	4821      	ldr	r0, [pc, #132]	; (80218c4 <MX_RTC_Init+0x94>)
 8021840:	4b21      	ldr	r3, [pc, #132]	; (80218c8 <MX_RTC_Init+0x98>)
 8021842:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 8021844:	231f      	movs	r3, #31
 8021846:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8021848:	2300      	movs	r3, #0
 802184a:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 802184c:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 802184e:	6183      	str	r3, [r0, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8021850:	2280      	movs	r2, #128	; 0x80
 8021852:	05d2      	lsls	r2, r2, #23
 8021854:	61c2      	str	r2, [r0, #28]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 8021856:	6203      	str	r3, [r0, #32]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 8021858:	3301      	adds	r3, #1
 802185a:	33ff      	adds	r3, #255	; 0xff
 802185c:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 802185e:	f003 fa4d 	bl	8024cfc <HAL_RTC_Init>
 8021862:	2800      	cmp	r0, #0
 8021864:	d121      	bne.n	80218aa <MX_RTC_Init+0x7a>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 8021866:	4817      	ldr	r0, [pc, #92]	; (80218c4 <MX_RTC_Init+0x94>)
 8021868:	f003 fb96 	bl	8024f98 <HAL_RTCEx_SetSSRU_IT>
 802186c:	2800      	cmp	r0, #0
 802186e:	d11f      	bne.n	80218b0 <MX_RTC_Init+0x80>
  {
    Error_Handler();
  }
  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8021870:	2300      	movs	r3, #0
 8021872:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 8021874:	9302      	str	r3, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8021876:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8021878:	2380      	movs	r3, #128	; 0x80
 802187a:	059b      	lsls	r3, r3, #22
 802187c:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
 802187e:	2380      	movs	r3, #128	; 0x80
 8021880:	005b      	lsls	r3, r3, #1
 8021882:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8021884:	2200      	movs	r2, #0
 8021886:	a901      	add	r1, sp, #4
 8021888:	480e      	ldr	r0, [pc, #56]	; (80218c4 <MX_RTC_Init+0x94>)
 802188a:	f003 fa99 	bl	8024dc0 <HAL_RTC_SetAlarm_IT>
 802188e:	2800      	cmp	r0, #0
 8021890:	d111      	bne.n	80218b6 <MX_RTC_Init+0x86>
  {
    Error_Handler();
  }
  /** Enable the Alarm B
  */
  sAlarm.Alarm = RTC_ALARM_B;
 8021892:	2380      	movs	r3, #128	; 0x80
 8021894:	009b      	lsls	r3, r3, #2
 8021896:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8021898:	2200      	movs	r2, #0
 802189a:	a901      	add	r1, sp, #4
 802189c:	4809      	ldr	r0, [pc, #36]	; (80218c4 <MX_RTC_Init+0x94>)
 802189e:	f003 fa8f 	bl	8024dc0 <HAL_RTC_SetAlarm_IT>
 80218a2:	2800      	cmp	r0, #0
 80218a4:	d10a      	bne.n	80218bc <MX_RTC_Init+0x8c>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 80218a6:	b00d      	add	sp, #52	; 0x34
 80218a8:	bd00      	pop	{pc}
    Error_Handler();
 80218aa:	f7ff ff14 	bl	80216d6 <Error_Handler>
 80218ae:	e7da      	b.n	8021866 <MX_RTC_Init+0x36>
    Error_Handler();
 80218b0:	f7ff ff11 	bl	80216d6 <Error_Handler>
 80218b4:	e7dc      	b.n	8021870 <MX_RTC_Init+0x40>
    Error_Handler();
 80218b6:	f7ff ff0e 	bl	80216d6 <Error_Handler>
 80218ba:	e7ea      	b.n	8021892 <MX_RTC_Init+0x62>
    Error_Handler();
 80218bc:	f7ff ff0b 	bl	80216d6 <Error_Handler>
}
 80218c0:	e7f1      	b.n	80218a6 <MX_RTC_Init+0x76>
 80218c2:	46c0      	nop			; (mov r8, r8)
 80218c4:	2000b818 	.word	0x2000b818
 80218c8:	40002800 	.word	0x40002800

080218cc <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 80218cc:	b510      	push	{r4, lr}
 80218ce:	b090      	sub	sp, #64	; 0x40
 80218d0:	0004      	movs	r4, r0

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80218d2:	2238      	movs	r2, #56	; 0x38
 80218d4:	2100      	movs	r1, #0
 80218d6:	a802      	add	r0, sp, #8
 80218d8:	f012 ff25 	bl	8034726 <memset>
  if(rtcHandle->Instance==RTC)
 80218dc:	6822      	ldr	r2, [r4, #0]
 80218de:	4b17      	ldr	r3, [pc, #92]	; (802193c <HAL_RTC_MspInit+0x70>)
 80218e0:	429a      	cmp	r2, r3
 80218e2:	d001      	beq.n	80218e8 <HAL_RTC_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(RTC_LSECSS_IRQn);
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 80218e4:	b010      	add	sp, #64	; 0x40
 80218e6:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 80218e8:	2380      	movs	r3, #128	; 0x80
 80218ea:	025b      	lsls	r3, r3, #9
 80218ec:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 80218ee:	2380      	movs	r3, #128	; 0x80
 80218f0:	005b      	lsls	r3, r3, #1
 80218f2:	930f      	str	r3, [sp, #60]	; 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80218f4:	a802      	add	r0, sp, #8
 80218f6:	f003 f807 	bl	8024908 <HAL_RCCEx_PeriphCLKConfig>
 80218fa:	2800      	cmp	r0, #0
 80218fc:	d11b      	bne.n	8021936 <HAL_RTC_MspInit+0x6a>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 80218fe:	23b0      	movs	r3, #176	; 0xb0
 8021900:	05db      	lsls	r3, r3, #23
 8021902:	2190      	movs	r1, #144	; 0x90
 8021904:	5858      	ldr	r0, [r3, r1]
 8021906:	2280      	movs	r2, #128	; 0x80
 8021908:	0212      	lsls	r2, r2, #8
 802190a:	4302      	orrs	r2, r0
 802190c:	505a      	str	r2, [r3, r1]
  * @retval None
  */
__STATIC_INLINE void LL_C2_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2APB1ENR1, Periphs);
 802190e:	22ac      	movs	r2, #172	; 0xac
 8021910:	0052      	lsls	r2, r2, #1
 8021912:	5899      	ldr	r1, [r3, r2]
 8021914:	2080      	movs	r0, #128	; 0x80
 8021916:	00c0      	lsls	r0, r0, #3
 8021918:	4301      	orrs	r1, r0
 802191a:	5099      	str	r1, [r3, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2APB1ENR1, Periphs);
 802191c:	589b      	ldr	r3, [r3, r2]
 802191e:	4003      	ands	r3, r0
 8021920:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8021922:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(RTC_LSECSS_IRQn, 0, 0);
 8021924:	2200      	movs	r2, #0
 8021926:	2100      	movs	r1, #0
 8021928:	2002      	movs	r0, #2
 802192a:	f001 fc01 	bl	8023130 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_LSECSS_IRQn);
 802192e:	2002      	movs	r0, #2
 8021930:	f001 fc2e 	bl	8023190 <HAL_NVIC_EnableIRQ>
}
 8021934:	e7d6      	b.n	80218e4 <HAL_RTC_MspInit+0x18>
      Error_Handler();
 8021936:	f7ff fece 	bl	80216d6 <Error_Handler>
 802193a:	e7e0      	b.n	80218fe <HAL_RTC_MspInit+0x32>
 802193c:	40002800 	.word	0x40002800

08021940 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 8021940:	4770      	bx	lr

08021942 <PWR_ExitOffMode>:
void PWR_ExitOffMode(void)
{
  /* USER CODE BEGIN ExitOffMode_1 */

  /* USER CODE END ExitOffMode_1 */
}
 8021942:	4770      	bx	lr

08021944 <PWR_EnterStopMode>:

void PWR_EnterStopMode(void)
{
 8021944:	b510      	push	{r4, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 8021946:	f001 fbd1 	bl	80230ec <HAL_SuspendTick>
  * @rmtoll EXTSCR       C2CSSF        LL_PWR_ClearFlag_C2STOP_C2STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C2STOP_C2STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C2CSSF);
 802194a:	4a04      	ldr	r2, [pc, #16]	; (802195c <PWR_EnterStopMode+0x18>)
 802194c:	2388      	movs	r3, #136	; 0x88
 802194e:	2102      	movs	r1, #2
 8021950:	50d1      	str	r1, [r2, r3]
  LL_PWR_ClearFlag_C2STOP_C2STB();

  /* USER CODE BEGIN EnterStopMode_2 */

  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 8021952:	2001      	movs	r0, #1
 8021954:	f002 ff10 	bl	8024778 <HAL_PWREx_EnterSTOP2Mode>
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 8021958:	bd10      	pop	{r4, pc}
 802195a:	46c0      	nop			; (mov r8, r8)
 802195c:	58000400 	.word	0x58000400

08021960 <PWR_ExitStopMode>:

void PWR_ExitStopMode(void)
{
 8021960:	b510      	push	{r4, lr}
  /* USER CODE BEGIN ExitStopMode_1 */

  /* USER CODE END ExitStopMode_1 */
  /* Resume sysTick : work around for debugger problem in dual core */
  HAL_ResumeTick();
 8021962:	f001 fbcb 	bl	80230fc <HAL_ResumeTick>
    SRAM ctrls, DMAx, DMAMux, AES, RNG, HSEM  */

  /* USER CODE BEGIN ExitStopMode_2 */

  /* USER CODE END ExitStopMode_2 */
}
 8021966:	bd10      	pop	{r4, pc}

08021968 <PWR_ExitSleepMode>:

  /* USER CODE END EnterSleepMode_3 */
}

void PWR_ExitSleepMode(void)
{
 8021968:	b510      	push	{r4, lr}
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Suspend sysTick */
  HAL_ResumeTick();
 802196a:	f001 fbc7 	bl	80230fc <HAL_ResumeTick>

  /* USER CODE BEGIN ExitSleepMode_2 */

  /* USER CODE END ExitSleepMode_2 */
}
 802196e:	bd10      	pop	{r4, pc}

08021970 <PWR_EnterSleepMode>:
{
 8021970:	b510      	push	{r4, lr}
  HAL_SuspendTick();
 8021972:	f001 fbbb 	bl	80230ec <HAL_SuspendTick>
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 8021976:	2101      	movs	r1, #1
 8021978:	2000      	movs	r0, #0
 802197a:	f002 fea7 	bl	80246cc <HAL_PWR_EnterSLEEPMode>
}
 802197e:	bd10      	pop	{r4, pc}

08021980 <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8021980:	4770      	bx	lr

08021982 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8021982:	e7fe      	b.n	8021982 <NMI_Handler>

08021984 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8021984:	e7fe      	b.n	8021984 <HardFault_Handler>

08021986 <SVC_Handler>:

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 8021986:	4770      	bx	lr

08021988 <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8021988:	4770      	bx	lr

0802198a <SysTick_Handler>:

  /* USER CODE END SysTick_IRQn 0 */
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 802198a:	4770      	bx	lr

0802198c <RTC_LSECSS_IRQHandler>:

/**
  * @brief This function handles RTC Wakeup + RTC Tamper and RTC TimeStamp + RTC Alarms (A & B) and RTC SSRU Interrupts and LSECSS Interrupts.
  */
void RTC_LSECSS_IRQHandler(void)
{
 802198c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN RTC_LSECSS_IRQn 0 */

  /* USER CODE END RTC_LSECSS_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 802198e:	4c04      	ldr	r4, [pc, #16]	; (80219a0 <RTC_LSECSS_IRQHandler+0x14>)
 8021990:	0020      	movs	r0, r4
 8021992:	f003 f92d 	bl	8024bf0 <HAL_RTC_AlarmIRQHandler>
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 8021996:	0020      	movs	r0, r4
 8021998:	f003 fb2e 	bl	8024ff8 <HAL_RTCEx_SSRUIRQHandler>
  /* USER CODE BEGIN RTC_LSECSS_IRQn 1 */

  /* USER CODE END RTC_LSECSS_IRQn 1 */
}
 802199c:	bd10      	pop	{r4, pc}
 802199e:	46c0      	nop			; (mov r8, r8)
 80219a0:	2000b818 	.word	0x2000b818

080219a4 <IPCC_C2_RX_C2_TX_IRQHandler>:

/**
  * @brief This function handles IPCC RX Occupied and TX Free Interrupt.
  */
void IPCC_C2_RX_C2_TX_IRQHandler(void)
{
 80219a4:	b510      	push	{r4, lr}
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 0 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 0 */
  HAL_IPCC_RX_IRQHandler(&hipcc);
 80219a6:	4c04      	ldr	r4, [pc, #16]	; (80219b8 <IPCC_C2_RX_C2_TX_IRQHandler+0x14>)
 80219a8:	0020      	movs	r0, r4
 80219aa:	f002 fdb1 	bl	8024510 <HAL_IPCC_RX_IRQHandler>
  HAL_IPCC_TX_IRQHandler(&hipcc);
 80219ae:	0020      	movs	r0, r4
 80219b0:	f002 fd84 	bl	80244bc <HAL_IPCC_TX_IRQHandler>
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 1 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 1 */
}
 80219b4:	bd10      	pop	{r4, pc}
 80219b6:	46c0      	nop			; (mov r8, r8)
 80219b8:	2000b7dc 	.word	0x2000b7dc

080219bc <SUBGHZ_Radio_IRQHandler>:

/**
  * @brief This function handles SUBGHZ Radio Interrupt.
  */
void SUBGHZ_Radio_IRQHandler(void)
{
 80219bc:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 80219be:	4802      	ldr	r0, [pc, #8]	; (80219c8 <SUBGHZ_Radio_IRQHandler+0xc>)
 80219c0:	f003 fdd0 	bl	8025564 <HAL_SUBGHZ_IRQHandler>
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 1 */

  /* USER CODE END SUBGHZ_Radio_IRQn 1 */
}
 80219c4:	bd10      	pop	{r4, pc}
 80219c6:	46c0      	nop			; (mov r8, r8)
 80219c8:	2000b850 	.word	0x2000b850

080219cc <MX_SUBGHZ_Init>:

SUBGHZ_HandleTypeDef hsubghz;

/* SUBGHZ init function */
void MX_SUBGHZ_Init(void)
{
 80219cc:	b510      	push	{r4, lr}
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 80219ce:	4805      	ldr	r0, [pc, #20]	; (80219e4 <MX_SUBGHZ_Init+0x18>)
 80219d0:	2308      	movs	r3, #8
 80219d2:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 80219d4:	f003 fb46 	bl	8025064 <HAL_SUBGHZ_Init>
 80219d8:	2800      	cmp	r0, #0
 80219da:	d100      	bne.n	80219de <MX_SUBGHZ_Init+0x12>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 80219dc:	bd10      	pop	{r4, pc}
    Error_Handler();
 80219de:	f7ff fe7a 	bl	80216d6 <Error_Handler>
}
 80219e2:	e7fb      	b.n	80219dc <MX_SUBGHZ_Init+0x10>
 80219e4:	2000b850 	.word	0x2000b850

080219e8 <HAL_SUBGHZ_MspInit>:

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 80219e8:	b500      	push	{lr}
 80219ea:	b083      	sub	sp, #12
  * @retval None
  */
__STATIC_INLINE void LL_C2_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2APB3ENR, Periphs);
 80219ec:	21b0      	movs	r1, #176	; 0xb0
 80219ee:	05c9      	lsls	r1, r1, #23
 80219f0:	22b2      	movs	r2, #178	; 0xb2
 80219f2:	0052      	lsls	r2, r2, #1
 80219f4:	5888      	ldr	r0, [r1, r2]
 80219f6:	2301      	movs	r3, #1
 80219f8:	4318      	orrs	r0, r3
 80219fa:	5088      	str	r0, [r1, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2APB3ENR, Periphs);
 80219fc:	588a      	ldr	r2, [r1, r2]
 80219fe:	4013      	ands	r3, r2
 8021a00:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8021a02:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 8021a04:	2200      	movs	r2, #0
 8021a06:	2100      	movs	r1, #0
 8021a08:	201f      	movs	r0, #31
 8021a0a:	f001 fb91 	bl	8023130 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 8021a0e:	201f      	movs	r0, #31
 8021a10:	f001 fbbe 	bl	8023190 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 8021a14:	b003      	add	sp, #12
 8021a16:	bd00      	pop	{pc}

08021a18 <System_Init>:

/* USER CODE END EF */

/* Private functions ---------------------------------------------------------*/
static void System_Init(void)
{
 8021a18:	b570      	push	{r4, r5, r6, lr}
  CLEAR_BIT(PWR->C2CR3, PWR_C2CR3_EIWUL);
 8021a1a:	4d13      	ldr	r5, [pc, #76]	; (8021a68 <System_Init+0x50>)
 8021a1c:	2484      	movs	r4, #132	; 0x84
 8021a1e:	592b      	ldr	r3, [r5, r4]
 8021a20:	4e12      	ldr	r6, [pc, #72]	; (8021a6c <System_Init+0x54>)
 8021a22:	4033      	ands	r3, r6
 8021a24:	512b      	str	r3, [r5, r4]
  CLEAR_BIT(EXTI->C2IMR1, ExtiLine);
 8021a26:	4b12      	ldr	r3, [pc, #72]	; (8021a70 <System_Init+0x58>)
 8021a28:	21c0      	movs	r1, #192	; 0xc0
 8021a2a:	585a      	ldr	r2, [r3, r1]
 8021a2c:	2090      	movs	r0, #144	; 0x90
 8021a2e:	0340      	lsls	r0, r0, #13
 8021a30:	4002      	ands	r2, r0
 8021a32:	505a      	str	r2, [r3, r1]
  CLEAR_BIT(EXTI->C2IMR2, ExtiLine);
 8021a34:	22d0      	movs	r2, #208	; 0xd0
 8021a36:	5899      	ldr	r1, [r3, r2]
 8021a38:	480e      	ldr	r0, [pc, #56]	; (8021a74 <System_Init+0x5c>)
 8021a3a:	4001      	ands	r1, r0
 8021a3c:	5099      	str	r1, [r3, r2]
  MODIFY_REG(PWR->C2CR3, PWR_C2CR3_EWRFIRQ, RadioIRQTrigger);
 8021a3e:	5929      	ldr	r1, [r5, r4]
 8021a40:	480d      	ldr	r0, [pc, #52]	; (8021a78 <System_Init+0x60>)
 8021a42:	4001      	ands	r1, r0
 8021a44:	2080      	movs	r0, #128	; 0x80
 8021a46:	0180      	lsls	r0, r0, #6
 8021a48:	4301      	orrs	r1, r0
 8021a4a:	5129      	str	r1, [r5, r4]
  SET_BIT(EXTI->C2IMR2, ExtiLine);
 8021a4c:	589c      	ldr	r4, [r3, r2]
 8021a4e:	2180      	movs	r1, #128	; 0x80
 8021a50:	0149      	lsls	r1, r1, #5
 8021a52:	4321      	orrs	r1, r4
 8021a54:	5099      	str	r1, [r3, r2]
 8021a56:	5899      	ldr	r1, [r3, r2]
 8021a58:	4308      	orrs	r0, r1
 8021a5a:	5098      	str	r0, [r3, r2]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 8021a5c:	22b0      	movs	r2, #176	; 0xb0
 8021a5e:	05d2      	lsls	r2, r2, #23
 8021a60:	6893      	ldr	r3, [r2, #8]
 8021a62:	4033      	ands	r3, r6
 8021a64:	6093      	str	r3, [r2, #8]
  /* Ensure that MSI is wake-up system clock */
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
  /* USER CODE BEGIN System_Init_Last */

  /* USER CODE END System_Init_Last */
}
 8021a66:	bd70      	pop	{r4, r5, r6, pc}
 8021a68:	58000400 	.word	0x58000400
 8021a6c:	ffff7fff 	.word	0xffff7fff
 8021a70:	58000800 	.word	0x58000800
 8021a74:	000070a0 	.word	0x000070a0
 8021a78:	ffffdfff 	.word	0xffffdfff

08021a7c <tiny_snprintf_like>:

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
{
 8021a7c:	b40c      	push	{r2, r3}
 8021a7e:	b500      	push	{lr}
 8021a80:	b083      	sub	sp, #12
 8021a82:	ab04      	add	r3, sp, #16
 8021a84:	cb04      	ldmia	r3!, {r2}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
 8021a86:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 8021a88:	f012 fd4e 	bl	8034528 <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 8021a8c:	b003      	add	sp, #12
 8021a8e:	bc08      	pop	{r3}
 8021a90:	b002      	add	sp, #8
 8021a92:	4718      	bx	r3

08021a94 <SystemApp_Init>:
{
 8021a94:	b510      	push	{r4, lr}
  UTIL_TIMER_Init();
 8021a96:	f012 fb0b 	bl	80340b0 <UTIL_TIMER_Init>
  UTIL_LPM_Init();
 8021a9a:	f012 f8c9 	bl	8033c30 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 8021a9e:	2101      	movs	r1, #1
 8021aa0:	2001      	movs	r0, #1
 8021aa2:	f012 f8e5 	bl	8033c70 <UTIL_LPM_SetOffMode>
  FEAT_INFO_Init();
 8021aa6:	f000 fcaf 	bl	8022408 <FEAT_INFO_Init>
  init_status = MBMUXIF_SystemInit();
 8021aaa:	f000 ff47 	bl	802293c <MBMUXIF_SystemInit>
  if (init_status < 0)
 8021aae:	2800      	cmp	r0, #0
 8021ab0:	db04      	blt.n	8021abc <SystemApp_Init+0x28>
  System_Init();
 8021ab2:	f7ff ffb1 	bl	8021a18 <System_Init>
  DBG_ProbesInit();
 8021ab6:	f7ff fd2b 	bl	8021510 <DBG_ProbesInit>
}
 8021aba:	bd10      	pop	{r4, pc}
    Error_Handler();
 8021abc:	f7ff fe0b 	bl	80216d6 <Error_Handler>
 8021ac0:	e7f7      	b.n	8021ab2 <SystemApp_Init+0x1e>
	...

08021ac4 <TimestampNow>:
{
 8021ac4:	b570      	push	{r4, r5, r6, lr}
 8021ac6:	b084      	sub	sp, #16
 8021ac8:	0004      	movs	r4, r0
 8021aca:	000d      	movs	r5, r1
  SysTime_t curtime = SysTimeGet();
 8021acc:	ae02      	add	r6, sp, #8
 8021ace:	0030      	movs	r0, r6
 8021ad0:	f012 fa72 	bl	8033fb8 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 8021ad4:	2204      	movs	r2, #4
 8021ad6:	5eb3      	ldrsh	r3, [r6, r2]
 8021ad8:	9300      	str	r3, [sp, #0]
 8021ada:	9b02      	ldr	r3, [sp, #8]
 8021adc:	4a05      	ldr	r2, [pc, #20]	; (8021af4 <TimestampNow+0x30>)
 8021ade:	2110      	movs	r1, #16
 8021ae0:	0020      	movs	r0, r4
 8021ae2:	f7ff ffcb 	bl	8021a7c <tiny_snprintf_like>
  *size = strlen((char *)buff);
 8021ae6:	0020      	movs	r0, r4
 8021ae8:	f7fe fb0e 	bl	8020108 <strlen>
 8021aec:	8028      	strh	r0, [r5, #0]
}
 8021aee:	b004      	add	sp, #16
 8021af0:	bd70      	pop	{r4, r5, r6, pc}
 8021af2:	46c0      	nop			; (mov r8, r8)
 8021af4:	08034930 	.word	0x08034930

08021af8 <Process_Sys_Cmd>:
{
 8021af8:	b510      	push	{r4, lr}
  APP_LOG(TS_ON, VLEVEL_L, ">CM0PLUS(System)\r\n");
 8021afa:	4b08      	ldr	r3, [pc, #32]	; (8021b1c <Process_Sys_Cmd+0x24>)
 8021afc:	2201      	movs	r2, #1
 8021afe:	2100      	movs	r1, #0
 8021b00:	2001      	movs	r0, #1
 8021b02:	f011 ffd9 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_ON, VLEVEL_M, "<CM0PLUS(System)\r\n");
 8021b06:	4b06      	ldr	r3, [pc, #24]	; (8021b20 <Process_Sys_Cmd+0x28>)
 8021b08:	2201      	movs	r2, #1
 8021b0a:	2100      	movs	r1, #0
 8021b0c:	2002      	movs	r0, #2
 8021b0e:	f011 ffd3 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 8021b12:	2000      	movs	r0, #0
 8021b14:	f000 fd94 	bl	8022640 <MBMUX_ResponseSnd>
}
 8021b18:	bd10      	pop	{r4, pc}
 8021b1a:	46c0      	nop			; (mov r8, r8)
 8021b1c:	0803493c 	.word	0x0803493c
 8021b20:	08034950 	.word	0x08034950

08021b24 <UTIL_SEQ_EvtIdle>:
{
 8021b24:	b510      	push	{r4, lr}
  UTIL_SEQ_Run(~TaskId_bm);
 8021b26:	43c0      	mvns	r0, r0
 8021b28:	f012 f930 	bl	8033d8c <UTIL_SEQ_Run>
}
 8021b2c:	bd10      	pop	{r4, pc}

08021b2e <UTIL_SEQ_Idle>:
{
 8021b2e:	b510      	push	{r4, lr}
  UTIL_LPM_EnterLowPower();
 8021b30:	f012 f8b4 	bl	8033c9c <UTIL_LPM_EnterLowPower>
}
 8021b34:	bd10      	pop	{r4, pc}
	...

08021b38 <GetUniqueId>:
{
 8021b38:	b570      	push	{r4, r5, r6, lr}
 8021b3a:	0004      	movs	r4, r0
  * @brief  Return the Unique Device Number
  * @retval Values between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 8021b3c:	4b16      	ldr	r3, [pc, #88]	; (8021b98 <GetUniqueId+0x60>)
 8021b3e:	681b      	ldr	r3, [r3, #0]
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 8021b40:	1c5a      	adds	r2, r3, #1
 8021b42:	d011      	beq.n	8021b68 <GetUniqueId+0x30>
    id[7] = val & 0xFF;
 8021b44:	71c3      	strb	r3, [r0, #7]
    id[6] = (val >> 8) & 0xFF;
 8021b46:	0a1a      	lsrs	r2, r3, #8
 8021b48:	7182      	strb	r2, [r0, #6]
    id[5] = (val >> 16) & 0xFF;
 8021b4a:	0c1a      	lsrs	r2, r3, #16
 8021b4c:	7142      	strb	r2, [r0, #5]
    id[4] = (val >> 24) & 0xFF;
 8021b4e:	0e1b      	lsrs	r3, r3, #24
 8021b50:	7103      	strb	r3, [r0, #4]
  *         For STM32WLxxxx devices, the device ID is 0x15
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x15)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
  return ((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 8021b52:	4b12      	ldr	r3, [pc, #72]	; (8021b9c <GetUniqueId+0x64>)
    id[3] = val & 0xFF;
 8021b54:	681a      	ldr	r2, [r3, #0]
 8021b56:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 8021b58:	681b      	ldr	r3, [r3, #0]
 8021b5a:	0a1a      	lsrs	r2, r3, #8
    id[2] = val & 0xFF;
 8021b5c:	7082      	strb	r2, [r0, #2]
    id[1] = (val >> 8) & 0xFF;
 8021b5e:	0c1a      	lsrs	r2, r3, #16
 8021b60:	7042      	strb	r2, [r0, #1]
    id[0] = (val >> 16) & 0xFF;
 8021b62:	0e1b      	lsrs	r3, r3, #24
 8021b64:	7003      	strb	r3, [r0, #0]
}
 8021b66:	bd70      	pop	{r4, r5, r6, pc}
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 8021b68:	f001 fad0 	bl	802310c <HAL_GetUIDw0>
 8021b6c:	0005      	movs	r5, r0
 8021b6e:	f001 fad9 	bl	8023124 <HAL_GetUIDw2>
 8021b72:	182d      	adds	r5, r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 8021b74:	f001 fad0 	bl	8023118 <HAL_GetUIDw1>
    id[7] = (ID_1_3_val) >> 24;
 8021b78:	0e2b      	lsrs	r3, r5, #24
 8021b7a:	71e3      	strb	r3, [r4, #7]
    id[6] = (ID_1_3_val) >> 16;
 8021b7c:	0c2b      	lsrs	r3, r5, #16
 8021b7e:	71a3      	strb	r3, [r4, #6]
    id[5] = (ID_1_3_val) >> 8;
 8021b80:	0a2b      	lsrs	r3, r5, #8
 8021b82:	7163      	strb	r3, [r4, #5]
    id[4] = (ID_1_3_val);
 8021b84:	7125      	strb	r5, [r4, #4]
    id[3] = (ID_2_val) >> 24;
 8021b86:	0e03      	lsrs	r3, r0, #24
 8021b88:	70e3      	strb	r3, [r4, #3]
    id[2] = (ID_2_val) >> 16;
 8021b8a:	0c03      	lsrs	r3, r0, #16
 8021b8c:	70a3      	strb	r3, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 8021b8e:	0a03      	lsrs	r3, r0, #8
 8021b90:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 8021b92:	7020      	strb	r0, [r4, #0]
 8021b94:	e7e7      	b.n	8021b66 <GetUniqueId+0x2e>
 8021b96:	46c0      	nop			; (mov r8, r8)
 8021b98:	1fff7580 	.word	0x1fff7580
 8021b9c:	1fff7584 	.word	0x1fff7584

08021ba0 <GetDevAddr>:
{
 8021ba0:	b510      	push	{r4, lr}
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 8021ba2:	4b07      	ldr	r3, [pc, #28]	; (8021bc0 <GetDevAddr+0x20>)
 8021ba4:	6818      	ldr	r0, [r3, #0]
  if (val == 0xFFFFFFFF)
 8021ba6:	1c43      	adds	r3, r0, #1
 8021ba8:	d000      	beq.n	8021bac <GetDevAddr+0xc>
}
 8021baa:	bd10      	pop	{r4, pc}
    val = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 8021bac:	f001 faae 	bl	802310c <HAL_GetUIDw0>
 8021bb0:	0004      	movs	r4, r0
 8021bb2:	f001 fab1 	bl	8023118 <HAL_GetUIDw1>
 8021bb6:	4044      	eors	r4, r0
 8021bb8:	f001 fab4 	bl	8023124 <HAL_GetUIDw2>
 8021bbc:	4060      	eors	r0, r4
  return val;
 8021bbe:	e7f4      	b.n	8021baa <GetDevAddr+0xa>
 8021bc0:	1fff7580 	.word	0x1fff7580

08021bc4 <UTIL_ADV_TRACE_PreSendHook>:
{
 8021bc4:	b510      	push	{r4, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 8021bc6:	2101      	movs	r1, #1
 8021bc8:	2002      	movs	r0, #2
 8021bca:	f012 f83b 	bl	8033c44 <UTIL_LPM_SetStopMode>
}
 8021bce:	bd10      	pop	{r4, pc}

08021bd0 <UTIL_ADV_TRACE_PostSendHook>:
{
 8021bd0:	b510      	push	{r4, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 8021bd2:	2100      	movs	r1, #0
 8021bd4:	2002      	movs	r0, #2
 8021bd6:	f012 f835 	bl	8033c44 <UTIL_LPM_SetStopMode>
}
 8021bda:	bd10      	pop	{r4, pc}

08021bdc <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 8021bdc:	2000      	movs	r0, #0
 8021bde:	4770      	bx	lr

08021be0 <HAL_GetTick>:

/**
  * @note This function overwrites the __weak one from HAL
  */
uint32_t HAL_GetTick(void)
{
 8021be0:	b510      	push	{r4, lr}
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  return TIMER_IF_GetTimerValue();
 8021be2:	f000 f825 	bl	8021c30 <TIMER_IF_GetTimerValue>
  /* USER CODE BEGIN HAL_GetTick_2 */

  /* USER CODE END HAL_GetTick_2 */
}
 8021be6:	bd10      	pop	{r4, pc}

08021be8 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 8021be8:	b500      	push	{lr}
 8021bea:	b083      	sub	sp, #12
 8021bec:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 8021bee:	9801      	ldr	r0, [sp, #4]
 8021bf0:	f000 f8fa 	bl	8021de8 <TIMER_IF_DelayMs>
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 8021bf4:	b003      	add	sp, #12
 8021bf6:	bd00      	pop	{pc}

08021bf8 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 8021bf8:	4b02      	ldr	r3, [pc, #8]	; (8021c04 <TIMER_IF_SetTimerContext+0xc>)
 8021bfa:	6898      	ldr	r0, [r3, #8]
static inline uint32_t GetTimerTicks(void)
{
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 8021bfc:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 8021bfe:	4b02      	ldr	r3, [pc, #8]	; (8021c08 <TIMER_IF_SetTimerContext+0x10>)
 8021c00:	6018      	str	r0, [r3, #0]
}
 8021c02:	4770      	bx	lr
 8021c04:	40002800 	.word	0x40002800
 8021c08:	2000a120 	.word	0x2000a120

08021c0c <TIMER_IF_GetTimerContext>:
  return RtcTimerContext;
 8021c0c:	4b01      	ldr	r3, [pc, #4]	; (8021c14 <TIMER_IF_GetTimerContext+0x8>)
 8021c0e:	6818      	ldr	r0, [r3, #0]
}
 8021c10:	4770      	bx	lr
 8021c12:	46c0      	nop			; (mov r8, r8)
 8021c14:	2000a120 	.word	0x2000a120

08021c18 <TIMER_IF_GetTimerElapsedTime>:
 8021c18:	4b03      	ldr	r3, [pc, #12]	; (8021c28 <TIMER_IF_GetTimerElapsedTime+0x10>)
 8021c1a:	6898      	ldr	r0, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 8021c1c:	43c0      	mvns	r0, r0
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 8021c1e:	4b03      	ldr	r3, [pc, #12]	; (8021c2c <TIMER_IF_GetTimerElapsedTime+0x14>)
 8021c20:	681b      	ldr	r3, [r3, #0]
 8021c22:	1ac0      	subs	r0, r0, r3
}
 8021c24:	4770      	bx	lr
 8021c26:	46c0      	nop			; (mov r8, r8)
 8021c28:	40002800 	.word	0x40002800
 8021c2c:	2000a120 	.word	0x2000a120

08021c30 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 8021c30:	4b04      	ldr	r3, [pc, #16]	; (8021c44 <TIMER_IF_GetTimerValue+0x14>)
 8021c32:	781b      	ldrb	r3, [r3, #0]
 8021c34:	2b00      	cmp	r3, #0
 8021c36:	d003      	beq.n	8021c40 <TIMER_IF_GetTimerValue+0x10>
 8021c38:	4b03      	ldr	r3, [pc, #12]	; (8021c48 <TIMER_IF_GetTimerValue+0x18>)
 8021c3a:	6898      	ldr	r0, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 8021c3c:	43c0      	mvns	r0, r0
}
 8021c3e:	4770      	bx	lr
  uint32_t ret = 0;
 8021c40:	2000      	movs	r0, #0
  return ret;
 8021c42:	e7fc      	b.n	8021c3e <TIMER_IF_GetTimerValue+0xe>
 8021c44:	2000a11c 	.word	0x2000a11c
 8021c48:	40002800 	.word	0x40002800

08021c4c <TIMER_IF_GetMinimumTimeout>:
}
 8021c4c:	2003      	movs	r0, #3
 8021c4e:	4770      	bx	lr

08021c50 <TIMER_IF_Convert_ms2Tick>:
{
 8021c50:	b510      	push	{r4, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 8021c52:	0d81      	lsrs	r1, r0, #22
 8021c54:	0280      	lsls	r0, r0, #10
 8021c56:	22fa      	movs	r2, #250	; 0xfa
 8021c58:	0092      	lsls	r2, r2, #2
 8021c5a:	2300      	movs	r3, #0
 8021c5c:	f7fe fc10 	bl	8020480 <__aeabi_uldivmod>
}
 8021c60:	bd10      	pop	{r4, pc}

08021c62 <TIMER_IF_Convert_Tick2ms>:
{
 8021c62:	b510      	push	{r4, lr}
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8021c64:	22fa      	movs	r2, #250	; 0xfa
 8021c66:	0092      	lsls	r2, r2, #2
 8021c68:	2300      	movs	r3, #0
 8021c6a:	2100      	movs	r1, #0
 8021c6c:	f7fe fc28 	bl	80204c0 <__aeabi_lmul>
 8021c70:	0589      	lsls	r1, r1, #22
 8021c72:	0a80      	lsrs	r0, r0, #10
 8021c74:	4308      	orrs	r0, r1
}
 8021c76:	bd10      	pop	{r4, pc}

08021c78 <TIMER_IF_StopTimer>:
{
 8021c78:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRBF);
 8021c7a:	4b07      	ldr	r3, [pc, #28]	; (8021c98 <TIMER_IF_StopTimer+0x20>)
 8021c7c:	2202      	movs	r2, #2
 8021c7e:	65da      	str	r2, [r3, #92]	; 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_B);
 8021c80:	2180      	movs	r1, #128	; 0x80
 8021c82:	4c06      	ldr	r4, [pc, #24]	; (8021c9c <TIMER_IF_StopTimer+0x24>)
 8021c84:	0089      	lsls	r1, r1, #2
 8021c86:	0020      	movs	r0, r4
 8021c88:	f002 ff6e 	bl	8024b68 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8021c8c:	2301      	movs	r3, #1
 8021c8e:	425b      	negs	r3, r3
 8021c90:	6323      	str	r3, [r4, #48]	; 0x30
}
 8021c92:	2000      	movs	r0, #0
 8021c94:	bd10      	pop	{r4, pc}
 8021c96:	46c0      	nop			; (mov r8, r8)
 8021c98:	40002800 	.word	0x40002800
 8021c9c:	2000b818 	.word	0x2000b818

08021ca0 <TIMER_IF_BkUp_Write_MSBticks>:
{
 8021ca0:	b510      	push	{r4, lr}
 8021ca2:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 8021ca4:	2102      	movs	r1, #2
 8021ca6:	4802      	ldr	r0, [pc, #8]	; (8021cb0 <TIMER_IF_BkUp_Write_MSBticks+0x10>)
 8021ca8:	f003 f9b8 	bl	802501c <HAL_RTCEx_BKUPWrite>
}
 8021cac:	bd10      	pop	{r4, pc}
 8021cae:	46c0      	nop			; (mov r8, r8)
 8021cb0:	2000b818 	.word	0x2000b818

08021cb4 <TIMER_IF_Init>:
{
 8021cb4:	b570      	push	{r4, r5, r6, lr}
  if (RTC_Initialized == false)
 8021cb6:	4b12      	ldr	r3, [pc, #72]	; (8021d00 <TIMER_IF_Init+0x4c>)
 8021cb8:	781b      	ldrb	r3, [r3, #0]
 8021cba:	2b00      	cmp	r3, #0
 8021cbc:	d001      	beq.n	8021cc2 <TIMER_IF_Init+0xe>
}
 8021cbe:	2000      	movs	r0, #0
 8021cc0:	bd70      	pop	{r4, r5, r6, pc}
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8021cc2:	4c10      	ldr	r4, [pc, #64]	; (8021d04 <TIMER_IF_Init+0x50>)
 8021cc4:	2501      	movs	r5, #1
 8021cc6:	426d      	negs	r5, r5
 8021cc8:	6325      	str	r5, [r4, #48]	; 0x30
    MX_RTC_Init();
 8021cca:	f7ff fdb1 	bl	8021830 <MX_RTC_Init>
    TIMER_IF_StopTimer();
 8021cce:	f7ff ffd3 	bl	8021c78 <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A); /* handled by Cm4 */
 8021cd2:	2180      	movs	r1, #128	; 0x80
 8021cd4:	0049      	lsls	r1, r1, #1
 8021cd6:	0020      	movs	r0, r4
 8021cd8:	f002 ff46 	bl	8024b68 <HAL_RTC_DeactivateAlarm>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_B); /* handled by Cm0plus */
 8021cdc:	2180      	movs	r1, #128	; 0x80
 8021cde:	0089      	lsls	r1, r1, #2
 8021ce0:	0020      	movs	r0, r4
 8021ce2:	f002 ff41 	bl	8024b68 <HAL_RTC_DeactivateAlarm>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8021ce6:	6325      	str	r5, [r4, #48]	; 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 8021ce8:	0020      	movs	r0, r4
 8021cea:	f003 f935 	bl	8024f58 <HAL_RTCEx_EnableBypassShadow>
    TIMER_IF_BkUp_Write_MSBticks(0);
 8021cee:	2000      	movs	r0, #0
 8021cf0:	f7ff ffd6 	bl	8021ca0 <TIMER_IF_BkUp_Write_MSBticks>
    TIMER_IF_SetTimerContext();
 8021cf4:	f7ff ff80 	bl	8021bf8 <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 8021cf8:	4b01      	ldr	r3, [pc, #4]	; (8021d00 <TIMER_IF_Init+0x4c>)
 8021cfa:	2201      	movs	r2, #1
 8021cfc:	701a      	strb	r2, [r3, #0]
 8021cfe:	e7de      	b.n	8021cbe <TIMER_IF_Init+0xa>
 8021d00:	2000a11c 	.word	0x2000a11c
 8021d04:	2000b818 	.word	0x2000b818

08021d08 <TIMER_IF_BkUp_Write_Seconds>:
{
 8021d08:	b510      	push	{r4, lr}
 8021d0a:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 8021d0c:	2100      	movs	r1, #0
 8021d0e:	4802      	ldr	r0, [pc, #8]	; (8021d18 <TIMER_IF_BkUp_Write_Seconds+0x10>)
 8021d10:	f003 f984 	bl	802501c <HAL_RTCEx_BKUPWrite>
}
 8021d14:	bd10      	pop	{r4, pc}
 8021d16:	46c0      	nop			; (mov r8, r8)
 8021d18:	2000b818 	.word	0x2000b818

08021d1c <TIMER_IF_BkUp_Write_SubSeconds>:
{
 8021d1c:	b510      	push	{r4, lr}
 8021d1e:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 8021d20:	2101      	movs	r1, #1
 8021d22:	4802      	ldr	r0, [pc, #8]	; (8021d2c <TIMER_IF_BkUp_Write_SubSeconds+0x10>)
 8021d24:	f003 f97a 	bl	802501c <HAL_RTCEx_BKUPWrite>
}
 8021d28:	bd10      	pop	{r4, pc}
 8021d2a:	46c0      	nop			; (mov r8, r8)
 8021d2c:	2000b818 	.word	0x2000b818

08021d30 <TIMER_IF_StartTimer>:
{
 8021d30:	b510      	push	{r4, lr}
 8021d32:	b08c      	sub	sp, #48	; 0x30
 8021d34:	0004      	movs	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 8021d36:	222c      	movs	r2, #44	; 0x2c
 8021d38:	2100      	movs	r1, #0
 8021d3a:	a801      	add	r0, sp, #4
 8021d3c:	f012 fcf3 	bl	8034726 <memset>
  TIMER_IF_StopTimer();
 8021d40:	f7ff ff9a 	bl	8021c78 <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 8021d44:	4b0d      	ldr	r3, [pc, #52]	; (8021d7c <TIMER_IF_StartTimer+0x4c>)
 8021d46:	6818      	ldr	r0, [r3, #0]
 8021d48:	1824      	adds	r4, r4, r0
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8021d4a:	2300      	movs	r3, #0
 8021d4c:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 8021d4e:	43e4      	mvns	r4, r4
 8021d50:	9402      	str	r4, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8021d52:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8021d54:	2380      	movs	r3, #128	; 0x80
 8021d56:	059b      	lsls	r3, r3, #22
 8021d58:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_B;
 8021d5a:	2380      	movs	r3, #128	; 0x80
 8021d5c:	009b      	lsls	r3, r3, #2
 8021d5e:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8021d60:	2201      	movs	r2, #1
 8021d62:	a901      	add	r1, sp, #4
 8021d64:	4806      	ldr	r0, [pc, #24]	; (8021d80 <TIMER_IF_StartTimer+0x50>)
 8021d66:	f003 f82b 	bl	8024dc0 <HAL_RTC_SetAlarm_IT>
 8021d6a:	2800      	cmp	r0, #0
 8021d6c:	d102      	bne.n	8021d74 <TIMER_IF_StartTimer+0x44>
}
 8021d6e:	2000      	movs	r0, #0
 8021d70:	b00c      	add	sp, #48	; 0x30
 8021d72:	bd10      	pop	{r4, pc}
    Error_Handler();
 8021d74:	f7ff fcaf 	bl	80216d6 <Error_Handler>
 8021d78:	e7f9      	b.n	8021d6e <TIMER_IF_StartTimer+0x3e>
 8021d7a:	46c0      	nop			; (mov r8, r8)
 8021d7c:	2000a120 	.word	0x2000a120
 8021d80:	2000b818 	.word	0x2000b818

08021d84 <TIMER_IF_BkUp_Read_MSBticks>:
{
 8021d84:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8021d86:	2102      	movs	r1, #2
 8021d88:	4801      	ldr	r0, [pc, #4]	; (8021d90 <TIMER_IF_BkUp_Read_MSBticks+0xc>)
 8021d8a:	f003 f94f 	bl	802502c <HAL_RTCEx_BKUPRead>
}
 8021d8e:	bd10      	pop	{r4, pc}
 8021d90:	2000b818 	.word	0x2000b818

08021d94 <TIMER_IF_GetTime>:
{
 8021d94:	b570      	push	{r4, r5, r6, lr}
 8021d96:	0005      	movs	r5, r0
 8021d98:	4b0a      	ldr	r3, [pc, #40]	; (8021dc4 <TIMER_IF_GetTime+0x30>)
 8021d9a:	689c      	ldr	r4, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 8021d9c:	43e4      	mvns	r4, r4
  uint32_t timerValueMSB = TIMER_IF_BkUp_Read_MSBticks();
 8021d9e:	f7ff fff1 	bl	8021d84 <TIMER_IF_BkUp_Read_MSBticks>
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 8021da2:	2200      	movs	r2, #0
 8021da4:	0003      	movs	r3, r0
 8021da6:	0020      	movs	r0, r4
 8021da8:	2100      	movs	r1, #0
 8021daa:	1812      	adds	r2, r2, r0
 8021dac:	414b      	adcs	r3, r1
 8021dae:	0011      	movs	r1, r2
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 8021db0:	059b      	lsls	r3, r3, #22
 8021db2:	0a8c      	lsrs	r4, r1, #10
 8021db4:	431c      	orrs	r4, r3
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 8021db6:	058a      	lsls	r2, r1, #22
 8021db8:	0d90      	lsrs	r0, r2, #22
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 8021dba:	f7ff ff52 	bl	8021c62 <TIMER_IF_Convert_Tick2ms>
 8021dbe:	8028      	strh	r0, [r5, #0]
}
 8021dc0:	0020      	movs	r0, r4
 8021dc2:	bd70      	pop	{r4, r5, r6, pc}
 8021dc4:	40002800 	.word	0x40002800

08021dc8 <TIMER_IF_BkUp_Read_Seconds>:
{
 8021dc8:	b510      	push	{r4, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 8021dca:	2100      	movs	r1, #0
 8021dcc:	4801      	ldr	r0, [pc, #4]	; (8021dd4 <TIMER_IF_BkUp_Read_Seconds+0xc>)
 8021dce:	f003 f92d 	bl	802502c <HAL_RTCEx_BKUPRead>
}
 8021dd2:	bd10      	pop	{r4, pc}
 8021dd4:	2000b818 	.word	0x2000b818

08021dd8 <TIMER_IF_BkUp_Read_SubSeconds>:
{
 8021dd8:	b510      	push	{r4, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 8021dda:	2101      	movs	r1, #1
 8021ddc:	4801      	ldr	r0, [pc, #4]	; (8021de4 <TIMER_IF_BkUp_Read_SubSeconds+0xc>)
 8021dde:	f003 f925 	bl	802502c <HAL_RTCEx_BKUPRead>
}
 8021de2:	bd10      	pop	{r4, pc}
 8021de4:	2000b818 	.word	0x2000b818

08021de8 <TIMER_IF_DelayMs>:
{
 8021de8:	b510      	push	{r4, lr}
  uint32_t delayTicks = TIMER_IF_Convert_ms2Tick(delay);
 8021dea:	f7ff ff31 	bl	8021c50 <TIMER_IF_Convert_ms2Tick>
 8021dee:	4b06      	ldr	r3, [pc, #24]	; (8021e08 <TIMER_IF_DelayMs+0x20>)
 8021df0:	689a      	ldr	r2, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 8021df2:	43d2      	mvns	r2, r2
 8021df4:	4b04      	ldr	r3, [pc, #16]	; (8021e08 <TIMER_IF_DelayMs+0x20>)
 8021df6:	689b      	ldr	r3, [r3, #8]
 8021df8:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8021dfa:	1a9b      	subs	r3, r3, r2
 8021dfc:	4283      	cmp	r3, r0
 8021dfe:	d201      	bcs.n	8021e04 <TIMER_IF_DelayMs+0x1c>
    __NOP();
 8021e00:	46c0      	nop			; (mov r8, r8)
 8021e02:	e7f7      	b.n	8021df4 <TIMER_IF_DelayMs+0xc>
}
 8021e04:	bd10      	pop	{r4, pc}
 8021e06:	46c0      	nop			; (mov r8, r8)
 8021e08:	40002800 	.word	0x40002800

08021e0c <HAL_RTC_AlarmAEventCallback>:
{
 8021e0c:	b510      	push	{r4, lr}
  if (MBMUXIF_GetCpusSynchroFlag() == CPUS_BOOT_SYNC_RTC_REGISTERED)
 8021e0e:	f000 fdd9 	bl	80229c4 <MBMUXIF_GetCpusSynchroFlag>
 8021e12:	4b08      	ldr	r3, [pc, #32]	; (8021e34 <HAL_RTC_AlarmAEventCallback+0x28>)
 8021e14:	4298      	cmp	r0, r3
 8021e16:	d000      	beq.n	8021e1a <HAL_RTC_AlarmAEventCallback+0xe>
}
 8021e18:	bd10      	pop	{r4, pc}
    com_obj = MBMUXIF_GetSystemFeatureNotifComPtr(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 8021e1a:	2002      	movs	r0, #2
 8021e1c:	f000 fddc 	bl	80229d8 <MBMUXIF_GetSystemFeatureNotifComPtr>
    if (com_obj != NULL)
 8021e20:	2800      	cmp	r0, #0
 8021e22:	d0f9      	beq.n	8021e18 <HAL_RTC_AlarmAEventCallback+0xc>
      com_obj->MsgId = SYS_RTC_ALARM_MSG_ID;
 8021e24:	2302      	movs	r3, #2
 8021e26:	6003      	str	r3, [r0, #0]
      com_obj->ParamCnt = 0;
 8021e28:	2300      	movs	r3, #0
 8021e2a:	81c3      	strh	r3, [r0, #14]
      MBMUXIF_SystemSendNotif_NoWait(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 8021e2c:	2002      	movs	r0, #2
 8021e2e:	f000 fdde 	bl	80229ee <MBMUXIF_SystemSendNotif_NoWait>
}
 8021e32:	e7f1      	b.n	8021e18 <HAL_RTC_AlarmAEventCallback+0xc>
 8021e34:	00009999 	.word	0x00009999

08021e38 <HAL_RTCEx_AlarmBEventCallback>:
{
 8021e38:	b510      	push	{r4, lr}
  UTIL_TIMER_IRQ_MAP_PROCESS();
 8021e3a:	f012 fa69 	bl	8034310 <UTIL_TIMER_IRQ_Handler>
}
 8021e3e:	bd10      	pop	{r4, pc}

08021e40 <HAL_RTCEx_SSRUEventCallback>:
{
 8021e40:	b510      	push	{r4, lr}
  uint32_t MSB_ticks = TIMER_IF_BkUp_Read_MSBticks();
 8021e42:	f7ff ff9f 	bl	8021d84 <TIMER_IF_BkUp_Read_MSBticks>
  TIMER_IF_BkUp_Write_MSBticks(MSB_ticks + 1);
 8021e46:	3001      	adds	r0, #1
 8021e48:	f7ff ff2a 	bl	8021ca0 <TIMER_IF_BkUp_Write_MSBticks>
}
 8021e4c:	bd10      	pop	{r4, pc}

08021e4e <MX_KMS_Init>:
/* USER CODE BEGIN 2 */
/* USER CODE END 2 */

/* KMS init function */
void MX_KMS_Init(void)
{
 8021e4e:	b510      	push	{r4, lr}
/***************************************/
   /**
  */

  C_Initialize(NULL);
 8021e50:	2000      	movs	r0, #0
 8021e52:	f005 f975 	bl	8027140 <KMS_Initialize>

  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */

}
 8021e56:	bd10      	pop	{r4, pc}

08021e58 <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 8021e58:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 8021e5a:	f7ff fe1b 	bl	8021a94 <SystemApp_Init>
  /* USER CODE BEGIN MX_LoRaWAN_Init_2 */

  /* USER CODE END MX_LoRaWAN_Init_2 */
}
 8021e5e:	bd10      	pop	{r4, pc}

08021e60 <MX_LoRaWAN_Process>:

void MX_LoRaWAN_Process(void)
{
 8021e60:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 8021e62:	2001      	movs	r0, #1
 8021e64:	4240      	negs	r0, r0
 8021e66:	f011 ff91 	bl	8033d8c <UTIL_SEQ_Run>
  /* USER CODE BEGIN MX_LoRaWAN_Process_2 */

  /* USER CODE END MX_LoRaWAN_Process_2 */
}
 8021e6a:	bd10      	pop	{r4, pc}

08021e6c <InitPackageProcess>:
/* USER CODE BEGIN EF */

/* USER CODE END EF */

void InitPackageProcess(void)
{
 8021e6c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN InitPackageProcess_1 */

  /* USER CODE END InitPackageProcess_1 */
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbLmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 8021e6e:	4a03      	ldr	r2, [pc, #12]	; (8021e7c <InitPackageProcess+0x10>)
 8021e70:	2100      	movs	r1, #0
 8021e72:	2040      	movs	r0, #64	; 0x40
 8021e74:	f012 f836 	bl	8033ee4 <UTIL_SEQ_RegTask>
  /* USER CODE BEGIN InitPackageProcess_2 */

  /* USER CODE END InitPackageProcess_2 */
}
 8021e78:	bd10      	pop	{r4, pc}
 8021e7a:	46c0      	nop			; (mov r8, r8)
 8021e7c:	08029051 	.word	0x08029051

08021e80 <OnMacProcessNotify>:

void OnMacProcessNotify(void)
{
 8021e80:	b510      	push	{r4, lr}
  /* USER CODE BEGIN OnMacProcessNotify_1 */

  /* USER CODE END OnMacProcessNotify_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbLmHandlerProcess), CFG_SEQ_Prio_0);
 8021e82:	2100      	movs	r1, #0
 8021e84:	2040      	movs	r0, #64	; 0x40
 8021e86:	f011 ff43 	bl	8033d10 <UTIL_SEQ_SetTask>
  /* USER CODE BEGIN OnMacProcessNotify_2 */

  /* USER CODE END OnMacProcessNotify_2 */
}
 8021e8a:	bd10      	pop	{r4, pc}

08021e8c <RBI_Init>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t RBI_Init(void)
{
 8021e8c:	b510      	push	{r4, lr}
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_Init();
 8021e8e:	f001 f885 	bl	8022f9c <BSP_RADIO_Init>
  /* USER CODE BEGIN RBI_Init_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_Init_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 8021e92:	bd10      	pop	{r4, pc}

08021e94 <RBI_ConfigRFSwitch>:
  return retcode;
#endif  /* USE_BSP_DRIVER */
}

int32_t RBI_ConfigRFSwitch(RBI_Switch_TypeDef Config)
{
 8021e94:	b510      	push	{r4, lr}
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 8021e96:	f001 f8bd 	bl	8023014 <BSP_RADIO_ConfigRFSwitch>
  /* USER CODE BEGIN RBI_ConfigRFSwitch_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_ConfigRFSwitch_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 8021e9a:	bd10      	pop	{r4, pc}

08021e9c <RBI_GetTxConfig>:

int32_t RBI_GetTxConfig(void)
{
 8021e9c:	b510      	push	{r4, lr}
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_GetTxConfig();
 8021e9e:	f001 f90b 	bl	80230b8 <BSP_RADIO_GetTxConfig>
  /* USER CODE BEGIN RBI_GetTxConfig_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_GetTxConfig_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 8021ea2:	bd10      	pop	{r4, pc}

08021ea4 <RBI_IsTCXO>:

int32_t RBI_IsTCXO(void)
{
 8021ea4:	b510      	push	{r4, lr}
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsTCXO();
 8021ea6:	f001 f909 	bl	80230bc <BSP_RADIO_IsTCXO>
  /* USER CODE BEGIN RBI_IsTCXO_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_IsTCXO_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 8021eaa:	bd10      	pop	{r4, pc}

08021eac <RBI_IsDCDC>:

int32_t RBI_IsDCDC(void)
{
 8021eac:	b510      	push	{r4, lr}
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsDCDC();
 8021eae:	f001 f907 	bl	80230c0 <BSP_RADIO_IsDCDC>
  /* USER CODE BEGIN RBI_IsDCDC_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_IsDCDC_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 8021eb2:	bd10      	pop	{r4, pc}

08021eb4 <OnSysTimeUpdate_mbwrapper>:

  /* USER CODE END OnBeaconStatusChange_mbwrapper_2 */
}

static void OnSysTimeUpdate_mbwrapper(void)
{
 8021eb4:	b510      	push	{r4, lr}
  /* USER CODE BEGIN OnBeaconStatusChange_mbwrapper_1 */

  /* USER CODE END OnBeaconStatusChange_mbwrapper_1 */
  MBMUX_ComParam_t *com_obj;

  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021eb6:	f000 fc35 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
  com_obj->MsgId = LMHANDLER_ON_ON_SYS_TIME_UPDATE_CB_ID;
 8021eba:	233c      	movs	r3, #60	; 0x3c
 8021ebc:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8021ebe:	2300      	movs	r3, #0
 8021ec0:	81c3      	strh	r3, [r0, #14]

  MBMUXIF_LoraSendNotif();
 8021ec2:	f000 fc3b 	bl	802273c <MBMUXIF_LoraSendNotif>
  /* once event is received and semaphore released: */
  return;
  /* USER CODE BEGIN OnBeaconStatusChange_mbwrapper_2 */

  /* USER CODE END OnBeaconStatusChange_mbwrapper_2 */
}
 8021ec6:	bd10      	pop	{r4, pc}

08021ec8 <OnClassChange_mbwrapper>:
{
 8021ec8:	b570      	push	{r4, r5, r6, lr}
 8021eca:	0005      	movs	r5, r0
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021ecc:	f000 fc2a 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021ed0:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_CLASS_CHANGE_CB_ID;
 8021ed2:	233a      	movs	r3, #58	; 0x3a
 8021ed4:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021ed6:	8981      	ldrh	r1, [r0, #12]
 8021ed8:	6900      	ldr	r0, [r0, #16]
 8021eda:	f000 fbb8 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)deviceClass;
 8021ede:	6005      	str	r5, [r0, #0]
  com_obj->ParamCnt = 1;
 8021ee0:	2301      	movs	r3, #1
 8021ee2:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021ee4:	f000 fc2a 	bl	802273c <MBMUXIF_LoraSendNotif>
}
 8021ee8:	bd70      	pop	{r4, r5, r6, pc}

08021eea <OnNvmDataChange_mbwrapper>:
{
 8021eea:	b570      	push	{r4, r5, r6, lr}
 8021eec:	0006      	movs	r6, r0
 8021eee:	000d      	movs	r5, r1
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021ef0:	f000 fc18 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021ef4:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_NVM_DATA_CHANGE_CB_ID;
 8021ef6:	2335      	movs	r3, #53	; 0x35
 8021ef8:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021efa:	8981      	ldrh	r1, [r0, #12]
 8021efc:	6900      	ldr	r0, [r0, #16]
 8021efe:	f000 fba6 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)state;
 8021f02:	6006      	str	r6, [r0, #0]
  com_buffer[1] = (uint32_t)size;
 8021f04:	6045      	str	r5, [r0, #4]
  com_obj->ParamCnt = 2;
 8021f06:	2302      	movs	r3, #2
 8021f08:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021f0a:	f000 fc17 	bl	802273c <MBMUXIF_LoraSendNotif>
}
 8021f0e:	bd70      	pop	{r4, r5, r6, pc}

08021f10 <GetTemperatureLevel_mbwrapper>:
{
 8021f10:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f12:	f000 fc07 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021f16:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_GET_TEMPERATURE_CB_ID;
 8021f18:	2334      	movs	r3, #52	; 0x34
 8021f1a:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8021f1c:	2300      	movs	r3, #0
 8021f1e:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_LoraSendNotif();
 8021f20:	f000 fc0c 	bl	802273c <MBMUXIF_LoraSendNotif>
  return (uint16_t) com_obj->ReturnVal;
 8021f24:	8aa0      	ldrh	r0, [r4, #20]
}
 8021f26:	bd10      	pop	{r4, pc}

08021f28 <GetBatteryLevel_mbwrapper>:
{
 8021f28:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f2a:	f000 fbfb 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021f2e:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_GET_BATTERY_LEVEL_CB_ID;
 8021f30:	2333      	movs	r3, #51	; 0x33
 8021f32:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8021f34:	2300      	movs	r3, #0
 8021f36:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_LoraSendNotif();
 8021f38:	f000 fc00 	bl	802273c <MBMUXIF_LoraSendNotif>
  return (uint8_t) com_obj->ReturnVal;
 8021f3c:	7d20      	ldrb	r0, [r4, #20]
}
 8021f3e:	bd10      	pop	{r4, pc}

08021f40 <OnBeaconStatusChange_mbwrapper>:
{
 8021f40:	b570      	push	{r4, r5, r6, lr}
 8021f42:	1e05      	subs	r5, r0, #0
  if (params != NULL)
 8021f44:	d004      	beq.n	8021f50 <OnBeaconStatusChange_mbwrapper+0x10>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, params, sizeof(LmHandlerBeaconParams_t));
 8021f46:	221c      	movs	r2, #28
 8021f48:	0001      	movs	r1, r0
 8021f4a:	480c      	ldr	r0, [pc, #48]	; (8021f7c <OnBeaconStatusChange_mbwrapper+0x3c>)
 8021f4c:	f011 fecc 	bl	8033ce8 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f50:	f000 fbe8 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021f54:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_BEACON_STATUS_CHANGE_CB_ID;
 8021f56:	233b      	movs	r3, #59	; 0x3b
 8021f58:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021f5a:	8981      	ldrh	r1, [r0, #12]
 8021f5c:	6900      	ldr	r0, [r0, #16]
 8021f5e:	f000 fb76 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  if (params == NULL)
 8021f62:	2d00      	cmp	r5, #0
 8021f64:	d006      	beq.n	8021f74 <OnBeaconStatusChange_mbwrapper+0x34>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 8021f66:	4b05      	ldr	r3, [pc, #20]	; (8021f7c <OnBeaconStatusChange_mbwrapper+0x3c>)
 8021f68:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 8021f6a:	2301      	movs	r3, #1
 8021f6c:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021f6e:	f000 fbe5 	bl	802273c <MBMUXIF_LoraSendNotif>
}
 8021f72:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 8021f74:	2300      	movs	r3, #0
 8021f76:	6003      	str	r3, [r0, #0]
 8021f78:	e7f7      	b.n	8021f6a <OnBeaconStatusChange_mbwrapper+0x2a>
 8021f7a:	46c0      	nop			; (mov r8, r8)
 8021f7c:	20009000 	.word	0x20009000

08021f80 <OnRxData_mbwrapper>:
{
 8021f80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021f82:	0005      	movs	r5, r0
 8021f84:	000e      	movs	r6, r1
  if (appData != NULL)
 8021f86:	2800      	cmp	r0, #0
 8021f88:	d018      	beq.n	8021fbc <OnRxData_mbwrapper+0x3c>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, appData, sizeof(LmHandlerAppData_t));
 8021f8a:	2208      	movs	r2, #8
 8021f8c:	0001      	movs	r1, r0
 8021f8e:	481e      	ldr	r0, [pc, #120]	; (8022008 <OnRxData_mbwrapper+0x88>)
 8021f90:	f011 feaa 	bl	8033ce8 <UTIL_MEM_cpy_8>
    if (appData->BufferSize > 0)
 8021f94:	786a      	ldrb	r2, [r5, #1]
 8021f96:	2a00      	cmp	r2, #0
 8021f98:	d101      	bne.n	8021f9e <OnRxData_mbwrapper+0x1e>
    next_addr = (sizeof(LmHandlerAppData_t) + 7) & ~7;
 8021f9a:	2708      	movs	r7, #8
 8021f9c:	e00f      	b.n	8021fbe <OnRxData_mbwrapper+0x3e>
      UTIL_MEM_cpy_8(&aLoraMbWrapShare2Buffer[next_addr], appData->Buffer, appData->BufferSize);
 8021f9e:	b292      	uxth	r2, r2
 8021fa0:	4c1a      	ldr	r4, [pc, #104]	; (802200c <OnRxData_mbwrapper+0x8c>)
 8021fa2:	6869      	ldr	r1, [r5, #4]
 8021fa4:	0020      	movs	r0, r4
 8021fa6:	f011 fe9f 	bl	8033ce8 <UTIL_MEM_cpy_8>
      ((LmHandlerAppData_t *)aLoraMbWrapShare2Buffer)->Buffer = &aLoraMbWrapShare2Buffer[next_addr];
 8021faa:	0023      	movs	r3, r4
 8021fac:	3b08      	subs	r3, #8
 8021fae:	605c      	str	r4, [r3, #4]
      next_addr = (appData->BufferSize + 7) & ~7;
 8021fb0:	786f      	ldrb	r7, [r5, #1]
 8021fb2:	3707      	adds	r7, #7
 8021fb4:	b2ff      	uxtb	r7, r7
 8021fb6:	2307      	movs	r3, #7
 8021fb8:	439f      	bics	r7, r3
 8021fba:	e000      	b.n	8021fbe <OnRxData_mbwrapper+0x3e>
  uint8_t next_addr = 0;
 8021fbc:	2700      	movs	r7, #0
  if (params != NULL)
 8021fbe:	2e00      	cmp	r6, #0
 8021fc0:	d005      	beq.n	8021fce <OnRxData_mbwrapper+0x4e>
    UTIL_MEM_cpy_8(&aLoraMbWrapShare2Buffer[next_addr], params, sizeof(LmHandlerRxParams_t));
 8021fc2:	4811      	ldr	r0, [pc, #68]	; (8022008 <OnRxData_mbwrapper+0x88>)
 8021fc4:	1838      	adds	r0, r7, r0
 8021fc6:	2210      	movs	r2, #16
 8021fc8:	0031      	movs	r1, r6
 8021fca:	f011 fe8d 	bl	8033ce8 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021fce:	f000 fba9 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021fd2:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_RX_DATA_CB_ID;
 8021fd4:	2339      	movs	r3, #57	; 0x39
 8021fd6:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021fd8:	8981      	ldrh	r1, [r0, #12]
 8021fda:	6900      	ldr	r0, [r0, #16]
 8021fdc:	f000 fb37 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  if (appData == NULL)
 8021fe0:	2d00      	cmp	r5, #0
 8021fe2:	d00b      	beq.n	8021ffc <OnRxData_mbwrapper+0x7c>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 8021fe4:	4b08      	ldr	r3, [pc, #32]	; (8022008 <OnRxData_mbwrapper+0x88>)
 8021fe6:	6003      	str	r3, [r0, #0]
  if (params == NULL)
 8021fe8:	2e00      	cmp	r6, #0
 8021fea:	d00a      	beq.n	8022002 <OnRxData_mbwrapper+0x82>
    com_buffer[1] = (uint32_t) &aLoraMbWrapShare2Buffer[next_addr];
 8021fec:	4b06      	ldr	r3, [pc, #24]	; (8022008 <OnRxData_mbwrapper+0x88>)
 8021fee:	18ff      	adds	r7, r7, r3
 8021ff0:	6047      	str	r7, [r0, #4]
  com_obj->ParamCnt = 2;
 8021ff2:	2302      	movs	r3, #2
 8021ff4:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021ff6:	f000 fba1 	bl	802273c <MBMUXIF_LoraSendNotif>
}
 8021ffa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    com_buffer[0] = (uint32_t)NULL;
 8021ffc:	2300      	movs	r3, #0
 8021ffe:	6003      	str	r3, [r0, #0]
 8022000:	e7f2      	b.n	8021fe8 <OnRxData_mbwrapper+0x68>
    com_buffer[1] = (uint32_t)NULL;
 8022002:	2300      	movs	r3, #0
 8022004:	6043      	str	r3, [r0, #4]
 8022006:	e7f4      	b.n	8021ff2 <OnRxData_mbwrapper+0x72>
 8022008:	20009000 	.word	0x20009000
 802200c:	20009008 	.word	0x20009008

08022010 <OnTxData_mbwrapper>:
{
 8022010:	b570      	push	{r4, r5, r6, lr}
 8022012:	1e05      	subs	r5, r0, #0
  if (params != NULL)
 8022014:	d004      	beq.n	8022020 <OnTxData_mbwrapper+0x10>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, params, sizeof(LmHandlerTxParams_t));
 8022016:	2218      	movs	r2, #24
 8022018:	0001      	movs	r1, r0
 802201a:	480c      	ldr	r0, [pc, #48]	; (802204c <OnTxData_mbwrapper+0x3c>)
 802201c:	f011 fe64 	bl	8033ce8 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8022020:	f000 fb80 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8022024:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_TX_DATA_CB_ID;
 8022026:	2338      	movs	r3, #56	; 0x38
 8022028:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 802202a:	8981      	ldrh	r1, [r0, #12]
 802202c:	6900      	ldr	r0, [r0, #16]
 802202e:	f000 fb0e 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  if (params == NULL)
 8022032:	2d00      	cmp	r5, #0
 8022034:	d006      	beq.n	8022044 <OnTxData_mbwrapper+0x34>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 8022036:	4b05      	ldr	r3, [pc, #20]	; (802204c <OnTxData_mbwrapper+0x3c>)
 8022038:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 802203a:	2301      	movs	r3, #1
 802203c:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 802203e:	f000 fb7d 	bl	802273c <MBMUXIF_LoraSendNotif>
}
 8022042:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 8022044:	2300      	movs	r3, #0
 8022046:	6003      	str	r3, [r0, #0]
 8022048:	e7f7      	b.n	802203a <OnTxData_mbwrapper+0x2a>
 802204a:	46c0      	nop			; (mov r8, r8)
 802204c:	20009000 	.word	0x20009000

08022050 <OnJoinRequest_mbwrapper>:
{
 8022050:	b570      	push	{r4, r5, r6, lr}
 8022052:	1e05      	subs	r5, r0, #0
  if (joinParams != NULL)
 8022054:	d004      	beq.n	8022060 <OnJoinRequest_mbwrapper+0x10>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, joinParams, sizeof(LmHandlerJoinParams_t));
 8022056:	2203      	movs	r2, #3
 8022058:	0001      	movs	r1, r0
 802205a:	480c      	ldr	r0, [pc, #48]	; (802208c <OnJoinRequest_mbwrapper+0x3c>)
 802205c:	f011 fe44 	bl	8033ce8 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8022060:	f000 fb60 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 8022064:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_JOIN_REQ_CB_ID;
 8022066:	2337      	movs	r3, #55	; 0x37
 8022068:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 802206a:	8981      	ldrh	r1, [r0, #12]
 802206c:	6900      	ldr	r0, [r0, #16]
 802206e:	f000 faee 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  if (joinParams == NULL)
 8022072:	2d00      	cmp	r5, #0
 8022074:	d006      	beq.n	8022084 <OnJoinRequest_mbwrapper+0x34>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 8022076:	4b05      	ldr	r3, [pc, #20]	; (802208c <OnJoinRequest_mbwrapper+0x3c>)
 8022078:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 802207a:	2301      	movs	r3, #1
 802207c:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 802207e:	f000 fb5d 	bl	802273c <MBMUXIF_LoraSendNotif>
}
 8022082:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 8022084:	2300      	movs	r3, #0
 8022086:	6003      	str	r3, [r0, #0]
 8022088:	e7f7      	b.n	802207a <OnJoinRequest_mbwrapper+0x2a>
 802208a:	46c0      	nop			; (mov r8, r8)
 802208c:	20009000 	.word	0x20009000

08022090 <OnNetworkParametersChange_mbwrapper>:
{
 8022090:	b570      	push	{r4, r5, r6, lr}
 8022092:	1e05      	subs	r5, r0, #0
  if (params != NULL)
 8022094:	d004      	beq.n	80220a0 <OnNetworkParametersChange_mbwrapper+0x10>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, params, sizeof(CommissioningParams_t));
 8022096:	2218      	movs	r2, #24
 8022098:	0001      	movs	r1, r0
 802209a:	480c      	ldr	r0, [pc, #48]	; (80220cc <OnNetworkParametersChange_mbwrapper+0x3c>)
 802209c:	f011 fe24 	bl	8033ce8 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 80220a0:	f000 fb40 	bl	8022724 <MBMUXIF_GetLoraFeatureNotifComPtr>
 80220a4:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_NETWORK_PARAMS_CHANGE_CB_ID;
 80220a6:	2336      	movs	r3, #54	; 0x36
 80220a8:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 80220aa:	8981      	ldrh	r1, [r0, #12]
 80220ac:	6900      	ldr	r0, [r0, #16]
 80220ae:	f000 face 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  if (params == NULL)
 80220b2:	2d00      	cmp	r5, #0
 80220b4:	d006      	beq.n	80220c4 <OnNetworkParametersChange_mbwrapper+0x34>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 80220b6:	4b05      	ldr	r3, [pc, #20]	; (80220cc <OnNetworkParametersChange_mbwrapper+0x3c>)
 80220b8:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 80220ba:	2301      	movs	r3, #1
 80220bc:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 80220be:	f000 fb3d 	bl	802273c <MBMUXIF_LoraSendNotif>
}
 80220c2:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 80220c4:	2300      	movs	r3, #0
 80220c6:	6003      	str	r3, [r0, #0]
 80220c8:	e7f7      	b.n	80220ba <OnNetworkParametersChange_mbwrapper+0x2a>
 80220ca:	46c0      	nop			; (mov r8, r8)
 80220cc:	20009000 	.word	0x20009000

080220d0 <Process_Lora_Cmd>:
{
 80220d0:	b510      	push	{r4, lr}
 80220d2:	b082      	sub	sp, #8
 80220d4:	0004      	movs	r4, r0
  APP_LOG(TS_ON, VLEVEL_H, ">CM0PLUS(LoRa)\r\n");
 80220d6:	4bc8      	ldr	r3, [pc, #800]	; (80223f8 <Process_Lora_Cmd+0x328>)
 80220d8:	2201      	movs	r2, #1
 80220da:	2100      	movs	r1, #0
 80220dc:	2003      	movs	r0, #3
 80220de:	f011 fceb 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(ComObj->ParamBuf, ComObj->BufSize);
 80220e2:	89a1      	ldrh	r1, [r4, #12]
 80220e4:	6920      	ldr	r0, [r4, #16]
 80220e6:	f000 fab2 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  switch (ComObj->MsgId)
 80220ea:	6823      	ldr	r3, [r4, #0]
 80220ec:	2b32      	cmp	r3, #50	; 0x32
 80220ee:	d80b      	bhi.n	8022108 <Process_Lora_Cmd+0x38>
 80220f0:	009b      	lsls	r3, r3, #2
 80220f2:	4ac2      	ldr	r2, [pc, #776]	; (80223fc <Process_Lora_Cmd+0x32c>)
 80220f4:	58d3      	ldr	r3, [r2, r3]
 80220f6:	469f      	mov	pc, r3
      errorStatus = LmHandlerInit(&callback_mbwrapper);
 80220f8:	48c1      	ldr	r0, [pc, #772]	; (8022400 <Process_Lora_Cmd+0x330>)
 80220fa:	f007 fa51 	bl	80295a0 <LmHandlerInit>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80220fe:	2300      	movs	r3, #0
 8022100:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022102:	6160      	str	r0, [r4, #20]
      InitPackageProcess();
 8022104:	f7ff feb2 	bl	8021e6c <InitPackageProcess>
  APP_LOG(TS_ON, VLEVEL_H, "<CM0PLUS(LoRa)\r\n");
 8022108:	4bbe      	ldr	r3, [pc, #760]	; (8022404 <Process_Lora_Cmd+0x334>)
 802210a:	2201      	movs	r2, #1
 802210c:	2100      	movs	r1, #0
 802210e:	2003      	movs	r0, #3
 8022110:	f011 fcd2 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_LORAWAN_ID);
 8022114:	2008      	movs	r0, #8
 8022116:	f000 fa93 	bl	8022640 <MBMUX_ResponseSnd>
}
 802211a:	b002      	add	sp, #8
 802211c:	bd10      	pop	{r4, pc}
      errorStatus = LmHandlerConfigure((LmHandlerParams_t *) com_buffer[0]);
 802211e:	6800      	ldr	r0, [r0, #0]
 8022120:	f006 feb4 	bl	8028e8c <LmHandlerConfigure>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022124:	2300      	movs	r3, #0
 8022126:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022128:	6160      	str	r0, [r4, #20]
      break;
 802212a:	e7ed      	b.n	8022108 <Process_Lora_Cmd+0x38>
      flagStatus = LmHandlerJoinStatus();
 802212c:	f006 ff98 	bl	8029060 <LmHandlerJoinStatus>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022130:	2300      	movs	r3, #0
 8022132:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) flagStatus; /* */
 8022134:	6160      	str	r0, [r4, #20]
      break;
 8022136:	e7e7      	b.n	8022108 <Process_Lora_Cmd+0x38>
      LmHandlerJoin((ActivationType_t) com_buffer[0]);
 8022138:	7800      	ldrb	r0, [r0, #0]
 802213a:	f007 f821 	bl	8029180 <LmHandlerJoin>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802213e:	2300      	movs	r3, #0
 8022140:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022142:	6163      	str	r3, [r4, #20]
      break;
 8022144:	e7e0      	b.n	8022108 <Process_Lora_Cmd+0x38>
      errorStatus = LmHandlerStop();
 8022146:	f006 ff9d 	bl	8029084 <LmHandlerStop>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802214a:	2300      	movs	r3, #0
 802214c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802214e:	6160      	str	r0, [r4, #20]
      break;
 8022150:	e7da      	b.n	8022108 <Process_Lora_Cmd+0x38>
      appData.Port = (uint8_t)com_buffer[0];
 8022152:	7803      	ldrb	r3, [r0, #0]
 8022154:	466a      	mov	r2, sp
 8022156:	7013      	strb	r3, [r2, #0]
      appData.BufferSize = (uint8_t)com_buffer[1];
 8022158:	7903      	ldrb	r3, [r0, #4]
 802215a:	7053      	strb	r3, [r2, #1]
      appData.Buffer = (uint8_t *)com_buffer[2];
 802215c:	6883      	ldr	r3, [r0, #8]
 802215e:	9301      	str	r3, [sp, #4]
      errorStatus = LmHandlerSend(&appData, (LmHandlerMsgTypes_t) com_buffer[3], (UTIL_TIMER_Time_t *)com_buffer[4], (bool)com_buffer[5]);
 8022160:	6902      	ldr	r2, [r0, #16]
 8022162:	6943      	ldr	r3, [r0, #20]
 8022164:	1e59      	subs	r1, r3, #1
 8022166:	418b      	sbcs	r3, r1
 8022168:	b2db      	uxtb	r3, r3
 802216a:	7b01      	ldrb	r1, [r0, #12]
 802216c:	4668      	mov	r0, sp
 802216e:	f007 f855 	bl	802921c <LmHandlerSend>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022172:	2300      	movs	r3, #0
 8022174:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022176:	6160      	str	r0, [r4, #20]
    break;
 8022178:	e7c6      	b.n	8022108 <Process_Lora_Cmd+0x38>
      LmHandlerProcess();
 802217a:	f006 ff69 	bl	8029050 <LmHandlerProcess>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802217e:	2300      	movs	r3, #0
 8022180:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022182:	6163      	str	r3, [r4, #20]
      break;
 8022184:	e7c0      	b.n	8022108 <Process_Lora_Cmd+0x38>
      errorStatus = LmHandlerRequestClass((DeviceClass_t) com_buffer[0]);
 8022186:	7800      	ldrb	r0, [r0, #0]
 8022188:	f006 ff94 	bl	80290b4 <LmHandlerRequestClass>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802218c:	2300      	movs	r3, #0
 802218e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022190:	6160      	str	r0, [r4, #20]
      break;
 8022192:	e7b9      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetCurrentClass((DeviceClass_t *) com_buffer[0]);
 8022194:	6800      	ldr	r0, [r0, #0]
 8022196:	f007 f8fb 	bl	8029390 <LmHandlerGetCurrentClass>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802219a:	2300      	movs	r3, #0
 802219c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802219e:	6160      	str	r0, [r4, #20]
      break;
 80221a0:	e7b2      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetDevEUI((uint8_t *) com_buffer[0]);
 80221a2:	6800      	ldr	r0, [r0, #0]
 80221a4:	f007 fa30 	bl	8029608 <LmHandlerGetDevEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80221a8:	2300      	movs	r3, #0
 80221aa:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80221ac:	6160      	str	r0, [r4, #20]
      break;
 80221ae:	e7ab      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetDevEUI((uint8_t *) com_buffer[0]);
 80221b0:	6800      	ldr	r0, [r0, #0]
 80221b2:	f007 fa42 	bl	802963a <LmHandlerSetDevEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80221b6:	2300      	movs	r3, #0
 80221b8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80221ba:	6160      	str	r0, [r4, #20]
      break;
 80221bc:	e7a4      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetAppEUI((uint8_t *) com_buffer[0]);
 80221be:	6800      	ldr	r0, [r0, #0]
 80221c0:	f007 fa53 	bl	802966a <LmHandlerGetAppEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80221c4:	2300      	movs	r3, #0
 80221c6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80221c8:	6160      	str	r0, [r4, #20]
      break;
 80221ca:	e79d      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetAppEUI((uint8_t *) com_buffer[0]);
 80221cc:	6800      	ldr	r0, [r0, #0]
 80221ce:	f007 fa65 	bl	802969c <LmHandlerSetAppEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80221d2:	2300      	movs	r3, #0
 80221d4:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80221d6:	6160      	str	r0, [r4, #20]
      break;
 80221d8:	e796      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetNwkKey((uint8_t *) com_buffer[0]);
 80221da:	6800      	ldr	r0, [r0, #0]
 80221dc:	f007 fc23 	bl	8029a26 <LmHandlerGetNwkKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80221e0:	2300      	movs	r3, #0
 80221e2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80221e4:	6160      	str	r0, [r4, #20]
      break;
 80221e6:	e78f      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetNwkKey((uint8_t *) com_buffer[0]);
 80221e8:	6800      	ldr	r0, [r0, #0]
 80221ea:	f007 fc35 	bl	8029a58 <LmHandlerSetNwkKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80221ee:	2300      	movs	r3, #0
 80221f0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80221f2:	6160      	str	r0, [r4, #20]
      break;
 80221f4:	e788      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetAppKey((uint8_t *) com_buffer[0]);
 80221f6:	6800      	ldr	r0, [r0, #0]
 80221f8:	f007 fc46 	bl	8029a88 <LmHandlerGetAppKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80221fc:	2300      	movs	r3, #0
 80221fe:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022200:	6160      	str	r0, [r4, #20]
      break;
 8022202:	e781      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetAppKey((uint8_t *) com_buffer[0]);
 8022204:	6800      	ldr	r0, [r0, #0]
 8022206:	f007 fc58 	bl	8029aba <LmHandlerSetAppKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802220a:	2300      	movs	r3, #0
 802220c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802220e:	6160      	str	r0, [r4, #20]
      break;
 8022210:	e77a      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetNwkSKey((uint8_t *) com_buffer[0]);
 8022212:	6800      	ldr	r0, [r0, #0]
 8022214:	f007 fc69 	bl	8029aea <LmHandlerGetNwkSKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022218:	2300      	movs	r3, #0
 802221a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802221c:	6160      	str	r0, [r4, #20]
      break;
 802221e:	e773      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetNwkSKey((uint8_t *) com_buffer[0]);
 8022220:	6800      	ldr	r0, [r0, #0]
 8022222:	f007 fc7b 	bl	8029b1c <LmHandlerSetNwkSKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022226:	2300      	movs	r3, #0
 8022228:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802222a:	6160      	str	r0, [r4, #20]
      break;
 802222c:	e76c      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetAppSKey((uint8_t *) com_buffer[0]);
 802222e:	6800      	ldr	r0, [r0, #0]
 8022230:	f007 fc8c 	bl	8029b4c <LmHandlerGetAppSKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022234:	2300      	movs	r3, #0
 8022236:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022238:	6160      	str	r0, [r4, #20]
      break;
 802223a:	e765      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetAppSKey((uint8_t *) com_buffer[0]);
 802223c:	6800      	ldr	r0, [r0, #0]
 802223e:	f007 fc9e 	bl	8029b7e <LmHandlerSetAppSKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022242:	2300      	movs	r3, #0
 8022244:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022246:	6160      	str	r0, [r4, #20]
      break;
 8022248:	e75e      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetNetworkID((uint32_t *) com_buffer[0]);
 802224a:	6800      	ldr	r0, [r0, #0]
 802224c:	f007 fa3e 	bl	80296cc <LmHandlerGetNetworkID>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022250:	2300      	movs	r3, #0
 8022252:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022254:	6160      	str	r0, [r4, #20]
      break;
 8022256:	e757      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetNetworkID((uint32_t) com_buffer[0]);
 8022258:	6800      	ldr	r0, [r0, #0]
 802225a:	f007 fa4c 	bl	80296f6 <LmHandlerSetNetworkID>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802225e:	2300      	movs	r3, #0
 8022260:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022262:	6160      	str	r0, [r4, #20]
      break;
 8022264:	e750      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetDevAddr((uint32_t *) com_buffer[0]);
 8022266:	6800      	ldr	r0, [r0, #0]
 8022268:	f007 fa5d 	bl	8029726 <LmHandlerGetDevAddr>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802226c:	2300      	movs	r3, #0
 802226e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022270:	6160      	str	r0, [r4, #20]
      break;
 8022272:	e749      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetDevAddr((uint32_t) com_buffer[0]);
 8022274:	6800      	ldr	r0, [r0, #0]
 8022276:	f007 fa6b 	bl	8029750 <LmHandlerSetDevAddr>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802227a:	2300      	movs	r3, #0
 802227c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802227e:	6160      	str	r0, [r4, #20]
      break;
 8022280:	e742      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetActiveRegion((LoRaMacRegion_t *) com_buffer[0]);
 8022282:	6800      	ldr	r0, [r0, #0]
 8022284:	f007 f954 	bl	8029530 <LmHandlerGetActiveRegion>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022288:	2300      	movs	r3, #0
 802228a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802228c:	6160      	str	r0, [r4, #20]
      break;
 802228e:	e73b      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetActiveRegion((LoRaMacRegion_t) com_buffer[0]);
 8022290:	7800      	ldrb	r0, [r0, #0]
 8022292:	f007 fa75 	bl	8029780 <LmHandlerSetActiveRegion>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022296:	2300      	movs	r3, #0
 8022298:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802229a:	6160      	str	r0, [r4, #20]
      break;
 802229c:	e734      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetAdrEnable((bool *) com_buffer[0]);
 802229e:	6800      	ldr	r0, [r0, #0]
 80222a0:	f007 fa7e 	bl	80297a0 <LmHandlerGetAdrEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222a4:	2300      	movs	r3, #0
 80222a6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80222a8:	6160      	str	r0, [r4, #20]
      break;
 80222aa:	e72d      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetAdrEnable((bool) com_buffer[0]);
 80222ac:	6800      	ldr	r0, [r0, #0]
 80222ae:	1e43      	subs	r3, r0, #1
 80222b0:	4198      	sbcs	r0, r3
 80222b2:	b2c0      	uxtb	r0, r0
 80222b4:	f007 fa80 	bl	80297b8 <LmHandlerSetAdrEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222b8:	2300      	movs	r3, #0
 80222ba:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80222bc:	6160      	str	r0, [r4, #20]
      break;
 80222be:	e723      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetTxDatarate((int8_t *) com_buffer[0]);
 80222c0:	6800      	ldr	r0, [r0, #0]
 80222c2:	f007 f8cd 	bl	8029460 <LmHandlerGetTxDatarate>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222c6:	2300      	movs	r3, #0
 80222c8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80222ca:	6160      	str	r0, [r4, #20]
      break;
 80222cc:	e71c      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetTxDatarate((int8_t) com_buffer[0]);
 80222ce:	7800      	ldrb	r0, [r0, #0]
 80222d0:	b240      	sxtb	r0, r0
 80222d2:	f007 fa87 	bl	80297e4 <LmHandlerSetTxDatarate>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222d6:	2300      	movs	r3, #0
 80222d8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80222da:	6160      	str	r0, [r4, #20]
      break;
 80222dc:	e714      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetDutyCycleEnable((bool *) com_buffer[0]);
 80222de:	6800      	ldr	r0, [r0, #0]
 80222e0:	f007 fa9c 	bl	802981c <LmHandlerGetDutyCycleEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222e4:	2300      	movs	r3, #0
 80222e6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80222e8:	6160      	str	r0, [r4, #20]
      break;
 80222ea:	e70d      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetDutyCycleEnable((bool) com_buffer[0]);
 80222ec:	6800      	ldr	r0, [r0, #0]
 80222ee:	1e43      	subs	r3, r0, #1
 80222f0:	4198      	sbcs	r0, r3
 80222f2:	b2c0      	uxtb	r0, r0
 80222f4:	f007 fa9e 	bl	8029834 <LmHandlerSetDutyCycleEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222f8:	2300      	movs	r3, #0
 80222fa:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80222fc:	6160      	str	r0, [r4, #20]
      break;
 80222fe:	e703      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetRX2Params((RxChannelParams_t *) com_buffer[0]);
 8022300:	6800      	ldr	r0, [r0, #0]
 8022302:	f007 faa1 	bl	8029848 <LmHandlerGetRX2Params>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022306:	2300      	movs	r3, #0
 8022308:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802230a:	6160      	str	r0, [r4, #20]
      break;
 802230c:	e6fc      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetTxPower((int8_t *) com_buffer[0]);
 802230e:	6800      	ldr	r0, [r0, #0]
 8022310:	f007 fab2 	bl	8029878 <LmHandlerGetTxPower>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022314:	2300      	movs	r3, #0
 8022316:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022318:	6160      	str	r0, [r4, #20]
      break;
 802231a:	e6f5      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetRx1Delay((uint32_t *) com_buffer[0]);
 802231c:	6800      	ldr	r0, [r0, #0]
 802231e:	f007 fac2 	bl	80298a6 <LmHandlerGetRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022322:	2300      	movs	r3, #0
 8022324:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022326:	6160      	str	r0, [r4, #20]
      break;
 8022328:	e6ee      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetRx2Delay((uint32_t *) com_buffer[0]);
 802232a:	6800      	ldr	r0, [r0, #0]
 802232c:	f007 fad0 	bl	80298d0 <LmHandlerGetRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022330:	2300      	movs	r3, #0
 8022332:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022334:	6160      	str	r0, [r4, #20]
      break;
 8022336:	e6e7      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetJoinRx1Delay((uint32_t *) com_buffer[0]);
 8022338:	6800      	ldr	r0, [r0, #0]
 802233a:	f007 fade 	bl	80298fa <LmHandlerGetJoinRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802233e:	2300      	movs	r3, #0
 8022340:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022342:	6160      	str	r0, [r4, #20]
      break;
 8022344:	e6e0      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetJoinRx2Delay((uint32_t *) com_buffer[0]);
 8022346:	6800      	ldr	r0, [r0, #0]
 8022348:	f007 faec 	bl	8029924 <LmHandlerGetJoinRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802234c:	2300      	movs	r3, #0
 802234e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022350:	6160      	str	r0, [r4, #20]
      break;
 8022352:	e6d9      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetRX2Params((RxChannelParams_t *) com_buffer[0]);
 8022354:	6800      	ldr	r0, [r0, #0]
 8022356:	f007 fb0a 	bl	802996e <LmHandlerSetRX2Params>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802235a:	2300      	movs	r3, #0
 802235c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802235e:	6160      	str	r0, [r4, #20]
      break;
 8022360:	e6d2      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetTxPower((int8_t) com_buffer[0]);
 8022362:	7800      	ldrb	r0, [r0, #0]
 8022364:	b240      	sxtb	r0, r0
 8022366:	f007 faf2 	bl	802994e <LmHandlerSetTxPower>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802236a:	2300      	movs	r3, #0
 802236c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802236e:	6160      	str	r0, [r4, #20]
      break;
 8022370:	e6ca      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetRx1Delay((uint32_t) com_buffer[0]);
 8022372:	6800      	ldr	r0, [r0, #0]
 8022374:	f007 fb0e 	bl	8029994 <LmHandlerSetRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022378:	2300      	movs	r3, #0
 802237a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802237c:	6160      	str	r0, [r4, #20]
      break;
 802237e:	e6c3      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetRx2Delay((uint32_t) com_buffer[0]);
 8022380:	6800      	ldr	r0, [r0, #0]
 8022382:	f007 fb17 	bl	80299b4 <LmHandlerSetRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022386:	2300      	movs	r3, #0
 8022388:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 802238a:	6160      	str	r0, [r4, #20]
      break;
 802238c:	e6bc      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetJoinRx1Delay((uint32_t) com_buffer[0]);
 802238e:	6800      	ldr	r0, [r0, #0]
 8022390:	f007 fb20 	bl	80299d4 <LmHandlerSetJoinRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022394:	2300      	movs	r3, #0
 8022396:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 8022398:	6160      	str	r0, [r4, #20]
      break;
 802239a:	e6b5      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetJoinRx2Delay((uint32_t) com_buffer[0]);
 802239c:	6800      	ldr	r0, [r0, #0]
 802239e:	f007 fb29 	bl	80299f4 <LmHandlerSetJoinRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223a2:	2300      	movs	r3, #0
 80223a4:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80223a6:	6160      	str	r0, [r4, #20]
      break;
 80223a8:	e6ae      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetPingPeriodicity((uint8_t *) com_buffer[0]);
 80223aa:	6800      	ldr	r0, [r0, #0]
 80223ac:	f007 fb32 	bl	8029a14 <LmHandlerGetPingPeriodicity>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223b0:	2300      	movs	r3, #0
 80223b2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80223b4:	6160      	str	r0, [r4, #20]
      break;
 80223b6:	e6a7      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerSetPingPeriodicity((uint8_t) com_buffer[0]);
 80223b8:	7800      	ldrb	r0, [r0, #0]
 80223ba:	f007 fb2e 	bl	8029a1a <LmHandlerSetPingPeriodicity>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223be:	2300      	movs	r3, #0
 80223c0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80223c2:	6160      	str	r0, [r4, #20]
      break;
 80223c4:	e6a0      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerGetBeaconState((BeaconState_t *) com_buffer[0]);
 80223c6:	6800      	ldr	r0, [r0, #0]
 80223c8:	f007 fb2a 	bl	8029a20 <LmHandlerGetBeaconState>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223cc:	2300      	movs	r3, #0
 80223ce:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80223d0:	6160      	str	r0, [r4, #20]
      break;
 80223d2:	e699      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerLinkCheckReq();
 80223d4:	f006 fe5f 	bl	8029096 <LmHandlerLinkCheckReq>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223d8:	2300      	movs	r3, #0
 80223da:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80223dc:	6160      	str	r0, [r4, #20]
      break;
 80223de:	e693      	b.n	8022108 <Process_Lora_Cmd+0x38>
      ret_code = LmHandlerDeviceTimeReq();
 80223e0:	f006 fd46 	bl	8028e70 <LmHandlerDeviceTimeReq>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223e4:	2300      	movs	r3, #0
 80223e6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_code; /* */
 80223e8:	6160      	str	r0, [r4, #20]
      break;
 80223ea:	e68d      	b.n	8022108 <Process_Lora_Cmd+0x38>
      LoraInfo_Init();
 80223ec:	f000 f83a 	bl	8022464 <LoraInfo_Init>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223f0:	2300      	movs	r3, #0
 80223f2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80223f4:	6163      	str	r3, [r4, #20]
      break;
 80223f6:	e687      	b.n	8022108 <Process_Lora_Cmd+0x38>
 80223f8:	080349a4 	.word	0x080349a4
 80223fc:	080349cc 	.word	0x080349cc
 8022400:	2000a000 	.word	0x2000a000
 8022404:	080349b8 	.word	0x080349b8

08022408 <FEAT_INFO_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void FEAT_INFO_Init(void)
{
 8022408:	b510      	push	{r4, lr}
  /* USER CODE BEGIN FEAT_INFO_Init_1 */

  /* USER CODE END FEAT_INFO_Init_1 */

  /* Set LoRaWAN Info_Config */
  LoraInfo_Init();
 802240a:	f000 f82b 	bl	8022464 <LoraInfo_Init>
  /* USER CODE BEGIN FEAT_INFO_Init_2 */

  /* USER CODE END FEAT_INFO_Init_2 */
}
 802240e:	bd10      	pop	{r4, pc}

08022410 <FEAT_INFO_GetListPtr>:
  /* USER CODE END FEAT_INFO_GetListPtr_1 */
  return (FEAT_INFO_List_t *) &Feat_Info_List;
  /* USER CODE BEGIN FEAT_INFO_GetListPtr_2 */

  /* USER CODE END FEAT_INFO_GetListPtr_2 */
}
 8022410:	4800      	ldr	r0, [pc, #0]	; (8022414 <FEAT_INFO_GetListPtr+0x4>)
 8022412:	4770      	bx	lr
 8022414:	20009118 	.word	0x20009118

08022418 <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 8022418:	4800      	ldr	r0, [pc, #0]	; (802241c <LoraInfo_GetPtr+0x4>)
 802241a:	4770      	bx	lr
 802241c:	20009170 	.word	0x20009170

08022420 <StoreValueInFeatureListTable>:

/* USER CODE END EF */

/* Private functions --------------------------------------------------------*/
void StoreValueInFeatureListTable(void)
{
 8022420:	b570      	push	{r4, r5, r6, lr}

  /* USER CODE BEGIN StoreValueInFeatureListTable_1 */

  /* USER CODE END StoreValueInFeatureListTable_1 */

  p_MBMUX_Cm0plusFeatureList = FEAT_INFO_GetListPtr();
 8022422:	f7ff fff5 	bl	8022410 <FEAT_INFO_GetListPtr>

  if (p_MBMUX_Cm0plusFeatureList != NULL)
 8022426:	2800      	cmp	r0, #0
 8022428:	d016      	beq.n	8022458 <StoreValueInFeatureListTable+0x38>
  {
    cm0plus_nr_of_supported_features = p_MBMUX_Cm0plusFeatureList->Feat_Info_Cnt;
 802242a:	7805      	ldrb	r5, [r0, #0]

    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 802242c:	2300      	movs	r3, #0
 802242e:	42ab      	cmp	r3, r5
 8022430:	d208      	bcs.n	8022444 <StoreValueInFeatureListTable+0x24>
    {
      p_feature = i + p_MBMUX_Cm0plusFeatureList->Feat_Info_TableAddress;
 8022432:	6841      	ldr	r1, [r0, #4]
 8022434:	011a      	lsls	r2, r3, #4
 8022436:	188c      	adds	r4, r1, r2
      if (p_feature->Feat_Info_Feature_Id == FEAT_INFO_LORAWAN_ID)
 8022438:	5c8a      	ldrb	r2, [r1, r2]
 802243a:	2a08      	cmp	r2, #8
 802243c:	d00a      	beq.n	8022454 <StoreValueInFeatureListTable+0x34>
    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 802243e:	3301      	adds	r3, #1
 8022440:	b2db      	uxtb	r3, r3
 8022442:	e7f4      	b.n	802242e <StoreValueInFeatureListTable+0xe>
  uint8_t found = 0;
 8022444:	2300      	movs	r3, #0
        break;
      }
    }
  }

  if (found)
 8022446:	2b00      	cmp	r3, #0
 8022448:	d006      	beq.n	8022458 <StoreValueInFeatureListTable+0x38>
  {
    p_feature->Feat_Info_Config_Size = sizeof(LoraInfo_t) / sizeof(uint32_t);
 802244a:	2304      	movs	r3, #4
 802244c:	60a3      	str	r3, [r4, #8]
    p_feature->Feat_Info_Config_Ptr = &loraInfo;
 802244e:	4b04      	ldr	r3, [pc, #16]	; (8022460 <StoreValueInFeatureListTable+0x40>)
 8022450:	60e3      	str	r3, [r4, #12]
 8022452:	e003      	b.n	802245c <StoreValueInFeatureListTable+0x3c>
        found = 1;
 8022454:	2301      	movs	r3, #1
 8022456:	e7f6      	b.n	8022446 <StoreValueInFeatureListTable+0x26>
  }
  else
  {
    Error_Handler();
 8022458:	f7ff f93d 	bl	80216d6 <Error_Handler>

  /* USER CODE BEGIN StoreValueInFeatureListTable_2 */

  /* USER CODE END StoreValueInFeatureListTable_2 */
  return;
}
 802245c:	bd70      	pop	{r4, r5, r6, pc}
 802245e:	46c0      	nop			; (mov r8, r8)
 8022460:	20009170 	.word	0x20009170

08022464 <LoraInfo_Init>:
{
 8022464:	b510      	push	{r4, lr}
  loraInfo.ClassB = 0;
 8022466:	4b07      	ldr	r3, [pc, #28]	; (8022484 <LoraInfo_Init+0x20>)
 8022468:	2200      	movs	r2, #0
 802246a:	609a      	str	r2, [r3, #8]
  loraInfo.Region |= (1 << LORAMAC_REGION_US915) ;
 802246c:	3221      	adds	r2, #33	; 0x21
 802246e:	32ff      	adds	r2, #255	; 0xff
 8022470:	605a      	str	r2, [r3, #4]
  loraInfo.Kms = 1;
 8022472:	3a20      	subs	r2, #32
 8022474:	3aff      	subs	r2, #255	; 0xff
 8022476:	60da      	str	r2, [r3, #12]
  loraInfo.ActivationMode = ACTIVATION_BY_PERSONALIZATION + (OVER_THE_AIR_ACTIVATION << 1);
 8022478:	3202      	adds	r2, #2
 802247a:	601a      	str	r2, [r3, #0]
  StoreValueInFeatureListTable();
 802247c:	f7ff ffd0 	bl	8022420 <StoreValueInFeatureListTable>
}
 8022480:	bd10      	pop	{r4, pc}
 8022482:	46c0      	nop			; (mov r8, r8)
 8022484:	20009170 	.word	0x20009170

08022488 <MBMUX_IsrCommandRcvCb>:

  /* USER CODE END MBMUX_RetrieveSecureSramConfig_Last */
}

static void MBMUX_IsrCommandRcvCb(uint32_t channelIdx)
{
 8022488:	b510      	push	{r4, lr}
 802248a:	0003      	movs	r3, r0
  /* USER CODE BEGIN MBMUX_IsrCommandRcvCb_1 */

  /* USER CODE END MBMUX_IsrCommandRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBCmdRespParam[channelIdx];
 802248c:	4a05      	ldr	r2, [pc, #20]	; (80224a4 <MBMUX_IsrCommandRcvCb+0x1c>)
 802248e:	6812      	ldr	r2, [r2, #0]
 8022490:	0040      	lsls	r0, r0, #1
 8022492:	18c0      	adds	r0, r0, r3
 8022494:	00c0      	lsls	r0, r0, #3
 8022496:	1810      	adds	r0, r2, r0
  /* call registered callback */
  MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[channelIdx].MsgCm0plusCb(com_obj);
 8022498:	009b      	lsls	r3, r3, #2
 802249a:	4a03      	ldr	r2, [pc, #12]	; (80224a8 <MBMUX_IsrCommandRcvCb+0x20>)
 802249c:	589b      	ldr	r3, [r3, r2]
 802249e:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrCommandRcvCb_Last */

  /* USER CODE END MBMUX_IsrCommandRcvCb_Last */
  return;
}
 80224a0:	bd10      	pop	{r4, pc}
 80224a2:	46c0      	nop			; (mov r8, r8)
 80224a4:	2000a1ac 	.word	0x2000a1ac
 80224a8:	2000a124 	.word	0x2000a124

080224ac <MBMUX_IsrAcknowledgeRcvCb>:

static void MBMUX_IsrAcknowledgeRcvCb(uint32_t channelIdx)
{
 80224ac:	b510      	push	{r4, lr}
 80224ae:	0003      	movs	r3, r0
  /* USER CODE BEGIN MBMUX_IsrAcknowledgeRcvCb_1 */

  /* USER CODE END MBMUX_IsrAcknowledgeRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBNotifAckParam[channelIdx];
 80224b0:	4a06      	ldr	r2, [pc, #24]	; (80224cc <MBMUX_IsrAcknowledgeRcvCb+0x20>)
 80224b2:	6811      	ldr	r1, [r2, #0]
 80224b4:	0042      	lsls	r2, r0, #1
 80224b6:	1812      	adds	r2, r2, r0
 80224b8:	00d2      	lsls	r2, r2, #3
 80224ba:	3290      	adds	r2, #144	; 0x90
 80224bc:	1888      	adds	r0, r1, r2
  /* call registered callback */
  MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[channelIdx].MsgCm0plusCb(com_obj);
 80224be:	3306      	adds	r3, #6
 80224c0:	009b      	lsls	r3, r3, #2
 80224c2:	4a03      	ldr	r2, [pc, #12]	; (80224d0 <MBMUX_IsrAcknowledgeRcvCb+0x24>)
 80224c4:	589b      	ldr	r3, [r3, r2]
 80224c6:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrAcknowledgeRcvCb_Last */

  /* USER CODE END MBMUX_IsrAcknowledgeRcvCb_Last */
  return;
}
 80224c8:	bd10      	pop	{r4, pc}
 80224ca:	46c0      	nop			; (mov r8, r8)
 80224cc:	2000a1ac 	.word	0x2000a1ac
 80224d0:	2000a124 	.word	0x2000a124

080224d4 <MBMUX_GetFeatureChIdx>:
static uint8_t MBMUX_GetFeatureChIdx(FEAT_INFO_IdTypeDef e_featID, MBMUX_ComType_t ComType)
{
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_1 */

  /* USER CODE END MBMUX_GetFeatureChIdx_1 */
  return p_MBMUX_ComTable->MBMUXMapping[e_featID][ComType];
 80224d4:	4b04      	ldr	r3, [pc, #16]	; (80224e8 <MBMUX_GetFeatureChIdx+0x14>)
 80224d6:	681b      	ldr	r3, [r3, #0]
 80224d8:	0040      	lsls	r0, r0, #1
 80224da:	181b      	adds	r3, r3, r0
 80224dc:	185b      	adds	r3, r3, r1
 80224de:	3321      	adds	r3, #33	; 0x21
 80224e0:	33ff      	adds	r3, #255	; 0xff
 80224e2:	7818      	ldrb	r0, [r3, #0]
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_Last */

  /* USER CODE END MBMUX_GetFeatureChIdx_Last */
}
 80224e4:	4770      	bx	lr
 80224e6:	46c0      	nop			; (mov r8, r8)
 80224e8:	2000a1ac 	.word	0x2000a1ac

080224ec <MBMUX_IsrNotRegistered>:

static void MBMUX_IsrNotRegistered(void *ComObj)
{
 80224ec:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_1 */

  /* USER CODE END MBMUX_IsrNotRegistered_1 */
  Error_Handler();
 80224ee:	f7ff f8f2 	bl	80216d6 <Error_Handler>
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_Last */

  /* USER CODE END MBMUX_IsrNotRegistered_Last */
}
 80224f2:	bd10      	pop	{r4, pc}

080224f4 <MBMUX_SEC_VerifySramBuffer>:
{
 80224f4:	b510      	push	{r4, lr}
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SYSTEM_AND_FLASH_ENABLE) != 0)
 80224f6:	4b13      	ldr	r3, [pc, #76]	; (8022544 <MBMUX_SEC_VerifySramBuffer+0x50>)
 80224f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80224fa:	07db      	lsls	r3, r3, #31
 80224fc:	d519      	bpl.n	8022532 <MBMUX_SEC_VerifySramBuffer+0x3e>
    if (((((uint32_t)(pBufferAddress)) >= SRAM1_BASE)
 80224fe:	0003      	movs	r3, r0
 8022500:	2280      	movs	r2, #128	; 0x80
 8022502:	0592      	lsls	r2, r2, #22
 8022504:	4290      	cmp	r0, r2
 8022506:	d304      	bcc.n	8022512 <MBMUX_SEC_VerifySramBuffer+0x1e>
         && ((((uint32_t)(pBufferAddress)) + bufferSize) <= unsecure_sram1_end)) ||
 8022508:	1842      	adds	r2, r0, r1
 802250a:	4c0f      	ldr	r4, [pc, #60]	; (8022548 <MBMUX_SEC_VerifySramBuffer+0x54>)
 802250c:	6824      	ldr	r4, [r4, #0]
 802250e:	42a2      	cmp	r2, r4
 8022510:	d907      	bls.n	8022522 <MBMUX_SEC_VerifySramBuffer+0x2e>
 8022512:	4a0e      	ldr	r2, [pc, #56]	; (802254c <MBMUX_SEC_VerifySramBuffer+0x58>)
 8022514:	4293      	cmp	r3, r2
 8022516:	d911      	bls.n	802253c <MBMUX_SEC_VerifySramBuffer+0x48>
        ((((uint32_t)(pBufferAddress)) >= SRAM2_BASE) && ((((uint32_t)(pBufferAddress)) + bufferSize) <= unsecure_sram2_end))
 8022518:	185a      	adds	r2, r3, r1
 802251a:	4c0d      	ldr	r4, [pc, #52]	; (8022550 <MBMUX_SEC_VerifySramBuffer+0x5c>)
 802251c:	6824      	ldr	r4, [r4, #0]
 802251e:	42a2      	cmp	r2, r4
 8022520:	d80c      	bhi.n	802253c <MBMUX_SEC_VerifySramBuffer+0x48>
      if (((uint32_t)pBufferAddress <= unsecure_sram2_end) && (bufferSize < (SRAM1_SIZE + SRAM2_SIZE)))
 8022522:	4a0b      	ldr	r2, [pc, #44]	; (8022550 <MBMUX_SEC_VerifySramBuffer+0x5c>)
 8022524:	6812      	ldr	r2, [r2, #0]
 8022526:	4293      	cmp	r3, r2
 8022528:	d804      	bhi.n	8022534 <MBMUX_SEC_VerifySramBuffer+0x40>
 802252a:	2380      	movs	r3, #128	; 0x80
 802252c:	025b      	lsls	r3, r3, #9
 802252e:	4299      	cmp	r1, r3
 8022530:	d200      	bcs.n	8022534 <MBMUX_SEC_VerifySramBuffer+0x40>
}
 8022532:	bd10      	pop	{r4, pc}
        Error_Handler();
 8022534:	f7ff f8cf 	bl	80216d6 <Error_Handler>
  uint32_t *p_validated_address = NULL;
 8022538:	2000      	movs	r0, #0
 802253a:	e7fa      	b.n	8022532 <MBMUX_SEC_VerifySramBuffer+0x3e>
      Error_Handler();
 802253c:	f7ff f8cb 	bl	80216d6 <Error_Handler>
  uint32_t *p_validated_address = NULL;
 8022540:	2000      	movs	r0, #0
 8022542:	e7f6      	b.n	8022532 <MBMUX_SEC_VerifySramBuffer+0x3e>
 8022544:	2000a154 	.word	0x2000a154
 8022548:	2000a1b0 	.word	0x2000a1b0
 802254c:	20007fff 	.word	0x20007fff
 8022550:	2000a1b4 	.word	0x2000a1b4

08022554 <MBMUX_RetrieveSecureSramConfig>:
{
 8022554:	b510      	push	{r4, lr}
  HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
 8022556:	4c0d      	ldr	r4, [pc, #52]	; (802258c <MBMUX_RetrieveSecureSramConfig+0x38>)
 8022558:	0020      	movs	r0, r4
 802255a:	f001 fe57 	bl	802420c <HAL_FLASHEx_OBGetConfig>
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SRAM1_DISABLE) != 0)
 802255e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8022560:	065a      	lsls	r2, r3, #25
 8022562:	d508      	bpl.n	8022576 <MBMUX_RetrieveSecureSramConfig+0x22>
    unsecure_sram1_end = SRAM1_BASE + SRAM1_SIZE;
 8022564:	4a0a      	ldr	r2, [pc, #40]	; (8022590 <MBMUX_RetrieveSecureSramConfig+0x3c>)
 8022566:	490b      	ldr	r1, [pc, #44]	; (8022594 <MBMUX_RetrieveSecureSramConfig+0x40>)
 8022568:	6011      	str	r1, [r2, #0]
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SRAM2_DISABLE) != 0)
 802256a:	061b      	lsls	r3, r3, #24
 802256c:	d508      	bpl.n	8022580 <MBMUX_RetrieveSecureSramConfig+0x2c>
    unsecure_sram2_end = SRAM2_BASE + SRAM2_SIZE;
 802256e:	4b0a      	ldr	r3, [pc, #40]	; (8022598 <MBMUX_RetrieveSecureSramConfig+0x44>)
 8022570:	4a0a      	ldr	r2, [pc, #40]	; (802259c <MBMUX_RetrieveSecureSramConfig+0x48>)
 8022572:	601a      	str	r2, [r3, #0]
}
 8022574:	bd10      	pop	{r4, pc}
    unsecure_sram1_end = OptionsBytesStruct.SecureSRAM1StartAddr;
 8022576:	4a05      	ldr	r2, [pc, #20]	; (802258c <MBMUX_RetrieveSecureSramConfig+0x38>)
 8022578:	6b91      	ldr	r1, [r2, #56]	; 0x38
 802257a:	4a05      	ldr	r2, [pc, #20]	; (8022590 <MBMUX_RetrieveSecureSramConfig+0x3c>)
 802257c:	6011      	str	r1, [r2, #0]
 802257e:	e7f4      	b.n	802256a <MBMUX_RetrieveSecureSramConfig+0x16>
    unsecure_sram2_end = OptionsBytesStruct.SecureSRAM2StartAddr;
 8022580:	4b02      	ldr	r3, [pc, #8]	; (802258c <MBMUX_RetrieveSecureSramConfig+0x38>)
 8022582:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8022584:	4b04      	ldr	r3, [pc, #16]	; (8022598 <MBMUX_RetrieveSecureSramConfig+0x44>)
 8022586:	601a      	str	r2, [r3, #0]
}
 8022588:	e7f4      	b.n	8022574 <MBMUX_RetrieveSecureSramConfig+0x20>
 802258a:	46c0      	nop			; (mov r8, r8)
 802258c:	2000a154 	.word	0x2000a154
 8022590:	2000a1b0 	.word	0x2000a1b0
 8022594:	20008000 	.word	0x20008000
 8022598:	2000a1b4 	.word	0x2000a1b4
 802259c:	20010000 	.word	0x20010000

080225a0 <MBMUX_RegisterFeatureCallback>:
{
 80225a0:	b570      	push	{r4, r5, r6, lr}
 80225a2:	000c      	movs	r4, r1
 80225a4:	0015      	movs	r5, r2
  check_existing_feature_registration = MBMUX_GetFeatureChIdx(e_featID, ComType);
 80225a6:	f7ff ff95 	bl	80224d4 <MBMUX_GetFeatureChIdx>
  if (check_existing_feature_registration != MB_CHANNEL_NOT_REGISTERED)
 80225aa:	28ff      	cmp	r0, #255	; 0xff
 80225ac:	d00b      	beq.n	80225c6 <MBMUX_RegisterFeatureCallback+0x26>
      if (ComType == MBMUX_CMD_RESP)
 80225ae:	2c00      	cmp	r4, #0
 80225b0:	d104      	bne.n	80225bc <MBMUX_RegisterFeatureCallback+0x1c>
        MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[channel_idx].MsgCm0plusCb = MsgCb;
 80225b2:	0083      	lsls	r3, r0, #2
 80225b4:	4a05      	ldr	r2, [pc, #20]	; (80225cc <MBMUX_RegisterFeatureCallback+0x2c>)
 80225b6:	509d      	str	r5, [r3, r2]
      ret = channel_idx;
 80225b8:	b240      	sxtb	r0, r0
}
 80225ba:	bd70      	pop	{r4, r5, r6, pc}
        MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[channel_idx].MsgCm0plusCb = MsgCb;
 80225bc:	1d83      	adds	r3, r0, #6
 80225be:	009b      	lsls	r3, r3, #2
 80225c0:	4a02      	ldr	r2, [pc, #8]	; (80225cc <MBMUX_RegisterFeatureCallback+0x2c>)
 80225c2:	509d      	str	r5, [r3, r2]
 80225c4:	e7f8      	b.n	80225b8 <MBMUX_RegisterFeatureCallback+0x18>
  int8_t ret = -1;
 80225c6:	2001      	movs	r0, #1
 80225c8:	4240      	negs	r0, r0
 80225ca:	e7f6      	b.n	80225ba <MBMUX_RegisterFeatureCallback+0x1a>
 80225cc:	2000a124 	.word	0x2000a124

080225d0 <MBMUX_GetFeatureComPtr>:
{
 80225d0:	b510      	push	{r4, lr}
 80225d2:	000c      	movs	r4, r1
  channel_idx = MBMUX_GetFeatureChIdx(e_featID, ComType);
 80225d4:	f7ff ff7e 	bl	80224d4 <MBMUX_GetFeatureChIdx>
  if (channel_idx < MBMUX_CHANNEL_NUMBER)
 80225d8:	2805      	cmp	r0, #5
 80225da:	d810      	bhi.n	80225fe <MBMUX_GetFeatureComPtr+0x2e>
    if (ComType == MBMUX_CMD_RESP)  /* TX */
 80225dc:	2c00      	cmp	r4, #0
 80225de:	d106      	bne.n	80225ee <MBMUX_GetFeatureComPtr+0x1e>
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBCmdRespParam[channel_idx];
 80225e0:	4b08      	ldr	r3, [pc, #32]	; (8022604 <MBMUX_GetFeatureComPtr+0x34>)
 80225e2:	681b      	ldr	r3, [r3, #0]
 80225e4:	0042      	lsls	r2, r0, #1
 80225e6:	1810      	adds	r0, r2, r0
 80225e8:	00c0      	lsls	r0, r0, #3
 80225ea:	1818      	adds	r0, r3, r0
}
 80225ec:	bd10      	pop	{r4, pc}
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBNotifAckParam[channel_idx];
 80225ee:	4b05      	ldr	r3, [pc, #20]	; (8022604 <MBMUX_GetFeatureComPtr+0x34>)
 80225f0:	681b      	ldr	r3, [r3, #0]
 80225f2:	0042      	lsls	r2, r0, #1
 80225f4:	1810      	adds	r0, r2, r0
 80225f6:	00c0      	lsls	r0, r0, #3
 80225f8:	3090      	adds	r0, #144	; 0x90
 80225fa:	1818      	adds	r0, r3, r0
 80225fc:	e7f6      	b.n	80225ec <MBMUX_GetFeatureComPtr+0x1c>
  MBMUX_ComParam_t *com_param_ptr = NULL;
 80225fe:	2000      	movs	r0, #0
  return com_param_ptr;
 8022600:	e7f4      	b.n	80225ec <MBMUX_GetFeatureComPtr+0x1c>
 8022602:	46c0      	nop			; (mov r8, r8)
 8022604:	2000a1ac 	.word	0x2000a1ac

08022608 <MBMUX_NotificationSnd>:
{
 8022608:	b510      	push	{r4, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_NOTIF_ACK);
 802260a:	2101      	movs	r1, #1
 802260c:	f7ff ff62 	bl	80224d4 <MBMUX_GetFeatureChIdx>
 8022610:	0004      	movs	r4, r0
  if (p_MBMUX_ComTable->MBNotifAckParam[mb_ch].ParamCnt > p_MBMUX_ComTable->MBNotifAckParam[mb_ch].BufSize)
 8022612:	4b0a      	ldr	r3, [pc, #40]	; (802263c <MBMUX_NotificationSnd+0x34>)
 8022614:	681b      	ldr	r3, [r3, #0]
 8022616:	0042      	lsls	r2, r0, #1
 8022618:	1812      	adds	r2, r2, r0
 802261a:	00d2      	lsls	r2, r2, #3
 802261c:	189b      	adds	r3, r3, r2
 802261e:	001a      	movs	r2, r3
 8022620:	329e      	adds	r2, #158	; 0x9e
 8022622:	8812      	ldrh	r2, [r2, #0]
 8022624:	339c      	adds	r3, #156	; 0x9c
 8022626:	881b      	ldrh	r3, [r3, #0]
 8022628:	429a      	cmp	r2, r3
 802262a:	d803      	bhi.n	8022634 <MBMUX_NotificationSnd+0x2c>
  return IPCC_IF_NotificationSnd(mb_ch);
 802262c:	0020      	movs	r0, r4
 802262e:	f7ff f827 	bl	8021680 <IPCC_IF_NotificationSnd>
}
 8022632:	bd10      	pop	{r4, pc}
    Error_Handler();
 8022634:	f7ff f84f 	bl	80216d6 <Error_Handler>
 8022638:	e7f8      	b.n	802262c <MBMUX_NotificationSnd+0x24>
 802263a:	46c0      	nop			; (mov r8, r8)
 802263c:	2000a1ac 	.word	0x2000a1ac

08022640 <MBMUX_ResponseSnd>:
{
 8022640:	b510      	push	{r4, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_CMD_RESP);
 8022642:	2100      	movs	r1, #0
 8022644:	f7ff ff46 	bl	80224d4 <MBMUX_GetFeatureChIdx>
  return IPCC_IF_ResponseSnd(mb_ch);
 8022648:	f7ff f82a 	bl	80216a0 <IPCC_IF_ResponseSnd>
}
 802264c:	bd10      	pop	{r4, pc}

0802264e <MBMUX_SEC_VerifySramBufferPtr>:
{
 802264e:	b510      	push	{r4, lr}
  pbuf_validated = MBMUX_SEC_VerifySramBuffer(pBufferAddress, bufferSize);
 8022650:	f7ff ff50 	bl	80224f4 <MBMUX_SEC_VerifySramBuffer>
}
 8022654:	bd10      	pop	{r4, pc}
	...

08022658 <MBMUX_Init>:
{
 8022658:	b510      	push	{r4, lr}
 802265a:	0004      	movs	r4, r0
  IPCC_IF_Init(MBMUX_IsrCommandRcvCb, MBMUX_IsrAcknowledgeRcvCb);
 802265c:	4911      	ldr	r1, [pc, #68]	; (80226a4 <MBMUX_Init+0x4c>)
 802265e:	4812      	ldr	r0, [pc, #72]	; (80226a8 <MBMUX_Init+0x50>)
 8022660:	f7fe ffce 	bl	8021600 <IPCC_IF_Init>
  MBMUX_RetrieveSecureSramConfig();
 8022664:	f7ff ff76 	bl	8022554 <MBMUX_RetrieveSecureSramConfig>
  p_MBMUX_ComTable = (MBMUX_ComTable_t *) MBMUX_SEC_VerifySramBufferPtr((uint32_t *) pMBMUX_ComTable, sizeof(MBMUX_ComTable_t));
 8022668:	219e      	movs	r1, #158	; 0x9e
 802266a:	0049      	lsls	r1, r1, #1
 802266c:	0020      	movs	r0, r4
 802266e:	f7ff ffee 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
 8022672:	4b0e      	ldr	r3, [pc, #56]	; (80226ac <MBMUX_Init+0x54>)
 8022674:	6018      	str	r0, [r3, #0]
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 8022676:	2200      	movs	r2, #0
 8022678:	2a05      	cmp	r2, #5
 802267a:	d811      	bhi.n	80226a0 <MBMUX_Init+0x48>
    MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[i].MsgCm0plusCb = MBMUX_IsrNotRegistered;
 802267c:	490c      	ldr	r1, [pc, #48]	; (80226b0 <MBMUX_Init+0x58>)
 802267e:	0093      	lsls	r3, r2, #2
 8022680:	4c0c      	ldr	r4, [pc, #48]	; (80226b4 <MBMUX_Init+0x5c>)
 8022682:	505c      	str	r4, [r3, r1]
    MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[i].MsgCm0plusCb = MBMUX_IsrNotRegistered;
 8022684:	1d93      	adds	r3, r2, #6
 8022686:	009b      	lsls	r3, r3, #2
 8022688:	505c      	str	r4, [r3, r1]
    p_MBMUX_ComTable->MBCmdRespParam[i].MsgCm0plusCb = MBMUX_IsrNotRegistered; /* not used anymore */
 802268a:	0053      	lsls	r3, r2, #1
 802268c:	1899      	adds	r1, r3, r2
 802268e:	00c9      	lsls	r1, r1, #3
 8022690:	1841      	adds	r1, r0, r1
 8022692:	608c      	str	r4, [r1, #8]
    p_MBMUX_ComTable->MBNotifAckParam[i].MsgCm0plusCb = MBMUX_IsrNotRegistered; /* not used anymore */
 8022694:	000b      	movs	r3, r1
 8022696:	3398      	adds	r3, #152	; 0x98
 8022698:	601c      	str	r4, [r3, #0]
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 802269a:	3201      	adds	r2, #1
 802269c:	b2d2      	uxtb	r2, r2
 802269e:	e7eb      	b.n	8022678 <MBMUX_Init+0x20>
}
 80226a0:	bd10      	pop	{r4, pc}
 80226a2:	46c0      	nop			; (mov r8, r8)
 80226a4:	080224ad 	.word	0x080224ad
 80226a8:	08022489 	.word	0x08022489
 80226ac:	2000a1ac 	.word	0x2000a1ac
 80226b0:	2000a124 	.word	0x2000a124
 80226b4:	080224ed 	.word	0x080224ed

080226b8 <MBMUXIF_TaskLoraCmdRcv>:

  /* USER CODE END MBMUXIF_IsrLoraCmdRcvCb_Last */
}

static void MBMUXIF_TaskLoraCmdRcv(void)
{
 80226b8:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskLoraCmdRcv_1 */

  /* USER CODE END MBMUXIF_TaskLoraCmdRcv_1 */
  Process_Lora_Cmd(LoraComObj);
 80226ba:	4b02      	ldr	r3, [pc, #8]	; (80226c4 <MBMUXIF_TaskLoraCmdRcv+0xc>)
 80226bc:	6818      	ldr	r0, [r3, #0]
 80226be:	f7ff fd07 	bl	80220d0 <Process_Lora_Cmd>
  /* USER CODE BEGIN MBMUXIF_TaskLoraCmdRcv_Last */

  /* USER CODE END MBMUXIF_TaskLoraCmdRcv_Last */
}
 80226c2:	bd10      	pop	{r4, pc}
 80226c4:	2000a1b8 	.word	0x2000a1b8

080226c8 <MBMUXIF_IsrLoraCmdRcvCb>:
{
 80226c8:	b510      	push	{r4, lr}
  LoraComObj = (MBMUX_ComParam_t *) ComObj;
 80226ca:	4b03      	ldr	r3, [pc, #12]	; (80226d8 <MBMUXIF_IsrLoraCmdRcvCb+0x10>)
 80226cc:	6018      	str	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbLoRaCmdRcv), CFG_SEQ_Prio_0);
 80226ce:	2100      	movs	r1, #0
 80226d0:	2004      	movs	r0, #4
 80226d2:	f011 fb1d 	bl	8033d10 <UTIL_SEQ_SetTask>
}
 80226d6:	bd10      	pop	{r4, pc}
 80226d8:	2000a1b8 	.word	0x2000a1b8

080226dc <MBMUXIF_IsrLoraAckRcvCb>:
{
 80226dc:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbLoraAckRcv);
 80226de:	2004      	movs	r0, #4
 80226e0:	f011 fb2a 	bl	8033d38 <UTIL_SEQ_SetEvt>
}
 80226e4:	bd10      	pop	{r4, pc}
	...

080226e8 <MBMUXIF_LoraInit>:
{
 80226e8:	b510      	push	{r4, lr}
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_LORAWAN_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrLoraAckRcvCb);
 80226ea:	4a0b      	ldr	r2, [pc, #44]	; (8022718 <MBMUXIF_LoraInit+0x30>)
 80226ec:	2101      	movs	r1, #1
 80226ee:	2008      	movs	r0, #8
 80226f0:	f7ff ff56 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 80226f4:	2800      	cmp	r0, #0
 80226f6:	da02      	bge.n	80226fe <MBMUXIF_LoraInit+0x16>
  if (ret >= 0)
 80226f8:	2800      	cmp	r0, #0
 80226fa:	da06      	bge.n	802270a <MBMUXIF_LoraInit+0x22>
}
 80226fc:	bd10      	pop	{r4, pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_LORAWAN_ID, MBMUX_CMD_RESP, MBMUXIF_IsrLoraCmdRcvCb);
 80226fe:	4a07      	ldr	r2, [pc, #28]	; (802271c <MBMUXIF_LoraInit+0x34>)
 8022700:	2100      	movs	r1, #0
 8022702:	2008      	movs	r0, #8
 8022704:	f7ff ff4c 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
 8022708:	e7f6      	b.n	80226f8 <MBMUXIF_LoraInit+0x10>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbLoRaCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskLoraCmdRcv);
 802270a:	4a05      	ldr	r2, [pc, #20]	; (8022720 <MBMUXIF_LoraInit+0x38>)
 802270c:	2100      	movs	r1, #0
 802270e:	2004      	movs	r0, #4
 8022710:	f011 fbe8 	bl	8033ee4 <UTIL_SEQ_RegTask>
    ret = 0;
 8022714:	2000      	movs	r0, #0
 8022716:	e7f1      	b.n	80226fc <MBMUXIF_LoraInit+0x14>
 8022718:	080226dd 	.word	0x080226dd
 802271c:	080226c9 	.word	0x080226c9
 8022720:	080226b9 	.word	0x080226b9

08022724 <MBMUXIF_GetLoraFeatureNotifComPtr>:
{
 8022724:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_LORAWAN_ID, MBMUX_NOTIF_ACK);
 8022726:	2101      	movs	r1, #1
 8022728:	2008      	movs	r0, #8
 802272a:	f7ff ff51 	bl	80225d0 <MBMUX_GetFeatureComPtr>
 802272e:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 8022730:	d001      	beq.n	8022736 <MBMUXIF_GetLoraFeatureNotifComPtr+0x12>
}
 8022732:	0020      	movs	r0, r4
 8022734:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 8022736:	f7fe ffce 	bl	80216d6 <Error_Handler>
  return com_param_ptr;
 802273a:	e7fa      	b.n	8022732 <MBMUXIF_GetLoraFeatureNotifComPtr+0xe>

0802273c <MBMUXIF_LoraSendNotif>:
{
 802273c:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(FEAT_INFO_LORAWAN_ID) == 0)
 802273e:	2008      	movs	r0, #8
 8022740:	f7ff ff62 	bl	8022608 <MBMUX_NotificationSnd>
 8022744:	2800      	cmp	r0, #0
 8022746:	d103      	bne.n	8022750 <MBMUXIF_LoraSendNotif+0x14>
    UTIL_SEQ_WaitEvt(1 << CFG_SEQ_Evt_MbLoraAckRcv);
 8022748:	3004      	adds	r0, #4
 802274a:	f011 fba7 	bl	8033e9c <UTIL_SEQ_WaitEvt>
}
 802274e:	bd10      	pop	{r4, pc}
    Error_Handler();
 8022750:	f7fe ffc1 	bl	80216d6 <Error_Handler>
}
 8022754:	e7fb      	b.n	802274e <MBMUXIF_LoraSendNotif+0x12>

08022756 <MBMUXIF_TaskRadioNotifSnd>:

  /* USER CODE END MBMUXIF_TaskRadioCmdRcv_Last */
}

static void MBMUXIF_TaskRadioNotifSnd(void)
{
 8022756:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifSnd_1 */

  /* USER CODE END MBMUXIF_TaskRadioNotifSnd_1 */
  if (MBMUX_NotificationSnd(FEAT_INFO_RADIO_ID) == 0)
 8022758:	2007      	movs	r0, #7
 802275a:	f7ff ff55 	bl	8022608 <MBMUX_NotificationSnd>
 802275e:	2800      	cmp	r0, #0
 8022760:	d103      	bne.n	802276a <MBMUXIF_TaskRadioNotifSnd+0x14>
  {
    UTIL_SEQ_WaitEvt(1 << CFG_SEQ_Evt_MbRadioAckRcv);
 8022762:	3008      	adds	r0, #8
 8022764:	f011 fb9a 	bl	8033e9c <UTIL_SEQ_WaitEvt>
    Error_Handler();
  }
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifSnd_Last */

  /* USER CODE END MBMUXIF_TaskRadioNotifSnd_Last */
}
 8022768:	bd10      	pop	{r4, pc}
    Error_Handler();
 802276a:	f7fe ffb4 	bl	80216d6 <Error_Handler>
}
 802276e:	e7fb      	b.n	8022768 <MBMUXIF_TaskRadioNotifSnd+0x12>

08022770 <MBMUXIF_TaskRadioCmdRcv>:
{
 8022770:	b510      	push	{r4, lr}
  Process_Radio_Cmd(RadioComObj);
 8022772:	4b02      	ldr	r3, [pc, #8]	; (802277c <MBMUXIF_TaskRadioCmdRcv+0xc>)
 8022774:	6818      	ldr	r0, [r3, #0]
 8022776:	f000 f9fb 	bl	8022b70 <Process_Radio_Cmd>
}
 802277a:	bd10      	pop	{r4, pc}
 802277c:	2000a1bc 	.word	0x2000a1bc

08022780 <MBMUXIF_IsrRadioCmdRcvCb>:
{
 8022780:	b510      	push	{r4, lr}
  RadioComObj = (MBMUX_ComParam_t *) ComObj;
 8022782:	4b03      	ldr	r3, [pc, #12]	; (8022790 <MBMUXIF_IsrRadioCmdRcvCb+0x10>)
 8022784:	6018      	str	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbRadioCmdRcv), CFG_SEQ_Prio_0);
 8022786:	2100      	movs	r1, #0
 8022788:	2008      	movs	r0, #8
 802278a:	f011 fac1 	bl	8033d10 <UTIL_SEQ_SetTask>
}
 802278e:	bd10      	pop	{r4, pc}
 8022790:	2000a1bc 	.word	0x2000a1bc

08022794 <MBMUXIF_IsrRadioAckRcvCb>:
{
 8022794:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbRadioAckRcv);
 8022796:	2008      	movs	r0, #8
 8022798:	f011 face 	bl	8033d38 <UTIL_SEQ_SetEvt>
}
 802279c:	bd10      	pop	{r4, pc}
	...

080227a0 <MBMUXIF_RadioInit>:
{
 80227a0:	b510      	push	{r4, lr}
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_RADIO_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrRadioAckRcvCb);
 80227a2:	4a0e      	ldr	r2, [pc, #56]	; (80227dc <MBMUXIF_RadioInit+0x3c>)
 80227a4:	2101      	movs	r1, #1
 80227a6:	2007      	movs	r0, #7
 80227a8:	f7ff fefa 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 80227ac:	2800      	cmp	r0, #0
 80227ae:	da02      	bge.n	80227b6 <MBMUXIF_RadioInit+0x16>
  if (ret >= 0)
 80227b0:	2800      	cmp	r0, #0
 80227b2:	da06      	bge.n	80227c2 <MBMUXIF_RadioInit+0x22>
}
 80227b4:	bd10      	pop	{r4, pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_RADIO_ID, MBMUX_CMD_RESP, MBMUXIF_IsrRadioCmdRcvCb);
 80227b6:	4a0a      	ldr	r2, [pc, #40]	; (80227e0 <MBMUXIF_RadioInit+0x40>)
 80227b8:	2100      	movs	r1, #0
 80227ba:	2007      	movs	r0, #7
 80227bc:	f7ff fef0 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
 80227c0:	e7f6      	b.n	80227b0 <MBMUXIF_RadioInit+0x10>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbRadioCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskRadioCmdRcv);
 80227c2:	4a08      	ldr	r2, [pc, #32]	; (80227e4 <MBMUXIF_RadioInit+0x44>)
 80227c4:	2100      	movs	r1, #0
 80227c6:	2008      	movs	r0, #8
 80227c8:	f011 fb8c 	bl	8033ee4 <UTIL_SEQ_RegTask>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbRadioNotifSnd), UTIL_SEQ_RFU, MBMUXIF_TaskRadioNotifSnd);
 80227cc:	4a06      	ldr	r2, [pc, #24]	; (80227e8 <MBMUXIF_RadioInit+0x48>)
 80227ce:	2100      	movs	r1, #0
 80227d0:	2010      	movs	r0, #16
 80227d2:	f011 fb87 	bl	8033ee4 <UTIL_SEQ_RegTask>
    ret = 0;
 80227d6:	2000      	movs	r0, #0
 80227d8:	e7ec      	b.n	80227b4 <MBMUXIF_RadioInit+0x14>
 80227da:	46c0      	nop			; (mov r8, r8)
 80227dc:	08022795 	.word	0x08022795
 80227e0:	08022781 	.word	0x08022781
 80227e4:	08022771 	.word	0x08022771
 80227e8:	08022757 	.word	0x08022757

080227ec <MBMUXIF_GetRadioFeatureNotifComPtr>:
{
 80227ec:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_RADIO_ID, MBMUX_NOTIF_ACK);
 80227ee:	2101      	movs	r1, #1
 80227f0:	2007      	movs	r0, #7
 80227f2:	f7ff feed 	bl	80225d0 <MBMUX_GetFeatureComPtr>
 80227f6:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 80227f8:	d001      	beq.n	80227fe <MBMUXIF_GetRadioFeatureNotifComPtr+0x12>
}
 80227fa:	0020      	movs	r0, r4
 80227fc:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 80227fe:	f7fe ff6a 	bl	80216d6 <Error_Handler>
  return com_param_ptr;
 8022802:	e7fa      	b.n	80227fa <MBMUXIF_GetRadioFeatureNotifComPtr+0xe>

08022804 <MBMUXIF_RadioSendNotif>:
{
 8022804:	b510      	push	{r4, lr}
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbRadioNotifSnd), CFG_SEQ_Prio_0);
 8022806:	2100      	movs	r1, #0
 8022808:	2010      	movs	r0, #16
 802280a:	f011 fa81 	bl	8033d10 <UTIL_SEQ_SetTask>
}
 802280e:	bd10      	pop	{r4, pc}

08022810 <MBMUXIF_IsrSystemPrioAAckRcvCb>:
static void MBMUXIF_IsrSystemPrioAAckRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioAAckRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioAAckRcvCb */
}
 8022810:	4770      	bx	lr

08022812 <MBMUXIF_IsrSystemPrioACmdRcvCb>:
static void MBMUXIF_IsrSystemPrioACmdRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioACmdRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioACmdRcvCb */
}
 8022812:	4770      	bx	lr

08022814 <MBMUXIF_IsrSystemPrioBAckRcvCb>:
static void MBMUXIF_IsrSystemPrioBAckRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBAckRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBAckRcvCb */
}
 8022814:	4770      	bx	lr

08022816 <MBMUXIF_IsrSystemPrioBCmdRcvCb>:
static void MBMUXIF_IsrSystemPrioBCmdRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBCmdRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBCmdRcvCb */
}
 8022816:	4770      	bx	lr

08022818 <MBMUXIF_FeatureCm0plusRegistrationCmd>:

static int8_t MBMUXIF_FeatureCm0plusRegistrationCmd(uint32_t *pBuf)
{
 8022818:	b510      	push	{r4, lr}

  /* USER CODE BEGIN MBMUXIF_FeatureCm0plusRegistrationCmd_1 */

  /* USER CODE END MBMUXIF_FeatureCm0plusRegistrationCmd_1 */

  switch (pBuf[0])
 802281a:	6803      	ldr	r3, [r0, #0]
 802281c:	2b09      	cmp	r3, #9
 802281e:	d842      	bhi.n	80228a6 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x8e>
 8022820:	009b      	lsls	r3, r3, #2
 8022822:	4a22      	ldr	r2, [pc, #136]	; (80228ac <MBMUXIF_FeatureCm0plusRegistrationCmd+0x94>)
 8022824:	58d3      	ldr	r3, [r2, r3]
 8022826:	469f      	mov	pc, r3
  {
    case FEAT_INFO_SYSTEM_CMD_PRIO_A_ID:
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_CMD_PRIO_A_ID, MBMUX_CMD_RESP, MBMUXIF_IsrSystemPrioACmdRcvCb);
 8022828:	4a21      	ldr	r2, [pc, #132]	; (80228b0 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x98>)
 802282a:	2100      	movs	r1, #0
 802282c:	2001      	movs	r0, #1
 802282e:	f7ff feb7 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
 8022832:	0004      	movs	r4, r0
  /* USER CODE BEGIN MBMUXIF_FeatureCm0plusRegistrationCmd_Last */

  /* USER CODE END MBMUXIF_FeatureCm0plusRegistrationCmd_Last */

  return ret;
}
 8022834:	0020      	movs	r0, r4
 8022836:	bd10      	pop	{r4, pc}
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrSystemPrioAAckRcvCb);
 8022838:	4a1e      	ldr	r2, [pc, #120]	; (80228b4 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x9c>)
 802283a:	2101      	movs	r1, #1
 802283c:	2002      	movs	r0, #2
 802283e:	f7ff feaf 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
 8022842:	0004      	movs	r4, r0
      break;
 8022844:	e7f6      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_CMD_PRIO_B_ID, MBMUX_CMD_RESP, MBMUXIF_IsrSystemPrioBCmdRcvCb);
 8022846:	4a1c      	ldr	r2, [pc, #112]	; (80228b8 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa0>)
 8022848:	2100      	movs	r1, #0
 802284a:	2003      	movs	r0, #3
 802284c:	f7ff fea8 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
 8022850:	0004      	movs	r4, r0
      break;
 8022852:	e7ef      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_NOTIF_PRIO_B_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrSystemPrioBAckRcvCb);
 8022854:	4a19      	ldr	r2, [pc, #100]	; (80228bc <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa4>)
 8022856:	2101      	movs	r1, #1
 8022858:	2004      	movs	r0, #4
 802285a:	f7ff fea1 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
 802285e:	0004      	movs	r4, r0
      break;
 8022860:	e7e8      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_TraceInit(VERBOSE_LEVEL);
 8022862:	2002      	movs	r0, #2
 8022864:	f000 f8e4 	bl	8022a30 <MBMUXIF_TraceInit>
 8022868:	0004      	movs	r4, r0
      break;
 802286a:	e7e3      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_RadioInit();
 802286c:	f7ff ff98 	bl	80227a0 <MBMUXIF_RadioInit>
 8022870:	0004      	movs	r4, r0
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Radio registration done\r\n");
 8022872:	4b13      	ldr	r3, [pc, #76]	; (80228c0 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa8>)
 8022874:	2200      	movs	r2, #0
 8022876:	2100      	movs	r1, #0
 8022878:	2001      	movs	r0, #1
 802287a:	f011 f91d 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
      break;
 802287e:	e7d9      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_LoraInit();
 8022880:	f7ff ff32 	bl	80226e8 <MBMUXIF_LoraInit>
 8022884:	0004      	movs	r4, r0
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Lora registration done\r\n");
 8022886:	4b0f      	ldr	r3, [pc, #60]	; (80228c4 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xac>)
 8022888:	2200      	movs	r2, #0
 802288a:	2100      	movs	r1, #0
 802288c:	2001      	movs	r0, #1
 802288e:	f011 f913 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
      break;
 8022892:	e7cf      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Sigfox not supported\r\n");
 8022894:	4b0c      	ldr	r3, [pc, #48]	; (80228c8 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xb0>)
 8022896:	2200      	movs	r2, #0
 8022898:	2100      	movs	r1, #0
 802289a:	2001      	movs	r0, #1
 802289c:	f011 f90c 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
  int8_t ret = -2; /* feature not supported */
 80228a0:	2402      	movs	r4, #2
 80228a2:	4264      	negs	r4, r4
      break;
 80228a4:	e7c6      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
  switch (pBuf[0])
 80228a6:	2402      	movs	r4, #2
 80228a8:	4264      	negs	r4, r4
 80228aa:	e7c3      	b.n	8022834 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
 80228ac:	08034b04 	.word	0x08034b04
 80228b0:	08022813 	.word	0x08022813
 80228b4:	08022811 	.word	0x08022811
 80228b8:	08022817 	.word	0x08022817
 80228bc:	08022815 	.word	0x08022815
 80228c0:	08034a98 	.word	0x08034a98
 80228c4:	08034abc 	.word	0x08034abc
 80228c8:	08034ae0 	.word	0x08034ae0

080228cc <MBMUXIF_TaskSystemCmdRcv>:
{
 80228cc:	b510      	push	{r4, lr}
  uint32_t *com_buffer = MBMUX_SEC_VerifySramBufferPtr(SystemComObj->ParamBuf, SystemComObj->BufSize);
 80228ce:	4c0c      	ldr	r4, [pc, #48]	; (8022900 <MBMUXIF_TaskSystemCmdRcv+0x34>)
 80228d0:	6823      	ldr	r3, [r4, #0]
 80228d2:	8999      	ldrh	r1, [r3, #12]
 80228d4:	6918      	ldr	r0, [r3, #16]
 80228d6:	f7ff feba 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
 80228da:	0003      	movs	r3, r0
  if (SystemComObj->MsgId == SYS_REGISTER_FEATURE_MSG_ID)
 80228dc:	6820      	ldr	r0, [r4, #0]
 80228de:	6802      	ldr	r2, [r0, #0]
 80228e0:	2a01      	cmp	r2, #1
 80228e2:	d002      	beq.n	80228ea <MBMUXIF_TaskSystemCmdRcv+0x1e>
    Process_Sys_Cmd(SystemComObj);
 80228e4:	f7ff f908 	bl	8021af8 <Process_Sys_Cmd>
}
 80228e8:	bd10      	pop	{r4, pc}
    SystemComObj->ReturnVal = (uint32_t) MBMUXIF_FeatureCm0plusRegistrationCmd(com_buffer);
 80228ea:	0018      	movs	r0, r3
 80228ec:	f7ff ff94 	bl	8022818 <MBMUXIF_FeatureCm0plusRegistrationCmd>
 80228f0:	4b03      	ldr	r3, [pc, #12]	; (8022900 <MBMUXIF_TaskSystemCmdRcv+0x34>)
 80228f2:	681b      	ldr	r3, [r3, #0]
 80228f4:	6158      	str	r0, [r3, #20]
    MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 80228f6:	2000      	movs	r0, #0
 80228f8:	f7ff fea2 	bl	8022640 <MBMUX_ResponseSnd>
 80228fc:	e7f4      	b.n	80228e8 <MBMUXIF_TaskSystemCmdRcv+0x1c>
 80228fe:	46c0      	nop			; (mov r8, r8)
 8022900:	2000a1c0 	.word	0x2000a1c0

08022904 <MBMUXIF_IsrSystemCmdRcvCb>:
{
 8022904:	b510      	push	{r4, lr}
  SystemComObj = (MBMUX_ComParam_t *) ComObj;
 8022906:	4b09      	ldr	r3, [pc, #36]	; (802292c <MBMUXIF_IsrSystemCmdRcvCb+0x28>)
 8022908:	6018      	str	r0, [r3, #0]
  switch (SystemComObj->MsgId)
 802290a:	6803      	ldr	r3, [r0, #0]
 802290c:	2b00      	cmp	r3, #0
 802290e:	d108      	bne.n	8022922 <MBMUXIF_IsrSystemCmdRcvCb+0x1e>
      SystemComObj->ReturnVal = (uint32_t) FEAT_INFO_GetListPtr();
 8022910:	f7ff fd7e 	bl	8022410 <FEAT_INFO_GetListPtr>
 8022914:	4b05      	ldr	r3, [pc, #20]	; (802292c <MBMUXIF_IsrSystemCmdRcvCb+0x28>)
 8022916:	681b      	ldr	r3, [r3, #0]
 8022918:	6158      	str	r0, [r3, #20]
      MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 802291a:	2000      	movs	r0, #0
 802291c:	f7ff fe90 	bl	8022640 <MBMUX_ResponseSnd>
}
 8022920:	bd10      	pop	{r4, pc}
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbSystemCmdRcv), CFG_SEQ_Prio_0);
 8022922:	2100      	movs	r1, #0
 8022924:	2001      	movs	r0, #1
 8022926:	f011 f9f3 	bl	8033d10 <UTIL_SEQ_SetTask>
}
 802292a:	e7f9      	b.n	8022920 <MBMUXIF_IsrSystemCmdRcvCb+0x1c>
 802292c:	2000a1c0 	.word	0x2000a1c0

08022930 <MBMUXIF_IsrSystemAckRcvCb>:
{
 8022930:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbSystemAckRcv);
 8022932:	2001      	movs	r0, #1
 8022934:	f011 fa00 	bl	8033d38 <UTIL_SEQ_SetEvt>
}
 8022938:	bd10      	pop	{r4, pc}
	...

0802293c <MBMUXIF_SystemInit>:
{
 802293c:	b500      	push	{lr}
 802293e:	b097      	sub	sp, #92	; 0x5c
  HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
 8022940:	4668      	mov	r0, sp
 8022942:	f001 fc63 	bl	802420c <HAL_FLASHEx_OBGetConfig>
  pMb_RefTable = (MBMUX_ComTable_t *) OptionsBytesStruct.IPCCdataBufAddr;
 8022946:	9815      	ldr	r0, [sp, #84]	; 0x54
 8022948:	4b17      	ldr	r3, [pc, #92]	; (80229a8 <MBMUXIF_SystemInit+0x6c>)
 802294a:	6018      	str	r0, [r3, #0]
  while (pMb_RefTable->SynchronizeCpusAtBoot == CPUS_BOOT_SYNC_PREVENT_CPU2_TO_START);
 802294c:	239b      	movs	r3, #155	; 0x9b
 802294e:	005b      	lsls	r3, r3, #1
 8022950:	5ac3      	ldrh	r3, [r0, r3]
 8022952:	b29b      	uxth	r3, r3
 8022954:	4a15      	ldr	r2, [pc, #84]	; (80229ac <MBMUXIF_SystemInit+0x70>)
 8022956:	4293      	cmp	r3, r2
 8022958:	d0f8      	beq.n	802294c <MBMUXIF_SystemInit+0x10>
  MBMUX_Init(pMb_RefTable);
 802295a:	f7ff fe7d 	bl	8022658 <MBMUX_Init>
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrSystemAckRcvCb);
 802295e:	4a14      	ldr	r2, [pc, #80]	; (80229b0 <MBMUXIF_SystemInit+0x74>)
 8022960:	2101      	movs	r1, #1
 8022962:	2000      	movs	r0, #0
 8022964:	f7ff fe1c 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8022968:	2800      	cmp	r0, #0
 802296a:	da03      	bge.n	8022974 <MBMUXIF_SystemInit+0x38>
  if (ret >= 0)
 802296c:	2800      	cmp	r0, #0
 802296e:	da07      	bge.n	8022980 <MBMUXIF_SystemInit+0x44>
}
 8022970:	b017      	add	sp, #92	; 0x5c
 8022972:	bd00      	pop	{pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_ID, MBMUX_CMD_RESP, MBMUXIF_IsrSystemCmdRcvCb);
 8022974:	4a0f      	ldr	r2, [pc, #60]	; (80229b4 <MBMUXIF_SystemInit+0x78>)
 8022976:	2100      	movs	r1, #0
 8022978:	2000      	movs	r0, #0
 802297a:	f7ff fe11 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
 802297e:	e7f5      	b.n	802296c <MBMUXIF_SystemInit+0x30>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbSystemCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskSystemCmdRcv);
 8022980:	4a0d      	ldr	r2, [pc, #52]	; (80229b8 <MBMUXIF_SystemInit+0x7c>)
 8022982:	2100      	movs	r1, #0
 8022984:	2001      	movs	r0, #1
 8022986:	f011 faad 	bl	8033ee4 <UTIL_SEQ_RegTask>
    while (pMb_RefTable->SynchronizeCpusAtBoot != CPUS_BOOT_SYNC_ALLOW_CPU2_TO_START);
 802298a:	4b07      	ldr	r3, [pc, #28]	; (80229a8 <MBMUXIF_SystemInit+0x6c>)
 802298c:	681a      	ldr	r2, [r3, #0]
 802298e:	239b      	movs	r3, #155	; 0x9b
 8022990:	005b      	lsls	r3, r3, #1
 8022992:	5ad3      	ldrh	r3, [r2, r3]
 8022994:	b29b      	uxth	r3, r3
 8022996:	4909      	ldr	r1, [pc, #36]	; (80229bc <MBMUXIF_SystemInit+0x80>)
 8022998:	428b      	cmp	r3, r1
 802299a:	d1f6      	bne.n	802298a <MBMUXIF_SystemInit+0x4e>
    pMb_RefTable->SynchronizeCpusAtBoot = CPUS_BOOT_SYNC_CPU2_INIT_COMPLETED;
 802299c:	239b      	movs	r3, #155	; 0x9b
 802299e:	005b      	lsls	r3, r3, #1
 80229a0:	4907      	ldr	r1, [pc, #28]	; (80229c0 <MBMUXIF_SystemInit+0x84>)
 80229a2:	52d1      	strh	r1, [r2, r3]
 80229a4:	2000      	movs	r0, #0
 80229a6:	e7e3      	b.n	8022970 <MBMUXIF_SystemInit+0x34>
 80229a8:	2000a1c4 	.word	0x2000a1c4
 80229ac:	0000ffff 	.word	0x0000ffff
 80229b0:	08022931 	.word	0x08022931
 80229b4:	08022905 	.word	0x08022905
 80229b8:	080228cd 	.word	0x080228cd
 80229bc:	00005555 	.word	0x00005555
 80229c0:	ffffaaaa 	.word	0xffffaaaa

080229c4 <MBMUXIF_GetCpusSynchroFlag>:
  return pMb_RefTable->SynchronizeCpusAtBoot;
 80229c4:	4b03      	ldr	r3, [pc, #12]	; (80229d4 <MBMUXIF_GetCpusSynchroFlag+0x10>)
 80229c6:	681a      	ldr	r2, [r3, #0]
 80229c8:	239b      	movs	r3, #155	; 0x9b
 80229ca:	005b      	lsls	r3, r3, #1
 80229cc:	5ad0      	ldrh	r0, [r2, r3]
 80229ce:	b280      	uxth	r0, r0
}
 80229d0:	4770      	bx	lr
 80229d2:	46c0      	nop			; (mov r8, r8)
 80229d4:	2000a1c4 	.word	0x2000a1c4

080229d8 <MBMUXIF_GetSystemFeatureNotifComPtr>:
{
 80229d8:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(SystemPrioFeat, MBMUX_NOTIF_ACK);
 80229da:	2101      	movs	r1, #1
 80229dc:	f7ff fdf8 	bl	80225d0 <MBMUX_GetFeatureComPtr>
 80229e0:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 80229e2:	d001      	beq.n	80229e8 <MBMUXIF_GetSystemFeatureNotifComPtr+0x10>
}
 80229e4:	0020      	movs	r0, r4
 80229e6:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 80229e8:	f7fe fe75 	bl	80216d6 <Error_Handler>
  return com_param_ptr;
 80229ec:	e7fa      	b.n	80229e4 <MBMUXIF_GetSystemFeatureNotifComPtr+0xc>

080229ee <MBMUXIF_SystemSendNotif_NoWait>:
{
 80229ee:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(SystemPrioFeat) != 0)
 80229f0:	f7ff fe0a 	bl	8022608 <MBMUX_NotificationSnd>
 80229f4:	2800      	cmp	r0, #0
 80229f6:	d100      	bne.n	80229fa <MBMUXIF_SystemSendNotif_NoWait+0xc>
}
 80229f8:	bd10      	pop	{r4, pc}
    Error_Handler();
 80229fa:	f7fe fe6c 	bl	80216d6 <Error_Handler>
}
 80229fe:	e7fb      	b.n	80229f8 <MBMUXIF_SystemSendNotif_NoWait+0xa>

08022a00 <MBMUXIF_TraceBufferInit>:
static UTIL_ADV_TRACE_Status_t MBMUXIF_TraceBufferInit(void (*cb)(void *))
{
  /* USER CODE BEGIN MBMUXIF_TraceBufferInit_1 */

  /* USER CODE END MBMUXIF_TraceBufferInit_1 */
  TraceUtilCpltCallback = cb;
 8022a00:	4b01      	ldr	r3, [pc, #4]	; (8022a08 <MBMUXIF_TraceBufferInit+0x8>)
 8022a02:	6018      	str	r0, [r3, #0]
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN MBMUXIF_TraceBufferInit_Last */

  /* USER CODE END MBMUXIF_TraceBufferInit_Last */
}
 8022a04:	2000      	movs	r0, #0
 8022a06:	4770      	bx	lr
 8022a08:	2000a1c8 	.word	0x2000a1c8

08022a0c <MBMUXIF_TaskTraceAckRcv>:

  /* USER CODE END MBMUXIF_IsrTraceAckRcvCb_Last */
}

static void MBMUXIF_TaskTraceAckRcv(void)
{
 8022a0c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskTraceAckRcv_1 */

  /* USER CODE END MBMUXIF_TaskTraceAckRcv_1 */
  TraceUtilCpltCallback(NULL);
 8022a0e:	4b02      	ldr	r3, [pc, #8]	; (8022a18 <MBMUXIF_TaskTraceAckRcv+0xc>)
 8022a10:	681b      	ldr	r3, [r3, #0]
 8022a12:	2000      	movs	r0, #0
 8022a14:	4798      	blx	r3
  /* USER CODE BEGIN MBMUXIF_TaskTraceAckRcv_Last */

  /* USER CODE END MBMUXIF_TaskTraceAckRcv_Last */
}
 8022a16:	bd10      	pop	{r4, pc}
 8022a18:	2000a1c8 	.word	0x2000a1c8

08022a1c <MBMUXIF_IsrTraceAckRcvCb>:
{
 8022a1c:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbTraceAckRcv); /* not necessary */
 8022a1e:	2002      	movs	r0, #2
 8022a20:	f011 f98a 	bl	8033d38 <UTIL_SEQ_SetEvt>
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbTraceAckRcv), CFG_SEQ_Prio_0);
 8022a24:	2100      	movs	r1, #0
 8022a26:	2002      	movs	r0, #2
 8022a28:	f011 f972 	bl	8033d10 <UTIL_SEQ_SetTask>
}
 8022a2c:	bd10      	pop	{r4, pc}
	...

08022a30 <MBMUXIF_TraceInit>:
{
 8022a30:	b510      	push	{r4, lr}
 8022a32:	0004      	movs	r4, r0
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_TRACE_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrTraceAckRcvCb);
 8022a34:	4a0b      	ldr	r2, [pc, #44]	; (8022a64 <MBMUXIF_TraceInit+0x34>)
 8022a36:	2101      	movs	r1, #1
 8022a38:	2006      	movs	r0, #6
 8022a3a:	f7ff fdb1 	bl	80225a0 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8022a3e:	2800      	cmp	r0, #0
 8022a40:	da00      	bge.n	8022a44 <MBMUXIF_TraceInit+0x14>
}
 8022a42:	bd10      	pop	{r4, pc}
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbTraceAckRcv), UTIL_SEQ_RFU, MBMUXIF_TaskTraceAckRcv);
 8022a44:	4a08      	ldr	r2, [pc, #32]	; (8022a68 <MBMUXIF_TraceInit+0x38>)
 8022a46:	2100      	movs	r1, #0
 8022a48:	2002      	movs	r0, #2
 8022a4a:	f011 fa4b 	bl	8033ee4 <UTIL_SEQ_RegTask>
    UTIL_ADV_TRACE_Init();
 8022a4e:	f010 ffbd 	bl	80339cc <UTIL_ADV_TRACE_Init>
    UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 8022a52:	4806      	ldr	r0, [pc, #24]	; (8022a6c <MBMUXIF_TraceInit+0x3c>)
 8022a54:	f010 ffd4 	bl	8033a00 <UTIL_ADV_TRACE_RegisterTimeStampFunction>
    UTIL_ADV_TRACE_SetVerboseLevel(verboseLevel);
 8022a58:	0020      	movs	r0, r4
 8022a5a:	f010 ffd7 	bl	8033a0c <UTIL_ADV_TRACE_SetVerboseLevel>
    ret = 0;
 8022a5e:	2000      	movs	r0, #0
 8022a60:	e7ef      	b.n	8022a42 <MBMUXIF_TraceInit+0x12>
 8022a62:	46c0      	nop			; (mov r8, r8)
 8022a64:	08022a1d 	.word	0x08022a1d
 8022a68:	08022a0d 	.word	0x08022a0d
 8022a6c:	08021ac5 	.word	0x08021ac5

08022a70 <MBMUXIF_GetTraceFeatureNotifComPtr>:
{
 8022a70:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_TRACE_ID, MBMUX_NOTIF_ACK);
 8022a72:	2101      	movs	r1, #1
 8022a74:	2006      	movs	r0, #6
 8022a76:	f7ff fdab 	bl	80225d0 <MBMUX_GetFeatureComPtr>
 8022a7a:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 8022a7c:	d001      	beq.n	8022a82 <MBMUXIF_GetTraceFeatureNotifComPtr+0x12>
}
 8022a7e:	0020      	movs	r0, r4
 8022a80:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 8022a82:	f7fe fe28 	bl	80216d6 <Error_Handler>
  return com_param_ptr;
 8022a86:	e7fa      	b.n	8022a7e <MBMUXIF_GetTraceFeatureNotifComPtr+0xe>

08022a88 <MBMUXIF_TraceSendNotif_NoWait>:
{
 8022a88:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(FEAT_INFO_TRACE_ID) != 0)
 8022a8a:	2006      	movs	r0, #6
 8022a8c:	f7ff fdbc 	bl	8022608 <MBMUX_NotificationSnd>
 8022a90:	2800      	cmp	r0, #0
 8022a92:	d100      	bne.n	8022a96 <MBMUXIF_TraceSendNotif_NoWait+0xe>
}
 8022a94:	bd10      	pop	{r4, pc}
    Error_Handler();
 8022a96:	f7fe fe1e 	bl	80216d6 <Error_Handler>
}
 8022a9a:	e7fb      	b.n	8022a94 <MBMUXIF_TraceSendNotif_NoWait+0xc>

08022a9c <MBMUXIF_TraceBufferSend>:
{
 8022a9c:	b570      	push	{r4, r5, r6, lr}
 8022a9e:	0006      	movs	r6, r0
 8022aa0:	000d      	movs	r5, r1
  com_obj = MBMUXIF_GetTraceFeatureNotifComPtr();
 8022aa2:	f7ff ffe5 	bl	8022a70 <MBMUXIF_GetTraceFeatureNotifComPtr>
 8022aa6:	1e04      	subs	r4, r0, #0
  if (com_obj != NULL)
 8022aa8:	d00b      	beq.n	8022ac2 <MBMUXIF_TraceBufferSend+0x26>
    pbuf_validated = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8022aaa:	8981      	ldrh	r1, [r0, #12]
 8022aac:	6900      	ldr	r0, [r0, #16]
 8022aae:	f7ff fdce 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
    com_obj->MsgId = TRACE_SEND_MSG_ID;
 8022ab2:	2300      	movs	r3, #0
 8022ab4:	6023      	str	r3, [r4, #0]
    pbuf_validated[0] = (uint32_t) buf;
 8022ab6:	6006      	str	r6, [r0, #0]
    pbuf_validated[1] = (uint32_t) bufSize;
 8022ab8:	6045      	str	r5, [r0, #4]
    com_obj->ParamCnt = 2;
 8022aba:	3302      	adds	r3, #2
 8022abc:	81e3      	strh	r3, [r4, #14]
    MBMUXIF_TraceSendNotif_NoWait();
 8022abe:	f7ff ffe3 	bl	8022a88 <MBMUXIF_TraceSendNotif_NoWait>
}
 8022ac2:	2000      	movs	r0, #0
 8022ac4:	bd70      	pop	{r4, r5, r6, pc}

08022ac6 <RadioRxError_mbwrapper>:

  /* USER CODE END RadioRxTimeout_mbwrapper_2 */
}

static void RadioRxError_mbwrapper(void)
{
 8022ac6:	b510      	push	{r4, lr}
  /* USER CODE BEGIN RadioRxError_mbwrapper_1 */

  /* USER CODE END RadioRxError_mbwrapper_1 */
  MBMUX_ComParam_t *com_obj;

  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022ac8:	f7ff fe90 	bl	80227ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_RX_ERROR_CB_ID;
 8022acc:	2323      	movs	r3, #35	; 0x23
 8022ace:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022ad0:	2300      	movs	r3, #0
 8022ad2:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022ad4:	f7ff fe96 	bl	8022804 <MBMUXIF_RadioSendNotif>
  /* once event is received and semaphore released: */
  return;
  /* USER CODE BEGIN RadioRxError_mbwrapper_2 */

  /* USER CODE END RadioRxError_mbwrapper_2 */
}
 8022ad8:	bd10      	pop	{r4, pc}

08022ada <RadioRxTimeout_mbwrapper>:
{
 8022ada:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022adc:	f7ff fe86 	bl	80227ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_RX_TIMEOUT_CB_ID;
 8022ae0:	2322      	movs	r3, #34	; 0x22
 8022ae2:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022ae4:	2300      	movs	r3, #0
 8022ae6:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022ae8:	f7ff fe8c 	bl	8022804 <MBMUXIF_RadioSendNotif>
}
 8022aec:	bd10      	pop	{r4, pc}

08022aee <RadioTxTimeout_mbwrapper>:
{
 8022aee:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022af0:	f7ff fe7c 	bl	80227ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_TX_TIMEOUT_CB_ID;
 8022af4:	2320      	movs	r3, #32
 8022af6:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022af8:	2300      	movs	r3, #0
 8022afa:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022afc:	f7ff fe82 	bl	8022804 <MBMUXIF_RadioSendNotif>
}
 8022b00:	bd10      	pop	{r4, pc}

08022b02 <RadioTxDone_mbwrapper>:
{
 8022b02:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022b04:	f7ff fe72 	bl	80227ec <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_TX_DONE_CB_ID;
 8022b08:	231f      	movs	r3, #31
 8022b0a:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022b0c:	2300      	movs	r3, #0
 8022b0e:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022b10:	f7ff fe78 	bl	8022804 <MBMUXIF_RadioSendNotif>
}
 8022b14:	bd10      	pop	{r4, pc}
	...

08022b18 <RadioRxDone_mbwrapper>:
{
 8022b18:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022b1a:	46c6      	mov	lr, r8
 8022b1c:	b500      	push	{lr}
 8022b1e:	0005      	movs	r5, r0
 8022b20:	000e      	movs	r6, r1
 8022b22:	4690      	mov	r8, r2
 8022b24:	001f      	movs	r7, r3
  if (payload != NULL)
 8022b26:	2800      	cmp	r0, #0
 8022b28:	d004      	beq.n	8022b34 <RadioRxDone_mbwrapper+0x1c>
    UTIL_MEM_cpy_8(aRadioMbWrapRxBuffer, payload, size);
 8022b2a:	000a      	movs	r2, r1
 8022b2c:	0001      	movs	r1, r0
 8022b2e:	480f      	ldr	r0, [pc, #60]	; (8022b6c <RadioRxDone_mbwrapper+0x54>)
 8022b30:	f011 f8da 	bl	8033ce8 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022b34:	f7ff fe5a 	bl	80227ec <MBMUXIF_GetRadioFeatureNotifComPtr>
 8022b38:	0004      	movs	r4, r0
  com_obj->MsgId = RADIO_RX_DONE_CB_ID;
 8022b3a:	2321      	movs	r3, #33	; 0x21
 8022b3c:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8022b3e:	8981      	ldrh	r1, [r0, #12]
 8022b40:	6900      	ldr	r0, [r0, #16]
 8022b42:	f7ff fd84 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  if (payload == NULL)
 8022b46:	2d00      	cmp	r5, #0
 8022b48:	d00c      	beq.n	8022b64 <RadioRxDone_mbwrapper+0x4c>
    com_buffer[i++] = (uint32_t) aRadioMbWrapRxBuffer;
 8022b4a:	4b08      	ldr	r3, [pc, #32]	; (8022b6c <RadioRxDone_mbwrapper+0x54>)
 8022b4c:	6003      	str	r3, [r0, #0]
  com_buffer[i++] = (uint32_t) size;
 8022b4e:	6046      	str	r6, [r0, #4]
  com_buffer[i++] = (uint32_t) rssi;
 8022b50:	4643      	mov	r3, r8
 8022b52:	6083      	str	r3, [r0, #8]
  com_buffer[i++] = (uint32_t) snr;
 8022b54:	60c7      	str	r7, [r0, #12]
  com_obj->ParamCnt = i;
 8022b56:	2304      	movs	r3, #4
 8022b58:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_RadioSendNotif();
 8022b5a:	f7ff fe53 	bl	8022804 <MBMUXIF_RadioSendNotif>
}
 8022b5e:	bc80      	pop	{r7}
 8022b60:	46b8      	mov	r8, r7
 8022b62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    com_buffer[i++] = (uint32_t)NULL;
 8022b64:	2300      	movs	r3, #0
 8022b66:	6003      	str	r3, [r0, #0]
 8022b68:	e7f1      	b.n	8022b4e <RadioRxDone_mbwrapper+0x36>
 8022b6a:	46c0      	nop			; (mov r8, r8)
 8022b6c:	20009180 	.word	0x20009180

08022b70 <Process_Radio_Cmd>:
{
 8022b70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022b72:	46de      	mov	lr, fp
 8022b74:	4657      	mov	r7, sl
 8022b76:	464e      	mov	r6, r9
 8022b78:	4645      	mov	r5, r8
 8022b7a:	b5e0      	push	{r5, r6, r7, lr}
 8022b7c:	b08f      	sub	sp, #60	; 0x3c
 8022b7e:	0004      	movs	r4, r0
  APP_LOG(TS_ON, VLEVEL_H, ">CM0PLUS(Radio)\r\n");
 8022b80:	4bdc      	ldr	r3, [pc, #880]	; (8022ef4 <Process_Radio_Cmd+0x384>)
 8022b82:	2201      	movs	r2, #1
 8022b84:	2100      	movs	r1, #0
 8022b86:	2003      	movs	r0, #3
 8022b88:	f010 ff96 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(ComObj->ParamBuf, ComObj->BufSize);
 8022b8c:	89a1      	ldrh	r1, [r4, #12]
 8022b8e:	6920      	ldr	r0, [r4, #16]
 8022b90:	f7ff fd5d 	bl	802264e <MBMUX_SEC_VerifySramBufferPtr>
  switch (ComObj->MsgId)
 8022b94:	6823      	ldr	r3, [r4, #0]
 8022b96:	2b1e      	cmp	r3, #30
 8022b98:	d814      	bhi.n	8022bc4 <Process_Radio_Cmd+0x54>
 8022b9a:	009b      	lsls	r3, r3, #2
 8022b9c:	4ad6      	ldr	r2, [pc, #856]	; (8022ef8 <Process_Radio_Cmd+0x388>)
 8022b9e:	58d3      	ldr	r3, [r2, r3]
 8022ba0:	469f      	mov	pc, r3
      radioevents_mbwrapper.TxDone = &RadioTxDone_mbwrapper;
 8022ba2:	48d6      	ldr	r0, [pc, #856]	; (8022efc <Process_Radio_Cmd+0x38c>)
 8022ba4:	4bd6      	ldr	r3, [pc, #856]	; (8022f00 <Process_Radio_Cmd+0x390>)
 8022ba6:	6003      	str	r3, [r0, #0]
      radioevents_mbwrapper.TxTimeout = &RadioTxTimeout_mbwrapper;
 8022ba8:	4bd6      	ldr	r3, [pc, #856]	; (8022f04 <Process_Radio_Cmd+0x394>)
 8022baa:	6043      	str	r3, [r0, #4]
      radioevents_mbwrapper.RxDone = &RadioRxDone_mbwrapper;
 8022bac:	4bd6      	ldr	r3, [pc, #856]	; (8022f08 <Process_Radio_Cmd+0x398>)
 8022bae:	6083      	str	r3, [r0, #8]
      radioevents_mbwrapper.RxTimeout = &RadioRxTimeout_mbwrapper;
 8022bb0:	4bd6      	ldr	r3, [pc, #856]	; (8022f0c <Process_Radio_Cmd+0x39c>)
 8022bb2:	60c3      	str	r3, [r0, #12]
      radioevents_mbwrapper.RxError = &RadioRxError_mbwrapper;
 8022bb4:	4bd6      	ldr	r3, [pc, #856]	; (8022f10 <Process_Radio_Cmd+0x3a0>)
 8022bb6:	6103      	str	r3, [r0, #16]
      Radio.Init(&radioevents_mbwrapper);
 8022bb8:	4bd6      	ldr	r3, [pc, #856]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022bba:	681b      	ldr	r3, [r3, #0]
 8022bbc:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022bbe:	2300      	movs	r3, #0
 8022bc0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022bc2:	6163      	str	r3, [r4, #20]
  APP_LOG(TS_ON, VLEVEL_H, "<CM0PLUS(Radio)\r\n");
 8022bc4:	4bd4      	ldr	r3, [pc, #848]	; (8022f18 <Process_Radio_Cmd+0x3a8>)
 8022bc6:	2201      	movs	r2, #1
 8022bc8:	2100      	movs	r1, #0
 8022bca:	2003      	movs	r0, #3
 8022bcc:	f010 ff74 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_RADIO_ID);
 8022bd0:	2007      	movs	r0, #7
 8022bd2:	f7ff fd35 	bl	8022640 <MBMUX_ResponseSnd>
}
 8022bd6:	b00f      	add	sp, #60	; 0x3c
 8022bd8:	bcf0      	pop	{r4, r5, r6, r7}
 8022bda:	46bb      	mov	fp, r7
 8022bdc:	46b2      	mov	sl, r6
 8022bde:	46a9      	mov	r9, r5
 8022be0:	46a0      	mov	r8, r4
 8022be2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      status = Radio.GetStatus();
 8022be4:	4bcb      	ldr	r3, [pc, #812]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022be6:	685b      	ldr	r3, [r3, #4]
 8022be8:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022bea:	2300      	movs	r3, #0
 8022bec:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) status; /* */
 8022bee:	6160      	str	r0, [r4, #20]
      break;
 8022bf0:	e7e8      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetModem((RadioModems_t) com_buffer[0]);
 8022bf2:	4bc8      	ldr	r3, [pc, #800]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022bf4:	689b      	ldr	r3, [r3, #8]
 8022bf6:	7800      	ldrb	r0, [r0, #0]
 8022bf8:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022bfa:	2300      	movs	r3, #0
 8022bfc:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022bfe:	6163      	str	r3, [r4, #20]
      break;
 8022c00:	e7e0      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetChannel((uint32_t) com_buffer[0]);
 8022c02:	4bc4      	ldr	r3, [pc, #784]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022c04:	68db      	ldr	r3, [r3, #12]
 8022c06:	6800      	ldr	r0, [r0, #0]
 8022c08:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022c0a:	2300      	movs	r3, #0
 8022c0c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022c0e:	6163      	str	r3, [r4, #20]
      break;
 8022c10:	e7d8      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.IsChannelFree(com_buffer[0], com_buffer[1], (int16_t) com_buffer[2], com_buffer[3]);
 8022c12:	4bc0      	ldr	r3, [pc, #768]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022c14:	691d      	ldr	r5, [r3, #16]
 8022c16:	68c3      	ldr	r3, [r0, #12]
 8022c18:	2108      	movs	r1, #8
 8022c1a:	5e42      	ldrsh	r2, [r0, r1]
 8022c1c:	6841      	ldr	r1, [r0, #4]
 8022c1e:	6800      	ldr	r0, [r0, #0]
 8022c20:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022c22:	2300      	movs	r3, #0
 8022c24:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022c26:	6160      	str	r0, [r4, #20]
      break;
 8022c28:	e7cc      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.Random();
 8022c2a:	4bba      	ldr	r3, [pc, #744]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022c2c:	695b      	ldr	r3, [r3, #20]
 8022c2e:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022c30:	2300      	movs	r3, #0
 8022c32:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022c34:	6160      	str	r0, [r4, #20]
      break;
 8022c36:	e7c5      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetRxConfig((RadioModems_t) com_buffer[0],  com_buffer[1],
 8022c38:	4bb6      	ldr	r3, [pc, #728]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022c3a:	699b      	ldr	r3, [r3, #24]
 8022c3c:	4698      	mov	r8, r3
                        com_buffer[4], (uint16_t) com_buffer[5],
 8022c3e:	6943      	ldr	r3, [r0, #20]
 8022c40:	930a      	str	r3, [sp, #40]	; 0x28
                        (uint16_t) com_buffer[6], (bool) com_buffer[7],
 8022c42:	6982      	ldr	r2, [r0, #24]
 8022c44:	920b      	str	r2, [sp, #44]	; 0x2c
 8022c46:	69c3      	ldr	r3, [r0, #28]
 8022c48:	469b      	mov	fp, r3
                        (uint8_t) com_buffer[8],
 8022c4a:	6a01      	ldr	r1, [r0, #32]
 8022c4c:	910c      	str	r1, [sp, #48]	; 0x30
                        (bool) com_buffer[9], (bool) com_buffer[10], (uint8_t) com_buffer[11],
 8022c4e:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8022c50:	6a87      	ldr	r7, [r0, #40]	; 0x28
 8022c52:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8022c54:	930d      	str	r3, [sp, #52]	; 0x34
                        (bool) com_buffer[12], (bool) com_buffer[13]);
 8022c56:	6b03      	ldr	r3, [r0, #48]	; 0x30
      Radio.SetRxConfig((RadioModems_t) com_buffer[0],  com_buffer[1],
 8022c58:	7b02      	ldrb	r2, [r0, #12]
 8022c5a:	4692      	mov	sl, r2
 8022c5c:	6882      	ldr	r2, [r0, #8]
 8022c5e:	4691      	mov	r9, r2
 8022c60:	6841      	ldr	r1, [r0, #4]
 8022c62:	7802      	ldrb	r2, [r0, #0]
 8022c64:	4694      	mov	ip, r2
 8022c66:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8022c68:	1e55      	subs	r5, r2, #1
 8022c6a:	41aa      	sbcs	r2, r5
 8022c6c:	9209      	str	r2, [sp, #36]	; 0x24
 8022c6e:	1e5a      	subs	r2, r3, #1
 8022c70:	4193      	sbcs	r3, r2
 8022c72:	9308      	str	r3, [sp, #32]
 8022c74:	466b      	mov	r3, sp
 8022c76:	2234      	movs	r2, #52	; 0x34
 8022c78:	189b      	adds	r3, r3, r2
 8022c7a:	781b      	ldrb	r3, [r3, #0]
 8022c7c:	9307      	str	r3, [sp, #28]
 8022c7e:	1e7b      	subs	r3, r7, #1
 8022c80:	419f      	sbcs	r7, r3
 8022c82:	9706      	str	r7, [sp, #24]
 8022c84:	1e73      	subs	r3, r6, #1
 8022c86:	419e      	sbcs	r6, r3
 8022c88:	9605      	str	r6, [sp, #20]
 8022c8a:	466b      	mov	r3, sp
 8022c8c:	3a04      	subs	r2, #4
 8022c8e:	189b      	adds	r3, r3, r2
 8022c90:	781b      	ldrb	r3, [r3, #0]
 8022c92:	9304      	str	r3, [sp, #16]
 8022c94:	465d      	mov	r5, fp
 8022c96:	1e6b      	subs	r3, r5, #1
 8022c98:	419d      	sbcs	r5, r3
 8022c9a:	9503      	str	r5, [sp, #12]
 8022c9c:	466b      	mov	r3, sp
 8022c9e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8022ca0:	9302      	str	r3, [sp, #8]
 8022ca2:	466b      	mov	r3, sp
 8022ca4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8022ca6:	9301      	str	r3, [sp, #4]
 8022ca8:	6903      	ldr	r3, [r0, #16]
 8022caa:	9300      	str	r3, [sp, #0]
 8022cac:	4653      	mov	r3, sl
 8022cae:	464a      	mov	r2, r9
 8022cb0:	4660      	mov	r0, ip
 8022cb2:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022cb4:	2300      	movs	r3, #0
 8022cb6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022cb8:	6163      	str	r3, [r4, #20]
      break;
 8022cba:	e783      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetTxConfig((RadioModems_t) com_buffer[0], (int8_t) com_buffer[1],
 8022cbc:	4b95      	ldr	r3, [pc, #596]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022cbe:	69db      	ldr	r3, [r3, #28]
 8022cc0:	4698      	mov	r8, r3
                        (uint8_t) com_buffer[5], (uint16_t) com_buffer[6],
 8022cc2:	6943      	ldr	r3, [r0, #20]
 8022cc4:	930a      	str	r3, [sp, #40]	; 0x28
 8022cc6:	6982      	ldr	r2, [r0, #24]
 8022cc8:	920b      	str	r2, [sp, #44]	; 0x2c
                        (bool) com_buffer[7], (bool) com_buffer[8], (bool) com_buffer[9],
 8022cca:	69c5      	ldr	r5, [r0, #28]
 8022ccc:	6a06      	ldr	r6, [r0, #32]
 8022cce:	6a47      	ldr	r7, [r0, #36]	; 0x24
                        (uint8_t) com_buffer[10], (bool) com_buffer[11],  com_buffer[12]);
 8022cd0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8022cd2:	469c      	mov	ip, r3
 8022cd4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8022cd6:	468b      	mov	fp, r1
      Radio.SetTxConfig((RadioModems_t) com_buffer[0], (int8_t) com_buffer[1],
 8022cd8:	68c1      	ldr	r1, [r0, #12]
 8022cda:	468a      	mov	sl, r1
 8022cdc:	6882      	ldr	r2, [r0, #8]
 8022cde:	2304      	movs	r3, #4
 8022ce0:	56c3      	ldrsb	r3, [r0, r3]
 8022ce2:	930c      	str	r3, [sp, #48]	; 0x30
 8022ce4:	7803      	ldrb	r3, [r0, #0]
 8022ce6:	4699      	mov	r9, r3
 8022ce8:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8022cea:	9308      	str	r3, [sp, #32]
 8022cec:	465b      	mov	r3, fp
 8022cee:	1e59      	subs	r1, r3, #1
 8022cf0:	418b      	sbcs	r3, r1
 8022cf2:	9307      	str	r3, [sp, #28]
 8022cf4:	4663      	mov	r3, ip
 8022cf6:	b2db      	uxtb	r3, r3
 8022cf8:	9306      	str	r3, [sp, #24]
 8022cfa:	1e7b      	subs	r3, r7, #1
 8022cfc:	419f      	sbcs	r7, r3
 8022cfe:	9705      	str	r7, [sp, #20]
 8022d00:	1e73      	subs	r3, r6, #1
 8022d02:	419e      	sbcs	r6, r3
 8022d04:	9604      	str	r6, [sp, #16]
 8022d06:	1e6b      	subs	r3, r5, #1
 8022d08:	419d      	sbcs	r5, r3
 8022d0a:	9503      	str	r5, [sp, #12]
 8022d0c:	466b      	mov	r3, sp
 8022d0e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8022d10:	9302      	str	r3, [sp, #8]
 8022d12:	466b      	mov	r3, sp
 8022d14:	2128      	movs	r1, #40	; 0x28
 8022d16:	185b      	adds	r3, r3, r1
 8022d18:	781b      	ldrb	r3, [r3, #0]
 8022d1a:	9301      	str	r3, [sp, #4]
 8022d1c:	6903      	ldr	r3, [r0, #16]
 8022d1e:	9300      	str	r3, [sp, #0]
 8022d20:	4653      	mov	r3, sl
 8022d22:	990c      	ldr	r1, [sp, #48]	; 0x30
 8022d24:	4648      	mov	r0, r9
 8022d26:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d28:	2300      	movs	r3, #0
 8022d2a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022d2c:	6163      	str	r3, [r4, #20]
      break;
 8022d2e:	e749      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.CheckRfFrequency(com_buffer[0]);
 8022d30:	4b78      	ldr	r3, [pc, #480]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022d32:	6a1b      	ldr	r3, [r3, #32]
 8022d34:	6800      	ldr	r0, [r0, #0]
 8022d36:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d38:	2300      	movs	r3, #0
 8022d3a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022d3c:	6160      	str	r0, [r4, #20]
      break;
 8022d3e:	e741      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.TimeOnAir((RadioModems_t) com_buffer[0], (uint32_t) com_buffer[1],
 8022d40:	4b74      	ldr	r3, [pc, #464]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022d42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022d44:	4698      	mov	r8, r3
                                 (uint16_t) com_buffer[4], (bool) com_buffer[5],
 8022d46:	6905      	ldr	r5, [r0, #16]
 8022d48:	6946      	ldr	r6, [r0, #20]
                                 (uint8_t) com_buffer[6], (bool) com_buffer[7]);
 8022d4a:	6987      	ldr	r7, [r0, #24]
 8022d4c:	69c3      	ldr	r3, [r0, #28]
 8022d4e:	469c      	mov	ip, r3
      ret_uint = Radio.TimeOnAir((RadioModems_t) com_buffer[0], (uint32_t) com_buffer[1],
 8022d50:	7b03      	ldrb	r3, [r0, #12]
 8022d52:	4699      	mov	r9, r3
 8022d54:	6883      	ldr	r3, [r0, #8]
 8022d56:	469a      	mov	sl, r3
 8022d58:	6841      	ldr	r1, [r0, #4]
 8022d5a:	7800      	ldrb	r0, [r0, #0]
 8022d5c:	4663      	mov	r3, ip
 8022d5e:	1e5a      	subs	r2, r3, #1
 8022d60:	4193      	sbcs	r3, r2
 8022d62:	9303      	str	r3, [sp, #12]
 8022d64:	b2ff      	uxtb	r7, r7
 8022d66:	9702      	str	r7, [sp, #8]
 8022d68:	1e77      	subs	r7, r6, #1
 8022d6a:	41be      	sbcs	r6, r7
 8022d6c:	9601      	str	r6, [sp, #4]
 8022d6e:	b2ad      	uxth	r5, r5
 8022d70:	9500      	str	r5, [sp, #0]
 8022d72:	464b      	mov	r3, r9
 8022d74:	4652      	mov	r2, sl
 8022d76:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d78:	2300      	movs	r3, #0
 8022d7a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022d7c:	6160      	str	r0, [r4, #20]
      break;
 8022d7e:	e721      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.Send((uint8_t *) com_buffer[0], (uint8_t) com_buffer[1]);
 8022d80:	4b64      	ldr	r3, [pc, #400]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022d82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8022d84:	6802      	ldr	r2, [r0, #0]
 8022d86:	7901      	ldrb	r1, [r0, #4]
 8022d88:	0010      	movs	r0, r2
 8022d8a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d8c:	2300      	movs	r3, #0
 8022d8e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022d90:	6163      	str	r3, [r4, #20]
      break;
 8022d92:	e717      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.Sleep();
 8022d94:	4b5f      	ldr	r3, [pc, #380]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022d96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8022d98:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d9a:	2300      	movs	r3, #0
 8022d9c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022d9e:	6163      	str	r3, [r4, #20]
      break;
 8022da0:	e710      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.Standby();
 8022da2:	4b5c      	ldr	r3, [pc, #368]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022da4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8022da6:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022da8:	2300      	movs	r3, #0
 8022daa:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022dac:	6163      	str	r3, [r4, #20]
      break;
 8022dae:	e709      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.Rx(com_buffer[0]);
 8022db0:	4b58      	ldr	r3, [pc, #352]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022db2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8022db4:	6800      	ldr	r0, [r0, #0]
 8022db6:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022db8:	2300      	movs	r3, #0
 8022dba:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022dbc:	6163      	str	r3, [r4, #20]
      break;
 8022dbe:	e701      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.StartCad();
 8022dc0:	4b54      	ldr	r3, [pc, #336]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022dc2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8022dc4:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022dc6:	2300      	movs	r3, #0
 8022dc8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022dca:	6163      	str	r3, [r4, #20]
      break;
 8022dcc:	e6fa      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetTxContinuousWave(com_buffer[0], (int8_t) com_buffer[1], (uint16_t) com_buffer[2]);
 8022dce:	4b51      	ldr	r3, [pc, #324]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022dd0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8022dd2:	8902      	ldrh	r2, [r0, #8]
 8022dd4:	2104      	movs	r1, #4
 8022dd6:	5641      	ldrsb	r1, [r0, r1]
 8022dd8:	6800      	ldr	r0, [r0, #0]
 8022dda:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022ddc:	2300      	movs	r3, #0
 8022dde:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022de0:	6163      	str	r3, [r4, #20]
      break;
 8022de2:	e6ef      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_int =  Radio.Rssi((RadioModems_t) com_buffer[0]);
 8022de4:	4b4b      	ldr	r3, [pc, #300]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022de6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8022de8:	7800      	ldrb	r0, [r0, #0]
 8022dea:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022dec:	2300      	movs	r3, #0
 8022dee:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_int; /* */
 8022df0:	6160      	str	r0, [r4, #20]
      break;
 8022df2:	e6e7      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.Write((uint16_t) com_buffer[0], (uint8_t) com_buffer[1]);
 8022df4:	4b47      	ldr	r3, [pc, #284]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022df6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8022df8:	7901      	ldrb	r1, [r0, #4]
 8022dfa:	8800      	ldrh	r0, [r0, #0]
 8022dfc:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022dfe:	2300      	movs	r3, #0
 8022e00:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e02:	6163      	str	r3, [r4, #20]
      break;
 8022e04:	e6de      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.Read((uint16_t) com_buffer[0]);
 8022e06:	4b43      	ldr	r3, [pc, #268]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e08:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8022e0a:	8800      	ldrh	r0, [r0, #0]
 8022e0c:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e0e:	2300      	movs	r3, #0
 8022e10:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022e12:	6160      	str	r0, [r4, #20]
      break;
 8022e14:	e6d6      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.WriteRegisters((uint16_t) com_buffer[0], (uint8_t *) com_buffer[1], (uint8_t) com_buffer[2]);
 8022e16:	4b3f      	ldr	r3, [pc, #252]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e18:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8022e1a:	6841      	ldr	r1, [r0, #4]
 8022e1c:	7a02      	ldrb	r2, [r0, #8]
 8022e1e:	8800      	ldrh	r0, [r0, #0]
 8022e20:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e22:	2300      	movs	r3, #0
 8022e24:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e26:	6163      	str	r3, [r4, #20]
      break;
 8022e28:	e6cc      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.ReadRegisters((uint16_t) com_buffer[0], (uint8_t *) com_buffer[1], (uint8_t) com_buffer[2]);
 8022e2a:	4b3a      	ldr	r3, [pc, #232]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e2c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8022e2e:	6841      	ldr	r1, [r0, #4]
 8022e30:	7a02      	ldrb	r2, [r0, #8]
 8022e32:	8800      	ldrh	r0, [r0, #0]
 8022e34:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e36:	2300      	movs	r3, #0
 8022e38:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e3a:	6163      	str	r3, [r4, #20]
      break;
 8022e3c:	e6c2      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetMaxPayloadLength((RadioModems_t) com_buffer[0], (uint8_t) com_buffer[1]);
 8022e3e:	4b35      	ldr	r3, [pc, #212]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e40:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8022e42:	7901      	ldrb	r1, [r0, #4]
 8022e44:	7800      	ldrb	r0, [r0, #0]
 8022e46:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e48:	2300      	movs	r3, #0
 8022e4a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e4c:	6163      	str	r3, [r4, #20]
      break;
 8022e4e:	e6b9      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetPublicNetwork((bool) com_buffer[0]);
 8022e50:	4b30      	ldr	r3, [pc, #192]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e52:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8022e54:	6800      	ldr	r0, [r0, #0]
 8022e56:	1e42      	subs	r2, r0, #1
 8022e58:	4190      	sbcs	r0, r2
 8022e5a:	b2c0      	uxtb	r0, r0
 8022e5c:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e5e:	2300      	movs	r3, #0
 8022e60:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e62:	6163      	str	r3, [r4, #20]
      break;
 8022e64:	e6ae      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.GetWakeupTime();
 8022e66:	4b2b      	ldr	r3, [pc, #172]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e68:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8022e6a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e6c:	2300      	movs	r3, #0
 8022e6e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022e70:	6160      	str	r0, [r4, #20]
      break;
 8022e72:	e6a7      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.IrqProcess();
 8022e74:	4b27      	ldr	r3, [pc, #156]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e76:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8022e78:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e7a:	2300      	movs	r3, #0
 8022e7c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e7e:	6163      	str	r3, [r4, #20]
      break;
 8022e80:	e6a0      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.RxBoosted(com_buffer[0]);
 8022e82:	4b24      	ldr	r3, [pc, #144]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e84:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8022e86:	6800      	ldr	r0, [r0, #0]
 8022e88:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e8a:	2300      	movs	r3, #0
 8022e8c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e8e:	6163      	str	r3, [r4, #20]
      break;
 8022e90:	e698      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.SetRxDutyCycle(com_buffer[0], com_buffer[1]);
 8022e92:	4b20      	ldr	r3, [pc, #128]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022e94:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8022e96:	6841      	ldr	r1, [r0, #4]
 8022e98:	6800      	ldr	r0, [r0, #0]
 8022e9a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e9c:	2300      	movs	r3, #0
 8022e9e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022ea0:	6163      	str	r3, [r4, #20]
      break;
 8022ea2:	e68f      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.TxCw((int8_t)com_buffer[0]);
 8022ea4:	4b1b      	ldr	r3, [pc, #108]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022ea6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8022ea8:	7800      	ldrb	r0, [r0, #0]
 8022eaa:	b240      	sxtb	r0, r0
 8022eac:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022eae:	2300      	movs	r3, #0
 8022eb0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022eb2:	6163      	str	r3, [r4, #20]
      break;
 8022eb4:	e686      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      Radio.TxPrbs();
 8022eb6:	4b17      	ldr	r3, [pc, #92]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022eb8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8022eba:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022ebc:	2300      	movs	r3, #0
 8022ebe:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022ec0:	6163      	str	r3, [r4, #20]
      break;
 8022ec2:	e67f      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.RadioSetRxGenericConfig((GenericModems_t) com_buffer[0], (RxConfigGeneric_t *)com_buffer[1], com_buffer[2], com_buffer[3]);
 8022ec4:	4b13      	ldr	r3, [pc, #76]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022ec6:	6f5d      	ldr	r5, [r3, #116]	; 0x74
 8022ec8:	6841      	ldr	r1, [r0, #4]
 8022eca:	68c3      	ldr	r3, [r0, #12]
 8022ecc:	6882      	ldr	r2, [r0, #8]
 8022ece:	7800      	ldrb	r0, [r0, #0]
 8022ed0:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022ed2:	2300      	movs	r3, #0
 8022ed4:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022ed6:	6160      	str	r0, [r4, #20]
      break;
 8022ed8:	e674      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
      ret_uint = Radio.RadioSetTxGenericConfig((GenericModems_t) com_buffer[0], (TxConfigGeneric_t *)com_buffer[1], (int8_t) com_buffer[2], (uint32_t) com_buffer[3]);
 8022eda:	4b0e      	ldr	r3, [pc, #56]	; (8022f14 <Process_Radio_Cmd+0x3a4>)
 8022edc:	6f9d      	ldr	r5, [r3, #120]	; 0x78
 8022ede:	6841      	ldr	r1, [r0, #4]
 8022ee0:	68c3      	ldr	r3, [r0, #12]
 8022ee2:	2208      	movs	r2, #8
 8022ee4:	5682      	ldrsb	r2, [r0, r2]
 8022ee6:	7800      	ldrb	r0, [r0, #0]
 8022ee8:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022eea:	2300      	movs	r3, #0
 8022eec:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022eee:	6160      	str	r0, [r4, #20]
      break;
 8022ef0:	e668      	b.n	8022bc4 <Process_Radio_Cmd+0x54>
 8022ef2:	46c0      	nop			; (mov r8, r8)
 8022ef4:	08034b3c 	.word	0x08034b3c
 8022ef8:	08034b64 	.word	0x08034b64
 8022efc:	2000a1cc 	.word	0x2000a1cc
 8022f00:	08022b03 	.word	0x08022b03
 8022f04:	08022aef 	.word	0x08022aef
 8022f08:	08022b19 	.word	0x08022b19
 8022f0c:	08022adb 	.word	0x08022adb
 8022f10:	08022ac7 	.word	0x08022ac7
 8022f14:	080356b4 	.word	0x080356b4
 8022f18:	08034b50 	.word	0x08034b50

08022f1c <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 8022f1c:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8022f1e:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8022f20:	3304      	adds	r3, #4

08022f22 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8022f22:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8022f24:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 8022f26:	d3f9      	bcc.n	8022f1c <CopyDataInit>
  bx lr
 8022f28:	4770      	bx	lr

08022f2a <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 8022f2a:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 8022f2c:	3004      	adds	r0, #4

08022f2e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 8022f2e:	4288      	cmp	r0, r1
  bcc FillZerobss
 8022f30:	d3fb      	bcc.n	8022f2a <FillZerobss>
  bx lr
 8022f32:	4770      	bx	lr

08022f34 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8022f34:	480f      	ldr	r0, [pc, #60]	; (8022f74 <LoopForever+0x4>)
  mov   sp, r0          /* set stack pointer */
 8022f36:	4685      	mov	sp, r0

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 8022f38:	480f      	ldr	r0, [pc, #60]	; (8022f78 <LoopForever+0x8>)
 8022f3a:	4910      	ldr	r1, [pc, #64]	; (8022f7c <LoopForever+0xc>)
 8022f3c:	2300      	movs	r3, #0
 8022f3e:	f7ff fff6 	bl	8022f2e <LoopFillZerobss>

/* Zero fill the MB_MEM2 segments. */
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 8022f42:	480f      	ldr	r0, [pc, #60]	; (8022f80 <LoopForever+0x10>)
 8022f44:	490f      	ldr	r1, [pc, #60]	; (8022f84 <LoopForever+0x14>)
 8022f46:	2300      	movs	r3, #0
 8022f48:	f7ff fff1 	bl	8022f2e <LoopFillZerobss>

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 8022f4c:	480e      	ldr	r0, [pc, #56]	; (8022f88 <LoopForever+0x18>)
 8022f4e:	490f      	ldr	r1, [pc, #60]	; (8022f8c <LoopForever+0x1c>)
 8022f50:	4a0f      	ldr	r2, [pc, #60]	; (8022f90 <LoopForever+0x20>)
 8022f52:	2300      	movs	r3, #0
 8022f54:	f7ff ffe5 	bl	8022f22 <LoopCopyDataInit>

/* Copy the MB_MEM2 segment initializers from flash to SRAM */
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 8022f58:	4809      	ldr	r0, [pc, #36]	; (8022f80 <LoopForever+0x10>)
 8022f5a:	490a      	ldr	r1, [pc, #40]	; (8022f84 <LoopForever+0x14>)
 8022f5c:	4a0d      	ldr	r2, [pc, #52]	; (8022f94 <LoopForever+0x24>)
 8022f5e:	2300      	movs	r3, #0
 8022f60:	f7ff ffdf 	bl	8022f22 <LoopCopyDataInit>

/* Call the clock system initialization function.*/
  bl  SystemInit
 8022f64:	f000 f8ae 	bl	80230c4 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8022f68:	f011 fba2 	bl	80346b0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8022f6c:	f7fe fba9 	bl	80216c2 <main>

08022f70 <LoopForever>:

LoopForever:
    b LoopForever
 8022f70:	e7fe      	b.n	8022f70 <LoopForever>
 8022f72:	0000      	.short	0x0000
  ldr   r0, =_estack
 8022f74:	20010000 	.word	0x20010000
  INIT_BSS _sbss, _ebss
 8022f78:	2000a0f8 	.word	0x2000a0f8
 8022f7c:	2000bd94 	.word	0x2000bd94
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 8022f80:	20009000 	.word	0x20009000
 8022f84:	20009680 	.word	0x20009680
  INIT_DATA _sdata, _edata, _sidata
 8022f88:	2000a000 	.word	0x2000a000
 8022f8c:	2000a0f8 	.word	0x2000a0f8
 8022f90:	08035ab4 	.word	0x08035ab4
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 8022f94:	08035bac 	.word	0x08035bac

08022f98 <ADC_COMP_DAC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8022f98:	e7fe      	b.n	8022f98 <ADC_COMP_DAC_IRQHandler>
	...

08022f9c <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 8022f9c:	b510      	push	{r4, lr}
 8022f9e:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 8022fa0:	2400      	movs	r4, #0
 8022fa2:	9405      	str	r4, [sp, #20]
  SET_BIT(RCC->C2AHB2ENR, Periphs);
 8022fa4:	21b0      	movs	r1, #176	; 0xb0
 8022fa6:	05c9      	lsls	r1, r1, #23
 8022fa8:	22a6      	movs	r2, #166	; 0xa6
 8022faa:	0052      	lsls	r2, r2, #1
 8022fac:	5888      	ldr	r0, [r1, r2]
 8022fae:	2304      	movs	r3, #4
 8022fb0:	4318      	orrs	r0, r3
 8022fb2:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB2ENR, Periphs);
 8022fb4:	588a      	ldr	r2, [r1, r2]
 8022fb6:	4013      	ands	r3, r2
 8022fb8:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 8022fba:	9b00      	ldr	r3, [sp, #0]
  
  /* Enable the Radio Switch Clock */
  RF_SW_CTRL3_GPIO_CLK_ENABLE();
  
  /* Configure the Radio Switch pin */
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
 8022fbc:	2310      	movs	r3, #16
 8022fbe:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 8022fc0:	3b0f      	subs	r3, #15
 8022fc2:	9302      	str	r3, [sp, #8]
  gpio_init_structure.Pull  = GPIO_NOPULL;
 8022fc4:	9403      	str	r4, [sp, #12]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8022fc6:	3302      	adds	r3, #2
 8022fc8:	9304      	str	r3, [sp, #16]
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 8022fca:	4c11      	ldr	r4, [pc, #68]	; (8023010 <BSP_RADIO_Init+0x74>)
 8022fcc:	a901      	add	r1, sp, #4
 8022fce:	0020      	movs	r0, r4
 8022fd0:	f001 f9b6 	bl	8024340 <HAL_GPIO_Init>
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 8022fd4:	2320      	movs	r3, #32
 8022fd6:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 8022fd8:	a901      	add	r1, sp, #4
 8022fda:	0020      	movs	r0, r4
 8022fdc:	f001 f9b0 	bl	8024340 <HAL_GPIO_Init>
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 8022fe0:	2308      	movs	r3, #8
 8022fe2:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 8022fe4:	a901      	add	r1, sp, #4
 8022fe6:	0020      	movs	r0, r4
 8022fe8:	f001 f9aa 	bl	8024340 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 8022fec:	2200      	movs	r2, #0
 8022fee:	2120      	movs	r1, #32
 8022ff0:	0020      	movs	r0, r4
 8022ff2:	f001 fa5b 	bl	80244ac <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 8022ff6:	2200      	movs	r2, #0
 8022ff8:	2110      	movs	r1, #16
 8022ffa:	0020      	movs	r0, r4
 8022ffc:	f001 fa56 	bl	80244ac <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 8023000:	2200      	movs	r2, #0
 8023002:	2108      	movs	r1, #8
 8023004:	0020      	movs	r0, r4
 8023006:	f001 fa51 	bl	80244ac <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 802300a:	2000      	movs	r0, #0
 802300c:	b006      	add	sp, #24
 802300e:	bd10      	pop	{r4, pc}
 8023010:	48000800 	.word	0x48000800

08023014 <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 8023014:	b510      	push	{r4, lr}
  switch (Config)
 8023016:	2802      	cmp	r0, #2
 8023018:	d03a      	beq.n	8023090 <BSP_RADIO_ConfigRFSwitch+0x7c>
 802301a:	d814      	bhi.n	8023046 <BSP_RADIO_ConfigRFSwitch+0x32>
 802301c:	2800      	cmp	r0, #0
 802301e:	d025      	beq.n	802306c <BSP_RADIO_ConfigRFSwitch+0x58>
 8023020:	2801      	cmp	r0, #1
 8023022:	d133      	bne.n	802308c <BSP_RADIO_ConfigRFSwitch+0x78>
      break;      
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 8023024:	4c23      	ldr	r4, [pc, #140]	; (80230b4 <BSP_RADIO_ConfigRFSwitch+0xa0>)
 8023026:	2201      	movs	r2, #1
 8023028:	2108      	movs	r1, #8
 802302a:	0020      	movs	r0, r4
 802302c:	f001 fa3e 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 8023030:	2201      	movs	r2, #1
 8023032:	2110      	movs	r1, #16
 8023034:	0020      	movs	r0, r4
 8023036:	f001 fa39 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 802303a:	2200      	movs	r2, #0
 802303c:	2120      	movs	r1, #32
 802303e:	0020      	movs	r0, r4
 8023040:	f001 fa34 	bl	80244ac <HAL_GPIO_WritePin>
      break;
 8023044:	e022      	b.n	802308c <BSP_RADIO_ConfigRFSwitch+0x78>
  switch (Config)
 8023046:	2803      	cmp	r0, #3
 8023048:	d120      	bne.n	802308c <BSP_RADIO_ConfigRFSwitch+0x78>
      break;
    }
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802304a:	4c1a      	ldr	r4, [pc, #104]	; (80230b4 <BSP_RADIO_ConfigRFSwitch+0xa0>)
 802304c:	2201      	movs	r2, #1
 802304e:	2108      	movs	r1, #8
 8023050:	0020      	movs	r0, r4
 8023052:	f001 fa2b 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 8023056:	2200      	movs	r2, #0
 8023058:	2110      	movs	r1, #16
 802305a:	0020      	movs	r0, r4
 802305c:	f001 fa26 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 8023060:	2201      	movs	r2, #1
 8023062:	2120      	movs	r1, #32
 8023064:	0020      	movs	r0, r4
 8023066:	f001 fa21 	bl	80244ac <HAL_GPIO_WritePin>
      break;
 802306a:	e00f      	b.n	802308c <BSP_RADIO_ConfigRFSwitch+0x78>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 802306c:	4c11      	ldr	r4, [pc, #68]	; (80230b4 <BSP_RADIO_ConfigRFSwitch+0xa0>)
 802306e:	2200      	movs	r2, #0
 8023070:	2108      	movs	r1, #8
 8023072:	0020      	movs	r0, r4
 8023074:	f001 fa1a 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 8023078:	2200      	movs	r2, #0
 802307a:	2110      	movs	r1, #16
 802307c:	0020      	movs	r0, r4
 802307e:	f001 fa15 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET);
 8023082:	2200      	movs	r2, #0
 8023084:	2120      	movs	r1, #32
 8023086:	0020      	movs	r0, r4
 8023088:	f001 fa10 	bl	80244ac <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 802308c:	2000      	movs	r0, #0
 802308e:	bd10      	pop	{r4, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 8023090:	4c08      	ldr	r4, [pc, #32]	; (80230b4 <BSP_RADIO_ConfigRFSwitch+0xa0>)
 8023092:	2201      	movs	r2, #1
 8023094:	2108      	movs	r1, #8
 8023096:	0020      	movs	r0, r4
 8023098:	f001 fa08 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 802309c:	2201      	movs	r2, #1
 802309e:	2110      	movs	r1, #16
 80230a0:	0020      	movs	r0, r4
 80230a2:	f001 fa03 	bl	80244ac <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 80230a6:	2201      	movs	r2, #1
 80230a8:	2120      	movs	r1, #32
 80230aa:	0020      	movs	r0, r4
 80230ac:	f001 f9fe 	bl	80244ac <HAL_GPIO_WritePin>
      break;
 80230b0:	e7ec      	b.n	802308c <BSP_RADIO_ConfigRFSwitch+0x78>
 80230b2:	46c0      	nop			; (mov r8, r8)
 80230b4:	48000800 	.word	0x48000800

080230b8 <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 80230b8:	2000      	movs	r0, #0
 80230ba:	4770      	bx	lr

080230bc <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 80230bc:	2001      	movs	r0, #1
 80230be:	4770      	bx	lr

080230c0 <BSP_RADIO_IsDCDC>:
  *  RADIO_CONF_DCDC_SUPPORTED  
  */
int32_t BSP_RADIO_IsDCDC(void)
{
  return RADIO_CONF_DCDC_SUPPORTED;
}
 80230c0:	2001      	movs	r0, #1
 80230c2:	4770      	bx	lr

080230c4 <SystemInit>:

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 80230c4:	4770      	bx	lr
	...

080230c8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80230c8:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
#endif

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
 80230ca:	f001 fc09 	bl	80248e0 <HAL_RCC_GetHCLK2Freq>
 80230ce:	4b06      	ldr	r3, [pc, #24]	; (80230e8 <HAL_Init+0x20>)
 80230d0:	6018      	str	r0, [r3, #0]
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80230d2:	2003      	movs	r0, #3
 80230d4:	f7fe fd82 	bl	8021bdc <HAL_InitTick>
 80230d8:	1e04      	subs	r4, r0, #0
 80230da:	d002      	beq.n	80230e2 <HAL_Init+0x1a>
  {
    status = HAL_ERROR;
 80230dc:	2401      	movs	r4, #1
    HAL_MspInit();
  }

  /* Return function status */
  return status;
}
 80230de:	0020      	movs	r0, r4
 80230e0:	bd10      	pop	{r4, pc}
    HAL_MspInit();
 80230e2:	f7fe fc4d 	bl	8021980 <HAL_MspInit>
 80230e6:	e7fa      	b.n	80230de <HAL_Init+0x16>
 80230e8:	2000a034 	.word	0x2000a034

080230ec <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 80230ec:	4a02      	ldr	r2, [pc, #8]	; (80230f8 <HAL_SuspendTick+0xc>)
 80230ee:	6813      	ldr	r3, [r2, #0]
 80230f0:	2102      	movs	r1, #2
 80230f2:	438b      	bics	r3, r1
 80230f4:	6013      	str	r3, [r2, #0]
}
 80230f6:	4770      	bx	lr
 80230f8:	e000e010 	.word	0xe000e010

080230fc <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 80230fc:	4a02      	ldr	r2, [pc, #8]	; (8023108 <HAL_ResumeTick+0xc>)
 80230fe:	6813      	ldr	r3, [r2, #0]
 8023100:	2102      	movs	r1, #2
 8023102:	430b      	orrs	r3, r1
 8023104:	6013      	str	r3, [r2, #0]
}
 8023106:	4770      	bx	lr
 8023108:	e000e010 	.word	0xe000e010

0802310c <HAL_GetUIDw0>:
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
 802310c:	4b01      	ldr	r3, [pc, #4]	; (8023114 <HAL_GetUIDw0+0x8>)
 802310e:	6818      	ldr	r0, [r3, #0]
}
 8023110:	4770      	bx	lr
 8023112:	46c0      	nop			; (mov r8, r8)
 8023114:	1fff7590 	.word	0x1fff7590

08023118 <HAL_GetUIDw1>:
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 8023118:	4b01      	ldr	r3, [pc, #4]	; (8023120 <HAL_GetUIDw1+0x8>)
 802311a:	6818      	ldr	r0, [r3, #0]
}
 802311c:	4770      	bx	lr
 802311e:	46c0      	nop			; (mov r8, r8)
 8023120:	1fff7594 	.word	0x1fff7594

08023124 <HAL_GetUIDw2>:
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 8023124:	4b01      	ldr	r3, [pc, #4]	; (802312c <HAL_GetUIDw2+0x8>)
 8023126:	6818      	ldr	r0, [r3, #0]
}
 8023128:	4770      	bx	lr
 802312a:	46c0      	nop			; (mov r8, r8)
 802312c:	1fff7598 	.word	0x1fff7598

08023130 <HAL_NVIC_SetPriority>:
  *         with stm32wlxx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8023130:	b570      	push	{r4, r5, r6, lr}
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8023132:	2800      	cmp	r0, #0
 8023134:	db11      	blt.n	802315a <HAL_NVIC_SetPriority+0x2a>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8023136:	0883      	lsrs	r3, r0, #2
 8023138:	4e13      	ldr	r6, [pc, #76]	; (8023188 <HAL_NVIC_SetPriority+0x58>)
 802313a:	33c0      	adds	r3, #192	; 0xc0
 802313c:	009b      	lsls	r3, r3, #2
 802313e:	599d      	ldr	r5, [r3, r6]
 8023140:	2403      	movs	r4, #3
 8023142:	4020      	ands	r0, r4
 8023144:	00c0      	lsls	r0, r0, #3
 8023146:	22ff      	movs	r2, #255	; 0xff
 8023148:	0014      	movs	r4, r2
 802314a:	4084      	lsls	r4, r0
 802314c:	43a5      	bics	r5, r4
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 802314e:	0189      	lsls	r1, r1, #6
 8023150:	400a      	ands	r2, r1
 8023152:	4082      	lsls	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8023154:	432a      	orrs	r2, r5
 8023156:	519a      	str	r2, [r3, r6]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
}
 8023158:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 802315a:	230f      	movs	r3, #15
 802315c:	4003      	ands	r3, r0
 802315e:	3b08      	subs	r3, #8
 8023160:	089b      	lsrs	r3, r3, #2
 8023162:	3306      	adds	r3, #6
 8023164:	009b      	lsls	r3, r3, #2
 8023166:	4a09      	ldr	r2, [pc, #36]	; (802318c <HAL_NVIC_SetPriority+0x5c>)
 8023168:	4694      	mov	ip, r2
 802316a:	4463      	add	r3, ip
 802316c:	685c      	ldr	r4, [r3, #4]
 802316e:	2203      	movs	r2, #3
 8023170:	4010      	ands	r0, r2
 8023172:	00c0      	lsls	r0, r0, #3
 8023174:	32fc      	adds	r2, #252	; 0xfc
 8023176:	0015      	movs	r5, r2
 8023178:	4085      	lsls	r5, r0
 802317a:	43ac      	bics	r4, r5
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 802317c:	0189      	lsls	r1, r1, #6
 802317e:	400a      	ands	r2, r1
 8023180:	4082      	lsls	r2, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8023182:	4322      	orrs	r2, r4
 8023184:	605a      	str	r2, [r3, #4]
 8023186:	e7e7      	b.n	8023158 <HAL_NVIC_SetPriority+0x28>
 8023188:	e000e100 	.word	0xe000e100
 802318c:	e000ed00 	.word	0xe000ed00

08023190 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8023190:	2800      	cmp	r0, #0
 8023192:	db05      	blt.n	80231a0 <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8023194:	231f      	movs	r3, #31
 8023196:	4018      	ands	r0, r3
 8023198:	3b1e      	subs	r3, #30
 802319a:	4083      	lsls	r3, r0
 802319c:	4a01      	ldr	r2, [pc, #4]	; (80231a4 <HAL_NVIC_EnableIRQ+0x14>)
 802319e:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80231a0:	4770      	bx	lr
 80231a2:	46c0      	nop			; (mov r8, r8)
 80231a4:	e000e100 	.word	0xe000e100

080231a8 <CRYP_SetKey>:
  *         occurs when the key is written out of HAL scope.
  * @retval None
  */
static void CRYP_SetKey(CRYP_HandleTypeDef *hcryp, uint32_t KeySize)
{
  if (hcryp->Init.pKey != NULL)
 80231a8:	68c3      	ldr	r3, [r0, #12]
 80231aa:	2b00      	cmp	r3, #0
 80231ac:	d024      	beq.n	80231f8 <CRYP_SetKey+0x50>
  {
    switch (KeySize)
 80231ae:	2900      	cmp	r1, #0
 80231b0:	d023      	beq.n	80231fa <CRYP_SetKey+0x52>
 80231b2:	2280      	movs	r2, #128	; 0x80
 80231b4:	02d2      	lsls	r2, r2, #11
 80231b6:	4291      	cmp	r1, r2
 80231b8:	d11e      	bne.n	80231f8 <CRYP_SetKey+0x50>
    {
      case CRYP_KEYSIZE_256B:
        hcryp->Instance->KEYR7 = *(uint32_t *)(hcryp->Init.pKey);
 80231ba:	6802      	ldr	r2, [r0, #0]
 80231bc:	681b      	ldr	r3, [r3, #0]
 80231be:	63d3      	str	r3, [r2, #60]	; 0x3c
        hcryp->Instance->KEYR6 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 80231c0:	68c2      	ldr	r2, [r0, #12]
 80231c2:	6803      	ldr	r3, [r0, #0]
 80231c4:	6852      	ldr	r2, [r2, #4]
 80231c6:	639a      	str	r2, [r3, #56]	; 0x38
        hcryp->Instance->KEYR5 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 80231c8:	68c2      	ldr	r2, [r0, #12]
 80231ca:	6803      	ldr	r3, [r0, #0]
 80231cc:	6892      	ldr	r2, [r2, #8]
 80231ce:	635a      	str	r2, [r3, #52]	; 0x34
        hcryp->Instance->KEYR4 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 80231d0:	68c2      	ldr	r2, [r0, #12]
 80231d2:	6803      	ldr	r3, [r0, #0]
 80231d4:	68d2      	ldr	r2, [r2, #12]
 80231d6:	631a      	str	r2, [r3, #48]	; 0x30
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey + 4U);
 80231d8:	68c2      	ldr	r2, [r0, #12]
 80231da:	6803      	ldr	r3, [r0, #0]
 80231dc:	6912      	ldr	r2, [r2, #16]
 80231de:	61da      	str	r2, [r3, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 5U);
 80231e0:	68c2      	ldr	r2, [r0, #12]
 80231e2:	6803      	ldr	r3, [r0, #0]
 80231e4:	6952      	ldr	r2, [r2, #20]
 80231e6:	619a      	str	r2, [r3, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 6U);
 80231e8:	68c2      	ldr	r2, [r0, #12]
 80231ea:	6803      	ldr	r3, [r0, #0]
 80231ec:	6992      	ldr	r2, [r2, #24]
 80231ee:	615a      	str	r2, [r3, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 7U);
 80231f0:	68c2      	ldr	r2, [r0, #12]
 80231f2:	6803      	ldr	r3, [r0, #0]
 80231f4:	69d2      	ldr	r2, [r2, #28]
 80231f6:	611a      	str	r2, [r3, #16]
        break;
      default:
        break;
    }
  }
}
 80231f8:	4770      	bx	lr
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
 80231fa:	6802      	ldr	r2, [r0, #0]
 80231fc:	681b      	ldr	r3, [r3, #0]
 80231fe:	61d3      	str	r3, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 8023200:	68c2      	ldr	r2, [r0, #12]
 8023202:	6803      	ldr	r3, [r0, #0]
 8023204:	6852      	ldr	r2, [r2, #4]
 8023206:	619a      	str	r2, [r3, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 8023208:	68c2      	ldr	r2, [r0, #12]
 802320a:	6803      	ldr	r3, [r0, #0]
 802320c:	6892      	ldr	r2, [r2, #8]
 802320e:	615a      	str	r2, [r3, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 8023210:	68c2      	ldr	r2, [r0, #12]
 8023212:	6803      	ldr	r3, [r0, #0]
 8023214:	68d2      	ldr	r2, [r2, #12]
 8023216:	611a      	str	r2, [r3, #16]
}
 8023218:	e7ee      	b.n	80231f8 <CRYP_SetKey+0x50>

0802321a <CRYP_WaitOnCCFlag>:
  * @param  Timeout Timeout duration.
  * @note   This function can only be used in thread mode.
  * @retval HAL status
  */
static HAL_StatusTypeDef CRYP_WaitOnCCFlag(CRYP_HandleTypeDef *hcryp, uint32_t Timeout)
{
 802321a:	b570      	push	{r4, r5, r6, lr}
 802321c:	0005      	movs	r5, r0
 802321e:	000c      	movs	r4, r1
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 8023220:	f7fe fcde 	bl	8021be0 <HAL_GetTick>
 8023224:	0006      	movs	r6, r0

  while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 8023226:	682b      	ldr	r3, [r5, #0]
 8023228:	685b      	ldr	r3, [r3, #4]
 802322a:	07db      	lsls	r3, r3, #31
 802322c:	d40a      	bmi.n	8023244 <CRYP_WaitOnCCFlag+0x2a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 802322e:	1c63      	adds	r3, r4, #1
 8023230:	d0f9      	beq.n	8023226 <CRYP_WaitOnCCFlag+0xc>
    {
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8023232:	f7fe fcd5 	bl	8021be0 <HAL_GetTick>
 8023236:	1b80      	subs	r0, r0, r6
 8023238:	42a0      	cmp	r0, r4
 802323a:	d805      	bhi.n	8023248 <CRYP_WaitOnCCFlag+0x2e>
 802323c:	2c00      	cmp	r4, #0
 802323e:	d1f2      	bne.n	8023226 <CRYP_WaitOnCCFlag+0xc>
      {
        return HAL_ERROR;
 8023240:	2001      	movs	r0, #1
 8023242:	e000      	b.n	8023246 <CRYP_WaitOnCCFlag+0x2c>
      }
    }
  }
  return HAL_OK;
 8023244:	2000      	movs	r0, #0
}
 8023246:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8023248:	2001      	movs	r0, #1
 802324a:	e7fc      	b.n	8023246 <CRYP_WaitOnCCFlag+0x2c>

0802324c <CRYP_GCMCCM_SetHeaderPhase>:
{
 802324c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802324e:	b08d      	sub	sp, #52	; 0x34
 8023250:	0004      	movs	r4, r0
 8023252:	000d      	movs	r5, r1
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 8023254:	4669      	mov	r1, sp
 8023256:	4b90      	ldr	r3, [pc, #576]	; (8023498 <CRYP_GCMCCM_SetHeaderPhase+0x24c>)
 8023258:	000a      	movs	r2, r1
 802325a:	cb43      	ldmia	r3!, {r0, r1, r6}
 802325c:	c243      	stmia	r2!, {r0, r1, r6}
 802325e:	cb43      	ldmia	r3!, {r0, r1, r6}
 8023260:	c243      	stmia	r2!, {r0, r1, r6}
 8023262:	cb43      	ldmia	r3!, {r0, r1, r6}
 8023264:	c243      	stmia	r2!, {r0, r1, r6}
 8023266:	cb43      	ldmia	r3!, {r0, r1, r6}
 8023268:	c243      	stmia	r2!, {r0, r1, r6}
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_WORD)
 802326a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802326c:	2b00      	cmp	r3, #0
 802326e:	d151      	bne.n	8023314 <CRYP_GCMCCM_SetHeaderPhase+0xc8>
    size_in_bytes = hcryp->Init.HeaderSize * 4U;
 8023270:	69e3      	ldr	r3, [r4, #28]
 8023272:	009e      	lsls	r6, r3, #2
  if ((size_in_bytes != 0U))
 8023274:	2e00      	cmp	r6, #0
 8023276:	d100      	bne.n	802327a <CRYP_GCMCCM_SetHeaderPhase+0x2e>
 8023278:	e0f7      	b.n	802346a <CRYP_GCMCCM_SetHeaderPhase+0x21e>
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 802327a:	6821      	ldr	r1, [r4, #0]
 802327c:	680b      	ldr	r3, [r1, #0]
 802327e:	4a87      	ldr	r2, [pc, #540]	; (802349c <CRYP_GCMCCM_SetHeaderPhase+0x250>)
 8023280:	401a      	ands	r2, r3
 8023282:	2380      	movs	r3, #128	; 0x80
 8023284:	019b      	lsls	r3, r3, #6
 8023286:	4313      	orrs	r3, r2
 8023288:	600b      	str	r3, [r1, #0]
    __HAL_CRYP_ENABLE(hcryp);
 802328a:	6822      	ldr	r2, [r4, #0]
 802328c:	6813      	ldr	r3, [r2, #0]
 802328e:	2101      	movs	r1, #1
 8023290:	430b      	orrs	r3, r1
 8023292:	6013      	str	r3, [r2, #0]
    if ((size_in_bytes % 16U) == 0U)
 8023294:	230f      	movs	r3, #15
 8023296:	001f      	movs	r7, r3
 8023298:	4037      	ands	r7, r6
 802329a:	4233      	tst	r3, r6
 802329c:	d04c      	beq.n	8023338 <CRYP_GCMCCM_SetHeaderPhase+0xec>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 802329e:	2700      	movs	r7, #0
 80232a0:	0933      	lsrs	r3, r6, #4
 80232a2:	009b      	lsls	r3, r3, #2
 80232a4:	42bb      	cmp	r3, r7
 80232a6:	d800      	bhi.n	80232aa <CRYP_GCMCCM_SetHeaderPhase+0x5e>
 80232a8:	e090      	b.n	80233cc <CRYP_GCMCCM_SetHeaderPhase+0x180>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80232aa:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232ac:	009b      	lsls	r3, r3, #2
 80232ae:	6822      	ldr	r2, [r4, #0]
 80232b0:	69a1      	ldr	r1, [r4, #24]
 80232b2:	58cb      	ldr	r3, [r1, r3]
 80232b4:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 80232b6:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232b8:	3301      	adds	r3, #1
 80232ba:	b29b      	uxth	r3, r3
 80232bc:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80232be:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232c0:	009b      	lsls	r3, r3, #2
 80232c2:	6822      	ldr	r2, [r4, #0]
 80232c4:	69a1      	ldr	r1, [r4, #24]
 80232c6:	58cb      	ldr	r3, [r1, r3]
 80232c8:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 80232ca:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232cc:	3301      	adds	r3, #1
 80232ce:	b29b      	uxth	r3, r3
 80232d0:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80232d2:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232d4:	009b      	lsls	r3, r3, #2
 80232d6:	6822      	ldr	r2, [r4, #0]
 80232d8:	69a1      	ldr	r1, [r4, #24]
 80232da:	58cb      	ldr	r3, [r1, r3]
 80232dc:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 80232de:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232e0:	3301      	adds	r3, #1
 80232e2:	b29b      	uxth	r3, r3
 80232e4:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80232e6:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232e8:	009b      	lsls	r3, r3, #2
 80232ea:	6822      	ldr	r2, [r4, #0]
 80232ec:	69a1      	ldr	r1, [r4, #24]
 80232ee:	58cb      	ldr	r3, [r1, r3]
 80232f0:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 80232f2:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80232f4:	3301      	adds	r3, #1
 80232f6:	b29b      	uxth	r3, r3
 80232f8:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80232fa:	0029      	movs	r1, r5
 80232fc:	0020      	movs	r0, r4
 80232fe:	f7ff ff8c 	bl	802321a <CRYP_WaitOnCCFlag>
 8023302:	2800      	cmp	r0, #0
 8023304:	d152      	bne.n	80233ac <CRYP_GCMCCM_SetHeaderPhase+0x160>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023306:	6822      	ldr	r2, [r4, #0]
 8023308:	6813      	ldr	r3, [r2, #0]
 802330a:	2180      	movs	r1, #128	; 0x80
 802330c:	430b      	orrs	r3, r1
 802330e:	6013      	str	r3, [r2, #0]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 8023310:	3704      	adds	r7, #4
 8023312:	e7c5      	b.n	80232a0 <CRYP_GCMCCM_SetHeaderPhase+0x54>
    size_in_bytes = hcryp->Init.HeaderSize;
 8023314:	69e6      	ldr	r6, [r4, #28]
 8023316:	e7ad      	b.n	8023274 <CRYP_GCMCCM_SetHeaderPhase+0x28>
          __HAL_CRYP_DISABLE(hcryp);
 8023318:	6821      	ldr	r1, [r4, #0]
 802331a:	680b      	ldr	r3, [r1, #0]
 802331c:	2201      	movs	r2, #1
 802331e:	4393      	bics	r3, r2
 8023320:	600b      	str	r3, [r1, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023322:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023324:	2110      	movs	r1, #16
 8023326:	430b      	orrs	r3, r1
 8023328:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 802332a:	2351      	movs	r3, #81	; 0x51
 802332c:	54e2      	strb	r2, [r4, r3]
          __HAL_UNLOCK(hcryp);
 802332e:	3b01      	subs	r3, #1
 8023330:	2200      	movs	r2, #0
 8023332:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 8023334:	2001      	movs	r0, #1
 8023336:	e0ad      	b.n	8023494 <CRYP_GCMCCM_SetHeaderPhase+0x248>
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 8023338:	08b3      	lsrs	r3, r6, #2
 802333a:	42bb      	cmp	r3, r7
 802333c:	d934      	bls.n	80233a8 <CRYP_GCMCCM_SetHeaderPhase+0x15c>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 802333e:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023340:	009b      	lsls	r3, r3, #2
 8023342:	6822      	ldr	r2, [r4, #0]
 8023344:	69a1      	ldr	r1, [r4, #24]
 8023346:	58cb      	ldr	r3, [r1, r3]
 8023348:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 802334a:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802334c:	3301      	adds	r3, #1
 802334e:	b29b      	uxth	r3, r3
 8023350:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8023352:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023354:	009b      	lsls	r3, r3, #2
 8023356:	6822      	ldr	r2, [r4, #0]
 8023358:	69a1      	ldr	r1, [r4, #24]
 802335a:	58cb      	ldr	r3, [r1, r3]
 802335c:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 802335e:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023360:	3301      	adds	r3, #1
 8023362:	b29b      	uxth	r3, r3
 8023364:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8023366:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023368:	009b      	lsls	r3, r3, #2
 802336a:	6822      	ldr	r2, [r4, #0]
 802336c:	69a1      	ldr	r1, [r4, #24]
 802336e:	58cb      	ldr	r3, [r1, r3]
 8023370:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8023372:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023374:	3301      	adds	r3, #1
 8023376:	b29b      	uxth	r3, r3
 8023378:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 802337a:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802337c:	009b      	lsls	r3, r3, #2
 802337e:	6822      	ldr	r2, [r4, #0]
 8023380:	69a1      	ldr	r1, [r4, #24]
 8023382:	58cb      	ldr	r3, [r1, r3]
 8023384:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8023386:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023388:	3301      	adds	r3, #1
 802338a:	b29b      	uxth	r3, r3
 802338c:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 802338e:	0029      	movs	r1, r5
 8023390:	0020      	movs	r0, r4
 8023392:	f7ff ff42 	bl	802321a <CRYP_WaitOnCCFlag>
 8023396:	2800      	cmp	r0, #0
 8023398:	d1be      	bne.n	8023318 <CRYP_GCMCCM_SetHeaderPhase+0xcc>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 802339a:	6822      	ldr	r2, [r4, #0]
 802339c:	6813      	ldr	r3, [r2, #0]
 802339e:	2180      	movs	r1, #128	; 0x80
 80233a0:	430b      	orrs	r3, r1
 80233a2:	6013      	str	r3, [r2, #0]
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 80233a4:	3704      	adds	r7, #4
 80233a6:	e7c7      	b.n	8023338 <CRYP_GCMCCM_SetHeaderPhase+0xec>
  return HAL_OK;
 80233a8:	2000      	movs	r0, #0
 80233aa:	e073      	b.n	8023494 <CRYP_GCMCCM_SetHeaderPhase+0x248>
          __HAL_CRYP_DISABLE(hcryp);
 80233ac:	6821      	ldr	r1, [r4, #0]
 80233ae:	680b      	ldr	r3, [r1, #0]
 80233b0:	2201      	movs	r2, #1
 80233b2:	4393      	bics	r3, r2
 80233b4:	600b      	str	r3, [r1, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80233b6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80233b8:	2110      	movs	r1, #16
 80233ba:	430b      	orrs	r3, r1
 80233bc:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 80233be:	2351      	movs	r3, #81	; 0x51
 80233c0:	54e2      	strb	r2, [r4, r3]
          __HAL_UNLOCK(hcryp);
 80233c2:	3b01      	subs	r3, #1
 80233c4:	2200      	movs	r2, #0
 80233c6:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 80233c8:	2001      	movs	r0, #1
 80233ca:	e063      	b.n	8023494 <CRYP_GCMCCM_SetHeaderPhase+0x248>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 80233cc:	2200      	movs	r2, #0
 80233ce:	08b1      	lsrs	r1, r6, #2
 80233d0:	2303      	movs	r3, #3
 80233d2:	400b      	ands	r3, r1
 80233d4:	4293      	cmp	r3, r2
 80233d6:	d90b      	bls.n	80233f0 <CRYP_GCMCCM_SetHeaderPhase+0x1a4>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80233d8:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80233da:	009b      	lsls	r3, r3, #2
 80233dc:	6821      	ldr	r1, [r4, #0]
 80233de:	69a0      	ldr	r0, [r4, #24]
 80233e0:	58c3      	ldr	r3, [r0, r3]
 80233e2:	608b      	str	r3, [r1, #8]
        hcryp->CrypHeaderCount++ ;
 80233e4:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80233e6:	3301      	adds	r3, #1
 80233e8:	b29b      	uxth	r3, r3
 80233ea:	87a3      	strh	r3, [r4, #60]	; 0x3c
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 80233ec:	3201      	adds	r2, #1
 80233ee:	e7ee      	b.n	80233ce <CRYP_GCMCCM_SetHeaderPhase+0x182>
      if ((size_in_bytes % 4U) == 0U)
 80233f0:	2103      	movs	r1, #3
 80233f2:	000b      	movs	r3, r1
 80233f4:	4033      	ands	r3, r6
 80233f6:	4231      	tst	r1, r6
 80233f8:	d012      	beq.n	8023420 <CRYP_GCMCCM_SetHeaderPhase+0x1d4>
         tmp =  *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80233fa:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
 80233fc:	0089      	lsls	r1, r1, #2
 80233fe:	69a0      	ldr	r0, [r4, #24]
 8023400:	5841      	ldr	r1, [r0, r1]
         tmp &= mask[(hcryp->Init.DataType * 2U) + (size_in_bytes % 4U)];
 8023402:	6860      	ldr	r0, [r4, #4]
 8023404:	0040      	lsls	r0, r0, #1
 8023406:	181b      	adds	r3, r3, r0
 8023408:	009b      	lsls	r3, r3, #2
 802340a:	4668      	mov	r0, sp
 802340c:	581b      	ldr	r3, [r3, r0]
 802340e:	400b      	ands	r3, r1
         hcryp->Instance->DINR = tmp;
 8023410:	6821      	ldr	r1, [r4, #0]
 8023412:	608b      	str	r3, [r1, #8]
         loopcounter++;
 8023414:	3201      	adds	r2, #1
         while (loopcounter < 4U)
 8023416:	e015      	b.n	8023444 <CRYP_GCMCCM_SetHeaderPhase+0x1f8>
          hcryp->Instance->DINR = 0x0U;
 8023418:	6823      	ldr	r3, [r4, #0]
 802341a:	2100      	movs	r1, #0
 802341c:	6099      	str	r1, [r3, #8]
          loopcounter++;
 802341e:	3201      	adds	r2, #1
        while (loopcounter < 4U)
 8023420:	2a03      	cmp	r2, #3
 8023422:	d9f9      	bls.n	8023418 <CRYP_GCMCCM_SetHeaderPhase+0x1cc>
      if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023424:	0029      	movs	r1, r5
 8023426:	0020      	movs	r0, r4
 8023428:	f7ff fef7 	bl	802321a <CRYP_WaitOnCCFlag>
 802342c:	2800      	cmp	r0, #0
 802342e:	d10c      	bne.n	802344a <CRYP_GCMCCM_SetHeaderPhase+0x1fe>
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023430:	6822      	ldr	r2, [r4, #0]
 8023432:	6813      	ldr	r3, [r2, #0]
 8023434:	2180      	movs	r1, #128	; 0x80
 8023436:	430b      	orrs	r3, r1
 8023438:	6013      	str	r3, [r2, #0]
 802343a:	e02b      	b.n	8023494 <CRYP_GCMCCM_SetHeaderPhase+0x248>
           hcryp->Instance->DINR = 0x0U;
 802343c:	6823      	ldr	r3, [r4, #0]
 802343e:	2100      	movs	r1, #0
 8023440:	6099      	str	r1, [r3, #8]
           loopcounter++;
 8023442:	3201      	adds	r2, #1
         while (loopcounter < 4U)
 8023444:	2a03      	cmp	r2, #3
 8023446:	d9f9      	bls.n	802343c <CRYP_GCMCCM_SetHeaderPhase+0x1f0>
 8023448:	e7ec      	b.n	8023424 <CRYP_GCMCCM_SetHeaderPhase+0x1d8>
        __HAL_CRYP_DISABLE(hcryp);
 802344a:	6821      	ldr	r1, [r4, #0]
 802344c:	680b      	ldr	r3, [r1, #0]
 802344e:	2201      	movs	r2, #1
 8023450:	4393      	bics	r3, r2
 8023452:	600b      	str	r3, [r1, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023454:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023456:	2110      	movs	r1, #16
 8023458:	430b      	orrs	r3, r1
 802345a:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 802345c:	2351      	movs	r3, #81	; 0x51
 802345e:	54e2      	strb	r2, [r4, r3]
        __HAL_UNLOCK(hcryp);
 8023460:	3b01      	subs	r3, #1
 8023462:	2200      	movs	r2, #0
 8023464:	54e2      	strb	r2, [r4, r3]
        return HAL_ERROR;
 8023466:	2001      	movs	r0, #1
 8023468:	e014      	b.n	8023494 <CRYP_GCMCCM_SetHeaderPhase+0x248>
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE, hcryp->Init.DataType);
 802346a:	6822      	ldr	r2, [r4, #0]
 802346c:	6813      	ldr	r3, [r2, #0]
 802346e:	2106      	movs	r1, #6
 8023470:	438b      	bics	r3, r1
 8023472:	6861      	ldr	r1, [r4, #4]
 8023474:	430b      	orrs	r3, r1
 8023476:	6013      	str	r3, [r2, #0]
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 8023478:	6821      	ldr	r1, [r4, #0]
 802347a:	680b      	ldr	r3, [r1, #0]
 802347c:	4a07      	ldr	r2, [pc, #28]	; (802349c <CRYP_GCMCCM_SetHeaderPhase+0x250>)
 802347e:	401a      	ands	r2, r3
 8023480:	2380      	movs	r3, #128	; 0x80
 8023482:	019b      	lsls	r3, r3, #6
 8023484:	4313      	orrs	r3, r2
 8023486:	600b      	str	r3, [r1, #0]
    __HAL_CRYP_ENABLE(hcryp);
 8023488:	6822      	ldr	r2, [r4, #0]
 802348a:	6813      	ldr	r3, [r2, #0]
 802348c:	2101      	movs	r1, #1
 802348e:	430b      	orrs	r3, r1
 8023490:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8023492:	2000      	movs	r0, #0
}
 8023494:	b00d      	add	sp, #52	; 0x34
 8023496:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023498:	08034880 	.word	0x08034880
 802349c:	ffff9fff 	.word	0xffff9fff

080234a0 <HAL_CRYP_Init>:
{
 80234a0:	b510      	push	{r4, lr}
 80234a2:	1e04      	subs	r4, r0, #0
  if (hcryp == NULL)
 80234a4:	d01d      	beq.n	80234e2 <HAL_CRYP_Init+0x42>
  if (hcryp->State == HAL_CRYP_STATE_RESET)
 80234a6:	2351      	movs	r3, #81	; 0x51
 80234a8:	5cc3      	ldrb	r3, [r0, r3]
 80234aa:	2b00      	cmp	r3, #0
 80234ac:	d013      	beq.n	80234d6 <HAL_CRYP_Init+0x36>
  MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 80234ae:	6821      	ldr	r1, [r4, #0]
 80234b0:	680b      	ldr	r3, [r1, #0]
 80234b2:	4a0d      	ldr	r2, [pc, #52]	; (80234e8 <HAL_CRYP_Init+0x48>)
 80234b4:	4013      	ands	r3, r2
 80234b6:	6862      	ldr	r2, [r4, #4]
 80234b8:	68a0      	ldr	r0, [r4, #8]
 80234ba:	4302      	orrs	r2, r0
 80234bc:	6960      	ldr	r0, [r4, #20]
 80234be:	4302      	orrs	r2, r0
 80234c0:	4313      	orrs	r3, r2
 80234c2:	600b      	str	r3, [r1, #0]
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 80234c4:	2300      	movs	r3, #0
 80234c6:	6563      	str	r3, [r4, #84]	; 0x54
  hcryp->KeyIVConfig = 0U;
 80234c8:	65a3      	str	r3, [r4, #88]	; 0x58
  hcryp->State = HAL_CRYP_STATE_READY;
 80234ca:	3301      	adds	r3, #1
 80234cc:	2251      	movs	r2, #81	; 0x51
 80234ce:	54a3      	strb	r3, [r4, r2]
  hcryp->Phase = CRYP_PHASE_READY;
 80234d0:	6463      	str	r3, [r4, #68]	; 0x44
  return HAL_OK;
 80234d2:	2000      	movs	r0, #0
}
 80234d4:	bd10      	pop	{r4, pc}
    hcryp->Lock = HAL_UNLOCKED;
 80234d6:	3350      	adds	r3, #80	; 0x50
 80234d8:	2200      	movs	r2, #0
 80234da:	54c2      	strb	r2, [r0, r3]
    HAL_CRYP_MspInit(hcryp);
 80234dc:	f7fe f81a 	bl	8021514 <HAL_CRYP_MspInit>
 80234e0:	e7e5      	b.n	80234ae <HAL_CRYP_Init+0xe>
    return HAL_ERROR;
 80234e2:	2001      	movs	r0, #1
 80234e4:	e7f6      	b.n	80234d4 <HAL_CRYP_Init+0x34>
 80234e6:	46c0      	nop			; (mov r8, r8)
 80234e8:	fffaff99 	.word	0xfffaff99

080234ec <HAL_CRYP_DeInit>:
{
 80234ec:	b570      	push	{r4, r5, r6, lr}
 80234ee:	1e04      	subs	r4, r0, #0
  if (hcryp == NULL)
 80234f0:	d013      	beq.n	802351a <HAL_CRYP_DeInit+0x2e>
  hcryp->Phase = CRYP_PHASE_READY;
 80234f2:	2101      	movs	r1, #1
 80234f4:	6441      	str	r1, [r0, #68]	; 0x44
  hcryp->CrypInCount = 0;
 80234f6:	2300      	movs	r3, #0
 80234f8:	2500      	movs	r5, #0
 80234fa:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->CrypOutCount = 0;
 80234fc:	2240      	movs	r2, #64	; 0x40
 80234fe:	5283      	strh	r3, [r0, r2]
  hcryp->CrypHeaderCount = 0;
 8023500:	8783      	strh	r3, [r0, #60]	; 0x3c
  __HAL_CRYP_DISABLE(hcryp);
 8023502:	6802      	ldr	r2, [r0, #0]
 8023504:	6813      	ldr	r3, [r2, #0]
 8023506:	438b      	bics	r3, r1
 8023508:	6013      	str	r3, [r2, #0]
  HAL_CRYP_MspDeInit(hcryp);
 802350a:	f7fe f821 	bl	8021550 <HAL_CRYP_MspDeInit>
  hcryp->State = HAL_CRYP_STATE_RESET;
 802350e:	2351      	movs	r3, #81	; 0x51
 8023510:	54e5      	strb	r5, [r4, r3]
  __HAL_UNLOCK(hcryp);
 8023512:	3b01      	subs	r3, #1
 8023514:	54e5      	strb	r5, [r4, r3]
  return HAL_OK;
 8023516:	2000      	movs	r0, #0
}
 8023518:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 802351a:	2001      	movs	r0, #1
 802351c:	e7fc      	b.n	8023518 <HAL_CRYP_DeInit+0x2c>

0802351e <HAL_CRYP_ErrorCallback>:
}
 802351e:	4770      	bx	lr

08023520 <CRYP_AES_ProcessData>:
{
 8023520:	b530      	push	{r4, r5, lr}
 8023522:	b085      	sub	sp, #20
 8023524:	0004      	movs	r4, r0
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8023526:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8023528:	009b      	lsls	r3, r3, #2
 802352a:	6802      	ldr	r2, [r0, #0]
 802352c:	6b40      	ldr	r0, [r0, #52]	; 0x34
 802352e:	58c3      	ldr	r3, [r0, r3]
 8023530:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 8023532:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023534:	3301      	adds	r3, #1
 8023536:	b29b      	uxth	r3, r3
 8023538:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 802353a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 802353c:	009b      	lsls	r3, r3, #2
 802353e:	6822      	ldr	r2, [r4, #0]
 8023540:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8023542:	58c3      	ldr	r3, [r0, r3]
 8023544:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 8023546:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023548:	3301      	adds	r3, #1
 802354a:	b29b      	uxth	r3, r3
 802354c:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 802354e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023550:	009b      	lsls	r3, r3, #2
 8023552:	6822      	ldr	r2, [r4, #0]
 8023554:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8023556:	58c3      	ldr	r3, [r0, r3]
 8023558:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 802355a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 802355c:	3301      	adds	r3, #1
 802355e:	b29b      	uxth	r3, r3
 8023560:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8023562:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023564:	009b      	lsls	r3, r3, #2
 8023566:	6822      	ldr	r2, [r4, #0]
 8023568:	6b60      	ldr	r0, [r4, #52]	; 0x34
 802356a:	58c3      	ldr	r3, [r0, r3]
 802356c:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 802356e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023570:	3301      	adds	r3, #1
 8023572:	b29b      	uxth	r3, r3
 8023574:	87e3      	strh	r3, [r4, #62]	; 0x3e
  if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023576:	0020      	movs	r0, r4
 8023578:	f7ff fe4f 	bl	802321a <CRYP_WaitOnCCFlag>
 802357c:	2800      	cmp	r0, #0
 802357e:	d106      	bne.n	802358e <CRYP_AES_ProcessData+0x6e>
  __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023580:	6822      	ldr	r2, [r4, #0]
 8023582:	6813      	ldr	r3, [r2, #0]
 8023584:	2180      	movs	r1, #128	; 0x80
 8023586:	430b      	orrs	r3, r1
 8023588:	6013      	str	r3, [r2, #0]
  for (i = 0U; i < 4U; i++)
 802358a:	2300      	movs	r3, #0
 802358c:	e017      	b.n	80235be <CRYP_AES_ProcessData+0x9e>
    __HAL_CRYP_DISABLE(hcryp);
 802358e:	6821      	ldr	r1, [r4, #0]
 8023590:	680b      	ldr	r3, [r1, #0]
 8023592:	2201      	movs	r2, #1
 8023594:	4393      	bics	r3, r2
 8023596:	600b      	str	r3, [r1, #0]
    hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023598:	6d63      	ldr	r3, [r4, #84]	; 0x54
 802359a:	2110      	movs	r1, #16
 802359c:	430b      	orrs	r3, r1
 802359e:	6563      	str	r3, [r4, #84]	; 0x54
    hcryp->State = HAL_CRYP_STATE_READY;
 80235a0:	2351      	movs	r3, #81	; 0x51
 80235a2:	54e2      	strb	r2, [r4, r3]
    __HAL_UNLOCK(hcryp);
 80235a4:	3b01      	subs	r3, #1
 80235a6:	2200      	movs	r2, #0
 80235a8:	54e2      	strb	r2, [r4, r3]
    HAL_CRYP_ErrorCallback(hcryp);
 80235aa:	0020      	movs	r0, r4
 80235ac:	f7ff ffb7 	bl	802351e <HAL_CRYP_ErrorCallback>
 80235b0:	e7e6      	b.n	8023580 <CRYP_AES_ProcessData+0x60>
    temp[i] = hcryp->Instance->DOUTR;
 80235b2:	6822      	ldr	r2, [r4, #0]
 80235b4:	68d1      	ldr	r1, [r2, #12]
 80235b6:	009a      	lsls	r2, r3, #2
 80235b8:	4668      	mov	r0, sp
 80235ba:	5011      	str	r1, [r2, r0]
  for (i = 0U; i < 4U; i++)
 80235bc:	3301      	adds	r3, #1
 80235be:	2b03      	cmp	r3, #3
 80235c0:	d9f7      	bls.n	80235b2 <CRYP_AES_ProcessData+0x92>
  i= 0U;
 80235c2:	2100      	movs	r1, #0
 80235c4:	e00c      	b.n	80235e0 <CRYP_AES_ProcessData+0xc0>
    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[i];
 80235c6:	2240      	movs	r2, #64	; 0x40
 80235c8:	5aa3      	ldrh	r3, [r4, r2]
 80235ca:	009b      	lsls	r3, r3, #2
 80235cc:	0088      	lsls	r0, r1, #2
 80235ce:	466d      	mov	r5, sp
 80235d0:	5940      	ldr	r0, [r0, r5]
 80235d2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 80235d4:	50e8      	str	r0, [r5, r3]
    hcryp->CrypOutCount++;
 80235d6:	5aa3      	ldrh	r3, [r4, r2]
 80235d8:	3301      	adds	r3, #1
 80235da:	b29b      	uxth	r3, r3
 80235dc:	52a3      	strh	r3, [r4, r2]
    i++;
 80235de:	3101      	adds	r1, #1
  while((hcryp->CrypOutCount < ((hcryp->Size + 3U)/4U)) && (i<4U))
 80235e0:	2340      	movs	r3, #64	; 0x40
 80235e2:	5ae2      	ldrh	r2, [r4, r3]
 80235e4:	b292      	uxth	r2, r2
 80235e6:	3302      	adds	r3, #2
 80235e8:	5ae3      	ldrh	r3, [r4, r3]
 80235ea:	3303      	adds	r3, #3
 80235ec:	089b      	lsrs	r3, r3, #2
 80235ee:	429a      	cmp	r2, r3
 80235f0:	d201      	bcs.n	80235f6 <CRYP_AES_ProcessData+0xd6>
 80235f2:	2903      	cmp	r1, #3
 80235f4:	d9e7      	bls.n	80235c6 <CRYP_AES_ProcessData+0xa6>
}
 80235f6:	b005      	add	sp, #20
 80235f8:	bd30      	pop	{r4, r5, pc}

080235fa <CRYP_AES_Encrypt>:
{
 80235fa:	b570      	push	{r4, r5, r6, lr}
 80235fc:	0004      	movs	r4, r0
 80235fe:	000d      	movs	r5, r1
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 8023600:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8023602:	2b01      	cmp	r3, #1
 8023604:	d104      	bne.n	8023610 <CRYP_AES_Encrypt+0x16>
    if (hcryp->KeyIVConfig == 1U)
 8023606:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8023608:	2b01      	cmp	r3, #1
 802360a:	d018      	beq.n	802363e <CRYP_AES_Encrypt+0x44>
      hcryp->KeyIVConfig = 1U;
 802360c:	2301      	movs	r3, #1
 802360e:	6583      	str	r3, [r0, #88]	; 0x58
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023610:	68a1      	ldr	r1, [r4, #8]
 8023612:	0020      	movs	r0, r4
 8023614:	f7ff fdc8 	bl	80231a8 <CRYP_SetKey>
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 8023618:	6963      	ldr	r3, [r4, #20]
 802361a:	2b00      	cmp	r3, #0
 802361c:	d00f      	beq.n	802363e <CRYP_AES_Encrypt+0x44>
      hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 802361e:	6922      	ldr	r2, [r4, #16]
 8023620:	6823      	ldr	r3, [r4, #0]
 8023622:	6812      	ldr	r2, [r2, #0]
 8023624:	62da      	str	r2, [r3, #44]	; 0x2c
      hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 8023626:	6922      	ldr	r2, [r4, #16]
 8023628:	6823      	ldr	r3, [r4, #0]
 802362a:	6852      	ldr	r2, [r2, #4]
 802362c:	629a      	str	r2, [r3, #40]	; 0x28
      hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 802362e:	6922      	ldr	r2, [r4, #16]
 8023630:	6823      	ldr	r3, [r4, #0]
 8023632:	6892      	ldr	r2, [r2, #8]
 8023634:	625a      	str	r2, [r3, #36]	; 0x24
      hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 8023636:	6922      	ldr	r2, [r4, #16]
 8023638:	6823      	ldr	r3, [r4, #0]
 802363a:	68d2      	ldr	r2, [r2, #12]
 802363c:	621a      	str	r2, [r3, #32]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 802363e:	2302      	movs	r3, #2
 8023640:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_CRYP_ENABLE(hcryp);
 8023642:	6822      	ldr	r2, [r4, #0]
 8023644:	6813      	ldr	r3, [r2, #0]
 8023646:	2101      	movs	r1, #1
 8023648:	430b      	orrs	r3, r1
 802364a:	6013      	str	r3, [r2, #0]
  incount = hcryp->CrypInCount;
 802364c:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 802364e:	b292      	uxth	r2, r2
  outcount = hcryp->CrypOutCount;
 8023650:	2340      	movs	r3, #64	; 0x40
 8023652:	5ae0      	ldrh	r0, [r4, r3]
 8023654:	b280      	uxth	r0, r0
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 8023656:	e008      	b.n	802366a <CRYP_AES_Encrypt+0x70>
    CRYP_AES_ProcessData(hcryp, Timeout);
 8023658:	0029      	movs	r1, r5
 802365a:	0020      	movs	r0, r4
 802365c:	f7ff ff60 	bl	8023520 <CRYP_AES_ProcessData>
    incount = hcryp->CrypInCount;
 8023660:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8023662:	b292      	uxth	r2, r2
    outcount = hcryp->CrypOutCount;
 8023664:	2340      	movs	r3, #64	; 0x40
 8023666:	5ae0      	ldrh	r0, [r4, r3]
 8023668:	b280      	uxth	r0, r0
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 802366a:	2342      	movs	r3, #66	; 0x42
 802366c:	5ae3      	ldrh	r3, [r4, r3]
 802366e:	089b      	lsrs	r3, r3, #2
 8023670:	4293      	cmp	r3, r2
 8023672:	d901      	bls.n	8023678 <CRYP_AES_Encrypt+0x7e>
 8023674:	4283      	cmp	r3, r0
 8023676:	d8ef      	bhi.n	8023658 <CRYP_AES_Encrypt+0x5e>
  __HAL_CRYP_DISABLE(hcryp);
 8023678:	6821      	ldr	r1, [r4, #0]
 802367a:	680b      	ldr	r3, [r1, #0]
 802367c:	2201      	movs	r2, #1
 802367e:	4393      	bics	r3, r2
 8023680:	600b      	str	r3, [r1, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 8023682:	2351      	movs	r3, #81	; 0x51
 8023684:	54e2      	strb	r2, [r4, r3]
}
 8023686:	2000      	movs	r0, #0
 8023688:	bd70      	pop	{r4, r5, r6, pc}
	...

0802368c <CRYP_AESCCM_Process>:
{
 802368c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802368e:	b085      	sub	sp, #20
 8023690:	0004      	movs	r4, r0
 8023692:	000d      	movs	r5, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 8023694:	2342      	movs	r3, #66	; 0x42
 8023696:	5ac3      	ldrh	r3, [r0, r3]
 8023698:	089e      	lsrs	r6, r3, #2
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 802369a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 802369c:	2a01      	cmp	r2, #1
 802369e:	d033      	beq.n	8023708 <CRYP_AESCCM_Process+0x7c>
    hcryp->SizesSum = hcryp->Size;
 80236a0:	65c3      	str	r3, [r0, #92]	; 0x5c
    hcryp->CrypHeaderCount = 0U;
 80236a2:	2300      	movs	r3, #0
 80236a4:	87a3      	strh	r3, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 80236a6:	6822      	ldr	r2, [r4, #0]
 80236a8:	6813      	ldr	r3, [r2, #0]
 80236aa:	497b      	ldr	r1, [pc, #492]	; (8023898 <CRYP_AESCCM_Process+0x20c>)
 80236ac:	400b      	ands	r3, r1
 80236ae:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80236b0:	68a1      	ldr	r1, [r4, #8]
 80236b2:	0020      	movs	r0, r4
 80236b4:	f7ff fd78 	bl	80231a8 <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.B0);
 80236b8:	6a22      	ldr	r2, [r4, #32]
 80236ba:	6823      	ldr	r3, [r4, #0]
 80236bc:	6812      	ldr	r2, [r2, #0]
 80236be:	62da      	str	r2, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.B0 + 1U);
 80236c0:	6a22      	ldr	r2, [r4, #32]
 80236c2:	6823      	ldr	r3, [r4, #0]
 80236c4:	6852      	ldr	r2, [r2, #4]
 80236c6:	629a      	str	r2, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.B0 + 2U);
 80236c8:	6a22      	ldr	r2, [r4, #32]
 80236ca:	6823      	ldr	r3, [r4, #0]
 80236cc:	6892      	ldr	r2, [r2, #8]
 80236ce:	625a      	str	r2, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.B0 + 3U);
 80236d0:	6a22      	ldr	r2, [r4, #32]
 80236d2:	6823      	ldr	r3, [r4, #0]
 80236d4:	68d2      	ldr	r2, [r2, #12]
 80236d6:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 80236d8:	6822      	ldr	r2, [r4, #0]
 80236da:	6813      	ldr	r3, [r2, #0]
 80236dc:	2101      	movs	r1, #1
 80236de:	430b      	orrs	r3, r1
 80236e0:	6013      	str	r3, [r2, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80236e2:	0029      	movs	r1, r5
 80236e4:	0020      	movs	r0, r4
 80236e6:	f7ff fd98 	bl	802321a <CRYP_WaitOnCCFlag>
 80236ea:	2800      	cmp	r0, #0
 80236ec:	d018      	beq.n	8023720 <CRYP_AESCCM_Process+0x94>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80236ee:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80236f0:	2210      	movs	r2, #16
 80236f2:	4313      	orrs	r3, r2
 80236f4:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 80236f6:	2351      	movs	r3, #81	; 0x51
 80236f8:	3a0f      	subs	r2, #15
 80236fa:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 80236fc:	3b01      	subs	r3, #1
 80236fe:	2200      	movs	r2, #0
 8023700:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 8023702:	2001      	movs	r0, #1
}
 8023704:	b005      	add	sp, #20
 8023706:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (hcryp->KeyIVConfig == 1U)
 8023708:	6d82      	ldr	r2, [r0, #88]	; 0x58
 802370a:	2a01      	cmp	r2, #1
 802370c:	d003      	beq.n	8023716 <CRYP_AESCCM_Process+0x8a>
      hcryp->KeyIVConfig = 1U;
 802370e:	2201      	movs	r2, #1
 8023710:	6582      	str	r2, [r0, #88]	; 0x58
      hcryp->SizesSum = hcryp->Size; /* Merely store payload length */
 8023712:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 8023714:	e7c5      	b.n	80236a2 <CRYP_AESCCM_Process+0x16>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 8023716:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8023718:	4694      	mov	ip, r2
 802371a:	4463      	add	r3, ip
 802371c:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 802371e:	e01a      	b.n	8023756 <CRYP_AESCCM_Process+0xca>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023720:	6822      	ldr	r2, [r4, #0]
 8023722:	6813      	ldr	r3, [r2, #0]
 8023724:	2180      	movs	r1, #128	; 0x80
 8023726:	430b      	orrs	r3, r1
 8023728:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 802372a:	0029      	movs	r1, r5
 802372c:	0020      	movs	r0, r4
 802372e:	f7ff fd8d 	bl	802324c <CRYP_GCMCCM_SetHeaderPhase>
 8023732:	2800      	cmp	r0, #0
 8023734:	d000      	beq.n	8023738 <CRYP_AESCCM_Process+0xac>
 8023736:	e0ab      	b.n	8023890 <CRYP_AESCCM_Process+0x204>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 8023738:	2302      	movs	r3, #2
 802373a:	6463      	str	r3, [r4, #68]	; 0x44
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 802373c:	6821      	ldr	r1, [r4, #0]
 802373e:	680b      	ldr	r3, [r1, #0]
 8023740:	4a55      	ldr	r2, [pc, #340]	; (8023898 <CRYP_AESCCM_Process+0x20c>)
 8023742:	401a      	ands	r2, r3
 8023744:	2380      	movs	r3, #128	; 0x80
 8023746:	01db      	lsls	r3, r3, #7
 8023748:	4313      	orrs	r3, r2
 802374a:	600b      	str	r3, [r1, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 802374c:	6822      	ldr	r2, [r4, #0]
 802374e:	6813      	ldr	r3, [r2, #0]
 8023750:	4952      	ldr	r1, [pc, #328]	; (802389c <CRYP_AESCCM_Process+0x210>)
 8023752:	400b      	ands	r3, r1
 8023754:	6013      	str	r3, [r2, #0]
  if ((hcryp->Size % 16U) != 0U)
 8023756:	2342      	movs	r3, #66	; 0x42
 8023758:	5ae3      	ldrh	r3, [r4, r3]
 802375a:	071b      	lsls	r3, r3, #28
 802375c:	d001      	beq.n	8023762 <CRYP_AESCCM_Process+0xd6>
    wordsize = ((wordsize / 4U) * 4U) ;
 802375e:	2303      	movs	r3, #3
 8023760:	439e      	bics	r6, r3
  tickstart = HAL_GetTick();
 8023762:	f7fe fa3d 	bl	8021be0 <HAL_GetTick>
 8023766:	0007      	movs	r7, r0
  incount = hcryp->CrypInCount;
 8023768:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 802376a:	b29b      	uxth	r3, r3
  outcount = hcryp->CrypOutCount;
 802376c:	2240      	movs	r2, #64	; 0x40
 802376e:	5aa2      	ldrh	r2, [r4, r2]
 8023770:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 8023772:	e004      	b.n	802377e <CRYP_AESCCM_Process+0xf2>
    incount = hcryp->CrypInCount;
 8023774:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023776:	b29b      	uxth	r3, r3
    outcount = hcryp->CrypOutCount;
 8023778:	2240      	movs	r2, #64	; 0x40
 802377a:	5aa2      	ldrh	r2, [r4, r2]
 802377c:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 802377e:	429e      	cmp	r6, r3
 8023780:	d91e      	bls.n	80237c0 <CRYP_AESCCM_Process+0x134>
 8023782:	4296      	cmp	r6, r2
 8023784:	d91c      	bls.n	80237c0 <CRYP_AESCCM_Process+0x134>
    CRYP_AES_ProcessData(hcryp, Timeout);
 8023786:	0029      	movs	r1, r5
 8023788:	0020      	movs	r0, r4
 802378a:	f7ff fec9 	bl	8023520 <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 802378e:	1c6b      	adds	r3, r5, #1
 8023790:	d0f0      	beq.n	8023774 <CRYP_AESCCM_Process+0xe8>
      if (((HAL_GetTick() - tickstart) > Timeout) ||(Timeout == 0U))
 8023792:	f7fe fa25 	bl	8021be0 <HAL_GetTick>
 8023796:	1bc0      	subs	r0, r0, r7
 8023798:	42a8      	cmp	r0, r5
 802379a:	d801      	bhi.n	80237a0 <CRYP_AESCCM_Process+0x114>
 802379c:	2d00      	cmp	r5, #0
 802379e:	d1e9      	bne.n	8023774 <CRYP_AESCCM_Process+0xe8>
        __HAL_CRYP_DISABLE(hcryp);
 80237a0:	6821      	ldr	r1, [r4, #0]
 80237a2:	680b      	ldr	r3, [r1, #0]
 80237a4:	2201      	movs	r2, #1
 80237a6:	4393      	bics	r3, r2
 80237a8:	600b      	str	r3, [r1, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80237aa:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80237ac:	2110      	movs	r1, #16
 80237ae:	430b      	orrs	r3, r1
 80237b0:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 80237b2:	2351      	movs	r3, #81	; 0x51
 80237b4:	54e2      	strb	r2, [r4, r3]
        __HAL_UNLOCK(hcryp);
 80237b6:	3b01      	subs	r3, #1
 80237b8:	2200      	movs	r2, #0
 80237ba:	54e2      	strb	r2, [r4, r3]
        return HAL_ERROR;
 80237bc:	2001      	movs	r0, #1
 80237be:	e7a1      	b.n	8023704 <CRYP_AESCCM_Process+0x78>
  if ((hcryp->Size % 16U) != 0U)
 80237c0:	2342      	movs	r3, #66	; 0x42
 80237c2:	5ae3      	ldrh	r3, [r4, r3]
 80237c4:	071a      	lsls	r2, r3, #28
 80237c6:	d065      	beq.n	8023894 <CRYP_AESCCM_Process+0x208>
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 80237c8:	091e      	lsrs	r6, r3, #4
 80237ca:	3601      	adds	r6, #1
 80237cc:	0136      	lsls	r6, r6, #4
 80237ce:	1af7      	subs	r7, r6, r3
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_DECRYPT)
 80237d0:	6820      	ldr	r0, [r4, #0]
 80237d2:	6801      	ldr	r1, [r0, #0]
 80237d4:	2218      	movs	r2, #24
 80237d6:	400a      	ands	r2, r1
 80237d8:	2a10      	cmp	r2, #16
 80237da:	d006      	beq.n	80237ea <CRYP_AESCCM_Process+0x15e>
    if ((npblb % 4U) == 0U)
 80237dc:	07ba      	lsls	r2, r7, #30
 80237de:	d10b      	bne.n	80237f8 <CRYP_AESCCM_Process+0x16c>
      lastwordsize = (16U - npblb) / 4U;
 80237e0:	1b9e      	subs	r6, r3, r6
 80237e2:	3610      	adds	r6, #16
 80237e4:	08b6      	lsrs	r6, r6, #2
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 80237e6:	2200      	movs	r2, #0
 80237e8:	e016      	b.n	8023818 <CRYP_AESCCM_Process+0x18c>
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 80237ea:	6802      	ldr	r2, [r0, #0]
 80237ec:	492b      	ldr	r1, [pc, #172]	; (802389c <CRYP_AESCCM_Process+0x210>)
 80237ee:	400a      	ands	r2, r1
 80237f0:	0539      	lsls	r1, r7, #20
 80237f2:	430a      	orrs	r2, r1
 80237f4:	6002      	str	r2, [r0, #0]
 80237f6:	e7f1      	b.n	80237dc <CRYP_AESCCM_Process+0x150>
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 80237f8:	1b9e      	subs	r6, r3, r6
 80237fa:	3610      	adds	r6, #16
 80237fc:	08b6      	lsrs	r6, r6, #2
 80237fe:	3601      	adds	r6, #1
 8023800:	e7f1      	b.n	80237e6 <CRYP_AESCCM_Process+0x15a>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8023802:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023804:	009b      	lsls	r3, r3, #2
 8023806:	6821      	ldr	r1, [r4, #0]
 8023808:	6b60      	ldr	r0, [r4, #52]	; 0x34
 802380a:	58c3      	ldr	r3, [r0, r3]
 802380c:	608b      	str	r3, [r1, #8]
      hcryp->CrypInCount++;
 802380e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023810:	3301      	adds	r3, #1
 8023812:	b29b      	uxth	r3, r3
 8023814:	87e3      	strh	r3, [r4, #62]	; 0x3e
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 8023816:	3201      	adds	r2, #1
 8023818:	42b2      	cmp	r2, r6
 802381a:	d3f2      	bcc.n	8023802 <CRYP_AESCCM_Process+0x176>
 802381c:	e003      	b.n	8023826 <CRYP_AESCCM_Process+0x19a>
      hcryp->Instance->DINR  = 0U;
 802381e:	6823      	ldr	r3, [r4, #0]
 8023820:	2100      	movs	r1, #0
 8023822:	6099      	str	r1, [r3, #8]
      loopcounter++;
 8023824:	3201      	adds	r2, #1
    while (loopcounter < 4U)
 8023826:	2a03      	cmp	r2, #3
 8023828:	d9f9      	bls.n	802381e <CRYP_AESCCM_Process+0x192>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 802382a:	0029      	movs	r1, r5
 802382c:	0020      	movs	r0, r4
 802382e:	f7ff fcf4 	bl	802321a <CRYP_WaitOnCCFlag>
 8023832:	2800      	cmp	r0, #0
 8023834:	d106      	bne.n	8023844 <CRYP_AESCCM_Process+0x1b8>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023836:	6822      	ldr	r2, [r4, #0]
 8023838:	6813      	ldr	r3, [r2, #0]
 802383a:	2180      	movs	r1, #128	; 0x80
 802383c:	430b      	orrs	r3, r1
 802383e:	6013      	str	r3, [r2, #0]
    for (loopcounter = 0U; loopcounter < 4U; loopcounter++)
 8023840:	2300      	movs	r3, #0
 8023842:	e011      	b.n	8023868 <CRYP_AESCCM_Process+0x1dc>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023844:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023846:	2210      	movs	r2, #16
 8023848:	4313      	orrs	r3, r2
 802384a:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 802384c:	2351      	movs	r3, #81	; 0x51
 802384e:	3a0f      	subs	r2, #15
 8023850:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023852:	3b01      	subs	r3, #1
 8023854:	2200      	movs	r2, #0
 8023856:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 8023858:	2001      	movs	r0, #1
 802385a:	e753      	b.n	8023704 <CRYP_AESCCM_Process+0x78>
      temp[loopcounter] = hcryp->Instance->DOUTR;
 802385c:	6822      	ldr	r2, [r4, #0]
 802385e:	68d1      	ldr	r1, [r2, #12]
 8023860:	009a      	lsls	r2, r3, #2
 8023862:	466d      	mov	r5, sp
 8023864:	5151      	str	r1, [r2, r5]
    for (loopcounter = 0U; loopcounter < 4U; loopcounter++)
 8023866:	3301      	adds	r3, #1
 8023868:	2b03      	cmp	r3, #3
 802386a:	d9f7      	bls.n	802385c <CRYP_AESCCM_Process+0x1d0>
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 802386c:	2200      	movs	r2, #0
 802386e:	e00c      	b.n	802388a <CRYP_AESCCM_Process+0x1fe>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[loopcounter];
 8023870:	2140      	movs	r1, #64	; 0x40
 8023872:	5a63      	ldrh	r3, [r4, r1]
 8023874:	009b      	lsls	r3, r3, #2
 8023876:	0095      	lsls	r5, r2, #2
 8023878:	466f      	mov	r7, sp
 802387a:	59ed      	ldr	r5, [r5, r7]
 802387c:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 802387e:	50fd      	str	r5, [r7, r3]
      hcryp->CrypOutCount++;
 8023880:	5a63      	ldrh	r3, [r4, r1]
 8023882:	3301      	adds	r3, #1
 8023884:	b29b      	uxth	r3, r3
 8023886:	5263      	strh	r3, [r4, r1]
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 8023888:	3201      	adds	r2, #1
 802388a:	42b2      	cmp	r2, r6
 802388c:	d3f0      	bcc.n	8023870 <CRYP_AESCCM_Process+0x1e4>
 802388e:	e739      	b.n	8023704 <CRYP_AESCCM_Process+0x78>
      return HAL_ERROR;
 8023890:	2001      	movs	r0, #1
 8023892:	e737      	b.n	8023704 <CRYP_AESCCM_Process+0x78>
  return HAL_OK;
 8023894:	2000      	movs	r0, #0
 8023896:	e735      	b.n	8023704 <CRYP_AESCCM_Process+0x78>
 8023898:	ffff9fff 	.word	0xffff9fff
 802389c:	ff0fffff 	.word	0xff0fffff

080238a0 <CRYP_AES_Decrypt>:
{
 80238a0:	b570      	push	{r4, r5, r6, lr}
 80238a2:	0004      	movs	r4, r0
 80238a4:	000d      	movs	r5, r1
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 80238a6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80238a8:	2b01      	cmp	r3, #1
 80238aa:	d029      	beq.n	8023900 <CRYP_AES_Decrypt+0x60>
    if (hcryp->Init.Algorithm != CRYP_AES_CTR)   /*ECB or CBC*/
 80238ac:	6963      	ldr	r3, [r4, #20]
 80238ae:	2b40      	cmp	r3, #64	; 0x40
 80238b0:	d075      	beq.n	802399e <CRYP_AES_Decrypt+0xfe>
      if (hcryp->AutoKeyDerivation == DISABLE)/*Mode 2 Key preparation*/
 80238b2:	2330      	movs	r3, #48	; 0x30
 80238b4:	5ce3      	ldrb	r3, [r4, r3]
 80238b6:	2b00      	cmp	r3, #0
 80238b8:	d138      	bne.n	802392c <CRYP_AES_Decrypt+0x8c>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 80238ba:	6822      	ldr	r2, [r4, #0]
 80238bc:	6813      	ldr	r3, [r2, #0]
 80238be:	2118      	movs	r1, #24
 80238c0:	438b      	bics	r3, r1
 80238c2:	3910      	subs	r1, #16
 80238c4:	430b      	orrs	r3, r1
 80238c6:	6013      	str	r3, [r2, #0]
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80238c8:	68a1      	ldr	r1, [r4, #8]
 80238ca:	0020      	movs	r0, r4
 80238cc:	f7ff fc6c 	bl	80231a8 <CRYP_SetKey>
        __HAL_CRYP_ENABLE(hcryp);
 80238d0:	6822      	ldr	r2, [r4, #0]
 80238d2:	6813      	ldr	r3, [r2, #0]
 80238d4:	2101      	movs	r1, #1
 80238d6:	430b      	orrs	r3, r1
 80238d8:	6013      	str	r3, [r2, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80238da:	0029      	movs	r1, r5
 80238dc:	0020      	movs	r0, r4
 80238de:	f7ff fc9c 	bl	802321a <CRYP_WaitOnCCFlag>
 80238e2:	2800      	cmp	r0, #0
 80238e4:	d112      	bne.n	802390c <CRYP_AES_Decrypt+0x6c>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 80238e6:	6822      	ldr	r2, [r4, #0]
 80238e8:	6813      	ldr	r3, [r2, #0]
 80238ea:	2180      	movs	r1, #128	; 0x80
 80238ec:	430b      	orrs	r3, r1
 80238ee:	6013      	str	r3, [r2, #0]
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 80238f0:	6822      	ldr	r2, [r4, #0]
 80238f2:	6813      	ldr	r3, [r2, #0]
 80238f4:	3968      	subs	r1, #104	; 0x68
 80238f6:	438b      	bics	r3, r1
 80238f8:	3908      	subs	r1, #8
 80238fa:	430b      	orrs	r3, r1
 80238fc:	6013      	str	r3, [r2, #0]
 80238fe:	e01e      	b.n	802393e <CRYP_AES_Decrypt+0x9e>
    if (hcryp->KeyIVConfig == 1U)
 8023900:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8023902:	2b01      	cmp	r3, #1
 8023904:	d02e      	beq.n	8023964 <CRYP_AES_Decrypt+0xc4>
      hcryp->KeyIVConfig = 1U;
 8023906:	2301      	movs	r3, #1
 8023908:	6583      	str	r3, [r0, #88]	; 0x58
  if (DoKeyIVConfig == 1U)
 802390a:	e7cf      	b.n	80238ac <CRYP_AES_Decrypt+0xc>
          __HAL_CRYP_DISABLE(hcryp);
 802390c:	6821      	ldr	r1, [r4, #0]
 802390e:	680b      	ldr	r3, [r1, #0]
 8023910:	2201      	movs	r2, #1
 8023912:	4393      	bics	r3, r2
 8023914:	600b      	str	r3, [r1, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023916:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023918:	2110      	movs	r1, #16
 802391a:	430b      	orrs	r3, r1
 802391c:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 802391e:	2351      	movs	r3, #81	; 0x51
 8023920:	54e2      	strb	r2, [r4, r3]
          __HAL_UNLOCK(hcryp);
 8023922:	3b01      	subs	r3, #1
 8023924:	2200      	movs	r2, #0
 8023926:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 8023928:	2001      	movs	r0, #1
 802392a:	e045      	b.n	80239b8 <CRYP_AES_Decrypt+0x118>
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 802392c:	68a1      	ldr	r1, [r4, #8]
 802392e:	0020      	movs	r0, r4
 8023930:	f7ff fc3a 	bl	80231a8 <CRYP_SetKey>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION_DECRYPT);
 8023934:	6822      	ldr	r2, [r4, #0]
 8023936:	6813      	ldr	r3, [r2, #0]
 8023938:	2118      	movs	r1, #24
 802393a:	430b      	orrs	r3, r1
 802393c:	6013      	str	r3, [r2, #0]
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 802393e:	6963      	ldr	r3, [r4, #20]
 8023940:	2b00      	cmp	r3, #0
 8023942:	d00f      	beq.n	8023964 <CRYP_AES_Decrypt+0xc4>
      hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 8023944:	6922      	ldr	r2, [r4, #16]
 8023946:	6823      	ldr	r3, [r4, #0]
 8023948:	6812      	ldr	r2, [r2, #0]
 802394a:	62da      	str	r2, [r3, #44]	; 0x2c
      hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 802394c:	6922      	ldr	r2, [r4, #16]
 802394e:	6823      	ldr	r3, [r4, #0]
 8023950:	6852      	ldr	r2, [r2, #4]
 8023952:	629a      	str	r2, [r3, #40]	; 0x28
      hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 8023954:	6922      	ldr	r2, [r4, #16]
 8023956:	6823      	ldr	r3, [r4, #0]
 8023958:	6892      	ldr	r2, [r2, #8]
 802395a:	625a      	str	r2, [r3, #36]	; 0x24
      hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 802395c:	6922      	ldr	r2, [r4, #16]
 802395e:	6823      	ldr	r3, [r4, #0]
 8023960:	68d2      	ldr	r2, [r2, #12]
 8023962:	621a      	str	r2, [r3, #32]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 8023964:	2302      	movs	r3, #2
 8023966:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_CRYP_ENABLE(hcryp);
 8023968:	6822      	ldr	r2, [r4, #0]
 802396a:	6813      	ldr	r3, [r2, #0]
 802396c:	2101      	movs	r1, #1
 802396e:	430b      	orrs	r3, r1
 8023970:	6013      	str	r3, [r2, #0]
  incount = hcryp->CrypInCount;
 8023972:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8023974:	b292      	uxth	r2, r2
  outcount = hcryp->CrypOutCount;
 8023976:	2340      	movs	r3, #64	; 0x40
 8023978:	5ae0      	ldrh	r0, [r4, r3]
 802397a:	b280      	uxth	r0, r0
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 802397c:	2342      	movs	r3, #66	; 0x42
 802397e:	5ae3      	ldrh	r3, [r4, r3]
 8023980:	089b      	lsrs	r3, r3, #2
 8023982:	4293      	cmp	r3, r2
 8023984:	d910      	bls.n	80239a8 <CRYP_AES_Decrypt+0x108>
 8023986:	4283      	cmp	r3, r0
 8023988:	d90e      	bls.n	80239a8 <CRYP_AES_Decrypt+0x108>
    CRYP_AES_ProcessData(hcryp, Timeout);
 802398a:	0029      	movs	r1, r5
 802398c:	0020      	movs	r0, r4
 802398e:	f7ff fdc7 	bl	8023520 <CRYP_AES_ProcessData>
    incount = hcryp->CrypInCount;
 8023992:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8023994:	b292      	uxth	r2, r2
    outcount = hcryp->CrypOutCount;
 8023996:	2340      	movs	r3, #64	; 0x40
 8023998:	5ae0      	ldrh	r0, [r4, r3]
 802399a:	b280      	uxth	r0, r0
 802399c:	e7ee      	b.n	802397c <CRYP_AES_Decrypt+0xdc>
      CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 802399e:	68a1      	ldr	r1, [r4, #8]
 80239a0:	0020      	movs	r0, r4
 80239a2:	f7ff fc01 	bl	80231a8 <CRYP_SetKey>
 80239a6:	e7ca      	b.n	802393e <CRYP_AES_Decrypt+0x9e>
  __HAL_CRYP_DISABLE(hcryp);
 80239a8:	6821      	ldr	r1, [r4, #0]
 80239aa:	680b      	ldr	r3, [r1, #0]
 80239ac:	2201      	movs	r2, #1
 80239ae:	4393      	bics	r3, r2
 80239b0:	600b      	str	r3, [r1, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 80239b2:	2351      	movs	r3, #81	; 0x51
 80239b4:	54e2      	strb	r2, [r4, r3]
  return HAL_OK;
 80239b6:	2000      	movs	r0, #0
}
 80239b8:	bd70      	pop	{r4, r5, r6, pc}
	...

080239bc <CRYP_AESGCM_Process>:
{
 80239bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80239be:	b085      	sub	sp, #20
 80239c0:	0004      	movs	r4, r0
 80239c2:	000d      	movs	r5, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 80239c4:	2342      	movs	r3, #66	; 0x42
 80239c6:	5ac3      	ldrh	r3, [r0, r3]
 80239c8:	089e      	lsrs	r6, r3, #2
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 80239ca:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80239cc:	2a01      	cmp	r2, #1
 80239ce:	d033      	beq.n	8023a38 <CRYP_AESGCM_Process+0x7c>
    hcryp->SizesSum = hcryp->Size;
 80239d0:	65c3      	str	r3, [r0, #92]	; 0x5c
    hcryp->CrypHeaderCount = 0U;
 80239d2:	2300      	movs	r3, #0
 80239d4:	87a3      	strh	r3, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 80239d6:	6822      	ldr	r2, [r4, #0]
 80239d8:	6813      	ldr	r3, [r2, #0]
 80239da:	497a      	ldr	r1, [pc, #488]	; (8023bc4 <CRYP_AESGCM_Process+0x208>)
 80239dc:	400b      	ands	r3, r1
 80239de:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80239e0:	68a1      	ldr	r1, [r4, #8]
 80239e2:	0020      	movs	r0, r4
 80239e4:	f7ff fbe0 	bl	80231a8 <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 80239e8:	6922      	ldr	r2, [r4, #16]
 80239ea:	6823      	ldr	r3, [r4, #0]
 80239ec:	6812      	ldr	r2, [r2, #0]
 80239ee:	62da      	str	r2, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 80239f0:	6922      	ldr	r2, [r4, #16]
 80239f2:	6823      	ldr	r3, [r4, #0]
 80239f4:	6852      	ldr	r2, [r2, #4]
 80239f6:	629a      	str	r2, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 80239f8:	6922      	ldr	r2, [r4, #16]
 80239fa:	6823      	ldr	r3, [r4, #0]
 80239fc:	6892      	ldr	r2, [r2, #8]
 80239fe:	625a      	str	r2, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 8023a00:	6922      	ldr	r2, [r4, #16]
 8023a02:	6823      	ldr	r3, [r4, #0]
 8023a04:	68d2      	ldr	r2, [r2, #12]
 8023a06:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 8023a08:	6822      	ldr	r2, [r4, #0]
 8023a0a:	6813      	ldr	r3, [r2, #0]
 8023a0c:	2101      	movs	r1, #1
 8023a0e:	430b      	orrs	r3, r1
 8023a10:	6013      	str	r3, [r2, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023a12:	0029      	movs	r1, r5
 8023a14:	0020      	movs	r0, r4
 8023a16:	f7ff fc00 	bl	802321a <CRYP_WaitOnCCFlag>
 8023a1a:	2800      	cmp	r0, #0
 8023a1c:	d018      	beq.n	8023a50 <CRYP_AESGCM_Process+0x94>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023a1e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023a20:	2210      	movs	r2, #16
 8023a22:	4313      	orrs	r3, r2
 8023a24:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 8023a26:	2351      	movs	r3, #81	; 0x51
 8023a28:	3a0f      	subs	r2, #15
 8023a2a:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023a2c:	3b01      	subs	r3, #1
 8023a2e:	2200      	movs	r2, #0
 8023a30:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 8023a32:	2001      	movs	r0, #1
}
 8023a34:	b005      	add	sp, #20
 8023a36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (hcryp->KeyIVConfig == 1U)
 8023a38:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8023a3a:	2a01      	cmp	r2, #1
 8023a3c:	d003      	beq.n	8023a46 <CRYP_AESGCM_Process+0x8a>
      hcryp->KeyIVConfig = 1U;
 8023a3e:	2201      	movs	r2, #1
 8023a40:	6582      	str	r2, [r0, #88]	; 0x58
      hcryp->SizesSum = hcryp->Size; /* Merely store payload length */
 8023a42:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 8023a44:	e7c5      	b.n	80239d2 <CRYP_AESGCM_Process+0x16>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 8023a46:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8023a48:	4694      	mov	ip, r2
 8023a4a:	4463      	add	r3, ip
 8023a4c:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 8023a4e:	e01a      	b.n	8023a86 <CRYP_AESGCM_Process+0xca>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023a50:	6822      	ldr	r2, [r4, #0]
 8023a52:	6813      	ldr	r3, [r2, #0]
 8023a54:	2180      	movs	r1, #128	; 0x80
 8023a56:	430b      	orrs	r3, r1
 8023a58:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 8023a5a:	0029      	movs	r1, r5
 8023a5c:	0020      	movs	r0, r4
 8023a5e:	f7ff fbf5 	bl	802324c <CRYP_GCMCCM_SetHeaderPhase>
 8023a62:	2800      	cmp	r0, #0
 8023a64:	d000      	beq.n	8023a68 <CRYP_AESGCM_Process+0xac>
 8023a66:	e0a8      	b.n	8023bba <CRYP_AESGCM_Process+0x1fe>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 8023a68:	2302      	movs	r3, #2
 8023a6a:	6463      	str	r3, [r4, #68]	; 0x44
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 8023a6c:	6821      	ldr	r1, [r4, #0]
 8023a6e:	680b      	ldr	r3, [r1, #0]
 8023a70:	4a54      	ldr	r2, [pc, #336]	; (8023bc4 <CRYP_AESGCM_Process+0x208>)
 8023a72:	401a      	ands	r2, r3
 8023a74:	2380      	movs	r3, #128	; 0x80
 8023a76:	01db      	lsls	r3, r3, #7
 8023a78:	4313      	orrs	r3, r2
 8023a7a:	600b      	str	r3, [r1, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 8023a7c:	6822      	ldr	r2, [r4, #0]
 8023a7e:	6813      	ldr	r3, [r2, #0]
 8023a80:	4951      	ldr	r1, [pc, #324]	; (8023bc8 <CRYP_AESGCM_Process+0x20c>)
 8023a82:	400b      	ands	r3, r1
 8023a84:	6013      	str	r3, [r2, #0]
  if ((hcryp->Size % 16U) != 0U)
 8023a86:	2342      	movs	r3, #66	; 0x42
 8023a88:	5ae3      	ldrh	r3, [r4, r3]
 8023a8a:	071b      	lsls	r3, r3, #28
 8023a8c:	d001      	beq.n	8023a92 <CRYP_AESGCM_Process+0xd6>
    wordsize = ((wordsize / 4U) * 4U) ;
 8023a8e:	2303      	movs	r3, #3
 8023a90:	439e      	bics	r6, r3
  tickstart = HAL_GetTick();
 8023a92:	f7fe f8a5 	bl	8021be0 <HAL_GetTick>
 8023a96:	0007      	movs	r7, r0
  incount = hcryp->CrypInCount;
 8023a98:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023a9a:	b29b      	uxth	r3, r3
  outcount = hcryp->CrypOutCount;
 8023a9c:	2240      	movs	r2, #64	; 0x40
 8023a9e:	5aa2      	ldrh	r2, [r4, r2]
 8023aa0:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 8023aa2:	e004      	b.n	8023aae <CRYP_AESGCM_Process+0xf2>
    incount = hcryp->CrypInCount;
 8023aa4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023aa6:	b29b      	uxth	r3, r3
    outcount = hcryp->CrypOutCount;
 8023aa8:	2240      	movs	r2, #64	; 0x40
 8023aaa:	5aa2      	ldrh	r2, [r4, r2]
 8023aac:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 8023aae:	429e      	cmp	r6, r3
 8023ab0:	d91e      	bls.n	8023af0 <CRYP_AESGCM_Process+0x134>
 8023ab2:	4296      	cmp	r6, r2
 8023ab4:	d91c      	bls.n	8023af0 <CRYP_AESGCM_Process+0x134>
    CRYP_AES_ProcessData(hcryp, Timeout);
 8023ab6:	0029      	movs	r1, r5
 8023ab8:	0020      	movs	r0, r4
 8023aba:	f7ff fd31 	bl	8023520 <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 8023abe:	1c6b      	adds	r3, r5, #1
 8023ac0:	d0f0      	beq.n	8023aa4 <CRYP_AESGCM_Process+0xe8>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8023ac2:	f7fe f88d 	bl	8021be0 <HAL_GetTick>
 8023ac6:	1bc0      	subs	r0, r0, r7
 8023ac8:	42a8      	cmp	r0, r5
 8023aca:	d801      	bhi.n	8023ad0 <CRYP_AESGCM_Process+0x114>
 8023acc:	2d00      	cmp	r5, #0
 8023ace:	d1e9      	bne.n	8023aa4 <CRYP_AESGCM_Process+0xe8>
        __HAL_CRYP_DISABLE(hcryp);
 8023ad0:	6821      	ldr	r1, [r4, #0]
 8023ad2:	680b      	ldr	r3, [r1, #0]
 8023ad4:	2201      	movs	r2, #1
 8023ad6:	4393      	bics	r3, r2
 8023ad8:	600b      	str	r3, [r1, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023ada:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023adc:	2110      	movs	r1, #16
 8023ade:	430b      	orrs	r3, r1
 8023ae0:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 8023ae2:	2351      	movs	r3, #81	; 0x51
 8023ae4:	54e2      	strb	r2, [r4, r3]
        __HAL_UNLOCK(hcryp);
 8023ae6:	3b01      	subs	r3, #1
 8023ae8:	2200      	movs	r2, #0
 8023aea:	54e2      	strb	r2, [r4, r3]
        return HAL_ERROR;
 8023aec:	2001      	movs	r0, #1
 8023aee:	e7a1      	b.n	8023a34 <CRYP_AESGCM_Process+0x78>
  if ((hcryp->Size % 16U) != 0U)
 8023af0:	2342      	movs	r3, #66	; 0x42
 8023af2:	5ae3      	ldrh	r3, [r4, r3]
 8023af4:	071a      	lsls	r2, r3, #28
 8023af6:	d062      	beq.n	8023bbe <CRYP_AESGCM_Process+0x202>
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 8023af8:	091e      	lsrs	r6, r3, #4
 8023afa:	3601      	adds	r6, #1
 8023afc:	0136      	lsls	r6, r6, #4
 8023afe:	1af0      	subs	r0, r6, r3
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_ENCRYPT)
 8023b00:	6822      	ldr	r2, [r4, #0]
 8023b02:	6811      	ldr	r1, [r2, #0]
 8023b04:	2718      	movs	r7, #24
 8023b06:	420f      	tst	r7, r1
 8023b08:	d105      	bne.n	8023b16 <CRYP_AESGCM_Process+0x15a>
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 8023b0a:	6811      	ldr	r1, [r2, #0]
 8023b0c:	4f2e      	ldr	r7, [pc, #184]	; (8023bc8 <CRYP_AESGCM_Process+0x20c>)
 8023b0e:	4039      	ands	r1, r7
 8023b10:	0507      	lsls	r7, r0, #20
 8023b12:	4339      	orrs	r1, r7
 8023b14:	6011      	str	r1, [r2, #0]
    if ((npblb % 4U) == 0U)
 8023b16:	0782      	lsls	r2, r0, #30
 8023b18:	d104      	bne.n	8023b24 <CRYP_AESGCM_Process+0x168>
      lastwordsize = (16U - npblb) / 4U;
 8023b1a:	1b9e      	subs	r6, r3, r6
 8023b1c:	3610      	adds	r6, #16
 8023b1e:	08b6      	lsrs	r6, r6, #2
    for (index = 0U; index < lastwordsize; index ++)
 8023b20:	2200      	movs	r2, #0
 8023b22:	e00f      	b.n	8023b44 <CRYP_AESGCM_Process+0x188>
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 8023b24:	1b9e      	subs	r6, r3, r6
 8023b26:	3610      	adds	r6, #16
 8023b28:	08b6      	lsrs	r6, r6, #2
 8023b2a:	3601      	adds	r6, #1
 8023b2c:	e7f8      	b.n	8023b20 <CRYP_AESGCM_Process+0x164>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8023b2e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023b30:	009b      	lsls	r3, r3, #2
 8023b32:	6821      	ldr	r1, [r4, #0]
 8023b34:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8023b36:	58c3      	ldr	r3, [r0, r3]
 8023b38:	608b      	str	r3, [r1, #8]
      hcryp->CrypInCount++;
 8023b3a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023b3c:	3301      	adds	r3, #1
 8023b3e:	b29b      	uxth	r3, r3
 8023b40:	87e3      	strh	r3, [r4, #62]	; 0x3e
    for (index = 0U; index < lastwordsize; index ++)
 8023b42:	3201      	adds	r2, #1
 8023b44:	42b2      	cmp	r2, r6
 8023b46:	d3f2      	bcc.n	8023b2e <CRYP_AESGCM_Process+0x172>
 8023b48:	e003      	b.n	8023b52 <CRYP_AESGCM_Process+0x196>
      hcryp->Instance->DINR  = 0U;
 8023b4a:	6823      	ldr	r3, [r4, #0]
 8023b4c:	2100      	movs	r1, #0
 8023b4e:	6099      	str	r1, [r3, #8]
      index++;
 8023b50:	3201      	adds	r2, #1
    while (index < 4U)
 8023b52:	2a03      	cmp	r2, #3
 8023b54:	d9f9      	bls.n	8023b4a <CRYP_AESGCM_Process+0x18e>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023b56:	0029      	movs	r1, r5
 8023b58:	0020      	movs	r0, r4
 8023b5a:	f7ff fb5e 	bl	802321a <CRYP_WaitOnCCFlag>
 8023b5e:	2800      	cmp	r0, #0
 8023b60:	d106      	bne.n	8023b70 <CRYP_AESGCM_Process+0x1b4>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023b62:	6822      	ldr	r2, [r4, #0]
 8023b64:	6813      	ldr	r3, [r2, #0]
 8023b66:	2180      	movs	r1, #128	; 0x80
 8023b68:	430b      	orrs	r3, r1
 8023b6a:	6013      	str	r3, [r2, #0]
    for (index = 0U; index < 4U; index++)
 8023b6c:	2300      	movs	r3, #0
 8023b6e:	e00f      	b.n	8023b90 <CRYP_AESGCM_Process+0x1d4>
      hcryp->State = HAL_CRYP_STATE_READY;
 8023b70:	2351      	movs	r3, #81	; 0x51
 8023b72:	2201      	movs	r2, #1
 8023b74:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023b76:	3b01      	subs	r3, #1
 8023b78:	2200      	movs	r2, #0
 8023b7a:	54e2      	strb	r2, [r4, r3]
      HAL_CRYP_ErrorCallback(hcryp);
 8023b7c:	0020      	movs	r0, r4
 8023b7e:	f7ff fcce 	bl	802351e <HAL_CRYP_ErrorCallback>
 8023b82:	e7ee      	b.n	8023b62 <CRYP_AESGCM_Process+0x1a6>
      temp[index] = hcryp->Instance->DOUTR;
 8023b84:	6822      	ldr	r2, [r4, #0]
 8023b86:	68d1      	ldr	r1, [r2, #12]
 8023b88:	009a      	lsls	r2, r3, #2
 8023b8a:	4668      	mov	r0, sp
 8023b8c:	5011      	str	r1, [r2, r0]
    for (index = 0U; index < 4U; index++)
 8023b8e:	3301      	adds	r3, #1
 8023b90:	2b03      	cmp	r3, #3
 8023b92:	d9f7      	bls.n	8023b84 <CRYP_AESGCM_Process+0x1c8>
    for (index = 0U; index < lastwordsize; index++)
 8023b94:	2200      	movs	r2, #0
 8023b96:	e00c      	b.n	8023bb2 <CRYP_AESGCM_Process+0x1f6>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + (hcryp->CrypOutCount)) = temp[index];
 8023b98:	2140      	movs	r1, #64	; 0x40
 8023b9a:	5a63      	ldrh	r3, [r4, r1]
 8023b9c:	009b      	lsls	r3, r3, #2
 8023b9e:	0090      	lsls	r0, r2, #2
 8023ba0:	466d      	mov	r5, sp
 8023ba2:	5940      	ldr	r0, [r0, r5]
 8023ba4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8023ba6:	50e8      	str	r0, [r5, r3]
      hcryp->CrypOutCount++;
 8023ba8:	5a63      	ldrh	r3, [r4, r1]
 8023baa:	3301      	adds	r3, #1
 8023bac:	b29b      	uxth	r3, r3
 8023bae:	5263      	strh	r3, [r4, r1]
    for (index = 0U; index < lastwordsize; index++)
 8023bb0:	3201      	adds	r2, #1
 8023bb2:	42b2      	cmp	r2, r6
 8023bb4:	d3f0      	bcc.n	8023b98 <CRYP_AESGCM_Process+0x1dc>
  return HAL_OK;
 8023bb6:	2000      	movs	r0, #0
 8023bb8:	e73c      	b.n	8023a34 <CRYP_AESGCM_Process+0x78>
      return HAL_ERROR;
 8023bba:	2001      	movs	r0, #1
 8023bbc:	e73a      	b.n	8023a34 <CRYP_AESGCM_Process+0x78>
  return HAL_OK;
 8023bbe:	2000      	movs	r0, #0
 8023bc0:	e738      	b.n	8023a34 <CRYP_AESGCM_Process+0x78>
 8023bc2:	46c0      	nop			; (mov r8, r8)
 8023bc4:	ffff9fff 	.word	0xffff9fff
 8023bc8:	ff0fffff 	.word	0xff0fffff

08023bcc <HAL_CRYP_Encrypt>:
{
 8023bcc:	b570      	push	{r4, r5, r6, lr}
 8023bce:	0004      	movs	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 8023bd0:	2051      	movs	r0, #81	; 0x51
 8023bd2:	5c25      	ldrb	r5, [r4, r0]
 8023bd4:	b2e8      	uxtb	r0, r5
 8023bd6:	2d01      	cmp	r5, #1
 8023bd8:	d005      	beq.n	8023be6 <HAL_CRYP_Encrypt+0x1a>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 8023bda:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023bdc:	2208      	movs	r2, #8
 8023bde:	4313      	orrs	r3, r2
 8023be0:	6563      	str	r3, [r4, #84]	; 0x54
    status = HAL_ERROR;
 8023be2:	2001      	movs	r0, #1
}
 8023be4:	bd70      	pop	{r4, r5, r6, pc}
    hcryp->State = HAL_CRYP_STATE_BUSY;
 8023be6:	3550      	adds	r5, #80	; 0x50
 8023be8:	2602      	movs	r6, #2
 8023bea:	5566      	strb	r6, [r4, r5]
    __HAL_LOCK(hcryp);
 8023bec:	3d01      	subs	r5, #1
 8023bee:	5d65      	ldrb	r5, [r4, r5]
 8023bf0:	2d01      	cmp	r5, #1
 8023bf2:	d043      	beq.n	8023c7c <HAL_CRYP_Encrypt+0xb0>
 8023bf4:	2550      	movs	r5, #80	; 0x50
 8023bf6:	3e01      	subs	r6, #1
 8023bf8:	5566      	strb	r6, [r4, r5]
    hcryp->CrypInCount = 0U;
 8023bfa:	2500      	movs	r5, #0
 8023bfc:	87e5      	strh	r5, [r4, #62]	; 0x3e
    hcryp->CrypOutCount = 0U;
 8023bfe:	363f      	adds	r6, #63	; 0x3f
 8023c00:	53a5      	strh	r5, [r4, r6]
    hcryp->pCrypInBuffPtr = Input;
 8023c02:	6361      	str	r1, [r4, #52]	; 0x34
    hcryp->pCrypOutBuffPtr = Output;
 8023c04:	63a3      	str	r3, [r4, #56]	; 0x38
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 8023c06:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8023c08:	2b00      	cmp	r3, #0
 8023c0a:	d11f      	bne.n	8023c4c <HAL_CRYP_Encrypt+0x80>
      hcryp->Size = Size * 4U;
 8023c0c:	0092      	lsls	r2, r2, #2
 8023c0e:	3342      	adds	r3, #66	; 0x42
 8023c10:	52e2      	strh	r2, [r4, r3]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 8023c12:	6822      	ldr	r2, [r4, #0]
 8023c14:	6813      	ldr	r3, [r2, #0]
 8023c16:	2118      	movs	r1, #24
 8023c18:	438b      	bics	r3, r1
 8023c1a:	6013      	str	r3, [r2, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 8023c1c:	6823      	ldr	r3, [r4, #0]
 8023c1e:	681b      	ldr	r3, [r3, #0]
 8023c20:	4a17      	ldr	r2, [pc, #92]	; (8023c80 <HAL_CRYP_Encrypt+0xb4>)
 8023c22:	4013      	ands	r3, r2
    switch (algo)
 8023c24:	2b60      	cmp	r3, #96	; 0x60
 8023c26:	d024      	beq.n	8023c72 <HAL_CRYP_Encrypt+0xa6>
 8023c28:	d81a      	bhi.n	8023c60 <HAL_CRYP_Encrypt+0x94>
 8023c2a:	2b20      	cmp	r3, #32
 8023c2c:	d001      	beq.n	8023c32 <HAL_CRYP_Encrypt+0x66>
 8023c2e:	2b40      	cmp	r3, #64	; 0x40
 8023c30:	d10f      	bne.n	8023c52 <HAL_CRYP_Encrypt+0x86>
        status = CRYP_AES_Encrypt(hcryp, Timeout);
 8023c32:	9904      	ldr	r1, [sp, #16]
 8023c34:	0020      	movs	r0, r4
 8023c36:	f7ff fce0 	bl	80235fa <CRYP_AES_Encrypt>
    if (status == HAL_OK)
 8023c3a:	2800      	cmp	r0, #0
 8023c3c:	d1d2      	bne.n	8023be4 <HAL_CRYP_Encrypt+0x18>
      hcryp->State = HAL_CRYP_STATE_READY;
 8023c3e:	2351      	movs	r3, #81	; 0x51
 8023c40:	2201      	movs	r2, #1
 8023c42:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023c44:	3b01      	subs	r3, #1
 8023c46:	2200      	movs	r2, #0
 8023c48:	54e2      	strb	r2, [r4, r3]
 8023c4a:	e7cb      	b.n	8023be4 <HAL_CRYP_Encrypt+0x18>
      hcryp->Size = Size;
 8023c4c:	2342      	movs	r3, #66	; 0x42
 8023c4e:	52e2      	strh	r2, [r4, r3]
 8023c50:	e7df      	b.n	8023c12 <HAL_CRYP_Encrypt+0x46>
    switch (algo)
 8023c52:	2b00      	cmp	r3, #0
 8023c54:	d0ed      	beq.n	8023c32 <HAL_CRYP_Encrypt+0x66>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 8023c56:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023c58:	2220      	movs	r2, #32
 8023c5a:	4313      	orrs	r3, r2
 8023c5c:	6563      	str	r3, [r4, #84]	; 0x54
    if (status == HAL_OK)
 8023c5e:	e7c1      	b.n	8023be4 <HAL_CRYP_Encrypt+0x18>
    switch (algo)
 8023c60:	2280      	movs	r2, #128	; 0x80
 8023c62:	0252      	lsls	r2, r2, #9
 8023c64:	4293      	cmp	r3, r2
 8023c66:	d1f6      	bne.n	8023c56 <HAL_CRYP_Encrypt+0x8a>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 8023c68:	9904      	ldr	r1, [sp, #16]
 8023c6a:	0020      	movs	r0, r4
 8023c6c:	f7ff fd0e 	bl	802368c <CRYP_AESCCM_Process>
        break;
 8023c70:	e7e3      	b.n	8023c3a <HAL_CRYP_Encrypt+0x6e>
        status = CRYP_AESGCM_Process(hcryp, Timeout) ;
 8023c72:	9904      	ldr	r1, [sp, #16]
 8023c74:	0020      	movs	r0, r4
 8023c76:	f7ff fea1 	bl	80239bc <CRYP_AESGCM_Process>
        break;
 8023c7a:	e7de      	b.n	8023c3a <HAL_CRYP_Encrypt+0x6e>
    __HAL_LOCK(hcryp);
 8023c7c:	2002      	movs	r0, #2
 8023c7e:	e7b1      	b.n	8023be4 <HAL_CRYP_Encrypt+0x18>
 8023c80:	00010060 	.word	0x00010060

08023c84 <HAL_CRYP_Decrypt>:
{
 8023c84:	b570      	push	{r4, r5, r6, lr}
 8023c86:	0004      	movs	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 8023c88:	2051      	movs	r0, #81	; 0x51
 8023c8a:	5c25      	ldrb	r5, [r4, r0]
 8023c8c:	b2e8      	uxtb	r0, r5
 8023c8e:	2d01      	cmp	r5, #1
 8023c90:	d005      	beq.n	8023c9e <HAL_CRYP_Decrypt+0x1a>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 8023c92:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023c94:	2208      	movs	r2, #8
 8023c96:	4313      	orrs	r3, r2
 8023c98:	6563      	str	r3, [r4, #84]	; 0x54
    status = HAL_ERROR;
 8023c9a:	2001      	movs	r0, #1
}
 8023c9c:	bd70      	pop	{r4, r5, r6, pc}
    hcryp->State = HAL_CRYP_STATE_BUSY;
 8023c9e:	3550      	adds	r5, #80	; 0x50
 8023ca0:	2602      	movs	r6, #2
 8023ca2:	5566      	strb	r6, [r4, r5]
    __HAL_LOCK(hcryp);
 8023ca4:	3d01      	subs	r5, #1
 8023ca6:	5d65      	ldrb	r5, [r4, r5]
 8023ca8:	2d01      	cmp	r5, #1
 8023caa:	d045      	beq.n	8023d38 <HAL_CRYP_Decrypt+0xb4>
 8023cac:	2550      	movs	r5, #80	; 0x50
 8023cae:	3e01      	subs	r6, #1
 8023cb0:	5566      	strb	r6, [r4, r5]
    hcryp->CrypInCount = 0U;
 8023cb2:	2500      	movs	r5, #0
 8023cb4:	87e5      	strh	r5, [r4, #62]	; 0x3e
    hcryp->CrypOutCount = 0U;
 8023cb6:	363f      	adds	r6, #63	; 0x3f
 8023cb8:	53a5      	strh	r5, [r4, r6]
    hcryp->pCrypInBuffPtr = Input;
 8023cba:	6361      	str	r1, [r4, #52]	; 0x34
    hcryp->pCrypOutBuffPtr = Output;
 8023cbc:	63a3      	str	r3, [r4, #56]	; 0x38
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 8023cbe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8023cc0:	2b00      	cmp	r3, #0
 8023cc2:	d121      	bne.n	8023d08 <HAL_CRYP_Decrypt+0x84>
      hcryp->Size = Size * 4U;
 8023cc4:	0092      	lsls	r2, r2, #2
 8023cc6:	3342      	adds	r3, #66	; 0x42
 8023cc8:	52e2      	strh	r2, [r4, r3]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 8023cca:	6822      	ldr	r2, [r4, #0]
 8023ccc:	6813      	ldr	r3, [r2, #0]
 8023cce:	2118      	movs	r1, #24
 8023cd0:	438b      	bics	r3, r1
 8023cd2:	3908      	subs	r1, #8
 8023cd4:	430b      	orrs	r3, r1
 8023cd6:	6013      	str	r3, [r2, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 8023cd8:	6823      	ldr	r3, [r4, #0]
 8023cda:	681b      	ldr	r3, [r3, #0]
 8023cdc:	4a17      	ldr	r2, [pc, #92]	; (8023d3c <HAL_CRYP_Decrypt+0xb8>)
 8023cde:	4013      	ands	r3, r2
    switch (algo)
 8023ce0:	2b60      	cmp	r3, #96	; 0x60
 8023ce2:	d024      	beq.n	8023d2e <HAL_CRYP_Decrypt+0xaa>
 8023ce4:	d81a      	bhi.n	8023d1c <HAL_CRYP_Decrypt+0x98>
 8023ce6:	2b20      	cmp	r3, #32
 8023ce8:	d001      	beq.n	8023cee <HAL_CRYP_Decrypt+0x6a>
 8023cea:	2b40      	cmp	r3, #64	; 0x40
 8023cec:	d10f      	bne.n	8023d0e <HAL_CRYP_Decrypt+0x8a>
        status = CRYP_AES_Decrypt(hcryp, Timeout);
 8023cee:	9904      	ldr	r1, [sp, #16]
 8023cf0:	0020      	movs	r0, r4
 8023cf2:	f7ff fdd5 	bl	80238a0 <CRYP_AES_Decrypt>
    if (status == HAL_OK)
 8023cf6:	2800      	cmp	r0, #0
 8023cf8:	d1d0      	bne.n	8023c9c <HAL_CRYP_Decrypt+0x18>
      hcryp->State = HAL_CRYP_STATE_READY;
 8023cfa:	2351      	movs	r3, #81	; 0x51
 8023cfc:	2201      	movs	r2, #1
 8023cfe:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023d00:	3b01      	subs	r3, #1
 8023d02:	2200      	movs	r2, #0
 8023d04:	54e2      	strb	r2, [r4, r3]
 8023d06:	e7c9      	b.n	8023c9c <HAL_CRYP_Decrypt+0x18>
      hcryp->Size = Size;
 8023d08:	2342      	movs	r3, #66	; 0x42
 8023d0a:	52e2      	strh	r2, [r4, r3]
 8023d0c:	e7dd      	b.n	8023cca <HAL_CRYP_Decrypt+0x46>
    switch (algo)
 8023d0e:	2b00      	cmp	r3, #0
 8023d10:	d0ed      	beq.n	8023cee <HAL_CRYP_Decrypt+0x6a>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 8023d12:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023d14:	2220      	movs	r2, #32
 8023d16:	4313      	orrs	r3, r2
 8023d18:	6563      	str	r3, [r4, #84]	; 0x54
    if (status == HAL_OK)
 8023d1a:	e7bf      	b.n	8023c9c <HAL_CRYP_Decrypt+0x18>
    switch (algo)
 8023d1c:	2280      	movs	r2, #128	; 0x80
 8023d1e:	0252      	lsls	r2, r2, #9
 8023d20:	4293      	cmp	r3, r2
 8023d22:	d1f6      	bne.n	8023d12 <HAL_CRYP_Decrypt+0x8e>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 8023d24:	9904      	ldr	r1, [sp, #16]
 8023d26:	0020      	movs	r0, r4
 8023d28:	f7ff fcb0 	bl	802368c <CRYP_AESCCM_Process>
        break;
 8023d2c:	e7e3      	b.n	8023cf6 <HAL_CRYP_Decrypt+0x72>
        status = CRYP_AESGCM_Process(hcryp, Timeout) ;
 8023d2e:	9904      	ldr	r1, [sp, #16]
 8023d30:	0020      	movs	r0, r4
 8023d32:	f7ff fe43 	bl	80239bc <CRYP_AESGCM_Process>
        break;
 8023d36:	e7de      	b.n	8023cf6 <HAL_CRYP_Decrypt+0x72>
    __HAL_LOCK(hcryp);
 8023d38:	2002      	movs	r0, #2
 8023d3a:	e7af      	b.n	8023c9c <HAL_CRYP_Decrypt+0x18>
 8023d3c:	00010060 	.word	0x00010060

08023d40 <HAL_CRYPEx_AESGCM_GenerateAuthTAG>:
  * @param  AuthTag Pointer to the authentication buffer
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRYPEx_AESGCM_GenerateAuthTAG(CRYP_HandleTypeDef *hcryp, uint32_t *AuthTag, uint32_t Timeout)
{
 8023d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023d42:	46ce      	mov	lr, r9
 8023d44:	4647      	mov	r7, r8
 8023d46:	b580      	push	{r7, lr}
 8023d48:	0004      	movs	r4, r0
 8023d4a:	000e      	movs	r6, r1
 8023d4c:	0015      	movs	r5, r2
  uint32_t tickstart;
  /* Assume first Init.HeaderSize is in words */
  uint64_t headerlength = (uint64_t)hcryp->Init.HeaderSize * 32U; /* Header length in bits */
 8023d4e:	69c3      	ldr	r3, [r0, #28]
 8023d50:	0eda      	lsrs	r2, r3, #27
 8023d52:	0159      	lsls	r1, r3, #5
  uint64_t inputlength = (uint64_t)hcryp->SizesSum * 8U; /* Input length in bits */
 8023d54:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 8023d56:	00db      	lsls	r3, r3, #3
  uint32_t tagaddr = (uint32_t)AuthTag;

  /* Correct headerlength if Init.HeaderSize is actually in bytes */
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_BYTE)
 8023d58:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8023d5a:	2801      	cmp	r0, #1
 8023d5c:	d021      	beq.n	8023da2 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x62>
  {
    headerlength /= 4U;
  }

  if (hcryp->State == HAL_CRYP_STATE_READY)
 8023d5e:	2251      	movs	r2, #81	; 0x51
 8023d60:	5ca2      	ldrb	r2, [r4, r2]
 8023d62:	b2d7      	uxtb	r7, r2
 8023d64:	2a01      	cmp	r2, #1
 8023d66:	d17b      	bne.n	8023e60 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x120>
  {
    /* Process locked */
    __HAL_LOCK(hcryp);
 8023d68:	324f      	adds	r2, #79	; 0x4f
 8023d6a:	5ca2      	ldrb	r2, [r4, r2]
 8023d6c:	2a01      	cmp	r2, #1
 8023d6e:	d100      	bne.n	8023d72 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x32>
 8023d70:	e080      	b.n	8023e74 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x134>
 8023d72:	2250      	movs	r2, #80	; 0x50
 8023d74:	2001      	movs	r0, #1
 8023d76:	54a0      	strb	r0, [r4, r2]

    /* Change the CRYP peripheral state */
    hcryp->State = HAL_CRYP_STATE_BUSY;
 8023d78:	3201      	adds	r2, #1
 8023d7a:	3001      	adds	r0, #1
 8023d7c:	54a0      	strb	r0, [r4, r2]

    /* Check if initialization phase has already been performed */
    if (hcryp->Phase == CRYPEx_PHASE_PROCESS)
 8023d7e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8023d80:	2a02      	cmp	r2, #2
 8023d82:	d012      	beq.n	8023daa <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x6a>
      hcryp->Phase = CRYPEx_PHASE_FINAL;
    }
    else /* Initialization phase has not been performed*/
    {
      /* Disable the Peripheral */
      __HAL_CRYP_DISABLE(hcryp);
 8023d84:	6821      	ldr	r1, [r4, #0]
 8023d86:	680b      	ldr	r3, [r1, #0]
 8023d88:	2201      	movs	r2, #1
 8023d8a:	4393      	bics	r3, r2
 8023d8c:	600b      	str	r3, [r1, #0]

      /* Sequence error code field */
      hcryp->ErrorCode |= HAL_CRYP_ERROR_AUTH_TAG_SEQUENCE;
 8023d8e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023d90:	2140      	movs	r1, #64	; 0x40
 8023d92:	430b      	orrs	r3, r1
 8023d94:	6563      	str	r3, [r4, #84]	; 0x54

      /* Change the CRYP peripheral state */
      hcryp->State = HAL_CRYP_STATE_READY;
 8023d96:	2351      	movs	r3, #81	; 0x51
 8023d98:	54e2      	strb	r2, [r4, r3]

      /* Process unlocked */
      __HAL_UNLOCK(hcryp);
 8023d9a:	3b01      	subs	r3, #1
 8023d9c:	2200      	movs	r2, #0
 8023d9e:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 8023da0:	e063      	b.n	8023e6a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>
    headerlength /= 4U;
 8023da2:	0792      	lsls	r2, r2, #30
 8023da4:	0889      	lsrs	r1, r1, #2
 8023da6:	4311      	orrs	r1, r2
 8023da8:	e7d9      	b.n	8023d5e <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x1e>
      hcryp->Phase = CRYPEx_PHASE_FINAL;
 8023daa:	3201      	adds	r2, #1
 8023dac:	6462      	str	r2, [r4, #68]	; 0x44
    }

    /* Select final phase */
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_FINAL);
 8023dae:	6822      	ldr	r2, [r4, #0]
 8023db0:	4690      	mov	r8, r2
 8023db2:	6812      	ldr	r2, [r2, #0]
 8023db4:	4694      	mov	ip, r2
 8023db6:	22c0      	movs	r2, #192	; 0xc0
 8023db8:	01d2      	lsls	r2, r2, #7
 8023dba:	4660      	mov	r0, ip
 8023dbc:	4302      	orrs	r2, r0
 8023dbe:	4640      	mov	r0, r8
 8023dc0:	6002      	str	r2, [r0, #0]

    /* Set the encrypt operating mode*/
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 8023dc2:	6822      	ldr	r2, [r4, #0]
 8023dc4:	4691      	mov	r9, r2
 8023dc6:	6812      	ldr	r2, [r2, #0]
 8023dc8:	4690      	mov	r8, r2
 8023dca:	2218      	movs	r2, #24
 8023dcc:	4640      	mov	r0, r8
 8023dce:	4390      	bics	r0, r2
 8023dd0:	0002      	movs	r2, r0
 8023dd2:	4648      	mov	r0, r9
 8023dd4:	6002      	str	r2, [r0, #0]

    /*TinyAES peripheral from V3.1.1 : data has to be inserted normally (no swapping)*/
    /* Write into the AES_DINR register the number of bits in header (64 bits)
    followed by the number of bits in the payload */

    hcryp->Instance->DINR = 0U;
 8023dd6:	6820      	ldr	r0, [r4, #0]
 8023dd8:	2200      	movs	r2, #0
 8023dda:	6082      	str	r2, [r0, #8]
    hcryp->Instance->DINR = (uint32_t)(headerlength);
 8023ddc:	6820      	ldr	r0, [r4, #0]
 8023dde:	6081      	str	r1, [r0, #8]
    hcryp->Instance->DINR = 0U;
 8023de0:	6821      	ldr	r1, [r4, #0]
 8023de2:	608a      	str	r2, [r1, #8]
    hcryp->Instance->DINR = (uint32_t)(inputlength);
 8023de4:	6822      	ldr	r2, [r4, #0]
 8023de6:	6093      	str	r3, [r2, #8]

    /* Wait for CCF flag to be raised */
    tickstart = HAL_GetTick();
 8023de8:	f7fd fefa 	bl	8021be0 <HAL_GetTick>
 8023dec:	4680      	mov	r8, r0
    while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 8023dee:	6823      	ldr	r3, [r4, #0]
 8023df0:	685a      	ldr	r2, [r3, #4]
 8023df2:	07d2      	lsls	r2, r2, #31
 8023df4:	d418      	bmi.n	8023e28 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xe8>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8023df6:	1c6b      	adds	r3, r5, #1
 8023df8:	d0f9      	beq.n	8023dee <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xae>
      {
        if (((HAL_GetTick() - tickstart) > Timeout)||(Timeout == 0U))
 8023dfa:	f7fd fef1 	bl	8021be0 <HAL_GetTick>
 8023dfe:	4643      	mov	r3, r8
 8023e00:	1ac0      	subs	r0, r0, r3
 8023e02:	42a8      	cmp	r0, r5
 8023e04:	d801      	bhi.n	8023e0a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xca>
 8023e06:	2d00      	cmp	r5, #0
 8023e08:	d1f1      	bne.n	8023dee <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xae>
        {
          /* Disable the CRYP peripheral clock */
          __HAL_CRYP_DISABLE(hcryp);
 8023e0a:	6821      	ldr	r1, [r4, #0]
 8023e0c:	680b      	ldr	r3, [r1, #0]
 8023e0e:	2201      	movs	r2, #1
 8023e10:	4393      	bics	r3, r2
 8023e12:	600b      	str	r3, [r1, #0]

          /* Change state */
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023e14:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023e16:	2110      	movs	r1, #16
 8023e18:	430b      	orrs	r3, r1
 8023e1a:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 8023e1c:	2351      	movs	r3, #81	; 0x51
 8023e1e:	54e2      	strb	r2, [r4, r3]

          /* Process unlocked */
          __HAL_UNLOCK(hcryp);
 8023e20:	3b01      	subs	r3, #1
 8023e22:	2200      	movs	r2, #0
 8023e24:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 8023e26:	e020      	b.n	8023e6a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>
        }
      }
    }

    /* Read the authentication TAG in the output FIFO */
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 8023e28:	68db      	ldr	r3, [r3, #12]
 8023e2a:	6033      	str	r3, [r6, #0]
    tagaddr += 4U;
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 8023e2c:	6823      	ldr	r3, [r4, #0]
 8023e2e:	68db      	ldr	r3, [r3, #12]
 8023e30:	6073      	str	r3, [r6, #4]
    tagaddr += 4U;
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 8023e32:	6823      	ldr	r3, [r4, #0]
 8023e34:	68db      	ldr	r3, [r3, #12]
 8023e36:	60b3      	str	r3, [r6, #8]
    tagaddr += 4U;
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 8023e38:	6823      	ldr	r3, [r4, #0]
 8023e3a:	68db      	ldr	r3, [r3, #12]
 8023e3c:	60f3      	str	r3, [r6, #12]

    /* Clear CCF flag */
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023e3e:	6822      	ldr	r2, [r4, #0]
 8023e40:	6813      	ldr	r3, [r2, #0]
 8023e42:	2180      	movs	r1, #128	; 0x80
 8023e44:	430b      	orrs	r3, r1
 8023e46:	6013      	str	r3, [r2, #0]

    /* Disable the peripheral */
    __HAL_CRYP_DISABLE(hcryp);
 8023e48:	6821      	ldr	r1, [r4, #0]
 8023e4a:	680b      	ldr	r3, [r1, #0]
 8023e4c:	2201      	movs	r2, #1
 8023e4e:	4393      	bics	r3, r2
 8023e50:	600b      	str	r3, [r1, #0]

    /* Change the CRYP peripheral state */
    hcryp->State = HAL_CRYP_STATE_READY;
 8023e52:	2351      	movs	r3, #81	; 0x51
 8023e54:	54e2      	strb	r2, [r4, r3]

    /* Process unlocked */
    __HAL_UNLOCK(hcryp);
 8023e56:	3b01      	subs	r3, #1
 8023e58:	2200      	movs	r2, #0
 8023e5a:	54e2      	strb	r2, [r4, r3]
    /* Busy error code field */
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
    return HAL_ERROR;
  }
  /* Return function status */
  return HAL_OK;
 8023e5c:	2700      	movs	r7, #0
 8023e5e:	e004      	b.n	8023e6a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 8023e60:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023e62:	2208      	movs	r2, #8
 8023e64:	4313      	orrs	r3, r2
 8023e66:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_ERROR;
 8023e68:	2701      	movs	r7, #1
}
 8023e6a:	0038      	movs	r0, r7
 8023e6c:	bcc0      	pop	{r6, r7}
 8023e6e:	46b9      	mov	r9, r7
 8023e70:	46b0      	mov	r8, r6
 8023e72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hcryp);
 8023e74:	2702      	movs	r7, #2
 8023e76:	e7f8      	b.n	8023e6a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>

08023e78 <FLASH_Program_DoubleWord>:
  * @param  Address Specifies the address to be programmed.
  * @param  Data Specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 8023e78:	b530      	push	{r4, r5, lr}
#ifdef CORE_CM0PLUS
  /* Set PG bit */
  SET_BIT(FLASH->C2CR, FLASH_CR_PG);
 8023e7a:	4c05      	ldr	r4, [pc, #20]	; (8023e90 <FLASH_Program_DoubleWord+0x18>)
 8023e7c:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8023e7e:	2501      	movs	r5, #1
 8023e80:	4329      	orrs	r1, r5
 8023e82:	6661      	str	r1, [r4, #100]	; 0x64
  /* Set PG bit */
  SET_BIT(FLASH->CR, FLASH_CR_PG);
#endif

  /* Program first word */
  *(uint32_t *)Address = (uint32_t)Data;
 8023e84:	6002      	str	r2, [r0, #0]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8023e86:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 8023e8a:	6043      	str	r3, [r0, #4]
}
 8023e8c:	bd30      	pop	{r4, r5, pc}
 8023e8e:	46c0      	nop			; (mov r8, r8)
 8023e90:	58004000 	.word	0x58004000

08023e94 <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8023e94:	4b08      	ldr	r3, [pc, #32]	; (8023eb8 <HAL_FLASH_Unlock+0x24>)
 8023e96:	695b      	ldr	r3, [r3, #20]
 8023e98:	2b00      	cmp	r3, #0
 8023e9a:	db01      	blt.n	8023ea0 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 8023e9c:	2000      	movs	r0, #0
}
 8023e9e:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8023ea0:	4b05      	ldr	r3, [pc, #20]	; (8023eb8 <HAL_FLASH_Unlock+0x24>)
 8023ea2:	4a06      	ldr	r2, [pc, #24]	; (8023ebc <HAL_FLASH_Unlock+0x28>)
 8023ea4:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8023ea6:	4a06      	ldr	r2, [pc, #24]	; (8023ec0 <HAL_FLASH_Unlock+0x2c>)
 8023ea8:	609a      	str	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8023eaa:	695b      	ldr	r3, [r3, #20]
 8023eac:	2b00      	cmp	r3, #0
 8023eae:	db01      	blt.n	8023eb4 <HAL_FLASH_Unlock+0x20>
  HAL_StatusTypeDef status = HAL_OK;
 8023eb0:	2000      	movs	r0, #0
 8023eb2:	e7f4      	b.n	8023e9e <HAL_FLASH_Unlock+0xa>
      status = HAL_ERROR;
 8023eb4:	2001      	movs	r0, #1
 8023eb6:	e7f2      	b.n	8023e9e <HAL_FLASH_Unlock+0xa>
 8023eb8:	58004000 	.word	0x58004000
 8023ebc:	45670123 	.word	0x45670123
 8023ec0:	cdef89ab 	.word	0xcdef89ab

08023ec4 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8023ec4:	4b06      	ldr	r3, [pc, #24]	; (8023ee0 <HAL_FLASH_Lock+0x1c>)
 8023ec6:	6959      	ldr	r1, [r3, #20]
 8023ec8:	2280      	movs	r2, #128	; 0x80
 8023eca:	0612      	lsls	r2, r2, #24
 8023ecc:	430a      	orrs	r2, r1
 8023ece:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 8023ed0:	695b      	ldr	r3, [r3, #20]
 8023ed2:	2b00      	cmp	r3, #0
 8023ed4:	db01      	blt.n	8023eda <HAL_FLASH_Lock+0x16>
    status = HAL_ERROR;
 8023ed6:	2001      	movs	r0, #1
}
 8023ed8:	4770      	bx	lr
  HAL_StatusTypeDef status = HAL_OK;
 8023eda:	2000      	movs	r0, #0
 8023edc:	e7fc      	b.n	8023ed8 <HAL_FLASH_Lock+0x14>
 8023ede:	46c0      	nop			; (mov r8, r8)
 8023ee0:	58004000 	.word	0x58004000

08023ee4 <FLASH_WaitForLastOperation>:
{
 8023ee4:	b570      	push	{r4, r5, r6, lr}
 8023ee6:	0005      	movs	r5, r0
  uint32_t tickstart = HAL_GetTick();
 8023ee8:	f7fd fe7a 	bl	8021be0 <HAL_GetTick>
 8023eec:	0004      	movs	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8023eee:	4b19      	ldr	r3, [pc, #100]	; (8023f54 <FLASH_WaitForLastOperation+0x70>)
 8023ef0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8023ef2:	03db      	lsls	r3, r3, #15
 8023ef4:	d506      	bpl.n	8023f04 <FLASH_WaitForLastOperation+0x20>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8023ef6:	f7fd fe73 	bl	8021be0 <HAL_GetTick>
 8023efa:	1b00      	subs	r0, r0, r4
 8023efc:	42a8      	cmp	r0, r5
 8023efe:	d3f6      	bcc.n	8023eee <FLASH_WaitForLastOperation+0xa>
      return HAL_TIMEOUT;
 8023f00:	2003      	movs	r0, #3
}
 8023f02:	bd70      	pop	{r4, r5, r6, pc}
  error = FLASH->C2SR;
 8023f04:	4b13      	ldr	r3, [pc, #76]	; (8023f54 <FLASH_WaitForLastOperation+0x70>)
 8023f06:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  if ((error & FLASH_FLAG_EOP) != 0U)
 8023f08:	07d3      	lsls	r3, r2, #31
 8023f0a:	d502      	bpl.n	8023f12 <FLASH_WaitForLastOperation+0x2e>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8023f0c:	4b11      	ldr	r3, [pc, #68]	; (8023f54 <FLASH_WaitForLastOperation+0x70>)
 8023f0e:	2101      	movs	r1, #1
 8023f10:	6619      	str	r1, [r3, #96]	; 0x60
  error &= FLASH_FLAG_SR_ERRORS;
 8023f12:	4b11      	ldr	r3, [pc, #68]	; (8023f58 <FLASH_WaitForLastOperation+0x74>)
 8023f14:	4013      	ands	r3, r2
  __HAL_FLASH_CLEAR_FLAG(error);
 8023f16:	0412      	lsls	r2, r2, #16
 8023f18:	d505      	bpl.n	8023f26 <FLASH_WaitForLastOperation+0x42>
 8023f1a:	490e      	ldr	r1, [pc, #56]	; (8023f54 <FLASH_WaitForLastOperation+0x70>)
 8023f1c:	6908      	ldr	r0, [r1, #16]
 8023f1e:	2280      	movs	r2, #128	; 0x80
 8023f20:	0212      	lsls	r2, r2, #8
 8023f22:	4302      	orrs	r2, r0
 8023f24:	610a      	str	r2, [r1, #16]
 8023f26:	2b00      	cmp	r3, #0
 8023f28:	d001      	beq.n	8023f2e <FLASH_WaitForLastOperation+0x4a>
 8023f2a:	4a0a      	ldr	r2, [pc, #40]	; (8023f54 <FLASH_WaitForLastOperation+0x70>)
 8023f2c:	6613      	str	r3, [r2, #96]	; 0x60
  if (error != 0U)
 8023f2e:	2b00      	cmp	r3, #0
 8023f30:	d10a      	bne.n	8023f48 <FLASH_WaitForLastOperation+0x64>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8023f32:	4b08      	ldr	r3, [pc, #32]	; (8023f54 <FLASH_WaitForLastOperation+0x70>)
 8023f34:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8023f36:	035b      	lsls	r3, r3, #13
 8023f38:	d50a      	bpl.n	8023f50 <FLASH_WaitForLastOperation+0x6c>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8023f3a:	f7fd fe51 	bl	8021be0 <HAL_GetTick>
 8023f3e:	1b00      	subs	r0, r0, r4
 8023f40:	42a8      	cmp	r0, r5
 8023f42:	d3f6      	bcc.n	8023f32 <FLASH_WaitForLastOperation+0x4e>
      return HAL_TIMEOUT;
 8023f44:	2003      	movs	r0, #3
 8023f46:	e7dc      	b.n	8023f02 <FLASH_WaitForLastOperation+0x1e>
    pFlash.ErrorCode = error;
 8023f48:	4a04      	ldr	r2, [pc, #16]	; (8023f5c <FLASH_WaitForLastOperation+0x78>)
 8023f4a:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 8023f4c:	2001      	movs	r0, #1
 8023f4e:	e7d8      	b.n	8023f02 <FLASH_WaitForLastOperation+0x1e>
  return HAL_OK;
 8023f50:	2000      	movs	r0, #0
 8023f52:	e7d6      	b.n	8023f02 <FLASH_WaitForLastOperation+0x1e>
 8023f54:	58004000 	.word	0x58004000
 8023f58:	0000c3fa 	.word	0x0000c3fa
 8023f5c:	2000a1e8 	.word	0x2000a1e8

08023f60 <HAL_FLASH_Program>:
{
 8023f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023f62:	0007      	movs	r7, r0
 8023f64:	000c      	movs	r4, r1
 8023f66:	0015      	movs	r5, r2
 8023f68:	001e      	movs	r6, r3
  __HAL_LOCK(&pFlash);
 8023f6a:	4b14      	ldr	r3, [pc, #80]	; (8023fbc <HAL_FLASH_Program+0x5c>)
 8023f6c:	781b      	ldrb	r3, [r3, #0]
 8023f6e:	2b01      	cmp	r3, #1
 8023f70:	d022      	beq.n	8023fb8 <HAL_FLASH_Program+0x58>
 8023f72:	4b12      	ldr	r3, [pc, #72]	; (8023fbc <HAL_FLASH_Program+0x5c>)
 8023f74:	2201      	movs	r2, #1
 8023f76:	701a      	strb	r2, [r3, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8023f78:	2200      	movs	r2, #0
 8023f7a:	605a      	str	r2, [r3, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8023f7c:	20fa      	movs	r0, #250	; 0xfa
 8023f7e:	0080      	lsls	r0, r0, #2
 8023f80:	f7ff ffb0 	bl	8023ee4 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 8023f84:	2800      	cmp	r0, #0
 8023f86:	d10d      	bne.n	8023fa4 <HAL_FLASH_Program+0x44>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 8023f88:	2f01      	cmp	r7, #1
 8023f8a:	d00f      	beq.n	8023fac <HAL_FLASH_Program+0x4c>
      FLASH_Program_Fast(Address, (uint32_t)Data);
 8023f8c:	0029      	movs	r1, r5
 8023f8e:	0020      	movs	r0, r4
 8023f90:	f010 fc6a 	bl	8034868 <__FLASH_Program_Fast_veneer>
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8023f94:	20fa      	movs	r0, #250	; 0xfa
 8023f96:	0080      	lsls	r0, r0, #2
 8023f98:	f7ff ffa4 	bl	8023ee4 <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->C2CR, TypeProgram);
 8023f9c:	4a08      	ldr	r2, [pc, #32]	; (8023fc0 <HAL_FLASH_Program+0x60>)
 8023f9e:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8023fa0:	43bb      	bics	r3, r7
 8023fa2:	6653      	str	r3, [r2, #100]	; 0x64
  __HAL_UNLOCK(&pFlash);
 8023fa4:	4b05      	ldr	r3, [pc, #20]	; (8023fbc <HAL_FLASH_Program+0x5c>)
 8023fa6:	2200      	movs	r2, #0
 8023fa8:	701a      	strb	r2, [r3, #0]
}
 8023faa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      FLASH_Program_DoubleWord(Address, Data);
 8023fac:	002a      	movs	r2, r5
 8023fae:	0033      	movs	r3, r6
 8023fb0:	0020      	movs	r0, r4
 8023fb2:	f7ff ff61 	bl	8023e78 <FLASH_Program_DoubleWord>
 8023fb6:	e7ed      	b.n	8023f94 <HAL_FLASH_Program+0x34>
  __HAL_LOCK(&pFlash);
 8023fb8:	2002      	movs	r0, #2
 8023fba:	e7f6      	b.n	8023faa <HAL_FLASH_Program+0x4a>
 8023fbc:	2000a1e8 	.word	0x2000a1e8
 8023fc0:	58004000 	.word	0x58004000

08023fc4 <FLASH_MassErase>:
  */
static void FLASH_MassErase(void)
{
  /* Set the Mass Erase Bit and start bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, (FLASH_CR_MER | FLASH_CR_STRT));
 8023fc4:	4a02      	ldr	r2, [pc, #8]	; (8023fd0 <FLASH_MassErase+0xc>)
 8023fc6:	6e51      	ldr	r1, [r2, #100]	; 0x64
 8023fc8:	4b02      	ldr	r3, [pc, #8]	; (8023fd4 <FLASH_MassErase+0x10>)
 8023fca:	430b      	orrs	r3, r1
 8023fcc:	6653      	str	r3, [r2, #100]	; 0x64
#else
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
#endif
}
 8023fce:	4770      	bx	lr
 8023fd0:	58004000 	.word	0x58004000
 8023fd4:	00010004 	.word	0x00010004

08023fd8 <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 8023fd8:	4b0d      	ldr	r3, [pc, #52]	; (8024010 <FLASH_FlushCaches+0x38>)
 8023fda:	681b      	ldr	r3, [r3, #0]
 8023fdc:	2280      	movs	r2, #128	; 0x80
 8023fde:	0092      	lsls	r2, r2, #2
 8023fe0:	4013      	ands	r3, r2
 8023fe2:	2b01      	cmp	r3, #1
 8023fe4:	d000      	beq.n	8023fe8 <FLASH_FlushCaches+0x10>
    __HAL_FLASH_DATA_CACHE_RESET();
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
  }
#endif
}
 8023fe6:	4770      	bx	lr
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8023fe8:	4b09      	ldr	r3, [pc, #36]	; (8024010 <FLASH_FlushCaches+0x38>)
 8023fea:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8023fec:	4909      	ldr	r1, [pc, #36]	; (8024014 <FLASH_FlushCaches+0x3c>)
 8023fee:	400a      	ands	r2, r1
 8023ff0:	65da      	str	r2, [r3, #92]	; 0x5c
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8023ff2:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8023ff4:	2280      	movs	r2, #128	; 0x80
 8023ff6:	0112      	lsls	r2, r2, #4
 8023ff8:	430a      	orrs	r2, r1
 8023ffa:	65da      	str	r2, [r3, #92]	; 0x5c
 8023ffc:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8023ffe:	4906      	ldr	r1, [pc, #24]	; (8024018 <FLASH_FlushCaches+0x40>)
 8024000:	400a      	ands	r2, r1
 8024002:	65da      	str	r2, [r3, #92]	; 0x5c
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8024004:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8024006:	2280      	movs	r2, #128	; 0x80
 8024008:	0092      	lsls	r2, r2, #2
 802400a:	430a      	orrs	r2, r1
 802400c:	65da      	str	r2, [r3, #92]	; 0x5c
}
 802400e:	e7ea      	b.n	8023fe6 <FLASH_FlushCaches+0xe>
 8024010:	58004000 	.word	0x58004000
 8024014:	fffffdff 	.word	0xfffffdff
 8024018:	fffff7ff 	.word	0xfffff7ff

0802401c <FLASH_AcknowledgePageErase>:
  * @retval None
  */
static void FLASH_AcknowledgePageErase(void)
{
#ifdef CORE_CM0PLUS
  CLEAR_BIT(FLASH->C2CR, (FLASH_CR_PER | FLASH_CR_PNB));
 802401c:	4a02      	ldr	r2, [pc, #8]	; (8024028 <FLASH_AcknowledgePageErase+0xc>)
 802401e:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8024020:	4902      	ldr	r1, [pc, #8]	; (802402c <FLASH_AcknowledgePageErase+0x10>)
 8024022:	400b      	ands	r3, r1
 8024024:	6653      	str	r3, [r2, #100]	; 0x64
#else
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
#endif
}
 8024026:	4770      	bx	lr
 8024028:	58004000 	.word	0x58004000
 802402c:	fffffc05 	.word	0xfffffc05

08024030 <FLASH_OB_GetWRP>:
  * @param[out]  WRDPEndOffset Specifies the address where to copied the end page of
  *                            the write protected area
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t *WRPStartOffset, uint32_t *WRDPEndOffset)
{
 8024030:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_OB_WRPAREA(WRPArea));

  /* Get the configuration of the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 8024032:	2800      	cmp	r0, #0
 8024034:	d109      	bne.n	802404a <FLASH_OB_GetWRP+0x1a>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_STRT);
 8024036:	4c0a      	ldr	r4, [pc, #40]	; (8024060 <FLASH_OB_GetWRP+0x30>)
 8024038:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802403a:	237f      	movs	r3, #127	; 0x7f
 802403c:	4018      	ands	r0, r3
 802403e:	6008      	str	r0, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_END) >> FLASH_WRP1AR_WRP1A_END_Pos);
 8024040:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8024042:	0c09      	lsrs	r1, r1, #16
 8024044:	400b      	ands	r3, r1
 8024046:	6013      	str	r3, [r2, #0]
  else /* OB_WRPAREA_BANK1_AREAB */
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
  }
}
 8024048:	bd10      	pop	{r4, pc}
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
 802404a:	4c05      	ldr	r4, [pc, #20]	; (8024060 <FLASH_OB_GetWRP+0x30>)
 802404c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 802404e:	237f      	movs	r3, #127	; 0x7f
 8024050:	4018      	ands	r0, r3
 8024052:	6008      	str	r0, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
 8024054:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8024056:	0c09      	lsrs	r1, r1, #16
 8024058:	400b      	ands	r3, r1
 802405a:	6013      	str	r3, [r2, #0]
}
 802405c:	e7f4      	b.n	8024048 <FLASH_OB_GetWRP+0x18>
 802405e:	46c0      	nop			; (mov r8, r8)
 8024060:	58004000 	.word	0x58004000

08024064 <FLASH_OB_GetRDP>:
  *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
  *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
  uint32_t rdplvl = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 8024064:	4b04      	ldr	r3, [pc, #16]	; (8024078 <FLASH_OB_GetRDP+0x14>)
 8024066:	6a1b      	ldr	r3, [r3, #32]
 8024068:	20ff      	movs	r0, #255	; 0xff
 802406a:	4018      	ands	r0, r3

  if ((rdplvl != OB_RDP_LEVEL_0) && (rdplvl != OB_RDP_LEVEL_2))
 802406c:	28aa      	cmp	r0, #170	; 0xaa
 802406e:	d002      	beq.n	8024076 <FLASH_OB_GetRDP+0x12>
 8024070:	28cc      	cmp	r0, #204	; 0xcc
 8024072:	d000      	beq.n	8024076 <FLASH_OB_GetRDP+0x12>
  {
    return (OB_RDP_LEVEL_1);
 8024074:	20bb      	movs	r0, #187	; 0xbb
  }
  else
  {
    return rdplvl;
  }
}
 8024076:	4770      	bx	lr
 8024078:	58004000 	.word	0x58004000

0802407c <FLASH_OB_GetUser>:
  *         @arg @ref OB_BOOT_LOCK_DISABLE or @ref OB_BOOT_LOCK_ENABLE
  */
#endif
static uint32_t FLASH_OB_GetUser(void)
{
  uint32_t user_config = (READ_REG(FLASH->OPTR) & OB_USER_ALL);
 802407c:	4b02      	ldr	r3, [pc, #8]	; (8024088 <FLASH_OB_GetUser+0xc>)
 802407e:	6a18      	ldr	r0, [r3, #32]
 8024080:	4b02      	ldr	r3, [pc, #8]	; (802408c <FLASH_OB_GetUser+0x10>)
 8024082:	4018      	ands	r0, r3
  CLEAR_BIT(user_config, (FLASH_OPTR_RDP | FLASH_OPTR_ESE));

  return user_config;
}
 8024084:	4770      	bx	lr
 8024086:	46c0      	nop			; (mov r8, r8)
 8024088:	58004000 	.word	0x58004000
 802408c:	cf8f7e00 	.word	0xcf8f7e00

08024090 <FLASH_OB_GetPCROP>:
  * @param PCROP1BEndAddr [out] Specifies the address where to copied the end address of
  *                       the Zone 1B Proprietary code readout protection
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROP1AStartAddr, uint32_t *PCROP1AEndAddr, uint32_t *PCROP1BStartAddr, uint32_t *PCROP1BEndAddr)
{
 8024090:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t pcrop;

  pcrop             = (READ_BIT(FLASH->PCROP1BSR, FLASH_PCROP1BSR_PCROP1B_STRT));
 8024092:	4d10      	ldr	r5, [pc, #64]	; (80240d4 <FLASH_OB_GetPCROP+0x44>)
 8024094:	6b6c      	ldr	r4, [r5, #52]	; 0x34
  *PCROP1BStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 8024096:	02a4      	lsls	r4, r4, #10
 8024098:	26ff      	movs	r6, #255	; 0xff
 802409a:	02b6      	lsls	r6, r6, #10
 802409c:	4034      	ands	r4, r6
 802409e:	2780      	movs	r7, #128	; 0x80
 80240a0:	053f      	lsls	r7, r7, #20
 80240a2:	46bc      	mov	ip, r7
 80240a4:	4464      	add	r4, ip
 80240a6:	601c      	str	r4, [r3, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1BER, FLASH_PCROP1BER_PCROP1B_END));
 80240a8:	6bac      	ldr	r4, [r5, #56]	; 0x38
  *PCROP1BEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80240aa:	02a4      	lsls	r4, r4, #10
 80240ac:	4034      	ands	r4, r6
 80240ae:	4464      	add	r4, ip
 80240b0:	9b05      	ldr	r3, [sp, #20]
 80240b2:	601c      	str	r4, [r3, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1ASR, FLASH_PCROP1ASR_PCROP1A_STRT));
 80240b4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  *PCROP1AStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80240b6:	02a4      	lsls	r4, r4, #10
 80240b8:	4034      	ands	r4, r6
 80240ba:	4464      	add	r4, ip
 80240bc:	600c      	str	r4, [r1, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1AER, FLASH_PCROP1AER_PCROP1A_END));
 80240be:	6aab      	ldr	r3, [r5, #40]	; 0x28
  *PCROP1AEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80240c0:	029b      	lsls	r3, r3, #10
 80240c2:	4033      	ands	r3, r6
 80240c4:	4463      	add	r3, ip
 80240c6:	6013      	str	r3, [r2, #0]

  *PCROPConfig      = (READ_REG(FLASH->PCROP1AER) & FLASH_PCROP1AER_PCROP_RDP);
 80240c8:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80240ca:	0fdb      	lsrs	r3, r3, #31
 80240cc:	07db      	lsls	r3, r3, #31
 80240ce:	6003      	str	r3, [r0, #0]
}
 80240d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80240d2:	46c0      	nop			; (mov r8, r8)
 80240d4:	58004000 	.word	0x58004000

080240d8 <FLASH_OB_GetIPCCBufferAddr>:
  *           This value correspond to the first double-word of the IPCC mailbox data buffer area
  *           in SRAM starting from 0x20000000 (SRAM1 start address to SRAM2 end address).
  */
static uint32_t FLASH_OB_GetIPCCBufferAddr(void)
{
  return (uint32_t)((READ_BIT(FLASH->IPCCBR, FLASH_IPCCBR_IPCCDBA) << 4) + SRAM1_BASE);
 80240d8:	4b04      	ldr	r3, [pc, #16]	; (80240ec <FLASH_OB_GetIPCCBufferAddr+0x14>)
 80240da:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 80240dc:	0100      	lsls	r0, r0, #4
 80240de:	4b04      	ldr	r3, [pc, #16]	; (80240f0 <FLASH_OB_GetIPCCBufferAddr+0x18>)
 80240e0:	4018      	ands	r0, r3
 80240e2:	2380      	movs	r3, #128	; 0x80
 80240e4:	059b      	lsls	r3, r3, #22
 80240e6:	469c      	mov	ip, r3
 80240e8:	4460      	add	r0, ip
}
 80240ea:	4770      	bx	lr
 80240ec:	58004000 	.word	0x58004000
 80240f0:	0003fff0 	.word	0x0003fff0

080240f4 <FLASH_OB_GetC2BootResetConfig>:
  * @param  C2BootResetRegion   Specifies the Secure Boot reset memory region
  * @retval None
  */
static void FLASH_OB_GetC2BootResetConfig(uint32_t *C2BootResetVectAddr, uint32_t *C2BootResetRegion)
{
  *C2BootResetRegion = (READ_BIT(FLASH->SRRVR, FLASH_SRRVR_C2OPT));
 80240f4:	4a0e      	ldr	r2, [pc, #56]	; (8024130 <FLASH_OB_GetC2BootResetConfig+0x3c>)
 80240f6:	2384      	movs	r3, #132	; 0x84
 80240f8:	58d3      	ldr	r3, [r2, r3]
 80240fa:	0fdb      	lsrs	r3, r3, #31
 80240fc:	07db      	lsls	r3, r3, #31
 80240fe:	600b      	str	r3, [r1, #0]

  if (*C2BootResetRegion == OB_C2_BOOT_FROM_FLASH)
 8024100:	d10b      	bne.n	802411a <FLASH_OB_GetC2BootResetConfig+0x26>
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
  }
  else
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + SRAM1_BASE);
 8024102:	4a0b      	ldr	r2, [pc, #44]	; (8024130 <FLASH_OB_GetC2BootResetConfig+0x3c>)
 8024104:	2384      	movs	r3, #132	; 0x84
 8024106:	58d3      	ldr	r3, [r2, r3]
 8024108:	009b      	lsls	r3, r3, #2
 802410a:	4a0a      	ldr	r2, [pc, #40]	; (8024134 <FLASH_OB_GetC2BootResetConfig+0x40>)
 802410c:	4013      	ands	r3, r2
 802410e:	2280      	movs	r2, #128	; 0x80
 8024110:	0592      	lsls	r2, r2, #22
 8024112:	4694      	mov	ip, r2
 8024114:	4463      	add	r3, ip
 8024116:	6003      	str	r3, [r0, #0]
  }
}
 8024118:	4770      	bx	lr
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
 802411a:	2384      	movs	r3, #132	; 0x84
 802411c:	58d3      	ldr	r3, [r2, r3]
 802411e:	009b      	lsls	r3, r3, #2
 8024120:	4a04      	ldr	r2, [pc, #16]	; (8024134 <FLASH_OB_GetC2BootResetConfig+0x40>)
 8024122:	4013      	ands	r3, r2
 8024124:	2280      	movs	r2, #128	; 0x80
 8024126:	0512      	lsls	r2, r2, #20
 8024128:	4694      	mov	ip, r2
 802412a:	4463      	add	r3, ip
 802412c:	6003      	str	r3, [r0, #0]
 802412e:	e7f3      	b.n	8024118 <FLASH_OB_GetC2BootResetConfig+0x24>
 8024130:	58004000 	.word	0x58004000
 8024134:	0003fffc 	.word	0x0003fffc

08024138 <FLASH_OB_GetSUBGHZSPISecureAccess>:
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_DISABLE : Sub-GHz radio SPI Secure access disabled
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_ENABLE : Sub-GHz radio SPI Secure access enabled
  */
static uint32_t FLASH_OB_GetSUBGHZSPISecureAccess(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_SUBGHZSPISD));
 8024138:	4a02      	ldr	r2, [pc, #8]	; (8024144 <FLASH_OB_GetSUBGHZSPISecureAccess+0xc>)
 802413a:	2380      	movs	r3, #128	; 0x80
 802413c:	58d0      	ldr	r0, [r2, r3]
 802413e:	0fc0      	lsrs	r0, r0, #31
 8024140:	07c0      	lsls	r0, r0, #31
}
 8024142:	4770      	bx	lr
 8024144:	58004000 	.word	0x58004000

08024148 <FLASH_OB_GetC2DebugAccessMode>:
  *           @arg @ref OB_C2_DEBUG_ACCESS_DISABLE : CPU2 debug access disabled
  *           @arg @ref OB_C2_DEBUG_ACCESS_ENABLE : CPU2 debug access enabled
  */
static uint32_t FLASH_OB_GetC2DebugAccessMode(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_DDS));
 8024148:	4a03      	ldr	r2, [pc, #12]	; (8024158 <FLASH_OB_GetC2DebugAccessMode+0x10>)
 802414a:	2380      	movs	r3, #128	; 0x80
 802414c:	58d0      	ldr	r0, [r2, r3]
 802414e:	2380      	movs	r3, #128	; 0x80
 8024150:	015b      	lsls	r3, r3, #5
 8024152:	4018      	ands	r0, r3
}
 8024154:	4770      	bx	lr
 8024156:	46c0      	nop			; (mov r8, r8)
 8024158:	58004000 	.word	0x58004000

0802415c <FLASH_OB_GetSecureMode>:
  *                               Null
  */
static uint32_t FLASH_OB_GetSecureMode(uint32_t Reg, uint32_t Bit, uint32_t ValueEnable, uint32_t ValueDisable)
{
  /* Return status of bit (set as enable, set as disable) */
  if (READ_BIT(Reg, Bit) == 0U)
 802415c:	4201      	tst	r1, r0
 802415e:	d100      	bne.n	8024162 <FLASH_OB_GetSecureMode+0x6>
  {
    return ValueEnable;
 8024160:	0013      	movs	r3, r2
  }
  else
  {
    return ValueDisable;
  }
}
 8024162:	0018      	movs	r0, r3
 8024164:	4770      	bx	lr
	...

08024168 <FLASH_OB_GetSecureMemoryConfig>:
{
 8024168:	b5f0      	push	{r4, r5, r6, r7, lr}
 802416a:	46c6      	mov	lr, r8
 802416c:	b500      	push	{lr}
 802416e:	4698      	mov	r8, r3
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 8024170:	4c24      	ldr	r4, [pc, #144]	; (8024204 <FLASH_OB_GetSecureMemoryConfig+0x9c>)
 8024172:	2580      	movs	r5, #128	; 0x80
 8024174:	5966      	ldr	r6, [r4, r5]
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);
 8024176:	3504      	adds	r5, #4
 8024178:	5965      	ldr	r5, [r4, r5]
  uint32_t user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_SFSA) >> FLASH_SFR_SFSA_Pos);
 802417a:	247f      	movs	r4, #127	; 0x7f
 802417c:	0027      	movs	r7, r4
 802417e:	4037      	ands	r7, r6
  *SecureFlashStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 8024180:	2380      	movs	r3, #128	; 0x80
 8024182:	025b      	lsls	r3, r3, #9
 8024184:	469c      	mov	ip, r3
 8024186:	4467      	add	r7, ip
 8024188:	02ff      	lsls	r7, r7, #11
 802418a:	6007      	str	r7, [r0, #0]
  user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_HDPSA) >> FLASH_SFR_HDPSA_Pos);
 802418c:	0c30      	lsrs	r0, r6, #16
 802418e:	4004      	ands	r4, r0
  *HideProtectionStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 8024190:	4464      	add	r4, ip
 8024192:	02e4      	lsls	r4, r4, #11
 8024194:	600c      	str	r4, [r1, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SBRSA) >> FLASH_SRRVR_SBRSA_Pos);
 8024196:	0ca9      	lsrs	r1, r5, #18
  *SecureSRAM2StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM2_BASE);
 8024198:	0289      	lsls	r1, r1, #10
 802419a:	20f8      	movs	r0, #248	; 0xf8
 802419c:	01c0      	lsls	r0, r0, #7
 802419e:	4001      	ands	r1, r0
 80241a0:	4b19      	ldr	r3, [pc, #100]	; (8024208 <FLASH_OB_GetSecureMemoryConfig+0xa0>)
 80241a2:	469c      	mov	ip, r3
 80241a4:	4461      	add	r1, ip
 80241a6:	6011      	str	r1, [r2, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SNBRSA) >> FLASH_SRRVR_SNBRSA_Pos);
 80241a8:	0e6a      	lsrs	r2, r5, #25
  *SecureSRAM1StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM1_BASE);
 80241aa:	0292      	lsls	r2, r2, #10
 80241ac:	4002      	ands	r2, r0
 80241ae:	2380      	movs	r3, #128	; 0x80
 80241b0:	059b      	lsls	r3, r3, #22
 80241b2:	469c      	mov	ip, r3
 80241b4:	4462      	add	r2, ip
 80241b6:	4643      	mov	r3, r8
 80241b8:	601a      	str	r2, [r3, #0]
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 80241ba:	2310      	movs	r3, #16
 80241bc:	2201      	movs	r2, #1
 80241be:	2180      	movs	r1, #128	; 0x80
 80241c0:	0030      	movs	r0, r6
 80241c2:	f7ff ffcb 	bl	802415c <FLASH_OB_GetSecureMode>
 80241c6:	0004      	movs	r4, r0
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 80241c8:	2780      	movs	r7, #128	; 0x80
 80241ca:	043f      	lsls	r7, r7, #16
 80241cc:	2320      	movs	r3, #32
 80241ce:	2202      	movs	r2, #2
 80241d0:	0039      	movs	r1, r7
 80241d2:	0030      	movs	r0, r6
 80241d4:	f7ff ffc2 	bl	802415c <FLASH_OB_GetSecureMode>
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 80241d8:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 80241da:	2180      	movs	r1, #128	; 0x80
 80241dc:	2340      	movs	r3, #64	; 0x40
 80241de:	2204      	movs	r2, #4
 80241e0:	05c9      	lsls	r1, r1, #23
 80241e2:	0028      	movs	r0, r5
 80241e4:	f7ff ffba 	bl	802415c <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 80241e8:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_BRSD, OB_SECURE_SRAM2_ENABLE, OB_SECURE_SRAM2_DISABLE));
 80241ea:	2380      	movs	r3, #128	; 0x80
 80241ec:	2208      	movs	r2, #8
 80241ee:	0039      	movs	r1, r7
 80241f0:	0028      	movs	r0, r5
 80241f2:	f7ff ffb3 	bl	802415c <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 80241f6:	4304      	orrs	r4, r0
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 80241f8:	9b06      	ldr	r3, [sp, #24]
 80241fa:	601c      	str	r4, [r3, #0]
}
 80241fc:	bc80      	pop	{r7}
 80241fe:	46b8      	mov	r8, r7
 8024200:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024202:	46c0      	nop			; (mov r8, r8)
 8024204:	58004000 	.word	0x58004000
 8024208:	20008000 	.word	0x20008000

0802420c <HAL_FLASHEx_OBGetConfig>:
{
 802420c:	b530      	push	{r4, r5, lr}
 802420e:	b083      	sub	sp, #12
 8024210:	0004      	movs	r4, r0
  pOBInit->OptionType = OPTIONBYTE_ALL;
 8024212:	4b21      	ldr	r3, [pc, #132]	; (8024298 <HAL_FLASHEx_OBGetConfig+0x8c>)
 8024214:	6003      	str	r3, [r0, #0]
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
 8024216:	6840      	ldr	r0, [r0, #4]
 8024218:	2801      	cmp	r0, #1
 802421a:	d935      	bls.n	8024288 <HAL_FLASHEx_OBGetConfig+0x7c>
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 802421c:	f7ff ff22 	bl	8024064 <FLASH_OB_GetRDP>
 8024220:	6120      	str	r0, [r4, #16]
  pOBInit->UserConfig = FLASH_OB_GetUser();
 8024222:	f7ff ff2b 	bl	802407c <FLASH_OB_GetUser>
 8024226:	61a0      	str	r0, [r4, #24]
  pOBInit->UserType = OB_USER_ALL;
 8024228:	4b1c      	ldr	r3, [pc, #112]	; (802429c <HAL_FLASHEx_OBGetConfig+0x90>)
 802422a:	6163      	str	r3, [r4, #20]
  FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROP1AStartAddr), &(pOBInit->PCROP1AEndAddr), &(pOBInit->PCROP1BStartAddr), &(pOBInit->PCROP1BEndAddr));
 802422c:	0023      	movs	r3, r4
 802422e:	3328      	adds	r3, #40	; 0x28
 8024230:	0022      	movs	r2, r4
 8024232:	3224      	adds	r2, #36	; 0x24
 8024234:	0021      	movs	r1, r4
 8024236:	3120      	adds	r1, #32
 8024238:	0020      	movs	r0, r4
 802423a:	301c      	adds	r0, #28
 802423c:	0025      	movs	r5, r4
 802423e:	352c      	adds	r5, #44	; 0x2c
 8024240:	9500      	str	r5, [sp, #0]
 8024242:	f7ff ff25 	bl	8024090 <FLASH_OB_GetPCROP>
  pOBInit->PCROPConfig |= (OB_PCROP_ZONE_A | OB_PCROP_ZONE_B);
 8024246:	2303      	movs	r3, #3
 8024248:	69e2      	ldr	r2, [r4, #28]
 802424a:	4313      	orrs	r3, r2
 802424c:	61e3      	str	r3, [r4, #28]
  pOBInit->IPCCdataBufAddr = FLASH_OB_GetIPCCBufferAddr();
 802424e:	f7ff ff43 	bl	80240d8 <FLASH_OB_GetIPCCBufferAddr>
 8024252:	6560      	str	r0, [r4, #84]	; 0x54
  FLASH_OB_GetSecureMemoryConfig(&(pOBInit->SecureFlashStartAddr), &(pOBInit->HideProtectionStartAddr), &(pOBInit->SecureSRAM2StartAddr), &(pOBInit->SecureSRAM1StartAddr), &(pOBInit->SecureMode));
 8024254:	0023      	movs	r3, r4
 8024256:	3338      	adds	r3, #56	; 0x38
 8024258:	0022      	movs	r2, r4
 802425a:	3234      	adds	r2, #52	; 0x34
 802425c:	0021      	movs	r1, r4
 802425e:	313c      	adds	r1, #60	; 0x3c
 8024260:	0020      	movs	r0, r4
 8024262:	3030      	adds	r0, #48	; 0x30
 8024264:	3514      	adds	r5, #20
 8024266:	9500      	str	r5, [sp, #0]
 8024268:	f7ff ff7e 	bl	8024168 <FLASH_OB_GetSecureMemoryConfig>
  FLASH_OB_GetC2BootResetConfig(&(pOBInit->C2SecureBootVectAddr), &(pOBInit->C2BootRegion));
 802426c:	0021      	movs	r1, r4
 802426e:	314c      	adds	r1, #76	; 0x4c
 8024270:	0020      	movs	r0, r4
 8024272:	3050      	adds	r0, #80	; 0x50
 8024274:	f7ff ff3e 	bl	80240f4 <FLASH_OB_GetC2BootResetConfig>
  pOBInit->SUBGHZSPISecureAccess = FLASH_OB_GetSUBGHZSPISecureAccess();
 8024278:	f7ff ff5e 	bl	8024138 <FLASH_OB_GetSUBGHZSPISecureAccess>
 802427c:	6460      	str	r0, [r4, #68]	; 0x44
  pOBInit->C2DebugAccessMode = FLASH_OB_GetC2DebugAccessMode();
 802427e:	f7ff ff63 	bl	8024148 <FLASH_OB_GetC2DebugAccessMode>
 8024282:	64a0      	str	r0, [r4, #72]	; 0x48
}
 8024284:	b003      	add	sp, #12
 8024286:	bd30      	pop	{r4, r5, pc}
    FLASH_OB_GetWRP(pOBInit->WRPArea, &(pOBInit->WRPStartOffset), &(pOBInit->WRPEndOffset));
 8024288:	0022      	movs	r2, r4
 802428a:	320c      	adds	r2, #12
 802428c:	0021      	movs	r1, r4
 802428e:	3108      	adds	r1, #8
 8024290:	f7ff fece 	bl	8024030 <FLASH_OB_GetWRP>
 8024294:	e7c2      	b.n	802421c <HAL_FLASHEx_OBGetConfig+0x10>
 8024296:	46c0      	nop			; (mov r8, r8)
 8024298:	00000f1f 	.word	0x00000f1f
 802429c:	cf8f7e00 	.word	0xcf8f7e00

080242a0 <FLASH_PageErase>:
  MODIFY_REG(FLASH->C2CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 80242a0:	4a04      	ldr	r2, [pc, #16]	; (80242b4 <FLASH_PageErase+0x14>)
 80242a2:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80242a4:	4904      	ldr	r1, [pc, #16]	; (80242b8 <FLASH_PageErase+0x18>)
 80242a6:	400b      	ands	r3, r1
 80242a8:	00c0      	lsls	r0, r0, #3
 80242aa:	4303      	orrs	r3, r0
 80242ac:	4803      	ldr	r0, [pc, #12]	; (80242bc <FLASH_PageErase+0x1c>)
 80242ae:	4303      	orrs	r3, r0
 80242b0:	6653      	str	r3, [r2, #100]	; 0x64
}
 80242b2:	4770      	bx	lr
 80242b4:	58004000 	.word	0x58004000
 80242b8:	fffffc07 	.word	0xfffffc07
 80242bc:	00010002 	.word	0x00010002

080242c0 <HAL_FLASHEx_Erase>:
{
 80242c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80242c2:	0006      	movs	r6, r0
 80242c4:	000f      	movs	r7, r1
  __HAL_LOCK(&pFlash);
 80242c6:	4b1d      	ldr	r3, [pc, #116]	; (802433c <HAL_FLASHEx_Erase+0x7c>)
 80242c8:	781b      	ldrb	r3, [r3, #0]
 80242ca:	2b01      	cmp	r3, #1
 80242cc:	d034      	beq.n	8024338 <HAL_FLASHEx_Erase+0x78>
 80242ce:	4b1b      	ldr	r3, [pc, #108]	; (802433c <HAL_FLASHEx_Erase+0x7c>)
 80242d0:	2201      	movs	r2, #1
 80242d2:	701a      	strb	r2, [r3, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80242d4:	2200      	movs	r2, #0
 80242d6:	605a      	str	r2, [r3, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 80242d8:	20fa      	movs	r0, #250	; 0xfa
 80242da:	0080      	lsls	r0, r0, #2
 80242dc:	f7ff fe02 	bl	8023ee4 <FLASH_WaitForLastOperation>
 80242e0:	1e04      	subs	r4, r0, #0
  if (status == HAL_OK)
 80242e2:	d124      	bne.n	802432e <HAL_FLASHEx_Erase+0x6e>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 80242e4:	6833      	ldr	r3, [r6, #0]
 80242e6:	2b04      	cmp	r3, #4
 80242e8:	d014      	beq.n	8024314 <HAL_FLASHEx_Erase+0x54>
      *PageError = 0xFFFFFFFFU;
 80242ea:	2301      	movs	r3, #1
 80242ec:	425b      	negs	r3, r3
 80242ee:	603b      	str	r3, [r7, #0]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 80242f0:	6875      	ldr	r5, [r6, #4]
 80242f2:	6873      	ldr	r3, [r6, #4]
 80242f4:	68b2      	ldr	r2, [r6, #8]
 80242f6:	4694      	mov	ip, r2
 80242f8:	4463      	add	r3, ip
 80242fa:	42ab      	cmp	r3, r5
 80242fc:	d913      	bls.n	8024326 <HAL_FLASHEx_Erase+0x66>
        FLASH_PageErase(index);
 80242fe:	0028      	movs	r0, r5
 8024300:	f7ff ffce 	bl	80242a0 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8024304:	20fa      	movs	r0, #250	; 0xfa
 8024306:	0080      	lsls	r0, r0, #2
 8024308:	f7ff fdec 	bl	8023ee4 <FLASH_WaitForLastOperation>
 802430c:	1e04      	subs	r4, r0, #0
        if (status != HAL_OK)
 802430e:	d109      	bne.n	8024324 <HAL_FLASHEx_Erase+0x64>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 8024310:	3501      	adds	r5, #1
 8024312:	e7ee      	b.n	80242f2 <HAL_FLASHEx_Erase+0x32>
      FLASH_MassErase();
 8024314:	f7ff fe56 	bl	8023fc4 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8024318:	20fa      	movs	r0, #250	; 0xfa
 802431a:	0080      	lsls	r0, r0, #2
 802431c:	f7ff fde2 	bl	8023ee4 <FLASH_WaitForLastOperation>
 8024320:	0004      	movs	r4, r0
 8024322:	e002      	b.n	802432a <HAL_FLASHEx_Erase+0x6a>
          *PageError = index;
 8024324:	603d      	str	r5, [r7, #0]
      FLASH_AcknowledgePageErase();
 8024326:	f7ff fe79 	bl	802401c <FLASH_AcknowledgePageErase>
    FLASH_FlushCaches();
 802432a:	f7ff fe55 	bl	8023fd8 <FLASH_FlushCaches>
  __HAL_UNLOCK(&pFlash);
 802432e:	4b03      	ldr	r3, [pc, #12]	; (802433c <HAL_FLASHEx_Erase+0x7c>)
 8024330:	2200      	movs	r2, #0
 8024332:	701a      	strb	r2, [r3, #0]
}
 8024334:	0020      	movs	r0, r4
 8024336:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(&pFlash);
 8024338:	2402      	movs	r4, #2
 802433a:	e7fb      	b.n	8024334 <HAL_FLASHEx_Erase+0x74>
 802433c:	2000a1e8 	.word	0x2000a1e8

08024340 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8024340:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t position = 0x00u;
 8024342:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8024344:	e05b      	b.n	80243fe <HAL_GPIO_Init+0xbe>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8024346:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8024348:	005f      	lsls	r7, r3, #1
 802434a:	2603      	movs	r6, #3
 802434c:	40be      	lsls	r6, r7
 802434e:	43b4      	bics	r4, r6
 8024350:	0026      	movs	r6, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8024352:	68cc      	ldr	r4, [r1, #12]
 8024354:	40bc      	lsls	r4, r7
 8024356:	4334      	orrs	r4, r6
        GPIOx->OSPEEDR = temp;
 8024358:	6084      	str	r4, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 802435a:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 802435c:	4394      	bics	r4, r2
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 802435e:	684a      	ldr	r2, [r1, #4]
 8024360:	0916      	lsrs	r6, r2, #4
 8024362:	2201      	movs	r2, #1
 8024364:	4032      	ands	r2, r6
 8024366:	409a      	lsls	r2, r3
 8024368:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 802436a:	6042      	str	r2, [r0, #4]
 802436c:	e057      	b.n	802441e <HAL_GPIO_Init+0xde>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 802436e:	08dc      	lsrs	r4, r3, #3
 8024370:	3408      	adds	r4, #8
 8024372:	00a4      	lsls	r4, r4, #2
 8024374:	5826      	ldr	r6, [r4, r0]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8024376:	3205      	adds	r2, #5
 8024378:	401a      	ands	r2, r3
 802437a:	0092      	lsls	r2, r2, #2
 802437c:	270f      	movs	r7, #15
 802437e:	4097      	lsls	r7, r2
 8024380:	43be      	bics	r6, r7
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8024382:	690f      	ldr	r7, [r1, #16]
 8024384:	4097      	lsls	r7, r2
 8024386:	003a      	movs	r2, r7
 8024388:	4332      	orrs	r2, r6
        GPIOx->AFR[position >> 3u] = temp;
 802438a:	5022      	str	r2, [r4, r0]
 802438c:	e05b      	b.n	8024446 <HAL_GPIO_Init+0x106>
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = SYSCFG->EXTICR[position >> 2u];
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802438e:	2602      	movs	r6, #2
 8024390:	e000      	b.n	8024394 <HAL_GPIO_Init+0x54>
 8024392:	2600      	movs	r6, #0
 8024394:	40a6      	lsls	r6, r4
 8024396:	0034      	movs	r4, r6
 8024398:	433c      	orrs	r4, r7
        SYSCFG->EXTICR[position >> 2u] = temp;
 802439a:	3202      	adds	r2, #2
 802439c:	0092      	lsls	r2, r2, #2
 802439e:	4e3f      	ldr	r6, [pc, #252]	; (802449c <HAL_GPIO_Init+0x15c>)
 80243a0:	5194      	str	r4, [r2, r6]

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
 80243a2:	4c3f      	ldr	r4, [pc, #252]	; (80244a0 <HAL_GPIO_Init+0x160>)
 80243a4:	22c0      	movs	r2, #192	; 0xc0
 80243a6:	58a4      	ldr	r4, [r4, r2]
#else
        temp = EXTI->IMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 80243a8:	43ea      	mvns	r2, r5
 80243aa:	0026      	movs	r6, r4
 80243ac:	43ae      	bics	r6, r5
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 80243ae:	684f      	ldr	r7, [r1, #4]
 80243b0:	03ff      	lsls	r7, r7, #15
 80243b2:	d501      	bpl.n	80243b8 <HAL_GPIO_Init+0x78>
        {
          temp |= iocurrent;
 80243b4:	432c      	orrs	r4, r5
 80243b6:	0026      	movs	r6, r4
        }
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 = temp;
 80243b8:	4c39      	ldr	r4, [pc, #228]	; (80244a0 <HAL_GPIO_Init+0x160>)
 80243ba:	27c0      	movs	r7, #192	; 0xc0
 80243bc:	51e6      	str	r6, [r4, r7]
#else
        EXTI->IMR1 = temp;
#endif /* CORE_CM0PLUS */

#ifdef CORE_CM0PLUS
        temp = EXTI->C2EMR1;
 80243be:	26c4      	movs	r6, #196	; 0xc4
 80243c0:	59a4      	ldr	r4, [r4, r6]
#else
        temp = EXTI->EMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 80243c2:	0026      	movs	r6, r4
 80243c4:	4016      	ands	r6, r2
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 80243c6:	684f      	ldr	r7, [r1, #4]
 80243c8:	03bf      	lsls	r7, r7, #14
 80243ca:	d501      	bpl.n	80243d0 <HAL_GPIO_Init+0x90>
        {
          temp |= iocurrent;
 80243cc:	432c      	orrs	r4, r5
 80243ce:	0026      	movs	r6, r4
        }
#ifdef CORE_CM0PLUS
        EXTI->C2EMR1 = temp;
 80243d0:	4c33      	ldr	r4, [pc, #204]	; (80244a0 <HAL_GPIO_Init+0x160>)
 80243d2:	27c4      	movs	r7, #196	; 0xc4
 80243d4:	51e6      	str	r6, [r4, r7]
#else
        EXTI->EMR1 = temp;
#endif /* CORE_CM0PLUS */

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80243d6:	6824      	ldr	r4, [r4, #0]
        temp &= ~(iocurrent);
 80243d8:	0026      	movs	r6, r4
 80243da:	4016      	ands	r6, r2
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 80243dc:	684f      	ldr	r7, [r1, #4]
 80243de:	02ff      	lsls	r7, r7, #11
 80243e0:	d501      	bpl.n	80243e6 <HAL_GPIO_Init+0xa6>
        {
          temp |= iocurrent;
 80243e2:	432c      	orrs	r4, r5
 80243e4:	0026      	movs	r6, r4
        }
        EXTI->RTSR1 = temp;
 80243e6:	4c2e      	ldr	r4, [pc, #184]	; (80244a0 <HAL_GPIO_Init+0x160>)
 80243e8:	6026      	str	r6, [r4, #0]

        temp = EXTI->FTSR1;
 80243ea:	6864      	ldr	r4, [r4, #4]
        temp &= ~(iocurrent);
 80243ec:	4022      	ands	r2, r4
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 80243ee:	684e      	ldr	r6, [r1, #4]
 80243f0:	02b6      	lsls	r6, r6, #10
 80243f2:	d501      	bpl.n	80243f8 <HAL_GPIO_Init+0xb8>
        {
          temp |= iocurrent;
 80243f4:	002a      	movs	r2, r5
 80243f6:	4322      	orrs	r2, r4
        }
        EXTI->FTSR1 = temp;
 80243f8:	4c29      	ldr	r4, [pc, #164]	; (80244a0 <HAL_GPIO_Init+0x160>)
 80243fa:	6062      	str	r2, [r4, #4]
      }
    }

    position++;
 80243fc:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80243fe:	680c      	ldr	r4, [r1, #0]
 8024400:	0022      	movs	r2, r4
 8024402:	40da      	lsrs	r2, r3
 8024404:	d049      	beq.n	802449a <HAL_GPIO_Init+0x15a>
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8024406:	2201      	movs	r2, #1
 8024408:	409a      	lsls	r2, r3
 802440a:	0025      	movs	r5, r4
 802440c:	4015      	ands	r5, r2
    if (iocurrent != 0x00u)
 802440e:	4214      	tst	r4, r2
 8024410:	d0f4      	beq.n	80243fc <HAL_GPIO_Init+0xbc>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8024412:	2403      	movs	r4, #3
 8024414:	684e      	ldr	r6, [r1, #4]
 8024416:	4034      	ands	r4, r6
 8024418:	3c01      	subs	r4, #1
 802441a:	2c01      	cmp	r4, #1
 802441c:	d993      	bls.n	8024346 <HAL_GPIO_Init+0x6>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 802441e:	2203      	movs	r2, #3
 8024420:	684c      	ldr	r4, [r1, #4]
 8024422:	4022      	ands	r2, r4
 8024424:	2a03      	cmp	r2, #3
 8024426:	d009      	beq.n	802443c <HAL_GPIO_Init+0xfc>
        temp = GPIOx->PUPDR;
 8024428:	68c2      	ldr	r2, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802442a:	005e      	lsls	r6, r3, #1
 802442c:	2403      	movs	r4, #3
 802442e:	40b4      	lsls	r4, r6
 8024430:	43a2      	bics	r2, r4
 8024432:	0014      	movs	r4, r2
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8024434:	688a      	ldr	r2, [r1, #8]
 8024436:	40b2      	lsls	r2, r6
 8024438:	4322      	orrs	r2, r4
        GPIOx->PUPDR = temp;
 802443a:	60c2      	str	r2, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802443c:	2203      	movs	r2, #3
 802443e:	684c      	ldr	r4, [r1, #4]
 8024440:	4022      	ands	r2, r4
 8024442:	2a02      	cmp	r2, #2
 8024444:	d093      	beq.n	802436e <HAL_GPIO_Init+0x2e>
      temp = GPIOx->MODER;
 8024446:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8024448:	005e      	lsls	r6, r3, #1
 802444a:	2203      	movs	r2, #3
 802444c:	0017      	movs	r7, r2
 802444e:	40b7      	lsls	r7, r6
 8024450:	43bc      	bics	r4, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8024452:	684f      	ldr	r7, [r1, #4]
 8024454:	403a      	ands	r2, r7
 8024456:	40b2      	lsls	r2, r6
 8024458:	4322      	orrs	r2, r4
      GPIOx->MODER = temp;
 802445a:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802445c:	22c0      	movs	r2, #192	; 0xc0
 802445e:	0292      	lsls	r2, r2, #10
 8024460:	684c      	ldr	r4, [r1, #4]
 8024462:	4214      	tst	r4, r2
 8024464:	d0ca      	beq.n	80243fc <HAL_GPIO_Init+0xbc>
        temp = SYSCFG->EXTICR[position >> 2u];
 8024466:	089a      	lsrs	r2, r3, #2
 8024468:	1c94      	adds	r4, r2, #2
 802446a:	00a4      	lsls	r4, r4, #2
 802446c:	4e0b      	ldr	r6, [pc, #44]	; (802449c <HAL_GPIO_Init+0x15c>)
 802446e:	59a7      	ldr	r7, [r4, r6]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 8024470:	2403      	movs	r4, #3
 8024472:	401c      	ands	r4, r3
 8024474:	00a4      	lsls	r4, r4, #2
 8024476:	2607      	movs	r6, #7
 8024478:	40a6      	lsls	r6, r4
 802447a:	43b7      	bics	r7, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 802447c:	2690      	movs	r6, #144	; 0x90
 802447e:	05f6      	lsls	r6, r6, #23
 8024480:	42b0      	cmp	r0, r6
 8024482:	d086      	beq.n	8024392 <HAL_GPIO_Init+0x52>
 8024484:	4e07      	ldr	r6, [pc, #28]	; (80244a4 <HAL_GPIO_Init+0x164>)
 8024486:	42b0      	cmp	r0, r6
 8024488:	d005      	beq.n	8024496 <HAL_GPIO_Init+0x156>
 802448a:	4e07      	ldr	r6, [pc, #28]	; (80244a8 <HAL_GPIO_Init+0x168>)
 802448c:	42b0      	cmp	r0, r6
 802448e:	d100      	bne.n	8024492 <HAL_GPIO_Init+0x152>
 8024490:	e77d      	b.n	802438e <HAL_GPIO_Init+0x4e>
 8024492:	2607      	movs	r6, #7
 8024494:	e77e      	b.n	8024394 <HAL_GPIO_Init+0x54>
 8024496:	2601      	movs	r6, #1
 8024498:	e77c      	b.n	8024394 <HAL_GPIO_Init+0x54>
  }
}
 802449a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802449c:	40010000 	.word	0x40010000
 80244a0:	58000800 	.word	0x58000800
 80244a4:	48000400 	.word	0x48000400
 80244a8:	48000800 	.word	0x48000800

080244ac <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80244ac:	2a00      	cmp	r2, #0
 80244ae:	d001      	beq.n	80244b4 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80244b0:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 80244b2:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80244b4:	6281      	str	r1, [r0, #40]	; 0x28
}
 80244b6:	e7fc      	b.n	80244b2 <HAL_GPIO_WritePin+0x6>

080244b8 <HAL_IPCC_RxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_RxCallback can be implemented in the user file
   */
}
 80244b8:	4770      	bx	lr

080244ba <HAL_IPCC_TxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_TxCallback can be implemented in the user file
   */
}
 80244ba:	4770      	bx	lr

080244bc <HAL_IPCC_TX_IRQHandler>:
{
 80244bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80244be:	0007      	movs	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_TX_BUF;
 80244c0:	4b12      	ldr	r3, [pc, #72]	; (802450c <HAL_IPCC_TX_IRQHandler+0x50>)
 80244c2:	685a      	ldr	r2, [r3, #4]
 80244c4:	26fc      	movs	r6, #252	; 0xfc
 80244c6:	03b6      	lsls	r6, r6, #14
 80244c8:	4396      	bics	r6, r2
  irqmask = irqmask & ~(currentInstance->SR << IPCC_MR_CH1FM_Pos);
 80244ca:	68db      	ldr	r3, [r3, #12]
 80244cc:	041b      	lsls	r3, r3, #16
 80244ce:	439e      	bics	r6, r3
  uint32_t ch_count = 0U;
 80244d0:	2500      	movs	r5, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 80244d2:	e001      	b.n	80244d8 <HAL_IPCC_TX_IRQHandler+0x1c>
      irqmask =  irqmask & ~(bit_pos);
 80244d4:	43a6      	bics	r6, r4
    ch_count++;
 80244d6:	3501      	adds	r5, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 80244d8:	2e00      	cmp	r6, #0
 80244da:	d015      	beq.n	8024508 <HAL_IPCC_TX_IRQHandler+0x4c>
    bit_pos = 1UL << (IPCC_MR_CH1FM_Pos + (ch_count & CHANNEL_INDEX_Msk));
 80244dc:	230f      	movs	r3, #15
 80244de:	402b      	ands	r3, r5
 80244e0:	3310      	adds	r3, #16
 80244e2:	2401      	movs	r4, #1
 80244e4:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 80244e6:	4234      	tst	r4, r6
 80244e8:	d0f5      	beq.n	80244d6 <HAL_IPCC_TX_IRQHandler+0x1a>
      currentInstance->MR |= bit_pos;
 80244ea:	4a08      	ldr	r2, [pc, #32]	; (802450c <HAL_IPCC_TX_IRQHandler+0x50>)
 80244ec:	6853      	ldr	r3, [r2, #4]
 80244ee:	4323      	orrs	r3, r4
 80244f0:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackTx[ch_count] != NULL)
 80244f2:	1dab      	adds	r3, r5, #6
 80244f4:	009b      	lsls	r3, r3, #2
 80244f6:	18fb      	adds	r3, r7, r3
 80244f8:	685b      	ldr	r3, [r3, #4]
 80244fa:	2b00      	cmp	r3, #0
 80244fc:	d0ea      	beq.n	80244d4 <HAL_IPCC_TX_IRQHandler+0x18>
        hipcc->ChannelCallbackTx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_TX);
 80244fe:	2200      	movs	r2, #0
 8024500:	0029      	movs	r1, r5
 8024502:	0038      	movs	r0, r7
 8024504:	4798      	blx	r3
 8024506:	e7e5      	b.n	80244d4 <HAL_IPCC_TX_IRQHandler+0x18>
}
 8024508:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802450a:	46c0      	nop			; (mov r8, r8)
 802450c:	58000c10 	.word	0x58000c10

08024510 <HAL_IPCC_RX_IRQHandler>:
{
 8024510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8024512:	0007      	movs	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_RX_BUF;
 8024514:	4b10      	ldr	r3, [pc, #64]	; (8024558 <HAL_IPCC_RX_IRQHandler+0x48>)
 8024516:	685b      	ldr	r3, [r3, #4]
 8024518:	263f      	movs	r6, #63	; 0x3f
 802451a:	439e      	bics	r6, r3
  irqmask = irqmask & otherInstance->SR;
 802451c:	4b0f      	ldr	r3, [pc, #60]	; (802455c <HAL_IPCC_RX_IRQHandler+0x4c>)
 802451e:	68db      	ldr	r3, [r3, #12]
 8024520:	401e      	ands	r6, r3
  uint32_t ch_count = 0U;
 8024522:	2500      	movs	r5, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8024524:	e001      	b.n	802452a <HAL_IPCC_RX_IRQHandler+0x1a>
      irqmask = irqmask & ~(bit_pos);
 8024526:	43a6      	bics	r6, r4
    ch_count++;
 8024528:	3501      	adds	r5, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 802452a:	2e00      	cmp	r6, #0
 802452c:	d013      	beq.n	8024556 <HAL_IPCC_RX_IRQHandler+0x46>
    bit_pos = 1UL << (ch_count & CHANNEL_INDEX_Msk);
 802452e:	230f      	movs	r3, #15
 8024530:	402b      	ands	r3, r5
 8024532:	2401      	movs	r4, #1
 8024534:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 8024536:	4234      	tst	r4, r6
 8024538:	d0f6      	beq.n	8024528 <HAL_IPCC_RX_IRQHandler+0x18>
      currentInstance->MR |= bit_pos;
 802453a:	4a07      	ldr	r2, [pc, #28]	; (8024558 <HAL_IPCC_RX_IRQHandler+0x48>)
 802453c:	6853      	ldr	r3, [r2, #4]
 802453e:	4323      	orrs	r3, r4
 8024540:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackRx[ch_count] != NULL)
 8024542:	00ab      	lsls	r3, r5, #2
 8024544:	18fb      	adds	r3, r7, r3
 8024546:	685b      	ldr	r3, [r3, #4]
 8024548:	2b00      	cmp	r3, #0
 802454a:	d0ec      	beq.n	8024526 <HAL_IPCC_RX_IRQHandler+0x16>
        hipcc->ChannelCallbackRx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_RX);
 802454c:	2201      	movs	r2, #1
 802454e:	0029      	movs	r1, r5
 8024550:	0038      	movs	r0, r7
 8024552:	4798      	blx	r3
 8024554:	e7e7      	b.n	8024526 <HAL_IPCC_RX_IRQHandler+0x16>
}
 8024556:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024558:	58000c10 	.word	0x58000c10
 802455c:	58000c00 	.word	0x58000c00

08024560 <IPCC_UnmaskInterrupt>:
#if defined(CORE_CM0PLUS)
  IPCC_CommonTypeDef *currentInstance = IPCC_C2;
#else
  IPCC_CommonTypeDef *currentInstance = IPCC_C1;
#endif
  if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 8024560:	2900      	cmp	r1, #0
 8024562:	d109      	bne.n	8024578 <IPCC_UnmaskInterrupt+0x18>
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 8024564:	4909      	ldr	r1, [pc, #36]	; (802458c <IPCC_UnmaskInterrupt+0x2c>)
 8024566:	684b      	ldr	r3, [r1, #4]
 8024568:	220f      	movs	r2, #15
 802456a:	4010      	ands	r0, r2
 802456c:	2280      	movs	r2, #128	; 0x80
 802456e:	0252      	lsls	r2, r2, #9
 8024570:	4082      	lsls	r2, r0
 8024572:	4393      	bics	r3, r2
 8024574:	604b      	str	r3, [r1, #4]
  else
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
  }
}
 8024576:	4770      	bx	lr
    currentInstance->MR &= ~(IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 8024578:	4904      	ldr	r1, [pc, #16]	; (802458c <IPCC_UnmaskInterrupt+0x2c>)
 802457a:	684b      	ldr	r3, [r1, #4]
 802457c:	220f      	movs	r2, #15
 802457e:	4010      	ands	r0, r2
 8024580:	3a0e      	subs	r2, #14
 8024582:	4082      	lsls	r2, r0
 8024584:	4393      	bics	r3, r2
 8024586:	604b      	str	r3, [r1, #4]
}
 8024588:	e7f5      	b.n	8024576 <IPCC_UnmaskInterrupt+0x16>
 802458a:	46c0      	nop			; (mov r8, r8)
 802458c:	58000c10 	.word	0x58000c10

08024590 <HAL_IPCC_ActivateNotification>:
{
 8024590:	b510      	push	{r4, lr}
 8024592:	000c      	movs	r4, r1
  if (hipcc != NULL)
 8024594:	2800      	cmp	r0, #0
 8024596:	d028      	beq.n	80245ea <HAL_IPCC_ActivateNotification+0x5a>
    if (hipcc->State == HAL_IPCC_STATE_READY)
 8024598:	2138      	movs	r1, #56	; 0x38
 802459a:	5c41      	ldrb	r1, [r0, r1]
 802459c:	2901      	cmp	r1, #1
 802459e:	d001      	beq.n	80245a4 <HAL_IPCC_ActivateNotification+0x14>
      err = HAL_ERROR;
 80245a0:	2001      	movs	r0, #1
}
 80245a2:	bd10      	pop	{r4, pc}
      if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 80245a4:	2a00      	cmp	r2, #0
 80245a6:	d10f      	bne.n	80245c8 <HAL_IPCC_ActivateNotification+0x38>
        hipcc->ChannelCallbackTx[ChannelIndex] = cb;
 80245a8:	1da1      	adds	r1, r4, #6
 80245aa:	0089      	lsls	r1, r1, #2
 80245ac:	1841      	adds	r1, r0, r1
 80245ae:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80245b0:	210f      	movs	r1, #15
 80245b2:	4021      	ands	r1, r4
 80245b4:	2380      	movs	r3, #128	; 0x80
 80245b6:	025b      	lsls	r3, r3, #9
 80245b8:	408b      	lsls	r3, r1
 80245ba:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80245bc:	430b      	orrs	r3, r1
 80245be:	6343      	str	r3, [r0, #52]	; 0x34
      if (ChannelDir == IPCC_CHANNEL_DIR_RX)
 80245c0:	2a01      	cmp	r2, #1
 80245c2:	d00c      	beq.n	80245de <HAL_IPCC_ActivateNotification+0x4e>
  HAL_StatusTypeDef err = HAL_OK;
 80245c4:	2000      	movs	r0, #0
 80245c6:	e7ec      	b.n	80245a2 <HAL_IPCC_ActivateNotification+0x12>
        hipcc->ChannelCallbackRx[ChannelIndex] = cb;
 80245c8:	00a1      	lsls	r1, r4, #2
 80245ca:	1841      	adds	r1, r0, r1
 80245cc:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80245ce:	210f      	movs	r1, #15
 80245d0:	4021      	ands	r1, r4
 80245d2:	2301      	movs	r3, #1
 80245d4:	408b      	lsls	r3, r1
 80245d6:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80245d8:	430b      	orrs	r3, r1
 80245da:	6343      	str	r3, [r0, #52]	; 0x34
 80245dc:	e7f0      	b.n	80245c0 <HAL_IPCC_ActivateNotification+0x30>
        IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 80245de:	0011      	movs	r1, r2
 80245e0:	0020      	movs	r0, r4
 80245e2:	f7ff ffbd 	bl	8024560 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 80245e6:	2000      	movs	r0, #0
 80245e8:	e7db      	b.n	80245a2 <HAL_IPCC_ActivateNotification+0x12>
    err = HAL_ERROR;
 80245ea:	2001      	movs	r0, #1
 80245ec:	e7d9      	b.n	80245a2 <HAL_IPCC_ActivateNotification+0x12>
	...

080245f0 <HAL_IPCC_NotifyCPU>:
{
 80245f0:	b570      	push	{r4, r5, r6, lr}
 80245f2:	000b      	movs	r3, r1
  if (hipcc->State == HAL_IPCC_STATE_READY)
 80245f4:	2438      	movs	r4, #56	; 0x38
 80245f6:	5d04      	ldrb	r4, [r0, r4]
 80245f8:	2c01      	cmp	r4, #1
 80245fa:	d001      	beq.n	8024600 <HAL_IPCC_NotifyCPU+0x10>
    err = HAL_ERROR;
 80245fc:	2001      	movs	r0, #1
}
 80245fe:	bd70      	pop	{r4, r5, r6, pc}
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 8024600:	490c      	ldr	r1, [pc, #48]	; (8024634 <HAL_IPCC_NotifyCPU+0x44>)
 8024602:	6889      	ldr	r1, [r1, #8]
 8024604:	2a00      	cmp	r2, #0
 8024606:	d10d      	bne.n	8024624 <HAL_IPCC_NotifyCPU+0x34>
 8024608:	2480      	movs	r4, #128	; 0x80
 802460a:	0264      	lsls	r4, r4, #9
 802460c:	250f      	movs	r5, #15
 802460e:	401d      	ands	r5, r3
 8024610:	40ac      	lsls	r4, r5
 8024612:	4321      	orrs	r1, r4
 8024614:	4d07      	ldr	r5, [pc, #28]	; (8024634 <HAL_IPCC_NotifyCPU+0x44>)
 8024616:	60a9      	str	r1, [r5, #8]
    if ((hipcc->callbackRequest & mask) == mask)
 8024618:	6b41      	ldr	r1, [r0, #52]	; 0x34
 802461a:	4021      	ands	r1, r4
 802461c:	428c      	cmp	r4, r1
 802461e:	d003      	beq.n	8024628 <HAL_IPCC_NotifyCPU+0x38>
  HAL_StatusTypeDef err = HAL_OK;
 8024620:	2000      	movs	r0, #0
 8024622:	e7ec      	b.n	80245fe <HAL_IPCC_NotifyCPU+0xe>
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 8024624:	2401      	movs	r4, #1
 8024626:	e7f1      	b.n	802460c <HAL_IPCC_NotifyCPU+0x1c>
      IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 8024628:	0011      	movs	r1, r2
 802462a:	0018      	movs	r0, r3
 802462c:	f7ff ff98 	bl	8024560 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 8024630:	2000      	movs	r0, #0
 8024632:	e7e4      	b.n	80245fe <HAL_IPCC_NotifyCPU+0xe>
 8024634:	58000c10 	.word	0x58000c10

08024638 <IPCC_SetDefaultCallbacks>:
  */
void IPCC_SetDefaultCallbacks(IPCC_HandleTypeDef *hipcc)
{
  uint32_t i;
  /* Set all callbacks to default */
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8024638:	2200      	movs	r2, #0
 802463a:	2a05      	cmp	r2, #5
 802463c:	d80a      	bhi.n	8024654 <IPCC_SetDefaultCallbacks+0x1c>
  {
    hipcc->ChannelCallbackRx[i] = HAL_IPCC_RxCallback;
 802463e:	0093      	lsls	r3, r2, #2
 8024640:	18c3      	adds	r3, r0, r3
 8024642:	4905      	ldr	r1, [pc, #20]	; (8024658 <IPCC_SetDefaultCallbacks+0x20>)
 8024644:	6059      	str	r1, [r3, #4]
    hipcc->ChannelCallbackTx[i] = HAL_IPCC_TxCallback;
 8024646:	1d93      	adds	r3, r2, #6
 8024648:	009b      	lsls	r3, r3, #2
 802464a:	18c3      	adds	r3, r0, r3
 802464c:	4903      	ldr	r1, [pc, #12]	; (802465c <IPCC_SetDefaultCallbacks+0x24>)
 802464e:	6059      	str	r1, [r3, #4]
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8024650:	3201      	adds	r2, #1
 8024652:	e7f2      	b.n	802463a <IPCC_SetDefaultCallbacks+0x2>
  }
}
 8024654:	4770      	bx	lr
 8024656:	46c0      	nop			; (mov r8, r8)
 8024658:	080244b9 	.word	0x080244b9
 802465c:	080244bb 	.word	0x080244bb

08024660 <IPCC_Reset_Register>:
  * @param  Instance pointer to register
  */
void IPCC_Reset_Register(IPCC_CommonTypeDef *Instance)
{
  /* Disable RX and TX interrupts */
  Instance->CR  = 0x00000000U;
 8024660:	2300      	movs	r3, #0
 8024662:	6003      	str	r3, [r0, #0]

  /* Mask RX and TX interrupts */
  Instance->MR  = (IPCC_ALL_TX_BUF | IPCC_ALL_RX_BUF);
 8024664:	4b02      	ldr	r3, [pc, #8]	; (8024670 <IPCC_Reset_Register+0x10>)
 8024666:	6043      	str	r3, [r0, #4]

  /* Clear RX status */
  Instance->SCR = IPCC_ALL_RX_BUF;
 8024668:	233f      	movs	r3, #63	; 0x3f
 802466a:	6083      	str	r3, [r0, #8]
}
 802466c:	4770      	bx	lr
 802466e:	46c0      	nop			; (mov r8, r8)
 8024670:	003f003f 	.word	0x003f003f

08024674 <HAL_IPCC_Init>:
{
 8024674:	b570      	push	{r4, r5, r6, lr}
 8024676:	1e04      	subs	r4, r0, #0
  if (hipcc != NULL)
 8024678:	d018      	beq.n	80246ac <HAL_IPCC_Init+0x38>
    if (hipcc->State == HAL_IPCC_STATE_RESET)
 802467a:	2338      	movs	r3, #56	; 0x38
 802467c:	5cc3      	ldrb	r3, [r0, r3]
 802467e:	2b00      	cmp	r3, #0
 8024680:	d011      	beq.n	80246a6 <HAL_IPCC_Init+0x32>
    IPCC_Reset_Register(currentInstance);
 8024682:	4d0b      	ldr	r5, [pc, #44]	; (80246b0 <HAL_IPCC_Init+0x3c>)
 8024684:	0028      	movs	r0, r5
 8024686:	f7ff ffeb 	bl	8024660 <IPCC_Reset_Register>
    currentInstance->CR |= (IPCC_CR_RXOIE | IPCC_CR_TXFIE);
 802468a:	682a      	ldr	r2, [r5, #0]
 802468c:	4b09      	ldr	r3, [pc, #36]	; (80246b4 <HAL_IPCC_Init+0x40>)
 802468e:	4313      	orrs	r3, r2
 8024690:	602b      	str	r3, [r5, #0]
    IPCC_SetDefaultCallbacks(hipcc);
 8024692:	0020      	movs	r0, r4
 8024694:	f7ff ffd0 	bl	8024638 <IPCC_SetDefaultCallbacks>
    hipcc->callbackRequest = 0;
 8024698:	2300      	movs	r3, #0
 802469a:	6363      	str	r3, [r4, #52]	; 0x34
    hipcc->State = HAL_IPCC_STATE_READY;
 802469c:	3338      	adds	r3, #56	; 0x38
 802469e:	2201      	movs	r2, #1
 80246a0:	54e2      	strb	r2, [r4, r3]
  HAL_StatusTypeDef err = HAL_OK;
 80246a2:	2000      	movs	r0, #0
}
 80246a4:	bd70      	pop	{r4, r5, r6, pc}
      HAL_IPCC_MspInit(hipcc);
 80246a6:	f7fc ff7b 	bl	80215a0 <HAL_IPCC_MspInit>
 80246aa:	e7ea      	b.n	8024682 <HAL_IPCC_Init+0xe>
    err = HAL_ERROR;
 80246ac:	2001      	movs	r0, #1
 80246ae:	e7f9      	b.n	80246a4 <HAL_IPCC_Init+0x30>
 80246b0:	58000c10 	.word	0x58000c10
 80246b4:	00010001 	.word	0x00010001

080246b8 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80246b8:	4a03      	ldr	r2, [pc, #12]	; (80246c8 <HAL_PWR_EnableBkUpAccess+0x10>)
 80246ba:	6811      	ldr	r1, [r2, #0]
 80246bc:	2380      	movs	r3, #128	; 0x80
 80246be:	005b      	lsls	r3, r3, #1
 80246c0:	430b      	orrs	r3, r1
 80246c2:	6013      	str	r3, [r2, #0]
}
 80246c4:	4770      	bx	lr
 80246c6:	46c0      	nop			; (mov r8, r8)
 80246c8:	58000400 	.word	0x58000400

080246cc <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as
  *        the interrupt wake up source.
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 80246cc:	b510      	push	{r4, lr}
 80246ce:	000c      	movs	r4, r1
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 80246d0:	2800      	cmp	r0, #0
 80246d2:	d113      	bne.n	80246fc <HAL_PWR_EnterSLEEPMode+0x30>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 80246d4:	4b0e      	ldr	r3, [pc, #56]	; (8024710 <HAL_PWR_EnterSLEEPMode+0x44>)
 80246d6:	695b      	ldr	r3, [r3, #20]
 80246d8:	059b      	lsls	r3, r3, #22
 80246da:	d40a      	bmi.n	80246f2 <HAL_PWR_EnterSLEEPMode+0x26>
      HAL_PWREx_EnableLowPowerRunMode();
    }
  }

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80246dc:	4a0d      	ldr	r2, [pc, #52]	; (8024714 <HAL_PWR_EnterSLEEPMode+0x48>)
 80246de:	6913      	ldr	r3, [r2, #16]
 80246e0:	2104      	movs	r1, #4
 80246e2:	438b      	bics	r3, r1
 80246e4:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry -------------------------------------------------*/
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 80246e6:	2c01      	cmp	r4, #1
 80246e8:	d00f      	beq.n	802470a <HAL_PWR_EnterSLEEPMode+0x3e>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 80246ea:	bf40      	sev
    __WFE();
 80246ec:	bf20      	wfe
    __WFE();
 80246ee:	bf20      	wfe
  }
}
 80246f0:	bd10      	pop	{r4, pc}
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 80246f2:	f000 f81b 	bl	802472c <HAL_PWREx_DisableLowPowerRunMode>
 80246f6:	2800      	cmp	r0, #0
 80246f8:	d0f0      	beq.n	80246dc <HAL_PWR_EnterSLEEPMode+0x10>
 80246fa:	e7f9      	b.n	80246f0 <HAL_PWR_EnterSLEEPMode+0x24>
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 80246fc:	4b04      	ldr	r3, [pc, #16]	; (8024710 <HAL_PWR_EnterSLEEPMode+0x44>)
 80246fe:	695b      	ldr	r3, [r3, #20]
 8024700:	059b      	lsls	r3, r3, #22
 8024702:	d4eb      	bmi.n	80246dc <HAL_PWR_EnterSLEEPMode+0x10>
      HAL_PWREx_EnableLowPowerRunMode();
 8024704:	f000 f808 	bl	8024718 <HAL_PWREx_EnableLowPowerRunMode>
 8024708:	e7e8      	b.n	80246dc <HAL_PWR_EnterSLEEPMode+0x10>
    __WFI();
 802470a:	bf30      	wfi
 802470c:	e7f0      	b.n	80246f0 <HAL_PWR_EnterSLEEPMode+0x24>
 802470e:	46c0      	nop			; (mov r8, r8)
 8024710:	58000400 	.word	0x58000400
 8024714:	e000ed00 	.word	0xe000ed00

08024718 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 8024718:	4a03      	ldr	r2, [pc, #12]	; (8024728 <HAL_PWREx_EnableLowPowerRunMode+0x10>)
 802471a:	6811      	ldr	r1, [r2, #0]
 802471c:	2380      	movs	r3, #128	; 0x80
 802471e:	01db      	lsls	r3, r3, #7
 8024720:	430b      	orrs	r3, r1
 8024722:	6013      	str	r3, [r2, #0]
}
 8024724:	4770      	bx	lr
 8024726:	46c0      	nop			; (mov r8, r8)
 8024728:	58000400 	.word	0x58000400

0802472c <HAL_PWREx_DisableLowPowerRunMode>:
  *        returns HAL_TIMEOUT status). The system clock frequency can then be
  *        increased above 2 MHz.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
 802472c:	b510      	push	{r4, lr}
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 802472e:	4a0e      	ldr	r2, [pc, #56]	; (8024768 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8024730:	6813      	ldr	r3, [r2, #0]
 8024732:	490e      	ldr	r1, [pc, #56]	; (802476c <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 8024734:	400b      	ands	r3, r1
 8024736:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8024738:	4b0d      	ldr	r3, [pc, #52]	; (8024770 <HAL_PWREx_DisableLowPowerRunMode+0x44>)
 802473a:	6818      	ldr	r0, [r3, #0]
 802473c:	2332      	movs	r3, #50	; 0x32
 802473e:	4358      	muls	r0, r3
 8024740:	490c      	ldr	r1, [pc, #48]	; (8024774 <HAL_PWREx_DisableLowPowerRunMode+0x48>)
 8024742:	f7fb fce9 	bl	8020118 <__udivsi3>
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8024746:	4b08      	ldr	r3, [pc, #32]	; (8024768 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8024748:	695b      	ldr	r3, [r3, #20]
 802474a:	059b      	lsls	r3, r3, #22
 802474c:	d503      	bpl.n	8024756 <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 802474e:	2800      	cmp	r0, #0
 8024750:	d001      	beq.n	8024756 <HAL_PWREx_DisableLowPowerRunMode+0x2a>
  {
    wait_loop_index--;
 8024752:	3801      	subs	r0, #1
 8024754:	e7f7      	b.n	8024746 <HAL_PWREx_DisableLowPowerRunMode+0x1a>
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8024756:	4b04      	ldr	r3, [pc, #16]	; (8024768 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8024758:	695b      	ldr	r3, [r3, #20]
 802475a:	059b      	lsls	r3, r3, #22
 802475c:	d401      	bmi.n	8024762 <HAL_PWREx_DisableLowPowerRunMode+0x36>
  {
    return HAL_TIMEOUT;
  }

  return HAL_OK;
 802475e:	2000      	movs	r0, #0
}
 8024760:	bd10      	pop	{r4, pc}
    return HAL_TIMEOUT;
 8024762:	2003      	movs	r0, #3
 8024764:	e7fc      	b.n	8024760 <HAL_PWREx_DisableLowPowerRunMode+0x34>
 8024766:	46c0      	nop			; (mov r8, r8)
 8024768:	58000400 	.word	0x58000400
 802476c:	ffffbfff 	.word	0xffffbfff
 8024770:	2000a034 	.word	0x2000a034
 8024774:	000f4240 	.word	0x000f4240

08024778 <HAL_PWREx_EnterSTOP2Mode>:
  *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop mode with WFI instruction
  *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop mode with WFE instruction
  * @retval None
  */
void HAL_PWREx_EnterSTOP2Mode(uint8_t STOPEntry)
{
 8024778:	b510      	push	{r4, lr}
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 802477a:	490d      	ldr	r1, [pc, #52]	; (80247b0 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 802477c:	2280      	movs	r2, #128	; 0x80
 802477e:	588b      	ldr	r3, [r1, r2]
 8024780:	2407      	movs	r4, #7
 8024782:	43a3      	bics	r3, r4
 8024784:	3c05      	subs	r4, #5
 8024786:	4323      	orrs	r3, r4
 8024788:	508b      	str	r3, [r1, r2]
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802478a:	4a0a      	ldr	r2, [pc, #40]	; (80247b4 <HAL_PWREx_EnterSTOP2Mode+0x3c>)
 802478c:	6913      	ldr	r3, [r2, #16]
 802478e:	2104      	movs	r1, #4
 8024790:	430b      	orrs	r3, r1
 8024792:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 8024794:	2801      	cmp	r0, #1
 8024796:	d008      	beq.n	80247aa <HAL_PWREx_EnterSTOP2Mode+0x32>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 8024798:	bf40      	sev
    __WFE();
 802479a:	bf20      	wfe
    __WFE();
 802479c:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802479e:	4a05      	ldr	r2, [pc, #20]	; (80247b4 <HAL_PWREx_EnterSTOP2Mode+0x3c>)
 80247a0:	6913      	ldr	r3, [r2, #16]
 80247a2:	2104      	movs	r1, #4
 80247a4:	438b      	bics	r3, r1
 80247a6:	6113      	str	r3, [r2, #16]
}
 80247a8:	bd10      	pop	{r4, pc}
    __WFI();
 80247aa:	bf30      	wfi
 80247ac:	e7f7      	b.n	802479e <HAL_PWREx_EnterSTOP2Mode+0x26>
 80247ae:	46c0      	nop			; (mov r8, r8)
 80247b0:	58000400 	.word	0x58000400
 80247b4:	e000ed00 	.word	0xe000ed00

080247b8 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80247b8:	b510      	push	{r4, lr}
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80247ba:	23b0      	movs	r3, #176	; 0xb0
 80247bc:	05db      	lsls	r3, r3, #23
 80247be:	689a      	ldr	r2, [r3, #8]
 80247c0:	210c      	movs	r1, #12
 80247c2:	000c      	movs	r4, r1
 80247c4:	4014      	ands	r4, r2
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80247c6:	68d8      	ldr	r0, [r3, #12]
 80247c8:	2303      	movs	r3, #3
 80247ca:	4003      	ands	r3, r0
  uint32_t pllinputfreq;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
  pllsource = __HAL_RCC_GET_PLL_OSCSOURCE();

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80247cc:	4211      	tst	r1, r2
 80247ce:	d00a      	beq.n	80247e6 <HAL_RCC_GetSysClockFreq+0x2e>
 80247d0:	2c0c      	cmp	r4, #12
 80247d2:	d006      	beq.n	80247e2 <HAL_RCC_GetSysClockFreq+0x2a>
    {
      /* MSI used as system clock source */
      sysclockfreq = msifreq;
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80247d4:	2c04      	cmp	r4, #4
 80247d6:	d04f      	beq.n	8024878 <HAL_RCC_GetSysClockFreq+0xc0>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 80247d8:	2c08      	cmp	r4, #8
 80247da:	d040      	beq.n	802485e <HAL_RCC_GetSysClockFreq+0xa6>
  uint32_t msifreq = 0U;
 80247dc:	2100      	movs	r1, #0
  uint32_t sysclockfreq = 0U;
 80247de:	2000      	movs	r0, #0
 80247e0:	e02a      	b.n	8024838 <HAL_RCC_GetSysClockFreq+0x80>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 80247e2:	2b01      	cmp	r3, #1
 80247e4:	d1f6      	bne.n	80247d4 <HAL_RCC_GetSysClockFreq+0x1c>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 80247e6:	23b0      	movs	r3, #176	; 0xb0
 80247e8:	05db      	lsls	r3, r3, #23
 80247ea:	681a      	ldr	r2, [r3, #0]
 80247ec:	2108      	movs	r1, #8
 80247ee:	000b      	movs	r3, r1
 80247f0:	4013      	ands	r3, r2
 80247f2:	4211      	tst	r1, r2
 80247f4:	d00e      	beq.n	8024814 <HAL_RCC_GetSysClockFreq+0x5c>
 80247f6:	23b0      	movs	r3, #176	; 0xb0
 80247f8:	05db      	lsls	r3, r3, #23
 80247fa:	681a      	ldr	r2, [r3, #0]
 80247fc:	000b      	movs	r3, r1
 80247fe:	4013      	ands	r3, r2
 8024800:	4211      	tst	r1, r2
 8024802:	d125      	bne.n	8024850 <HAL_RCC_GetSysClockFreq+0x98>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8024804:	21b0      	movs	r1, #176	; 0xb0
 8024806:	05c9      	lsls	r1, r1, #23
 8024808:	2294      	movs	r2, #148	; 0x94
 802480a:	588a      	ldr	r2, [r1, r2]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 802480c:	009b      	lsls	r3, r3, #2
 802480e:	4a31      	ldr	r2, [pc, #196]	; (80248d4 <HAL_RCC_GetSysClockFreq+0x11c>)
 8024810:	5899      	ldr	r1, [r3, r2]
 8024812:	e00e      	b.n	8024832 <HAL_RCC_GetSysClockFreq+0x7a>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8024814:	22b0      	movs	r2, #176	; 0xb0
 8024816:	05d2      	lsls	r2, r2, #23
 8024818:	6812      	ldr	r2, [r2, #0]
 802481a:	0712      	lsls	r2, r2, #28
 802481c:	d414      	bmi.n	8024848 <HAL_RCC_GetSysClockFreq+0x90>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 802481e:	22b0      	movs	r2, #176	; 0xb0
 8024820:	05d2      	lsls	r2, r2, #23
 8024822:	2394      	movs	r3, #148	; 0x94
 8024824:	58d2      	ldr	r2, [r2, r3]
 8024826:	0a12      	lsrs	r2, r2, #8
 8024828:	3b85      	subs	r3, #133	; 0x85
 802482a:	4013      	ands	r3, r2
 802482c:	009b      	lsls	r3, r3, #2
 802482e:	4a29      	ldr	r2, [pc, #164]	; (80248d4 <HAL_RCC_GetSysClockFreq+0x11c>)
 8024830:	5899      	ldr	r1, [r3, r2]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8024832:	2c00      	cmp	r4, #0
 8024834:	d01e      	beq.n	8024874 <HAL_RCC_GetSysClockFreq+0xbc>
  uint32_t sysclockfreq = 0U;
 8024836:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8024838:	23b0      	movs	r3, #176	; 0xb0
 802483a:	05db      	lsls	r3, r3, #23
 802483c:	689a      	ldr	r2, [r3, #8]
 802483e:	230c      	movs	r3, #12
 8024840:	4013      	ands	r3, r2
  else
  {
    /* Nothing to do */
  }

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8024842:	2b0c      	cmp	r3, #12
 8024844:	d01e      	beq.n	8024884 <HAL_RCC_GetSysClockFreq+0xcc>
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
                                             LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
}
 8024846:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8024848:	22b0      	movs	r2, #176	; 0xb0
 802484a:	05d2      	lsls	r2, r2, #23
 802484c:	6812      	ldr	r2, [r2, #0]
 802484e:	e7ed      	b.n	802482c <HAL_RCC_GetSysClockFreq+0x74>
 8024850:	23b0      	movs	r3, #176	; 0xb0
 8024852:	05db      	lsls	r3, r3, #23
 8024854:	681a      	ldr	r2, [r3, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8024856:	0912      	lsrs	r2, r2, #4
 8024858:	230f      	movs	r3, #15
 802485a:	4013      	ands	r3, r2
 802485c:	e7d6      	b.n	802480c <HAL_RCC_GetSysClockFreq+0x54>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 802485e:	23b0      	movs	r3, #176	; 0xb0
 8024860:	05db      	lsls	r3, r3, #23
 8024862:	681a      	ldr	r2, [r3, #0]
 8024864:	2380      	movs	r3, #128	; 0x80
 8024866:	035b      	lsls	r3, r3, #13
 8024868:	0011      	movs	r1, r2
 802486a:	4019      	ands	r1, r3
 802486c:	421a      	tst	r2, r3
 802486e:	d106      	bne.n	802487e <HAL_RCC_GetSysClockFreq+0xc6>
      sysclockfreq = HSE_VALUE;
 8024870:	4819      	ldr	r0, [pc, #100]	; (80248d8 <HAL_RCC_GetSysClockFreq+0x120>)
 8024872:	e7e1      	b.n	8024838 <HAL_RCC_GetSysClockFreq+0x80>
      sysclockfreq = msifreq;
 8024874:	0008      	movs	r0, r1
 8024876:	e7df      	b.n	8024838 <HAL_RCC_GetSysClockFreq+0x80>
  uint32_t msifreq = 0U;
 8024878:	2100      	movs	r1, #0
    sysclockfreq = HSI_VALUE;
 802487a:	4818      	ldr	r0, [pc, #96]	; (80248dc <HAL_RCC_GetSysClockFreq+0x124>)
 802487c:	e7dc      	b.n	8024838 <HAL_RCC_GetSysClockFreq+0x80>
  uint32_t msifreq = 0U;
 802487e:	2100      	movs	r1, #0
      sysclockfreq = HSE_VALUE / 2U;
 8024880:	4816      	ldr	r0, [pc, #88]	; (80248dc <HAL_RCC_GetSysClockFreq+0x124>)
 8024882:	e7d9      	b.n	8024838 <HAL_RCC_GetSysClockFreq+0x80>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8024884:	23b0      	movs	r3, #176	; 0xb0
 8024886:	05db      	lsls	r3, r3, #23
 8024888:	68da      	ldr	r2, [r3, #12]
 802488a:	2303      	movs	r3, #3
 802488c:	4013      	ands	r3, r2
    switch (pllsource)
 802488e:	2b02      	cmp	r3, #2
 8024890:	d008      	beq.n	80248a4 <HAL_RCC_GetSysClockFreq+0xec>
 8024892:	2b03      	cmp	r3, #3
 8024894:	d107      	bne.n	80248a6 <HAL_RCC_GetSysClockFreq+0xee>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8024896:	23b0      	movs	r3, #176	; 0xb0
 8024898:	05db      	lsls	r3, r3, #23
 802489a:	681b      	ldr	r3, [r3, #0]
 802489c:	02db      	lsls	r3, r3, #11
 802489e:	d416      	bmi.n	80248ce <HAL_RCC_GetSysClockFreq+0x116>
          pllinputfreq = HSE_VALUE;
 80248a0:	490d      	ldr	r1, [pc, #52]	; (80248d8 <HAL_RCC_GetSysClockFreq+0x120>)
 80248a2:	e000      	b.n	80248a6 <HAL_RCC_GetSysClockFreq+0xee>
    switch (pllsource)
 80248a4:	490d      	ldr	r1, [pc, #52]	; (80248dc <HAL_RCC_GetSysClockFreq+0x124>)
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80248a6:	24b0      	movs	r4, #176	; 0xb0
 80248a8:	05e4      	lsls	r4, r4, #23
 80248aa:	68e3      	ldr	r3, [r4, #12]
 80248ac:	0a1b      	lsrs	r3, r3, #8
 80248ae:	207f      	movs	r0, #127	; 0x7f
 80248b0:	4018      	ands	r0, r3
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 80248b2:	4348      	muls	r0, r1
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80248b4:	68e3      	ldr	r3, [r4, #12]
 80248b6:	091b      	lsrs	r3, r3, #4
 80248b8:	2107      	movs	r1, #7
 80248ba:	4019      	ands	r1, r3
 80248bc:	3101      	adds	r1, #1
 80248be:	f7fb fc2b 	bl	8020118 <__udivsi3>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80248c2:	68e1      	ldr	r1, [r4, #12]
 80248c4:	0f49      	lsrs	r1, r1, #29
 80248c6:	3101      	adds	r1, #1
 80248c8:	f7fb fc26 	bl	8020118 <__udivsi3>
  return sysclockfreq;
 80248cc:	e7bb      	b.n	8024846 <HAL_RCC_GetSysClockFreq+0x8e>
          pllinputfreq = HSE_VALUE / 2U;
 80248ce:	4903      	ldr	r1, [pc, #12]	; (80248dc <HAL_RCC_GetSysClockFreq+0x124>)
 80248d0:	e7e9      	b.n	80248a6 <HAL_RCC_GetSysClockFreq+0xee>
 80248d2:	46c0      	nop			; (mov r8, r8)
 80248d4:	08034c20 	.word	0x08034c20
 80248d8:	01e84800 	.word	0x01e84800
 80248dc:	00f42400 	.word	0x00f42400

080248e0 <HAL_RCC_GetHCLK2Freq>:
/**
  * @brief  Return the HCLK2 frequency.
  * @retval HCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetHCLK2Freq(void)
{
 80248e0:	b510      	push	{r4, lr}
  /* Get SysClock and Compute HCLK2 frequency --------------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK2_FREQ(HAL_RCC_GetSysClockFreq(), LL_C2_RCC_GetAHBPrescaler())));
 80248e2:	f7ff ff69 	bl	80247b8 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 80248e6:	22b0      	movs	r2, #176	; 0xb0
 80248e8:	05d2      	lsls	r2, r2, #23
 80248ea:	2384      	movs	r3, #132	; 0x84
 80248ec:	005b      	lsls	r3, r3, #1
 80248ee:	58d2      	ldr	r2, [r2, r3]
 80248f0:	0912      	lsrs	r2, r2, #4
 80248f2:	3bf9      	subs	r3, #249	; 0xf9
 80248f4:	4013      	ands	r3, r2
 80248f6:	009b      	lsls	r3, r3, #2
 80248f8:	4a02      	ldr	r2, [pc, #8]	; (8024904 <HAL_RCC_GetHCLK2Freq+0x24>)
 80248fa:	5899      	ldr	r1, [r3, r2]
 80248fc:	f7fb fc0c 	bl	8020118 <__udivsi3>
}
 8024900:	bd10      	pop	{r4, pc}
 8024902:	46c0      	nop			; (mov r8, r8)
 8024904:	08034be0 	.word	0x08034be0

08024908 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8024908:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802490a:	0004      	movs	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 802490c:	6803      	ldr	r3, [r0, #0]
 802490e:	03db      	lsls	r3, r3, #15
 8024910:	d500      	bpl.n	8024914 <HAL_RCCEx_PeriphCLKConfig+0xc>
 8024912:	e0bf      	b.n	8024a94 <HAL_RCCEx_PeriphCLKConfig+0x18c>
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8024914:	2500      	movs	r5, #0
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8024916:	6823      	ldr	r3, [r4, #0]
 8024918:	07db      	lsls	r3, r3, #31
 802491a:	d50a      	bpl.n	8024932 <HAL_RCCEx_PeriphCLKConfig+0x2a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 802491c:	6863      	ldr	r3, [r4, #4]
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 802491e:	20b0      	movs	r0, #176	; 0xb0
 8024920:	05c0      	lsls	r0, r0, #23
 8024922:	2188      	movs	r1, #136	; 0x88
 8024924:	5842      	ldr	r2, [r0, r1]
 8024926:	0c1e      	lsrs	r6, r3, #16
 8024928:	43b2      	bics	r2, r6
 802492a:	041b      	lsls	r3, r3, #16
 802492c:	0c1b      	lsrs	r3, r3, #16
 802492e:	4313      	orrs	r3, r2
 8024930:	5043      	str	r3, [r0, r1]
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8024932:	6823      	ldr	r3, [r4, #0]
 8024934:	079b      	lsls	r3, r3, #30
 8024936:	d50a      	bpl.n	802494e <HAL_RCCEx_PeriphCLKConfig+0x46>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8024938:	68a3      	ldr	r3, [r4, #8]
 802493a:	20b0      	movs	r0, #176	; 0xb0
 802493c:	05c0      	lsls	r0, r0, #23
 802493e:	2188      	movs	r1, #136	; 0x88
 8024940:	5842      	ldr	r2, [r0, r1]
 8024942:	0c1e      	lsrs	r6, r3, #16
 8024944:	43b2      	bics	r2, r6
 8024946:	041b      	lsls	r3, r3, #16
 8024948:	0c1b      	lsrs	r3, r3, #16
 802494a:	4313      	orrs	r3, r2
 802494c:	5043      	str	r3, [r0, r1]
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 802494e:	6823      	ldr	r3, [r4, #0]
 8024950:	069b      	lsls	r3, r3, #26
 8024952:	d508      	bpl.n	8024966 <HAL_RCCEx_PeriphCLKConfig+0x5e>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8024954:	21b0      	movs	r1, #176	; 0xb0
 8024956:	05c9      	lsls	r1, r1, #23
 8024958:	2288      	movs	r2, #136	; 0x88
 802495a:	588b      	ldr	r3, [r1, r2]
 802495c:	487c      	ldr	r0, [pc, #496]	; (8024b50 <HAL_RCCEx_PeriphCLKConfig+0x248>)
 802495e:	4003      	ands	r3, r0
 8024960:	6920      	ldr	r0, [r4, #16]
 8024962:	4303      	orrs	r3, r0
 8024964:	508b      	str	r3, [r1, r2]
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8024966:	6823      	ldr	r3, [r4, #0]
 8024968:	059b      	lsls	r3, r3, #22
 802496a:	d50a      	bpl.n	8024982 <HAL_RCCEx_PeriphCLKConfig+0x7a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 802496c:	6a22      	ldr	r2, [r4, #32]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 802496e:	26b0      	movs	r6, #176	; 0xb0
 8024970:	05f6      	lsls	r6, r6, #23
 8024972:	2088      	movs	r0, #136	; 0x88
 8024974:	5833      	ldr	r3, [r6, r0]
 8024976:	0c11      	lsrs	r1, r2, #16
 8024978:	0409      	lsls	r1, r1, #16
 802497a:	438b      	bics	r3, r1
 802497c:	0412      	lsls	r2, r2, #16
 802497e:	4313      	orrs	r3, r2
 8024980:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8024982:	6823      	ldr	r3, [r4, #0]
 8024984:	055b      	lsls	r3, r3, #21
 8024986:	d50a      	bpl.n	802499e <HAL_RCCEx_PeriphCLKConfig+0x96>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8024988:	6a62      	ldr	r2, [r4, #36]	; 0x24
 802498a:	26b0      	movs	r6, #176	; 0xb0
 802498c:	05f6      	lsls	r6, r6, #23
 802498e:	2088      	movs	r0, #136	; 0x88
 8024990:	5833      	ldr	r3, [r6, r0]
 8024992:	0c11      	lsrs	r1, r2, #16
 8024994:	0409      	lsls	r1, r1, #16
 8024996:	438b      	bics	r3, r1
 8024998:	0412      	lsls	r2, r2, #16
 802499a:	4313      	orrs	r3, r2
 802499c:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 802499e:	6823      	ldr	r3, [r4, #0]
 80249a0:	051b      	lsls	r3, r3, #20
 80249a2:	d50a      	bpl.n	80249ba <HAL_RCCEx_PeriphCLKConfig+0xb2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 80249a4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80249a6:	26b0      	movs	r6, #176	; 0xb0
 80249a8:	05f6      	lsls	r6, r6, #23
 80249aa:	2088      	movs	r0, #136	; 0x88
 80249ac:	5833      	ldr	r3, [r6, r0]
 80249ae:	0c11      	lsrs	r1, r2, #16
 80249b0:	0409      	lsls	r1, r1, #16
 80249b2:	438b      	bics	r3, r1
 80249b4:	0412      	lsls	r2, r2, #16
 80249b6:	4313      	orrs	r3, r2
 80249b8:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80249ba:	6823      	ldr	r3, [r4, #0]
 80249bc:	065b      	lsls	r3, r3, #25
 80249be:	d50d      	bpl.n	80249dc <HAL_RCCEx_PeriphCLKConfig+0xd4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80249c0:	6963      	ldr	r3, [r4, #20]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 80249c2:	26b0      	movs	r6, #176	; 0xb0
 80249c4:	05f6      	lsls	r6, r6, #23
 80249c6:	2088      	movs	r0, #136	; 0x88
 80249c8:	5832      	ldr	r2, [r6, r0]
 80249ca:	0919      	lsrs	r1, r3, #4
 80249cc:	27ff      	movs	r7, #255	; 0xff
 80249ce:	033f      	lsls	r7, r7, #12
 80249d0:	4039      	ands	r1, r7
 80249d2:	438a      	bics	r2, r1
 80249d4:	011b      	lsls	r3, r3, #4
 80249d6:	403b      	ands	r3, r7
 80249d8:	4313      	orrs	r3, r2
 80249da:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80249dc:	6823      	ldr	r3, [r4, #0]
 80249de:	061b      	lsls	r3, r3, #24
 80249e0:	d50d      	bpl.n	80249fe <HAL_RCCEx_PeriphCLKConfig+0xf6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80249e2:	69a3      	ldr	r3, [r4, #24]
 80249e4:	26b0      	movs	r6, #176	; 0xb0
 80249e6:	05f6      	lsls	r6, r6, #23
 80249e8:	2088      	movs	r0, #136	; 0x88
 80249ea:	5832      	ldr	r2, [r6, r0]
 80249ec:	0919      	lsrs	r1, r3, #4
 80249ee:	27ff      	movs	r7, #255	; 0xff
 80249f0:	033f      	lsls	r7, r7, #12
 80249f2:	4039      	ands	r1, r7
 80249f4:	438a      	bics	r2, r1
 80249f6:	011b      	lsls	r3, r3, #4
 80249f8:	403b      	ands	r3, r7
 80249fa:	4313      	orrs	r3, r2
 80249fc:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80249fe:	6823      	ldr	r3, [r4, #0]
 8024a00:	05db      	lsls	r3, r3, #23
 8024a02:	d50d      	bpl.n	8024a20 <HAL_RCCEx_PeriphCLKConfig+0x118>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8024a04:	69e3      	ldr	r3, [r4, #28]
 8024a06:	26b0      	movs	r6, #176	; 0xb0
 8024a08:	05f6      	lsls	r6, r6, #23
 8024a0a:	2088      	movs	r0, #136	; 0x88
 8024a0c:	5832      	ldr	r2, [r6, r0]
 8024a0e:	0919      	lsrs	r1, r3, #4
 8024a10:	27ff      	movs	r7, #255	; 0xff
 8024a12:	033f      	lsls	r7, r7, #12
 8024a14:	4039      	ands	r1, r7
 8024a16:	438a      	bics	r2, r1
 8024a18:	011b      	lsls	r3, r3, #4
 8024a1a:	403b      	ands	r3, r7
 8024a1c:	4313      	orrs	r3, r2
 8024a1e:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 8024a20:	6823      	ldr	r3, [r4, #0]
 8024a22:	06db      	lsls	r3, r3, #27
 8024a24:	d50e      	bpl.n	8024a44 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 8024a26:	21b0      	movs	r1, #176	; 0xb0
 8024a28:	05c9      	lsls	r1, r1, #23
 8024a2a:	2288      	movs	r2, #136	; 0x88
 8024a2c:	588b      	ldr	r3, [r1, r2]
 8024a2e:	4849      	ldr	r0, [pc, #292]	; (8024b54 <HAL_RCCEx_PeriphCLKConfig+0x24c>)
 8024a30:	4003      	ands	r3, r0
 8024a32:	68e0      	ldr	r0, [r4, #12]
 8024a34:	4303      	orrs	r3, r0
 8024a36:	508b      	str	r3, [r1, r2]
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 8024a38:	2380      	movs	r3, #128	; 0x80
 8024a3a:	005b      	lsls	r3, r3, #1
 8024a3c:	68e2      	ldr	r2, [r4, #12]
 8024a3e:	429a      	cmp	r2, r3
 8024a40:	d100      	bne.n	8024a44 <HAL_RCCEx_PeriphCLKConfig+0x13c>
 8024a42:	e077      	b.n	8024b34 <HAL_RCCEx_PeriphCLKConfig+0x22c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8024a44:	6823      	ldr	r3, [r4, #0]
 8024a46:	041b      	lsls	r3, r3, #16
 8024a48:	d511      	bpl.n	8024a6e <HAL_RCCEx_PeriphCLKConfig+0x166>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 8024a4a:	21b0      	movs	r1, #176	; 0xb0
 8024a4c:	05c9      	lsls	r1, r1, #23
 8024a4e:	2288      	movs	r2, #136	; 0x88
 8024a50:	588b      	ldr	r3, [r1, r2]
 8024a52:	009b      	lsls	r3, r3, #2
 8024a54:	089b      	lsrs	r3, r3, #2
 8024a56:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8024a58:	4303      	orrs	r3, r0
 8024a5a:	508b      	str	r3, [r1, r2]
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8024a5c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8024a5e:	2b00      	cmp	r3, #0
 8024a60:	d105      	bne.n	8024a6e <HAL_RCCEx_PeriphCLKConfig+0x166>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 8024a62:	000a      	movs	r2, r1
 8024a64:	68c9      	ldr	r1, [r1, #12]
 8024a66:	2380      	movs	r3, #128	; 0x80
 8024a68:	045b      	lsls	r3, r3, #17
 8024a6a:	430b      	orrs	r3, r1
 8024a6c:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8024a6e:	6823      	ldr	r3, [r4, #0]
 8024a70:	045b      	lsls	r3, r3, #17
 8024a72:	d50d      	bpl.n	8024a90 <HAL_RCCEx_PeriphCLKConfig+0x188>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 8024a74:	21b0      	movs	r1, #176	; 0xb0
 8024a76:	05c9      	lsls	r1, r1, #23
 8024a78:	2288      	movs	r2, #136	; 0x88
 8024a7a:	588b      	ldr	r3, [r1, r2]
 8024a7c:	4836      	ldr	r0, [pc, #216]	; (8024b58 <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8024a7e:	4003      	ands	r3, r0
 8024a80:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8024a82:	4303      	orrs	r3, r0
 8024a84:	508b      	str	r3, [r1, r2]
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 8024a86:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8024a88:	2380      	movs	r3, #128	; 0x80
 8024a8a:	059b      	lsls	r3, r3, #22
 8024a8c:	429a      	cmp	r2, r3
 8024a8e:	d058      	beq.n	8024b42 <HAL_RCCEx_PeriphCLKConfig+0x23a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
    }
  }

  return status;
}
 8024a90:	0028      	movs	r0, r5
 8024a92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_PWR_EnableBkUpAccess();
 8024a94:	f7ff fe10 	bl	80246b8 <HAL_PWR_EnableBkUpAccess>
    tickstart = HAL_GetTick();
 8024a98:	f7fd f8a2 	bl	8021be0 <HAL_GetTick>
 8024a9c:	0005      	movs	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 8024a9e:	4b2f      	ldr	r3, [pc, #188]	; (8024b5c <HAL_RCCEx_PeriphCLKConfig+0x254>)
 8024aa0:	681b      	ldr	r3, [r3, #0]
 8024aa2:	05db      	lsls	r3, r3, #23
 8024aa4:	d406      	bmi.n	8024ab4 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8024aa6:	f7fd f89b 	bl	8021be0 <HAL_GetTick>
 8024aaa:	1b40      	subs	r0, r0, r5
 8024aac:	2802      	cmp	r0, #2
 8024aae:	d9f6      	bls.n	8024a9e <HAL_RCCEx_PeriphCLKConfig+0x196>
        ret = HAL_TIMEOUT;
 8024ab0:	2503      	movs	r5, #3
 8024ab2:	e000      	b.n	8024ab6 <HAL_RCCEx_PeriphCLKConfig+0x1ae>
  HAL_StatusTypeDef ret = HAL_OK;   /* Intermediate status */
 8024ab4:	2500      	movs	r5, #0
    if (ret == HAL_OK)
 8024ab6:	2d00      	cmp	r5, #0
 8024ab8:	d000      	beq.n	8024abc <HAL_RCCEx_PeriphCLKConfig+0x1b4>
 8024aba:	e72c      	b.n	8024916 <HAL_RCCEx_PeriphCLKConfig+0xe>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8024abc:	22b0      	movs	r2, #176	; 0xb0
 8024abe:	05d2      	lsls	r2, r2, #23
 8024ac0:	2390      	movs	r3, #144	; 0x90
 8024ac2:	58d3      	ldr	r3, [r2, r3]
 8024ac4:	22c0      	movs	r2, #192	; 0xc0
 8024ac6:	0092      	lsls	r2, r2, #2
 8024ac8:	4013      	ands	r3, r2
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 8024aca:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8024acc:	429a      	cmp	r2, r3
 8024ace:	d01e      	beq.n	8024b0e <HAL_RCCEx_PeriphCLKConfig+0x206>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8024ad0:	22b0      	movs	r2, #176	; 0xb0
 8024ad2:	05d2      	lsls	r2, r2, #23
 8024ad4:	2390      	movs	r3, #144	; 0x90
 8024ad6:	58d1      	ldr	r1, [r2, r3]
 8024ad8:	481e      	ldr	r0, [pc, #120]	; (8024b54 <HAL_RCCEx_PeriphCLKConfig+0x24c>)
 8024ada:	4001      	ands	r1, r0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8024adc:	58d6      	ldr	r6, [r2, r3]
 8024ade:	2080      	movs	r0, #128	; 0x80
 8024ae0:	0240      	lsls	r0, r0, #9
 8024ae2:	4330      	orrs	r0, r6
 8024ae4:	50d0      	str	r0, [r2, r3]
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8024ae6:	58d0      	ldr	r0, [r2, r3]
 8024ae8:	4e1d      	ldr	r6, [pc, #116]	; (8024b60 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8024aea:	4030      	ands	r0, r6
 8024aec:	50d0      	str	r0, [r2, r3]
        RCC->BDCR = tmpregister;
 8024aee:	50d1      	str	r1, [r2, r3]
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8024af0:	078b      	lsls	r3, r1, #30
 8024af2:	d40e      	bmi.n	8024b12 <HAL_RCCEx_PeriphCLKConfig+0x20a>
      if (ret == HAL_OK)
 8024af4:	2d00      	cmp	r5, #0
 8024af6:	d000      	beq.n	8024afa <HAL_RCCEx_PeriphCLKConfig+0x1f2>
 8024af8:	e70d      	b.n	8024916 <HAL_RCCEx_PeriphCLKConfig+0xe>
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8024afa:	21b0      	movs	r1, #176	; 0xb0
 8024afc:	05c9      	lsls	r1, r1, #23
 8024afe:	2290      	movs	r2, #144	; 0x90
 8024b00:	588b      	ldr	r3, [r1, r2]
 8024b02:	4814      	ldr	r0, [pc, #80]	; (8024b54 <HAL_RCCEx_PeriphCLKConfig+0x24c>)
 8024b04:	4003      	ands	r3, r0
 8024b06:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8024b08:	4303      	orrs	r3, r0
 8024b0a:	508b      	str	r3, [r1, r2]
}
 8024b0c:	e703      	b.n	8024916 <HAL_RCCEx_PeriphCLKConfig+0xe>
  uint32_t tmpregister = 0;
 8024b0e:	2100      	movs	r1, #0
 8024b10:	e7ee      	b.n	8024af0 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
        tickstart = HAL_GetTick();
 8024b12:	f7fd f865 	bl	8021be0 <HAL_GetTick>
 8024b16:	0006      	movs	r6, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8024b18:	22b0      	movs	r2, #176	; 0xb0
 8024b1a:	05d2      	lsls	r2, r2, #23
 8024b1c:	2390      	movs	r3, #144	; 0x90
 8024b1e:	58d3      	ldr	r3, [r2, r3]
 8024b20:	079b      	lsls	r3, r3, #30
 8024b22:	d4e7      	bmi.n	8024af4 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8024b24:	f7fd f85c 	bl	8021be0 <HAL_GetTick>
 8024b28:	1b80      	subs	r0, r0, r6
 8024b2a:	4a0e      	ldr	r2, [pc, #56]	; (8024b64 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8024b2c:	4290      	cmp	r0, r2
 8024b2e:	d9f3      	bls.n	8024b18 <HAL_RCCEx_PeriphCLKConfig+0x210>
            ret = HAL_TIMEOUT;
 8024b30:	2503      	movs	r5, #3
 8024b32:	e7df      	b.n	8024af4 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 8024b34:	000a      	movs	r2, r1
 8024b36:	68c9      	ldr	r1, [r1, #12]
 8024b38:	2380      	movs	r3, #128	; 0x80
 8024b3a:	045b      	lsls	r3, r3, #17
 8024b3c:	430b      	orrs	r3, r1
 8024b3e:	60d3      	str	r3, [r2, #12]
 8024b40:	e780      	b.n	8024a44 <HAL_RCCEx_PeriphCLKConfig+0x13c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8024b42:	000a      	movs	r2, r1
 8024b44:	68c9      	ldr	r1, [r1, #12]
 8024b46:	2380      	movs	r3, #128	; 0x80
 8024b48:	025b      	lsls	r3, r3, #9
 8024b4a:	430b      	orrs	r3, r1
 8024b4c:	60d3      	str	r3, [r2, #12]
 8024b4e:	e79f      	b.n	8024a90 <HAL_RCCEx_PeriphCLKConfig+0x188>
 8024b50:	fffff3ff 	.word	0xfffff3ff
 8024b54:	fffffcff 	.word	0xfffffcff
 8024b58:	cfffffff 	.word	0xcfffffff
 8024b5c:	58000400 	.word	0x58000400
 8024b60:	fffeffff 	.word	0xfffeffff
 8024b64:	00001388 	.word	0x00001388

08024b68 <HAL_RTC_DeactivateAlarm>:
{
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8024b68:	232c      	movs	r3, #44	; 0x2c
 8024b6a:	5cc3      	ldrb	r3, [r0, r3]
 8024b6c:	2b01      	cmp	r3, #1
 8024b6e:	d036      	beq.n	8024bde <HAL_RTC_DeactivateAlarm+0x76>
 8024b70:	232c      	movs	r3, #44	; 0x2c
 8024b72:	2201      	movs	r2, #1
 8024b74:	54c2      	strb	r2, [r0, r3]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8024b76:	3301      	adds	r3, #1
 8024b78:	3201      	adds	r2, #1
 8024b7a:	54c2      	strb	r2, [r0, r3]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8024b7c:	4b19      	ldr	r3, [pc, #100]	; (8024be4 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024b7e:	32c8      	adds	r2, #200	; 0xc8
 8024b80:	625a      	str	r2, [r3, #36]	; 0x24
 8024b82:	3a77      	subs	r2, #119	; 0x77
 8024b84:	625a      	str	r2, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 8024b86:	2380      	movs	r3, #128	; 0x80
 8024b88:	005b      	lsls	r3, r3, #1
 8024b8a:	4299      	cmp	r1, r3
 8024b8c:	d018      	beq.n	8024bc0 <HAL_RTC_DeactivateAlarm+0x58>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
  }
  else
  {
    /* AlarmB, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8024b8e:	4b15      	ldr	r3, [pc, #84]	; (8024be4 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024b90:	699a      	ldr	r2, [r3, #24]
 8024b92:	4915      	ldr	r1, [pc, #84]	; (8024be8 <HAL_RTC_DeactivateAlarm+0x80>)
 8024b94:	400a      	ands	r2, r1
 8024b96:	619a      	str	r2, [r3, #24]

    /* AlarmB, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8024b98:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8024b9a:	0052      	lsls	r2, r2, #1
 8024b9c:	0852      	lsrs	r2, r2, #1
 8024b9e:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Store in the handle the Alarm B disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8024ba0:	2102      	movs	r1, #2
 8024ba2:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8024ba4:	438a      	bics	r2, r1
 8024ba6:	6302      	str	r2, [r0, #48]	; 0x30

    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8024ba8:	65d9      	str	r1, [r3, #92]	; 0x5c
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8024baa:	4b0e      	ldr	r3, [pc, #56]	; (8024be4 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024bac:	22ff      	movs	r2, #255	; 0xff
 8024bae:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8024bb0:	232d      	movs	r3, #45	; 0x2d
 8024bb2:	3afe      	subs	r2, #254	; 0xfe
 8024bb4:	54c2      	strb	r2, [r0, r3]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8024bb6:	3b01      	subs	r3, #1
 8024bb8:	2200      	movs	r2, #0
 8024bba:	54c2      	strb	r2, [r0, r3]

  return HAL_OK;
 8024bbc:	2000      	movs	r0, #0
}
 8024bbe:	4770      	bx	lr
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8024bc0:	4b08      	ldr	r3, [pc, #32]	; (8024be4 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024bc2:	699a      	ldr	r2, [r3, #24]
 8024bc4:	4909      	ldr	r1, [pc, #36]	; (8024bec <HAL_RTC_DeactivateAlarm+0x84>)
 8024bc6:	400a      	ands	r2, r1
 8024bc8:	619a      	str	r2, [r3, #24]
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8024bca:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8024bcc:	0052      	lsls	r2, r2, #1
 8024bce:	0852      	lsrs	r2, r2, #1
 8024bd0:	645a      	str	r2, [r3, #68]	; 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8024bd2:	2101      	movs	r1, #1
 8024bd4:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8024bd6:	438a      	bics	r2, r1
 8024bd8:	6302      	str	r2, [r0, #48]	; 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8024bda:	65d9      	str	r1, [r3, #92]	; 0x5c
 8024bdc:	e7e5      	b.n	8024baa <HAL_RTC_DeactivateAlarm+0x42>
  __HAL_LOCK(hrtc);
 8024bde:	2002      	movs	r0, #2
 8024be0:	e7ed      	b.n	8024bbe <HAL_RTC_DeactivateAlarm+0x56>
 8024be2:	46c0      	nop			; (mov r8, r8)
 8024be4:	40002800 	.word	0x40002800
 8024be8:	ffffddff 	.word	0xffffddff
 8024bec:	ffffeeff 	.word	0xffffeeff

08024bf0 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8024bf0:	b570      	push	{r4, r5, r6, lr}
 8024bf2:	0004      	movs	r4, r0
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 8024bf4:	4b0c      	ldr	r3, [pc, #48]	; (8024c28 <HAL_RTC_AlarmIRQHandler+0x38>)
 8024bf6:	6d5d      	ldr	r5, [r3, #84]	; 0x54
 8024bf8:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8024bfa:	401d      	ands	r5, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 8024bfc:	07eb      	lsls	r3, r5, #31
 8024bfe:	d405      	bmi.n	8024c0c <HAL_RTC_AlarmIRQHandler+0x1c>
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 8024c00:	07ab      	lsls	r3, r5, #30
 8024c02:	d409      	bmi.n	8024c18 <HAL_RTC_AlarmIRQHandler+0x28>
    HAL_RTCEx_AlarmBEventCallback(hrtc);
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8024c04:	232d      	movs	r3, #45	; 0x2d
 8024c06:	2201      	movs	r2, #1
 8024c08:	54e2      	strb	r2, [r4, r3]
}
 8024c0a:	bd70      	pop	{r4, r5, r6, pc}
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8024c0c:	4b06      	ldr	r3, [pc, #24]	; (8024c28 <HAL_RTC_AlarmIRQHandler+0x38>)
 8024c0e:	2201      	movs	r2, #1
 8024c10:	65da      	str	r2, [r3, #92]	; 0x5c
    HAL_RTC_AlarmAEventCallback(hrtc);
 8024c12:	f7fd f8fb 	bl	8021e0c <HAL_RTC_AlarmAEventCallback>
 8024c16:	e7f3      	b.n	8024c00 <HAL_RTC_AlarmIRQHandler+0x10>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8024c18:	4b03      	ldr	r3, [pc, #12]	; (8024c28 <HAL_RTC_AlarmIRQHandler+0x38>)
 8024c1a:	2202      	movs	r2, #2
 8024c1c:	65da      	str	r2, [r3, #92]	; 0x5c
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 8024c1e:	0020      	movs	r0, r4
 8024c20:	f7fd f90a 	bl	8021e38 <HAL_RTCEx_AlarmBEventCallback>
 8024c24:	e7ee      	b.n	8024c04 <HAL_RTC_AlarmIRQHandler+0x14>
 8024c26:	46c0      	nop			; (mov r8, r8)
 8024c28:	40002800 	.word	0x40002800

08024c2c <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 8024c2c:	b510      	push	{r4, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 8024c2e:	4a0b      	ldr	r2, [pc, #44]	; (8024c5c <HAL_RTC_WaitForSynchro+0x30>)
 8024c30:	68d3      	ldr	r3, [r2, #12]
 8024c32:	2120      	movs	r1, #32
 8024c34:	438b      	bics	r3, r1
 8024c36:	60d3      	str	r3, [r2, #12]

  tickstart = HAL_GetTick();
 8024c38:	f7fc ffd2 	bl	8021be0 <HAL_GetTick>
 8024c3c:	0004      	movs	r4, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8024c3e:	4b07      	ldr	r3, [pc, #28]	; (8024c5c <HAL_RTC_WaitForSynchro+0x30>)
 8024c40:	68db      	ldr	r3, [r3, #12]
 8024c42:	069b      	lsls	r3, r3, #26
 8024c44:	d408      	bmi.n	8024c58 <HAL_RTC_WaitForSynchro+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8024c46:	f7fc ffcb 	bl	8021be0 <HAL_GetTick>
 8024c4a:	1b00      	subs	r0, r0, r4
 8024c4c:	23fa      	movs	r3, #250	; 0xfa
 8024c4e:	009b      	lsls	r3, r3, #2
 8024c50:	4298      	cmp	r0, r3
 8024c52:	d9f4      	bls.n	8024c3e <HAL_RTC_WaitForSynchro+0x12>
    {
      return HAL_TIMEOUT;
 8024c54:	2003      	movs	r0, #3
 8024c56:	e000      	b.n	8024c5a <HAL_RTC_WaitForSynchro+0x2e>
    }
  }

  return HAL_OK;
 8024c58:	2000      	movs	r0, #0
}
 8024c5a:	bd10      	pop	{r4, pc}
 8024c5c:	40002800 	.word	0x40002800

08024c60 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 8024c60:	b570      	push	{r4, r5, r6, lr}
 8024c62:	0004      	movs	r4, r0
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 8024c64:	4b10      	ldr	r3, [pc, #64]	; (8024ca8 <RTC_EnterInitMode+0x48>)
 8024c66:	68db      	ldr	r3, [r3, #12]
 8024c68:	065b      	lsls	r3, r3, #25
 8024c6a:	d502      	bpl.n	8024c72 <RTC_EnterInitMode+0x12>
  HAL_StatusTypeDef status = HAL_OK;
 8024c6c:	2500      	movs	r5, #0
      }
    }
  }

  return status;
}
 8024c6e:	0028      	movs	r0, r5
 8024c70:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8024c72:	4a0d      	ldr	r2, [pc, #52]	; (8024ca8 <RTC_EnterInitMode+0x48>)
 8024c74:	68d3      	ldr	r3, [r2, #12]
 8024c76:	2180      	movs	r1, #128	; 0x80
 8024c78:	430b      	orrs	r3, r1
 8024c7a:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 8024c7c:	f7fc ffb0 	bl	8021be0 <HAL_GetTick>
 8024c80:	0006      	movs	r6, r0
  HAL_StatusTypeDef status = HAL_OK;
 8024c82:	2500      	movs	r5, #0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8024c84:	4b08      	ldr	r3, [pc, #32]	; (8024ca8 <RTC_EnterInitMode+0x48>)
 8024c86:	68db      	ldr	r3, [r3, #12]
 8024c88:	065b      	lsls	r3, r3, #25
 8024c8a:	d4f0      	bmi.n	8024c6e <RTC_EnterInitMode+0xe>
 8024c8c:	2d03      	cmp	r5, #3
 8024c8e:	d0ee      	beq.n	8024c6e <RTC_EnterInitMode+0xe>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8024c90:	f7fc ffa6 	bl	8021be0 <HAL_GetTick>
 8024c94:	1b80      	subs	r0, r0, r6
 8024c96:	22fa      	movs	r2, #250	; 0xfa
 8024c98:	0092      	lsls	r2, r2, #2
 8024c9a:	4290      	cmp	r0, r2
 8024c9c:	d9f2      	bls.n	8024c84 <RTC_EnterInitMode+0x24>
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8024c9e:	232d      	movs	r3, #45	; 0x2d
 8024ca0:	2203      	movs	r2, #3
 8024ca2:	54e2      	strb	r2, [r4, r3]
        status = HAL_TIMEOUT;
 8024ca4:	2503      	movs	r5, #3
 8024ca6:	e7ed      	b.n	8024c84 <RTC_EnterInitMode+0x24>
 8024ca8:	40002800 	.word	0x40002800

08024cac <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8024cac:	b510      	push	{r4, lr}
 8024cae:	0004      	movs	r4, r0
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8024cb0:	4b11      	ldr	r3, [pc, #68]	; (8024cf8 <RTC_ExitInitMode+0x4c>)
 8024cb2:	68da      	ldr	r2, [r3, #12]
 8024cb4:	2180      	movs	r1, #128	; 0x80
 8024cb6:	438a      	bics	r2, r1
 8024cb8:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8024cba:	699b      	ldr	r3, [r3, #24]
 8024cbc:	069b      	lsls	r3, r3, #26
 8024cbe:	d408      	bmi.n	8024cd2 <RTC_ExitInitMode+0x26>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8024cc0:	f7ff ffb4 	bl	8024c2c <HAL_RTC_WaitForSynchro>
 8024cc4:	2800      	cmp	r0, #0
 8024cc6:	d016      	beq.n	8024cf6 <RTC_ExitInitMode+0x4a>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8024cc8:	232d      	movs	r3, #45	; 0x2d
 8024cca:	2203      	movs	r2, #3
 8024ccc:	54e2      	strb	r2, [r4, r3]
      status = HAL_TIMEOUT;
 8024cce:	2003      	movs	r0, #3
 8024cd0:	e011      	b.n	8024cf6 <RTC_ExitInitMode+0x4a>
    }
  }
  else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry. */
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8024cd2:	4a09      	ldr	r2, [pc, #36]	; (8024cf8 <RTC_ExitInitMode+0x4c>)
 8024cd4:	6993      	ldr	r3, [r2, #24]
 8024cd6:	2120      	movs	r1, #32
 8024cd8:	438b      	bics	r3, r1
 8024cda:	6193      	str	r3, [r2, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8024cdc:	f7ff ffa6 	bl	8024c2c <HAL_RTC_WaitForSynchro>
 8024ce0:	2800      	cmp	r0, #0
 8024ce2:	d003      	beq.n	8024cec <RTC_ExitInitMode+0x40>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8024ce4:	232d      	movs	r3, #45	; 0x2d
 8024ce6:	2203      	movs	r2, #3
 8024ce8:	54e2      	strb	r2, [r4, r3]
      status = HAL_TIMEOUT;
 8024cea:	2003      	movs	r0, #3
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8024cec:	4a02      	ldr	r2, [pc, #8]	; (8024cf8 <RTC_ExitInitMode+0x4c>)
 8024cee:	6993      	ldr	r3, [r2, #24]
 8024cf0:	2120      	movs	r1, #32
 8024cf2:	430b      	orrs	r3, r1
 8024cf4:	6193      	str	r3, [r2, #24]
  }

  return status;
}
 8024cf6:	bd10      	pop	{r4, pc}
 8024cf8:	40002800 	.word	0x40002800

08024cfc <HAL_RTC_Init>:
{
 8024cfc:	b570      	push	{r4, r5, r6, lr}
 8024cfe:	1e04      	subs	r4, r0, #0
  if (hrtc != NULL)
 8024d00:	d04a      	beq.n	8024d98 <HAL_RTC_Init+0x9c>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 8024d02:	232d      	movs	r3, #45	; 0x2d
 8024d04:	5cc3      	ldrb	r3, [r0, r3]
 8024d06:	2b00      	cmp	r3, #0
 8024d08:	d015      	beq.n	8024d36 <HAL_RTC_Init+0x3a>
    hrtc->State = HAL_RTC_STATE_BUSY;
 8024d0a:	232d      	movs	r3, #45	; 0x2d
 8024d0c:	2202      	movs	r2, #2
 8024d0e:	54e2      	strb	r2, [r4, r3]
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8024d10:	4b22      	ldr	r3, [pc, #136]	; (8024d9c <HAL_RTC_Init+0xa0>)
 8024d12:	32c8      	adds	r2, #200	; 0xc8
 8024d14:	625a      	str	r2, [r3, #36]	; 0x24
 8024d16:	3a77      	subs	r2, #119	; 0x77
 8024d18:	625a      	str	r2, [r3, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 8024d1a:	0020      	movs	r0, r4
 8024d1c:	f7ff ffa0 	bl	8024c60 <RTC_EnterInitMode>
    if (status == HAL_OK)
 8024d20:	2800      	cmp	r0, #0
 8024d22:	d00e      	beq.n	8024d42 <HAL_RTC_Init+0x46>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8024d24:	4b1d      	ldr	r3, [pc, #116]	; (8024d9c <HAL_RTC_Init+0xa0>)
 8024d26:	22ff      	movs	r2, #255	; 0xff
 8024d28:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 8024d2a:	2800      	cmp	r0, #0
 8024d2c:	d102      	bne.n	8024d34 <HAL_RTC_Init+0x38>
      hrtc->State = HAL_RTC_STATE_READY;
 8024d2e:	232d      	movs	r3, #45	; 0x2d
 8024d30:	3afe      	subs	r2, #254	; 0xfe
 8024d32:	54e2      	strb	r2, [r4, r3]
}
 8024d34:	bd70      	pop	{r4, r5, r6, pc}
      hrtc->Lock = HAL_UNLOCKED;
 8024d36:	332c      	adds	r3, #44	; 0x2c
 8024d38:	2200      	movs	r2, #0
 8024d3a:	54c2      	strb	r2, [r0, r3]
      HAL_RTC_MspInit(hrtc);
 8024d3c:	f7fc fdc6 	bl	80218cc <HAL_RTC_MspInit>
 8024d40:	e7e3      	b.n	8024d0a <HAL_RTC_Init+0xe>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 8024d42:	4b16      	ldr	r3, [pc, #88]	; (8024d9c <HAL_RTC_Init+0xa0>)
 8024d44:	699a      	ldr	r2, [r3, #24]
 8024d46:	4916      	ldr	r1, [pc, #88]	; (8024da0 <HAL_RTC_Init+0xa4>)
 8024d48:	400a      	ands	r2, r1
 8024d4a:	619a      	str	r2, [r3, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 8024d4c:	6999      	ldr	r1, [r3, #24]
 8024d4e:	6862      	ldr	r2, [r4, #4]
 8024d50:	6920      	ldr	r0, [r4, #16]
 8024d52:	4302      	orrs	r2, r0
 8024d54:	69a0      	ldr	r0, [r4, #24]
 8024d56:	4302      	orrs	r2, r0
 8024d58:	430a      	orrs	r2, r1
 8024d5a:	619a      	str	r2, [r3, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 8024d5c:	68a2      	ldr	r2, [r4, #8]
 8024d5e:	0412      	lsls	r2, r2, #16
 8024d60:	68e1      	ldr	r1, [r4, #12]
 8024d62:	430a      	orrs	r2, r1
 8024d64:	611a      	str	r2, [r3, #16]
      MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 8024d66:	68da      	ldr	r2, [r3, #12]
 8024d68:	490e      	ldr	r1, [pc, #56]	; (8024da4 <HAL_RTC_Init+0xa8>)
 8024d6a:	400a      	ands	r2, r1
 8024d6c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8024d6e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8024d70:	4301      	orrs	r1, r0
 8024d72:	430a      	orrs	r2, r1
 8024d74:	60da      	str	r2, [r3, #12]
      status = RTC_ExitInitMode(hrtc);
 8024d76:	0020      	movs	r0, r4
 8024d78:	f7ff ff98 	bl	8024cac <RTC_ExitInitMode>
      if (status == HAL_OK)
 8024d7c:	2800      	cmp	r0, #0
 8024d7e:	d1d1      	bne.n	8024d24 <HAL_RTC_Init+0x28>
        MODIFY_REG(RTC->CR, \
 8024d80:	4906      	ldr	r1, [pc, #24]	; (8024d9c <HAL_RTC_Init+0xa0>)
 8024d82:	698b      	ldr	r3, [r1, #24]
 8024d84:	00db      	lsls	r3, r3, #3
 8024d86:	08db      	lsrs	r3, r3, #3
 8024d88:	6a22      	ldr	r2, [r4, #32]
 8024d8a:	69e5      	ldr	r5, [r4, #28]
 8024d8c:	432a      	orrs	r2, r5
 8024d8e:	6965      	ldr	r5, [r4, #20]
 8024d90:	432a      	orrs	r2, r5
 8024d92:	4313      	orrs	r3, r2
 8024d94:	618b      	str	r3, [r1, #24]
 8024d96:	e7c5      	b.n	8024d24 <HAL_RTC_Init+0x28>
  HAL_StatusTypeDef status = HAL_ERROR;
 8024d98:	2001      	movs	r0, #1
 8024d9a:	e7cb      	b.n	8024d34 <HAL_RTC_Init+0x38>
 8024d9c:	40002800 	.word	0x40002800
 8024da0:	fb8fffbf 	.word	0xfb8fffbf
 8024da4:	ffffe0ff 	.word	0xffffe0ff

08024da8 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8024da8:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 8024daa:	2809      	cmp	r0, #9
 8024dac:	d903      	bls.n	8024db6 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
 8024dae:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 8024db0:	380a      	subs	r0, #10
 8024db2:	b2c0      	uxtb	r0, r0
 8024db4:	e7f9      	b.n	8024daa <RTC_ByteToBcd2+0x2>
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8024db6:	011b      	lsls	r3, r3, #4
 8024db8:	b2db      	uxtb	r3, r3
 8024dba:	4318      	orrs	r0, r3
}
 8024dbc:	4770      	bx	lr
	...

08024dc0 <HAL_RTC_SetAlarm_IT>:
{
 8024dc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024dc2:	46c6      	mov	lr, r8
 8024dc4:	b500      	push	{lr}
 8024dc6:	0005      	movs	r5, r0
 8024dc8:	000c      	movs	r4, r1
  __HAL_LOCK(hrtc);
 8024dca:	232c      	movs	r3, #44	; 0x2c
 8024dcc:	5cc3      	ldrb	r3, [r0, r3]
 8024dce:	2b01      	cmp	r3, #1
 8024dd0:	d100      	bne.n	8024dd4 <HAL_RTC_SetAlarm_IT+0x14>
 8024dd2:	e0b5      	b.n	8024f40 <HAL_RTC_SetAlarm_IT+0x180>
 8024dd4:	232c      	movs	r3, #44	; 0x2c
 8024dd6:	2101      	movs	r1, #1
 8024dd8:	54c1      	strb	r1, [r0, r3]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8024dda:	3301      	adds	r3, #1
 8024ddc:	3101      	adds	r1, #1
 8024dde:	54c1      	strb	r1, [r0, r3]
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 8024de0:	4b58      	ldr	r3, [pc, #352]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024de2:	68de      	ldr	r6, [r3, #12]
 8024de4:	23c0      	movs	r3, #192	; 0xc0
 8024de6:	009b      	lsls	r3, r3, #2
 8024de8:	401e      	ands	r6, r3
  if (binaryMode != RTC_BINARY_ONLY)
 8024dea:	2380      	movs	r3, #128	; 0x80
 8024dec:	005b      	lsls	r3, r3, #1
 8024dee:	429e      	cmp	r6, r3
 8024df0:	d044      	beq.n	8024e7c <HAL_RTC_SetAlarm_IT+0xbc>
    if (Format == RTC_FORMAT_BIN)
 8024df2:	2a00      	cmp	r2, #0
 8024df4:	d122      	bne.n	8024e3c <HAL_RTC_SetAlarm_IT+0x7c>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8024df6:	4b53      	ldr	r3, [pc, #332]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024df8:	699b      	ldr	r3, [r3, #24]
 8024dfa:	065b      	lsls	r3, r3, #25
 8024dfc:	d401      	bmi.n	8024e02 <HAL_RTC_SetAlarm_IT+0x42>
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 8024dfe:	2300      	movs	r3, #0
 8024e00:	70e3      	strb	r3, [r4, #3]
      if( sAlarm->AlarmMask != RTC_ALARMMASK_DATEWEEKDAY )
 8024e02:	6963      	ldr	r3, [r4, #20]
 8024e04:	4698      	mov	r8, r3
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8024e06:	7820      	ldrb	r0, [r4, #0]
 8024e08:	f7ff ffce 	bl	8024da8 <RTC_ByteToBcd2>
 8024e0c:	0407      	lsls	r7, r0, #16
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8024e0e:	7860      	ldrb	r0, [r4, #1]
 8024e10:	f7ff ffca 	bl	8024da8 <RTC_ByteToBcd2>
 8024e14:	0200      	lsls	r0, r0, #8
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8024e16:	4307      	orrs	r7, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8024e18:	78a0      	ldrb	r0, [r4, #2]
 8024e1a:	f7ff ffc5 	bl	8024da8 <RTC_ByteToBcd2>
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8024e1e:	4307      	orrs	r7, r0
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8024e20:	78e0      	ldrb	r0, [r4, #3]
 8024e22:	0580      	lsls	r0, r0, #22
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8024e24:	4307      	orrs	r7, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8024e26:	2324      	movs	r3, #36	; 0x24
 8024e28:	5ce0      	ldrb	r0, [r4, r3]
 8024e2a:	f7ff ffbd 	bl	8024da8 <RTC_ByteToBcd2>
 8024e2e:	0600      	lsls	r0, r0, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8024e30:	4338      	orrs	r0, r7
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8024e32:	6a23      	ldr	r3, [r4, #32]
 8024e34:	4318      	orrs	r0, r3
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8024e36:	4643      	mov	r3, r8
 8024e38:	4318      	orrs	r0, r3
 8024e3a:	e020      	b.n	8024e7e <HAL_RTC_SetAlarm_IT+0xbe>
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 8024e3c:	6962      	ldr	r2, [r4, #20]
 8024e3e:	4b42      	ldr	r3, [pc, #264]	; (8024f48 <HAL_RTC_SetAlarm_IT+0x188>)
 8024e40:	429a      	cmp	r2, r3
 8024e42:	d009      	beq.n	8024e58 <HAL_RTC_SetAlarm_IT+0x98>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 8024e44:	2380      	movs	r3, #128	; 0x80
 8024e46:	041b      	lsls	r3, r3, #16
 8024e48:	429a      	cmp	r2, r3
 8024e4a:	d005      	beq.n	8024e58 <HAL_RTC_SetAlarm_IT+0x98>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8024e4c:	4b3d      	ldr	r3, [pc, #244]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024e4e:	699b      	ldr	r3, [r3, #24]
 8024e50:	065b      	lsls	r3, r3, #25
 8024e52:	d401      	bmi.n	8024e58 <HAL_RTC_SetAlarm_IT+0x98>
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 8024e54:	2300      	movs	r3, #0
 8024e56:	70e3      	strb	r3, [r4, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8024e58:	7820      	ldrb	r0, [r4, #0]
 8024e5a:	0400      	lsls	r0, r0, #16
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8024e5c:	7863      	ldrb	r3, [r4, #1]
 8024e5e:	021b      	lsls	r3, r3, #8
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8024e60:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8024e62:	78a3      	ldrb	r3, [r4, #2]
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8024e64:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8024e66:	78e3      	ldrb	r3, [r4, #3]
 8024e68:	059b      	lsls	r3, r3, #22
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8024e6a:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8024e6c:	2324      	movs	r3, #36	; 0x24
 8024e6e:	5ce3      	ldrb	r3, [r4, r3]
 8024e70:	061b      	lsls	r3, r3, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8024e72:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8024e74:	6a23      	ldr	r3, [r4, #32]
 8024e76:	4318      	orrs	r0, r3
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8024e78:	4310      	orrs	r0, r2
 8024e7a:	e000      	b.n	8024e7e <HAL_RTC_SetAlarm_IT+0xbe>
  uint32_t tmpreg = 0;
 8024e7c:	2000      	movs	r0, #0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8024e7e:	4b31      	ldr	r3, [pc, #196]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024e80:	22ca      	movs	r2, #202	; 0xca
 8024e82:	625a      	str	r2, [r3, #36]	; 0x24
 8024e84:	3a77      	subs	r2, #119	; 0x77
 8024e86:	625a      	str	r2, [r3, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 8024e88:	2380      	movs	r3, #128	; 0x80
 8024e8a:	005b      	lsls	r3, r3, #1
 8024e8c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8024e8e:	429a      	cmp	r2, r3
 8024e90:	d02e      	beq.n	8024ef0 <HAL_RTC_SetAlarm_IT+0x130>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8024e92:	4b2c      	ldr	r3, [pc, #176]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024e94:	699a      	ldr	r2, [r3, #24]
 8024e96:	492d      	ldr	r1, [pc, #180]	; (8024f4c <HAL_RTC_SetAlarm_IT+0x18c>)
 8024e98:	400a      	ands	r2, r1
 8024e9a:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8024e9c:	2202      	movs	r2, #2
 8024e9e:	65da      	str	r2, [r3, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 8024ea0:	2380      	movs	r3, #128	; 0x80
 8024ea2:	005b      	lsls	r3, r3, #1
 8024ea4:	429e      	cmp	r6, r3
 8024ea6:	d045      	beq.n	8024f34 <HAL_RTC_SetAlarm_IT+0x174>
      WRITE_REG(RTC->ALRMBR, tmpreg);
 8024ea8:	4b26      	ldr	r3, [pc, #152]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024eaa:	6498      	str	r0, [r3, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 8024eac:	69a2      	ldr	r2, [r4, #24]
 8024eae:	64da      	str	r2, [r3, #76]	; 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 8024eb0:	6862      	ldr	r2, [r4, #4]
 8024eb2:	4b24      	ldr	r3, [pc, #144]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024eb4:	675a      	str	r2, [r3, #116]	; 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8024eb6:	2202      	movs	r2, #2
 8024eb8:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8024eba:	430a      	orrs	r2, r1
 8024ebc:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8024ebe:	6999      	ldr	r1, [r3, #24]
 8024ec0:	2288      	movs	r2, #136	; 0x88
 8024ec2:	0192      	lsls	r2, r2, #6
 8024ec4:	430a      	orrs	r2, r1
 8024ec6:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8024ec8:	4921      	ldr	r1, [pc, #132]	; (8024f50 <HAL_RTC_SetAlarm_IT+0x190>)
 8024eca:	22c0      	movs	r2, #192	; 0xc0
 8024ecc:	5888      	ldr	r0, [r1, r2]
 8024ece:	2380      	movs	r3, #128	; 0x80
 8024ed0:	029b      	lsls	r3, r3, #10
 8024ed2:	4303      	orrs	r3, r0
 8024ed4:	508b      	str	r3, [r1, r2]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8024ed6:	4b1b      	ldr	r3, [pc, #108]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024ed8:	323f      	adds	r2, #63	; 0x3f
 8024eda:	625a      	str	r2, [r3, #36]	; 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8024edc:	232d      	movs	r3, #45	; 0x2d
 8024ede:	3afe      	subs	r2, #254	; 0xfe
 8024ee0:	54ea      	strb	r2, [r5, r3]
  __HAL_UNLOCK(hrtc);
 8024ee2:	3b01      	subs	r3, #1
 8024ee4:	2200      	movs	r2, #0
 8024ee6:	54ea      	strb	r2, [r5, r3]
  return HAL_OK;
 8024ee8:	2000      	movs	r0, #0
}
 8024eea:	bc80      	pop	{r7}
 8024eec:	46b8      	mov	r8, r7
 8024eee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8024ef0:	4b14      	ldr	r3, [pc, #80]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024ef2:	699a      	ldr	r2, [r3, #24]
 8024ef4:	4917      	ldr	r1, [pc, #92]	; (8024f54 <HAL_RTC_SetAlarm_IT+0x194>)
 8024ef6:	400a      	ands	r2, r1
 8024ef8:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8024efa:	2201      	movs	r2, #1
 8024efc:	65da      	str	r2, [r3, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 8024efe:	2380      	movs	r3, #128	; 0x80
 8024f00:	005b      	lsls	r3, r3, #1
 8024f02:	429e      	cmp	r6, r3
 8024f04:	d010      	beq.n	8024f28 <HAL_RTC_SetAlarm_IT+0x168>
      WRITE_REG(RTC->ALRMAR, tmpreg);
 8024f06:	4b0f      	ldr	r3, [pc, #60]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024f08:	6418      	str	r0, [r3, #64]	; 0x40
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 8024f0a:	69a2      	ldr	r2, [r4, #24]
 8024f0c:	645a      	str	r2, [r3, #68]	; 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 8024f0e:	6862      	ldr	r2, [r4, #4]
 8024f10:	4b0c      	ldr	r3, [pc, #48]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024f12:	671a      	str	r2, [r3, #112]	; 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8024f14:	2201      	movs	r2, #1
 8024f16:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8024f18:	430a      	orrs	r2, r1
 8024f1a:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8024f1c:	6999      	ldr	r1, [r3, #24]
 8024f1e:	2288      	movs	r2, #136	; 0x88
 8024f20:	0152      	lsls	r2, r2, #5
 8024f22:	430a      	orrs	r2, r1
 8024f24:	619a      	str	r2, [r3, #24]
 8024f26:	e7cf      	b.n	8024ec8 <HAL_RTC_SetAlarm_IT+0x108>
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 8024f28:	69a3      	ldr	r3, [r4, #24]
 8024f2a:	69e2      	ldr	r2, [r4, #28]
 8024f2c:	4313      	orrs	r3, r2
 8024f2e:	4a05      	ldr	r2, [pc, #20]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024f30:	6453      	str	r3, [r2, #68]	; 0x44
 8024f32:	e7ec      	b.n	8024f0e <HAL_RTC_SetAlarm_IT+0x14e>
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 8024f34:	69a3      	ldr	r3, [r4, #24]
 8024f36:	69e2      	ldr	r2, [r4, #28]
 8024f38:	4313      	orrs	r3, r2
 8024f3a:	4a02      	ldr	r2, [pc, #8]	; (8024f44 <HAL_RTC_SetAlarm_IT+0x184>)
 8024f3c:	64d3      	str	r3, [r2, #76]	; 0x4c
 8024f3e:	e7b7      	b.n	8024eb0 <HAL_RTC_SetAlarm_IT+0xf0>
  __HAL_LOCK(hrtc);
 8024f40:	2002      	movs	r0, #2
 8024f42:	e7d2      	b.n	8024eea <HAL_RTC_SetAlarm_IT+0x12a>
 8024f44:	40002800 	.word	0x40002800
 8024f48:	80808080 	.word	0x80808080
 8024f4c:	ffffddff 	.word	0xffffddff
 8024f50:	58000800 	.word	0x58000800
 8024f54:	ffffeeff 	.word	0xffffeeff

08024f58 <HAL_RTCEx_EnableBypassShadow>:
  *         directly from the Calendar counter.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
 8024f58:	b570      	push	{r4, r5, r6, lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8024f5a:	232c      	movs	r3, #44	; 0x2c
 8024f5c:	5cc3      	ldrb	r3, [r0, r3]
 8024f5e:	2b01      	cmp	r3, #1
 8024f60:	d015      	beq.n	8024f8e <HAL_RTCEx_EnableBypassShadow+0x36>
 8024f62:	212c      	movs	r1, #44	; 0x2c
 8024f64:	2501      	movs	r5, #1
 8024f66:	5445      	strb	r5, [r0, r1]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8024f68:	242d      	movs	r4, #45	; 0x2d
 8024f6a:	2302      	movs	r3, #2
 8024f6c:	5503      	strb	r3, [r0, r4]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8024f6e:	4b09      	ldr	r3, [pc, #36]	; (8024f94 <HAL_RTCEx_EnableBypassShadow+0x3c>)
 8024f70:	22ca      	movs	r2, #202	; 0xca
 8024f72:	625a      	str	r2, [r3, #36]	; 0x24
 8024f74:	3a77      	subs	r2, #119	; 0x77
 8024f76:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8024f78:	699a      	ldr	r2, [r3, #24]
 8024f7a:	2620      	movs	r6, #32
 8024f7c:	4332      	orrs	r2, r6
 8024f7e:	619a      	str	r2, [r3, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8024f80:	22ff      	movs	r2, #255	; 0xff
 8024f82:	625a      	str	r2, [r3, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8024f84:	5505      	strb	r5, [r0, r4]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8024f86:	2300      	movs	r3, #0
 8024f88:	5443      	strb	r3, [r0, r1]

  return HAL_OK;
 8024f8a:	2000      	movs	r0, #0
}
 8024f8c:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hrtc);
 8024f8e:	2002      	movs	r0, #2
 8024f90:	e7fc      	b.n	8024f8c <HAL_RTCEx_EnableBypassShadow+0x34>
 8024f92:	46c0      	nop			; (mov r8, r8)
 8024f94:	40002800 	.word	0x40002800

08024f98 <HAL_RTCEx_SetSSRU_IT>:
  * @brief  Set SSR Underflow detection with Interrupt.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
 8024f98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024f9a:	46c6      	mov	lr, r8
 8024f9c:	b500      	push	{lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8024f9e:	232c      	movs	r3, #44	; 0x2c
 8024fa0:	5cc3      	ldrb	r3, [r0, r3]
 8024fa2:	2b01      	cmp	r3, #1
 8024fa4:	d022      	beq.n	8024fec <HAL_RTCEx_SetSSRU_IT+0x54>
 8024fa6:	232c      	movs	r3, #44	; 0x2c
 8024fa8:	4698      	mov	r8, r3
 8024faa:	2501      	movs	r5, #1
 8024fac:	54c5      	strb	r5, [r0, r3]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8024fae:	242d      	movs	r4, #45	; 0x2d
 8024fb0:	3b2a      	subs	r3, #42	; 0x2a
 8024fb2:	5503      	strb	r3, [r0, r4]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8024fb4:	4b0e      	ldr	r3, [pc, #56]	; (8024ff0 <HAL_RTCEx_SetSSRU_IT+0x58>)
 8024fb6:	22ca      	movs	r2, #202	; 0xca
 8024fb8:	625a      	str	r2, [r3, #36]	; 0x24
 8024fba:	3a77      	subs	r2, #119	; 0x77
 8024fbc:	625a      	str	r2, [r3, #36]	; 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 8024fbe:	699a      	ldr	r2, [r3, #24]
 8024fc0:	2680      	movs	r6, #128	; 0x80
 8024fc2:	4332      	orrs	r2, r6
 8024fc4:	619a      	str	r2, [r3, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8024fc6:	4f0b      	ldr	r7, [pc, #44]	; (8024ff4 <HAL_RTCEx_SetSSRU_IT+0x5c>)
 8024fc8:	3640      	adds	r6, #64	; 0x40
 8024fca:	59ba      	ldr	r2, [r7, r6]
 8024fcc:	4694      	mov	ip, r2
 8024fce:	2280      	movs	r2, #128	; 0x80
 8024fd0:	02d2      	lsls	r2, r2, #11
 8024fd2:	4661      	mov	r1, ip
 8024fd4:	430a      	orrs	r2, r1
 8024fd6:	51ba      	str	r2, [r7, r6]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8024fd8:	22ff      	movs	r2, #255	; 0xff
 8024fda:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8024fdc:	5505      	strb	r5, [r0, r4]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8024fde:	2300      	movs	r3, #0
 8024fe0:	4642      	mov	r2, r8
 8024fe2:	5483      	strb	r3, [r0, r2]

  return HAL_OK;
 8024fe4:	2000      	movs	r0, #0
}
 8024fe6:	bc80      	pop	{r7}
 8024fe8:	46b8      	mov	r8, r7
 8024fea:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(hrtc);
 8024fec:	2002      	movs	r0, #2
 8024fee:	e7fa      	b.n	8024fe6 <HAL_RTCEx_SetSSRU_IT+0x4e>
 8024ff0:	40002800 	.word	0x40002800
 8024ff4:	58000800 	.word	0x58000800

08024ff8 <HAL_RTCEx_SSRUIRQHandler>:
  * @brief  Handle SSR underflow interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8024ff8:	b510      	push	{r4, lr}
 8024ffa:	0004      	movs	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 8024ffc:	4b06      	ldr	r3, [pc, #24]	; (8025018 <HAL_RTCEx_SSRUIRQHandler+0x20>)
 8024ffe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8025000:	065b      	lsls	r3, r3, #25
 8025002:	d403      	bmi.n	802500c <HAL_RTCEx_SSRUIRQHandler+0x14>
    HAL_RTCEx_SSRUEventCallback(hrtc);
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8025004:	232d      	movs	r3, #45	; 0x2d
 8025006:	2201      	movs	r2, #1
 8025008:	54e2      	strb	r2, [r4, r3]
}
 802500a:	bd10      	pop	{r4, pc}
    RTC->SCR = RTC_SCR_CSSRUF;
 802500c:	4b02      	ldr	r3, [pc, #8]	; (8025018 <HAL_RTCEx_SSRUIRQHandler+0x20>)
 802500e:	2240      	movs	r2, #64	; 0x40
 8025010:	65da      	str	r2, [r3, #92]	; 0x5c
    HAL_RTCEx_SSRUEventCallback(hrtc);
 8025012:	f7fc ff15 	bl	8021e40 <HAL_RTCEx_SSRUEventCallback>
 8025016:	e7f5      	b.n	8025004 <HAL_RTCEx_SSRUIRQHandler+0xc>
 8025018:	40002800 	.word	0x40002800

0802501c <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802501c:	0089      	lsls	r1, r1, #2
 802501e:	4b02      	ldr	r3, [pc, #8]	; (8025028 <HAL_RTCEx_BKUPWrite+0xc>)
 8025020:	469c      	mov	ip, r3
 8025022:	4461      	add	r1, ip

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8025024:	600a      	str	r2, [r1, #0]
}
 8025026:	4770      	bx	lr
 8025028:	4000b100 	.word	0x4000b100

0802502c <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 802502c:	0089      	lsls	r1, r1, #2
 802502e:	4b02      	ldr	r3, [pc, #8]	; (8025038 <HAL_RTCEx_BKUPRead+0xc>)
 8025030:	469c      	mov	ip, r3
 8025032:	4461      	add	r1, ip

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8025034:	6808      	ldr	r0, [r1, #0]
}
 8025036:	4770      	bx	lr
 8025038:	4000b100 	.word	0x4000b100

0802503c <SUBGHZSPI_Init>:
  * @brief  Initializes the SUBGHZSPI peripheral
  * @param  BaudratePrescaler SPI Baudrate prescaler
  * @retval None
  */
void SUBGHZSPI_Init(uint32_t BaudratePrescaler)
{
 802503c:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802503e:	4b08      	ldr	r3, [pc, #32]	; (8025060 <SUBGHZSPI_Init+0x24>)
 8025040:	681c      	ldr	r4, [r3, #0]
 8025042:	2540      	movs	r5, #64	; 0x40
 8025044:	43ac      	bics	r4, r5
 8025046:	601c      	str	r4, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 8025048:	21c1      	movs	r1, #193	; 0xc1
 802504a:	0089      	lsls	r1, r1, #2
 802504c:	4301      	orrs	r1, r0
 802504e:	6019      	str	r1, [r3, #0]
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 8025050:	22b8      	movs	r2, #184	; 0xb8
 8025052:	0152      	lsls	r2, r2, #5
 8025054:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8025056:	681a      	ldr	r2, [r3, #0]
 8025058:	432a      	orrs	r2, r5
 802505a:	601a      	str	r2, [r3, #0]
}
 802505c:	bd30      	pop	{r4, r5, pc}
 802505e:	46c0      	nop			; (mov r8, r8)
 8025060:	58010000 	.word	0x58010000

08025064 <HAL_SUBGHZ_Init>:
{
 8025064:	b570      	push	{r4, r5, r6, lr}
 8025066:	b082      	sub	sp, #8
 8025068:	1e04      	subs	r4, r0, #0
  if (hsubghz == NULL)
 802506a:	d04d      	beq.n	8025108 <HAL_SUBGHZ_Init+0xa4>
  if (hsubghz->State == HAL_SUBGHZ_STATE_RESET)
 802506c:	7983      	ldrb	r3, [r0, #6]
 802506e:	2b00      	cmp	r3, #0
 8025070:	d03a      	beq.n	80250e8 <HAL_SUBGHZ_Init+0x84>
  hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8025072:	2302      	movs	r3, #2
 8025074:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 8025076:	21b0      	movs	r1, #176	; 0xb0
 8025078:	05c9      	lsls	r1, r1, #23
 802507a:	2294      	movs	r2, #148	; 0x94
 802507c:	588b      	ldr	r3, [r1, r2]
 802507e:	4823      	ldr	r0, [pc, #140]	; (802510c <HAL_SUBGHZ_Init+0xa8>)
 8025080:	4003      	ands	r3, r0
 8025082:	508b      	str	r3, [r1, r2]
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8025084:	4b22      	ldr	r3, [pc, #136]	; (8025110 <HAL_SUBGHZ_Init+0xac>)
 8025086:	681a      	ldr	r2, [r3, #0]
 8025088:	00d3      	lsls	r3, r2, #3
 802508a:	1a9b      	subs	r3, r3, r2
 802508c:	009b      	lsls	r3, r3, #2
 802508e:	0cdb      	lsrs	r3, r3, #19
 8025090:	2264      	movs	r2, #100	; 0x64
 8025092:	4353      	muls	r3, r2
 8025094:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 8025096:	9b01      	ldr	r3, [sp, #4]
 8025098:	2b00      	cmp	r3, #0
 802509a:	d029      	beq.n	80250f0 <HAL_SUBGHZ_Init+0x8c>
    count--;
 802509c:	9b01      	ldr	r3, [sp, #4]
 802509e:	3b01      	subs	r3, #1
 80250a0:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 80250a2:	22b0      	movs	r2, #176	; 0xb0
 80250a4:	05d2      	lsls	r2, r2, #23
 80250a6:	2394      	movs	r3, #148	; 0x94
 80250a8:	58d3      	ldr	r3, [r2, r3]
 80250aa:	045b      	lsls	r3, r3, #17
 80250ac:	d4f3      	bmi.n	8025096 <HAL_SUBGHZ_Init+0x32>
    status = HAL_OK;
 80250ae:	2500      	movs	r5, #0
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80250b0:	4b18      	ldr	r3, [pc, #96]	; (8025114 <HAL_SUBGHZ_Init+0xb0>)
 80250b2:	2290      	movs	r2, #144	; 0x90
 80250b4:	5898      	ldr	r0, [r3, r2]
 80250b6:	2180      	movs	r1, #128	; 0x80
 80250b8:	0209      	lsls	r1, r1, #8
 80250ba:	4301      	orrs	r1, r0
 80250bc:	5099      	str	r1, [r3, r2]
  SET_BIT(EXTI->IMR2, ExtiLine);
 80250be:	4816      	ldr	r0, [pc, #88]	; (8025118 <HAL_SUBGHZ_Init+0xb4>)
 80250c0:	5886      	ldr	r6, [r0, r2]
 80250c2:	2180      	movs	r1, #128	; 0x80
 80250c4:	0149      	lsls	r1, r1, #5
 80250c6:	4331      	orrs	r1, r6
 80250c8:	5081      	str	r1, [r0, r2]
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 80250ca:	689a      	ldr	r2, [r3, #8]
 80250cc:	4913      	ldr	r1, [pc, #76]	; (802511c <HAL_SUBGHZ_Init+0xb8>)
 80250ce:	400a      	ands	r2, r1
 80250d0:	2180      	movs	r1, #128	; 0x80
 80250d2:	0109      	lsls	r1, r1, #4
 80250d4:	430a      	orrs	r2, r1
 80250d6:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 80250d8:	6199      	str	r1, [r3, #24]
  if (status == HAL_OK)
 80250da:	2d00      	cmp	r5, #0
 80250dc:	d00c      	beq.n	80250f8 <HAL_SUBGHZ_Init+0x94>
  hsubghz->State     = HAL_SUBGHZ_STATE_READY;
 80250de:	2301      	movs	r3, #1
 80250e0:	71a3      	strb	r3, [r4, #6]
}
 80250e2:	0028      	movs	r0, r5
 80250e4:	b002      	add	sp, #8
 80250e6:	bd70      	pop	{r4, r5, r6, pc}
    hsubghz->Lock = HAL_UNLOCKED;
 80250e8:	7143      	strb	r3, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 80250ea:	f7fc fc7d 	bl	80219e8 <HAL_SUBGHZ_MspInit>
 80250ee:	e7c0      	b.n	8025072 <HAL_SUBGHZ_Init+0xe>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 80250f0:	3301      	adds	r3, #1
 80250f2:	60a3      	str	r3, [r4, #8]
      status  = HAL_ERROR;
 80250f4:	2501      	movs	r5, #1
      break;
 80250f6:	e7db      	b.n	80250b0 <HAL_SUBGHZ_Init+0x4c>
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 80250f8:	6820      	ldr	r0, [r4, #0]
 80250fa:	f7ff ff9f 	bl	802503c <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 80250fe:	2301      	movs	r3, #1
 8025100:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 8025102:	2300      	movs	r3, #0
 8025104:	60a3      	str	r3, [r4, #8]
 8025106:	e7ea      	b.n	80250de <HAL_SUBGHZ_Init+0x7a>
    return status;
 8025108:	2501      	movs	r5, #1
 802510a:	e7ea      	b.n	80250e2 <HAL_SUBGHZ_Init+0x7e>
 802510c:	ffff7fff 	.word	0xffff7fff
 8025110:	2000a034 	.word	0x2000a034
 8025114:	58000400 	.word	0x58000400
 8025118:	58000800 	.word	0x58000800
 802511c:	fffff7ff 	.word	0xfffff7ff

08025120 <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 8025120:	b082      	sub	sp, #8
 8025122:	0002      	movs	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8025124:	4b1a      	ldr	r3, [pc, #104]	; (8025190 <SUBGHZSPI_Transmit+0x70>)
 8025126:	6818      	ldr	r0, [r3, #0]
 8025128:	00c3      	lsls	r3, r0, #3
 802512a:	1a1b      	subs	r3, r3, r0
 802512c:	009b      	lsls	r3, r3, #2
 802512e:	0cdb      	lsrs	r3, r3, #19
 8025130:	2064      	movs	r0, #100	; 0x64
 8025132:	4343      	muls	r3, r0
 8025134:	9301      	str	r3, [sp, #4]

  /* Wait until TXE flag is set */
  do
  {
    if (count == 0U)
 8025136:	9b01      	ldr	r3, [sp, #4]
 8025138:	2b00      	cmp	r3, #0
 802513a:	d008      	beq.n	802514e <SUBGHZSPI_Transmit+0x2e>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 802513c:	9b01      	ldr	r3, [sp, #4]
 802513e:	3b01      	subs	r3, #1
 8025140:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 8025142:	4b14      	ldr	r3, [pc, #80]	; (8025194 <SUBGHZSPI_Transmit+0x74>)
 8025144:	689b      	ldr	r3, [r3, #8]
 8025146:	079b      	lsls	r3, r3, #30
 8025148:	d5f5      	bpl.n	8025136 <SUBGHZSPI_Transmit+0x16>
  HAL_StatusTypeDef status = HAL_OK;
 802514a:	2000      	movs	r0, #0
 802514c:	e002      	b.n	8025154 <SUBGHZSPI_Transmit+0x34>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 802514e:	3301      	adds	r3, #1
 8025150:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8025152:	2001      	movs	r0, #1

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 8025154:	4b10      	ldr	r3, [pc, #64]	; (8025198 <SUBGHZSPI_Transmit+0x78>)
 8025156:	7019      	strb	r1, [r3, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8025158:	4b0d      	ldr	r3, [pc, #52]	; (8025190 <SUBGHZSPI_Transmit+0x70>)
 802515a:	6819      	ldr	r1, [r3, #0]
 802515c:	00cb      	lsls	r3, r1, #3
 802515e:	1a5b      	subs	r3, r3, r1
 8025160:	009b      	lsls	r3, r3, #2
 8025162:	0cdb      	lsrs	r3, r3, #19
 8025164:	2164      	movs	r1, #100	; 0x64
 8025166:	434b      	muls	r3, r1
 8025168:	9301      	str	r3, [sp, #4]

  /* Wait until RXNE flag is set */
  do
  {
    if (count == 0U)
 802516a:	9b01      	ldr	r3, [sp, #4]
 802516c:	2b00      	cmp	r3, #0
 802516e:	d007      	beq.n	8025180 <SUBGHZSPI_Transmit+0x60>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 8025170:	9b01      	ldr	r3, [sp, #4]
 8025172:	3b01      	subs	r3, #1
 8025174:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 8025176:	4b07      	ldr	r3, [pc, #28]	; (8025194 <SUBGHZSPI_Transmit+0x74>)
 8025178:	689b      	ldr	r3, [r3, #8]
 802517a:	07db      	lsls	r3, r3, #31
 802517c:	d5f5      	bpl.n	802516a <SUBGHZSPI_Transmit+0x4a>
 802517e:	e002      	b.n	8025186 <SUBGHZSPI_Transmit+0x66>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8025180:	3301      	adds	r3, #1
 8025182:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8025184:	2001      	movs	r0, #1

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 8025186:	4b03      	ldr	r3, [pc, #12]	; (8025194 <SUBGHZSPI_Transmit+0x74>)
 8025188:	68db      	ldr	r3, [r3, #12]

  return status;
}
 802518a:	b002      	add	sp, #8
 802518c:	4770      	bx	lr
 802518e:	46c0      	nop			; (mov r8, r8)
 8025190:	2000a034 	.word	0x2000a034
 8025194:	58010000 	.word	0x58010000
 8025198:	5801000c 	.word	0x5801000c

0802519c <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 802519c:	b510      	push	{r4, lr}
 802519e:	b082      	sub	sp, #8
 80251a0:	0002      	movs	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 80251a2:	4b1b      	ldr	r3, [pc, #108]	; (8025210 <SUBGHZSPI_Receive+0x74>)
 80251a4:	6818      	ldr	r0, [r3, #0]
 80251a6:	00c3      	lsls	r3, r0, #3
 80251a8:	1a1b      	subs	r3, r3, r0
 80251aa:	009b      	lsls	r3, r3, #2
 80251ac:	0cdb      	lsrs	r3, r3, #19
 80251ae:	2064      	movs	r0, #100	; 0x64
 80251b0:	4343      	muls	r3, r0
 80251b2:	9301      	str	r3, [sp, #4]

  /* Wait until TXE flag is set */
  do
  {
    if (count == 0U)
 80251b4:	9b01      	ldr	r3, [sp, #4]
 80251b6:	2b00      	cmp	r3, #0
 80251b8:	d008      	beq.n	80251cc <SUBGHZSPI_Receive+0x30>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 80251ba:	9b01      	ldr	r3, [sp, #4]
 80251bc:	3b01      	subs	r3, #1
 80251be:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 80251c0:	4b14      	ldr	r3, [pc, #80]	; (8025214 <SUBGHZSPI_Receive+0x78>)
 80251c2:	689b      	ldr	r3, [r3, #8]
 80251c4:	079b      	lsls	r3, r3, #30
 80251c6:	d5f5      	bpl.n	80251b4 <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 80251c8:	2000      	movs	r0, #0
 80251ca:	e002      	b.n	80251d2 <SUBGHZSPI_Receive+0x36>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 80251cc:	3301      	adds	r3, #1
 80251ce:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 80251d0:	2001      	movs	r0, #1

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 80251d2:	4b11      	ldr	r3, [pc, #68]	; (8025218 <SUBGHZSPI_Receive+0x7c>)
 80251d4:	24ff      	movs	r4, #255	; 0xff
 80251d6:	701c      	strb	r4, [r3, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 80251d8:	4b0d      	ldr	r3, [pc, #52]	; (8025210 <SUBGHZSPI_Receive+0x74>)
 80251da:	681c      	ldr	r4, [r3, #0]
 80251dc:	00e3      	lsls	r3, r4, #3
 80251de:	1b1b      	subs	r3, r3, r4
 80251e0:	009b      	lsls	r3, r3, #2
 80251e2:	0cdb      	lsrs	r3, r3, #19
 80251e4:	2464      	movs	r4, #100	; 0x64
 80251e6:	4363      	muls	r3, r4
 80251e8:	9301      	str	r3, [sp, #4]

  /* Wait until RXNE flag is set */
  do
  {
    if (count == 0U)
 80251ea:	9b01      	ldr	r3, [sp, #4]
 80251ec:	2b00      	cmp	r3, #0
 80251ee:	d007      	beq.n	8025200 <SUBGHZSPI_Receive+0x64>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 80251f0:	9b01      	ldr	r3, [sp, #4]
 80251f2:	3b01      	subs	r3, #1
 80251f4:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 80251f6:	4b07      	ldr	r3, [pc, #28]	; (8025214 <SUBGHZSPI_Receive+0x78>)
 80251f8:	689b      	ldr	r3, [r3, #8]
 80251fa:	07db      	lsls	r3, r3, #31
 80251fc:	d5f5      	bpl.n	80251ea <SUBGHZSPI_Receive+0x4e>
 80251fe:	e002      	b.n	8025206 <SUBGHZSPI_Receive+0x6a>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8025200:	3301      	adds	r3, #1
 8025202:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8025204:	2001      	movs	r0, #1

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 8025206:	4b03      	ldr	r3, [pc, #12]	; (8025214 <SUBGHZSPI_Receive+0x78>)
 8025208:	68db      	ldr	r3, [r3, #12]
 802520a:	700b      	strb	r3, [r1, #0]

  return status;
}
 802520c:	b002      	add	sp, #8
 802520e:	bd10      	pop	{r4, pc}
 8025210:	2000a034 	.word	0x2000a034
 8025214:	58010000 	.word	0x58010000
 8025218:	5801000c 	.word	0x5801000c

0802521c <SUBGHZ_WaitOnBusy>:
  * @param  hsubghz pointer to a SUBGHZ_HandleTypeDef structure that contains
  *         the handle information for SUBGHZ module.
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZ_WaitOnBusy(SUBGHZ_HandleTypeDef *hsubghz)
{
 802521c:	b510      	push	{r4, lr}
 802521e:	b082      	sub	sp, #8
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 8025220:	4b14      	ldr	r3, [pc, #80]	; (8025274 <SUBGHZ_WaitOnBusy+0x58>)
 8025222:	681a      	ldr	r2, [r3, #0]
 8025224:	0053      	lsls	r3, r2, #1
 8025226:	189b      	adds	r3, r3, r2
 8025228:	00db      	lsls	r3, r3, #3
 802522a:	0d1b      	lsrs	r3, r3, #20
 802522c:	2264      	movs	r2, #100	; 0x64
 802522e:	4353      	muls	r3, r2
 8025230:	9301      	str	r3, [sp, #4]
 8025232:	e006      	b.n	8025242 <SUBGHZ_WaitOnBusy+0x26>
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 8025234:	3302      	adds	r3, #2
 8025236:	6083      	str	r3, [r0, #8]
      status  = HAL_ERROR;
 8025238:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 802523a:	b002      	add	sp, #8
 802523c:	bd10      	pop	{r4, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 802523e:	420c      	tst	r4, r1
 8025240:	d016      	beq.n	8025270 <SUBGHZ_WaitOnBusy+0x54>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 8025242:	4b0d      	ldr	r3, [pc, #52]	; (8025278 <SUBGHZ_WaitOnBusy+0x5c>)
 8025244:	695b      	ldr	r3, [r3, #20]
 8025246:	2204      	movs	r2, #4
 8025248:	0011      	movs	r1, r2
 802524a:	4019      	ands	r1, r3
 802524c:	421a      	tst	r2, r3
 802524e:	d000      	beq.n	8025252 <SUBGHZ_WaitOnBusy+0x36>
 8025250:	2101      	movs	r1, #1
    if (count == 0U)
 8025252:	9b01      	ldr	r3, [sp, #4]
 8025254:	2b00      	cmp	r3, #0
 8025256:	d0ed      	beq.n	8025234 <SUBGHZ_WaitOnBusy+0x18>
    count--;
 8025258:	9b01      	ldr	r3, [sp, #4]
 802525a:	3b01      	subs	r3, #1
 802525c:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 802525e:	4b06      	ldr	r3, [pc, #24]	; (8025278 <SUBGHZ_WaitOnBusy+0x5c>)
 8025260:	695b      	ldr	r3, [r3, #20]
 8025262:	2202      	movs	r2, #2
 8025264:	0014      	movs	r4, r2
 8025266:	401c      	ands	r4, r3
 8025268:	421a      	tst	r2, r3
 802526a:	d0e8      	beq.n	802523e <SUBGHZ_WaitOnBusy+0x22>
 802526c:	2401      	movs	r4, #1
 802526e:	e7e6      	b.n	802523e <SUBGHZ_WaitOnBusy+0x22>
  status = HAL_OK;
 8025270:	2000      	movs	r0, #0
 8025272:	e7e2      	b.n	802523a <SUBGHZ_WaitOnBusy+0x1e>
 8025274:	2000a034 	.word	0x2000a034
 8025278:	58000400 	.word	0x58000400

0802527c <SUBGHZ_CheckDeviceReady>:
{
 802527c:	b510      	push	{r4, lr}
 802527e:	b082      	sub	sp, #8
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 8025280:	7903      	ldrb	r3, [r0, #4]
 8025282:	2b01      	cmp	r3, #1
 8025284:	d003      	beq.n	802528e <SUBGHZ_CheckDeviceReady+0x12>
  return (SUBGHZ_WaitOnBusy(hsubghz));
 8025286:	f7ff ffc9 	bl	802521c <SUBGHZ_WaitOnBusy>
}
 802528a:	b002      	add	sp, #8
 802528c:	bd10      	pop	{r4, pc}
    count  = SUBGHZ_NSS_LOOP_TIME;
 802528e:	4b0d      	ldr	r3, [pc, #52]	; (80252c4 <SUBGHZ_CheckDeviceReady+0x48>)
 8025290:	681a      	ldr	r2, [r3, #0]
 8025292:	0053      	lsls	r3, r2, #1
 8025294:	189b      	adds	r3, r3, r2
 8025296:	00db      	lsls	r3, r3, #3
 8025298:	0c1b      	lsrs	r3, r3, #16
 802529a:	9301      	str	r3, [sp, #4]
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802529c:	490a      	ldr	r1, [pc, #40]	; (80252c8 <SUBGHZ_CheckDeviceReady+0x4c>)
 802529e:	2290      	movs	r2, #144	; 0x90
 80252a0:	588b      	ldr	r3, [r1, r2]
 80252a2:	4c0a      	ldr	r4, [pc, #40]	; (80252cc <SUBGHZ_CheckDeviceReady+0x50>)
 80252a4:	4023      	ands	r3, r4
 80252a6:	508b      	str	r3, [r1, r2]
      count--;
 80252a8:	9b01      	ldr	r3, [sp, #4]
 80252aa:	3b01      	subs	r3, #1
 80252ac:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 80252ae:	9b01      	ldr	r3, [sp, #4]
 80252b0:	2b00      	cmp	r3, #0
 80252b2:	d1f9      	bne.n	80252a8 <SUBGHZ_CheckDeviceReady+0x2c>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80252b4:	4904      	ldr	r1, [pc, #16]	; (80252c8 <SUBGHZ_CheckDeviceReady+0x4c>)
 80252b6:	2290      	movs	r2, #144	; 0x90
 80252b8:	588c      	ldr	r4, [r1, r2]
 80252ba:	2380      	movs	r3, #128	; 0x80
 80252bc:	021b      	lsls	r3, r3, #8
 80252be:	4323      	orrs	r3, r4
 80252c0:	508b      	str	r3, [r1, r2]
}
 80252c2:	e7e0      	b.n	8025286 <SUBGHZ_CheckDeviceReady+0xa>
 80252c4:	2000a034 	.word	0x2000a034
 80252c8:	58000400 	.word	0x58000400
 80252cc:	ffff7fff 	.word	0xffff7fff

080252d0 <HAL_SUBGHZ_WriteRegisters>:
{
 80252d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80252d2:	46c6      	mov	lr, r8
 80252d4:	b500      	push	{lr}
 80252d6:	0005      	movs	r5, r0
 80252d8:	000c      	movs	r4, r1
 80252da:	0017      	movs	r7, r2
 80252dc:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80252de:	7983      	ldrb	r3, [r0, #6]
 80252e0:	b2da      	uxtb	r2, r3
 80252e2:	4690      	mov	r8, r2
 80252e4:	2b01      	cmp	r3, #1
 80252e6:	d13a      	bne.n	802535e <HAL_SUBGHZ_WriteRegisters+0x8e>
    __HAL_LOCK(hsubghz);
 80252e8:	7943      	ldrb	r3, [r0, #5]
 80252ea:	2b01      	cmp	r3, #1
 80252ec:	d03a      	beq.n	8025364 <HAL_SUBGHZ_WriteRegisters+0x94>
 80252ee:	2301      	movs	r3, #1
 80252f0:	7143      	strb	r3, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 80252f2:	3301      	adds	r3, #1
 80252f4:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80252f6:	f7ff ffc1 	bl	802527c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80252fa:	491c      	ldr	r1, [pc, #112]	; (802536c <HAL_SUBGHZ_WriteRegisters+0x9c>)
 80252fc:	2290      	movs	r2, #144	; 0x90
 80252fe:	588b      	ldr	r3, [r1, r2]
 8025300:	481b      	ldr	r0, [pc, #108]	; (8025370 <HAL_SUBGHZ_WriteRegisters+0xa0>)
 8025302:	4003      	ands	r3, r0
 8025304:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 8025306:	210d      	movs	r1, #13
 8025308:	0028      	movs	r0, r5
 802530a:	f7ff ff09 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 802530e:	0a21      	lsrs	r1, r4, #8
 8025310:	0028      	movs	r0, r5
 8025312:	f7ff ff05 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 8025316:	b2e1      	uxtb	r1, r4
 8025318:	0028      	movs	r0, r5
 802531a:	f7ff ff01 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802531e:	2400      	movs	r4, #0
 8025320:	e005      	b.n	802532e <HAL_SUBGHZ_WriteRegisters+0x5e>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8025322:	5d39      	ldrb	r1, [r7, r4]
 8025324:	0028      	movs	r0, r5
 8025326:	f7ff fefb 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802532a:	3401      	adds	r4, #1
 802532c:	b2a4      	uxth	r4, r4
 802532e:	42b4      	cmp	r4, r6
 8025330:	d3f7      	bcc.n	8025322 <HAL_SUBGHZ_WriteRegisters+0x52>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025332:	490e      	ldr	r1, [pc, #56]	; (802536c <HAL_SUBGHZ_WriteRegisters+0x9c>)
 8025334:	2290      	movs	r2, #144	; 0x90
 8025336:	5888      	ldr	r0, [r1, r2]
 8025338:	2380      	movs	r3, #128	; 0x80
 802533a:	021b      	lsls	r3, r3, #8
 802533c:	4303      	orrs	r3, r0
 802533e:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8025340:	0028      	movs	r0, r5
 8025342:	f7ff ff6b 	bl	802521c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8025346:	68ab      	ldr	r3, [r5, #8]
 8025348:	2b00      	cmp	r3, #0
 802534a:	d100      	bne.n	802534e <HAL_SUBGHZ_WriteRegisters+0x7e>
      status = HAL_OK;
 802534c:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802534e:	2301      	movs	r3, #1
 8025350:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8025352:	2300      	movs	r3, #0
 8025354:	716b      	strb	r3, [r5, #5]
}
 8025356:	4640      	mov	r0, r8
 8025358:	bc80      	pop	{r7}
 802535a:	46b8      	mov	r8, r7
 802535c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 802535e:	2302      	movs	r3, #2
 8025360:	4698      	mov	r8, r3
 8025362:	e7f8      	b.n	8025356 <HAL_SUBGHZ_WriteRegisters+0x86>
    __HAL_LOCK(hsubghz);
 8025364:	2302      	movs	r3, #2
 8025366:	4698      	mov	r8, r3
 8025368:	e7f5      	b.n	8025356 <HAL_SUBGHZ_WriteRegisters+0x86>
 802536a:	46c0      	nop			; (mov r8, r8)
 802536c:	58000400 	.word	0x58000400
 8025370:	ffff7fff 	.word	0xffff7fff

08025374 <HAL_SUBGHZ_ReadRegisters>:
{
 8025374:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025376:	46c6      	mov	lr, r8
 8025378:	b500      	push	{lr}
 802537a:	0006      	movs	r6, r0
 802537c:	000c      	movs	r4, r1
 802537e:	0015      	movs	r5, r2
 8025380:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8025382:	7983      	ldrb	r3, [r0, #6]
 8025384:	b2da      	uxtb	r2, r3
 8025386:	4690      	mov	r8, r2
 8025388:	2b01      	cmp	r3, #1
 802538a:	d13d      	bne.n	8025408 <HAL_SUBGHZ_ReadRegisters+0x94>
    __HAL_LOCK(hsubghz);
 802538c:	7943      	ldrb	r3, [r0, #5]
 802538e:	2b01      	cmp	r3, #1
 8025390:	d03d      	beq.n	802540e <HAL_SUBGHZ_ReadRegisters+0x9a>
 8025392:	2301      	movs	r3, #1
 8025394:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8025396:	f7ff ff71 	bl	802527c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802539a:	491e      	ldr	r1, [pc, #120]	; (8025414 <HAL_SUBGHZ_ReadRegisters+0xa0>)
 802539c:	2290      	movs	r2, #144	; 0x90
 802539e:	588b      	ldr	r3, [r1, r2]
 80253a0:	481d      	ldr	r0, [pc, #116]	; (8025418 <HAL_SUBGHZ_ReadRegisters+0xa4>)
 80253a2:	4003      	ands	r3, r0
 80253a4:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 80253a6:	211d      	movs	r1, #29
 80253a8:	0030      	movs	r0, r6
 80253aa:	f7ff feb9 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 80253ae:	0a21      	lsrs	r1, r4, #8
 80253b0:	0030      	movs	r0, r6
 80253b2:	f7ff feb5 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 80253b6:	b2e1      	uxtb	r1, r4
 80253b8:	0030      	movs	r0, r6
 80253ba:	f7ff feb1 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 80253be:	2100      	movs	r1, #0
 80253c0:	0030      	movs	r0, r6
 80253c2:	f7ff fead 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80253c6:	2400      	movs	r4, #0
 80253c8:	e006      	b.n	80253d8 <HAL_SUBGHZ_ReadRegisters+0x64>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 80253ca:	0029      	movs	r1, r5
 80253cc:	0030      	movs	r0, r6
 80253ce:	f7ff fee5 	bl	802519c <SUBGHZSPI_Receive>
      pData++;
 80253d2:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 80253d4:	3401      	adds	r4, #1
 80253d6:	b2a4      	uxth	r4, r4
 80253d8:	42bc      	cmp	r4, r7
 80253da:	d3f6      	bcc.n	80253ca <HAL_SUBGHZ_ReadRegisters+0x56>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80253dc:	490d      	ldr	r1, [pc, #52]	; (8025414 <HAL_SUBGHZ_ReadRegisters+0xa0>)
 80253de:	2290      	movs	r2, #144	; 0x90
 80253e0:	5888      	ldr	r0, [r1, r2]
 80253e2:	2380      	movs	r3, #128	; 0x80
 80253e4:	021b      	lsls	r3, r3, #8
 80253e6:	4303      	orrs	r3, r0
 80253e8:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 80253ea:	0030      	movs	r0, r6
 80253ec:	f7ff ff16 	bl	802521c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80253f0:	68b3      	ldr	r3, [r6, #8]
 80253f2:	2b00      	cmp	r3, #0
 80253f4:	d100      	bne.n	80253f8 <HAL_SUBGHZ_ReadRegisters+0x84>
      status = HAL_OK;
 80253f6:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80253f8:	2301      	movs	r3, #1
 80253fa:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 80253fc:	2300      	movs	r3, #0
 80253fe:	7173      	strb	r3, [r6, #5]
}
 8025400:	4640      	mov	r0, r8
 8025402:	bc80      	pop	{r7}
 8025404:	46b8      	mov	r8, r7
 8025406:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8025408:	2302      	movs	r3, #2
 802540a:	4698      	mov	r8, r3
 802540c:	e7f8      	b.n	8025400 <HAL_SUBGHZ_ReadRegisters+0x8c>
    __HAL_LOCK(hsubghz);
 802540e:	2302      	movs	r3, #2
 8025410:	4698      	mov	r8, r3
 8025412:	e7f5      	b.n	8025400 <HAL_SUBGHZ_ReadRegisters+0x8c>
 8025414:	58000400 	.word	0x58000400
 8025418:	ffff7fff 	.word	0xffff7fff

0802541c <HAL_SUBGHZ_ExecSetCmd>:
{
 802541c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802541e:	46ce      	mov	lr, r9
 8025420:	4647      	mov	r7, r8
 8025422:	b580      	push	{r7, lr}
 8025424:	0005      	movs	r5, r0
 8025426:	4688      	mov	r8, r1
 8025428:	0017      	movs	r7, r2
 802542a:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802542c:	7983      	ldrb	r3, [r0, #6]
 802542e:	b2da      	uxtb	r2, r3
 8025430:	4691      	mov	r9, r2
 8025432:	2b01      	cmp	r3, #1
 8025434:	d13f      	bne.n	80254b6 <HAL_SUBGHZ_ExecSetCmd+0x9a>
    __HAL_LOCK(hsubghz);
 8025436:	7943      	ldrb	r3, [r0, #5]
 8025438:	2b01      	cmp	r3, #1
 802543a:	d03f      	beq.n	80254bc <HAL_SUBGHZ_ExecSetCmd+0xa0>
 802543c:	2301      	movs	r3, #1
 802543e:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8025440:	f7ff ff1c 	bl	802527c <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 8025444:	4643      	mov	r3, r8
 8025446:	2b84      	cmp	r3, #132	; 0x84
 8025448:	d004      	beq.n	8025454 <HAL_SUBGHZ_ExecSetCmd+0x38>
 802544a:	2b94      	cmp	r3, #148	; 0x94
 802544c:	d002      	beq.n	8025454 <HAL_SUBGHZ_ExecSetCmd+0x38>
      hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_DISABLE;
 802544e:	2300      	movs	r3, #0
 8025450:	712b      	strb	r3, [r5, #4]
 8025452:	e001      	b.n	8025458 <HAL_SUBGHZ_ExecSetCmd+0x3c>
      hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 8025454:	2301      	movs	r3, #1
 8025456:	712b      	strb	r3, [r5, #4]
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025458:	491a      	ldr	r1, [pc, #104]	; (80254c4 <HAL_SUBGHZ_ExecSetCmd+0xa8>)
 802545a:	2290      	movs	r2, #144	; 0x90
 802545c:	588b      	ldr	r3, [r1, r2]
 802545e:	481a      	ldr	r0, [pc, #104]	; (80254c8 <HAL_SUBGHZ_ExecSetCmd+0xac>)
 8025460:	4003      	ands	r3, r0
 8025462:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 8025464:	4641      	mov	r1, r8
 8025466:	0028      	movs	r0, r5
 8025468:	f7ff fe5a 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802546c:	2400      	movs	r4, #0
 802546e:	e005      	b.n	802547c <HAL_SUBGHZ_ExecSetCmd+0x60>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8025470:	5d39      	ldrb	r1, [r7, r4]
 8025472:	0028      	movs	r0, r5
 8025474:	f7ff fe54 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8025478:	3401      	adds	r4, #1
 802547a:	b2a4      	uxth	r4, r4
 802547c:	42b4      	cmp	r4, r6
 802547e:	d3f7      	bcc.n	8025470 <HAL_SUBGHZ_ExecSetCmd+0x54>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025480:	4910      	ldr	r1, [pc, #64]	; (80254c4 <HAL_SUBGHZ_ExecSetCmd+0xa8>)
 8025482:	2290      	movs	r2, #144	; 0x90
 8025484:	5888      	ldr	r0, [r1, r2]
 8025486:	2380      	movs	r3, #128	; 0x80
 8025488:	021b      	lsls	r3, r3, #8
 802548a:	4303      	orrs	r3, r0
 802548c:	508b      	str	r3, [r1, r2]
    if (Command != RADIO_SET_SLEEP)
 802548e:	4643      	mov	r3, r8
 8025490:	2b84      	cmp	r3, #132	; 0x84
 8025492:	d10c      	bne.n	80254ae <HAL_SUBGHZ_ExecSetCmd+0x92>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8025494:	68ab      	ldr	r3, [r5, #8]
 8025496:	2b00      	cmp	r3, #0
 8025498:	d100      	bne.n	802549c <HAL_SUBGHZ_ExecSetCmd+0x80>
      status = HAL_OK;
 802549a:	4699      	mov	r9, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802549c:	2301      	movs	r3, #1
 802549e:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 80254a0:	2300      	movs	r3, #0
 80254a2:	716b      	strb	r3, [r5, #5]
}
 80254a4:	4648      	mov	r0, r9
 80254a6:	bcc0      	pop	{r6, r7}
 80254a8:	46b9      	mov	r9, r7
 80254aa:	46b0      	mov	r8, r6
 80254ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 80254ae:	0028      	movs	r0, r5
 80254b0:	f7ff feb4 	bl	802521c <SUBGHZ_WaitOnBusy>
 80254b4:	e7ee      	b.n	8025494 <HAL_SUBGHZ_ExecSetCmd+0x78>
    return HAL_BUSY;
 80254b6:	2302      	movs	r3, #2
 80254b8:	4699      	mov	r9, r3
 80254ba:	e7f3      	b.n	80254a4 <HAL_SUBGHZ_ExecSetCmd+0x88>
    __HAL_LOCK(hsubghz);
 80254bc:	2302      	movs	r3, #2
 80254be:	4699      	mov	r9, r3
 80254c0:	e7f0      	b.n	80254a4 <HAL_SUBGHZ_ExecSetCmd+0x88>
 80254c2:	46c0      	nop			; (mov r8, r8)
 80254c4:	58000400 	.word	0x58000400
 80254c8:	ffff7fff 	.word	0xffff7fff

080254cc <HAL_SUBGHZ_ExecGetCmd>:
{
 80254cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80254ce:	46c6      	mov	lr, r8
 80254d0:	b500      	push	{lr}
 80254d2:	0006      	movs	r6, r0
 80254d4:	000c      	movs	r4, r1
 80254d6:	0015      	movs	r5, r2
 80254d8:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80254da:	7983      	ldrb	r3, [r0, #6]
 80254dc:	b2da      	uxtb	r2, r3
 80254de:	4690      	mov	r8, r2
 80254e0:	2b01      	cmp	r3, #1
 80254e2:	d135      	bne.n	8025550 <HAL_SUBGHZ_ExecGetCmd+0x84>
    __HAL_LOCK(hsubghz);
 80254e4:	7943      	ldrb	r3, [r0, #5]
 80254e6:	2b01      	cmp	r3, #1
 80254e8:	d035      	beq.n	8025556 <HAL_SUBGHZ_ExecGetCmd+0x8a>
 80254ea:	2301      	movs	r3, #1
 80254ec:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80254ee:	f7ff fec5 	bl	802527c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80254f2:	491a      	ldr	r1, [pc, #104]	; (802555c <HAL_SUBGHZ_ExecGetCmd+0x90>)
 80254f4:	2290      	movs	r2, #144	; 0x90
 80254f6:	588b      	ldr	r3, [r1, r2]
 80254f8:	4819      	ldr	r0, [pc, #100]	; (8025560 <HAL_SUBGHZ_ExecGetCmd+0x94>)
 80254fa:	4003      	ands	r3, r0
 80254fc:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 80254fe:	0021      	movs	r1, r4
 8025500:	0030      	movs	r0, r6
 8025502:	f7ff fe0d 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 8025506:	2100      	movs	r1, #0
 8025508:	0030      	movs	r0, r6
 802550a:	f7ff fe09 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802550e:	2400      	movs	r4, #0
 8025510:	e006      	b.n	8025520 <HAL_SUBGHZ_ExecGetCmd+0x54>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8025512:	0029      	movs	r1, r5
 8025514:	0030      	movs	r0, r6
 8025516:	f7ff fe41 	bl	802519c <SUBGHZSPI_Receive>
      pData++;
 802551a:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802551c:	3401      	adds	r4, #1
 802551e:	b2a4      	uxth	r4, r4
 8025520:	42bc      	cmp	r4, r7
 8025522:	d3f6      	bcc.n	8025512 <HAL_SUBGHZ_ExecGetCmd+0x46>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025524:	490d      	ldr	r1, [pc, #52]	; (802555c <HAL_SUBGHZ_ExecGetCmd+0x90>)
 8025526:	2290      	movs	r2, #144	; 0x90
 8025528:	5888      	ldr	r0, [r1, r2]
 802552a:	2380      	movs	r3, #128	; 0x80
 802552c:	021b      	lsls	r3, r3, #8
 802552e:	4303      	orrs	r3, r0
 8025530:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8025532:	0030      	movs	r0, r6
 8025534:	f7ff fe72 	bl	802521c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8025538:	68b3      	ldr	r3, [r6, #8]
 802553a:	2b00      	cmp	r3, #0
 802553c:	d100      	bne.n	8025540 <HAL_SUBGHZ_ExecGetCmd+0x74>
      status = HAL_OK;
 802553e:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8025540:	2301      	movs	r3, #1
 8025542:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 8025544:	2300      	movs	r3, #0
 8025546:	7173      	strb	r3, [r6, #5]
}
 8025548:	4640      	mov	r0, r8
 802554a:	bc80      	pop	{r7}
 802554c:	46b8      	mov	r8, r7
 802554e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8025550:	2302      	movs	r3, #2
 8025552:	4698      	mov	r8, r3
 8025554:	e7f8      	b.n	8025548 <HAL_SUBGHZ_ExecGetCmd+0x7c>
    __HAL_LOCK(hsubghz);
 8025556:	2302      	movs	r3, #2
 8025558:	4698      	mov	r8, r3
 802555a:	e7f5      	b.n	8025548 <HAL_SUBGHZ_ExecGetCmd+0x7c>
 802555c:	58000400 	.word	0x58000400
 8025560:	ffff7fff 	.word	0xffff7fff

08025564 <HAL_SUBGHZ_IRQHandler>:
{
 8025564:	b570      	push	{r4, r5, r6, lr}
 8025566:	b082      	sub	sp, #8
 8025568:	0005      	movs	r5, r0
  uint8_t tmpisr[2] = {0};
 802556a:	ae01      	add	r6, sp, #4
 802556c:	2300      	movs	r3, #0
 802556e:	8033      	strh	r3, [r6, #0]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 8025570:	3302      	adds	r3, #2
 8025572:	0032      	movs	r2, r6
 8025574:	2112      	movs	r1, #18
 8025576:	f7ff ffa9 	bl	80254cc <HAL_SUBGHZ_ExecGetCmd>
  itsource = tmpisr[0];
 802557a:	7834      	ldrb	r4, [r6, #0]
  itsource = (itsource << 8) | tmpisr[1];
 802557c:	0224      	lsls	r4, r4, #8
 802557e:	7873      	ldrb	r3, [r6, #1]
 8025580:	431c      	orrs	r4, r3
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 8025582:	07db      	lsls	r3, r3, #31
 8025584:	d41d      	bmi.n	80255c2 <HAL_SUBGHZ_IRQHandler+0x5e>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 8025586:	07a3      	lsls	r3, r4, #30
 8025588:	d41f      	bmi.n	80255ca <HAL_SUBGHZ_IRQHandler+0x66>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 802558a:	0763      	lsls	r3, r4, #29
 802558c:	d421      	bmi.n	80255d2 <HAL_SUBGHZ_IRQHandler+0x6e>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 802558e:	0723      	lsls	r3, r4, #28
 8025590:	d423      	bmi.n	80255da <HAL_SUBGHZ_IRQHandler+0x76>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 8025592:	06e3      	lsls	r3, r4, #27
 8025594:	d425      	bmi.n	80255e2 <HAL_SUBGHZ_IRQHandler+0x7e>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 8025596:	06a3      	lsls	r3, r4, #26
 8025598:	d427      	bmi.n	80255ea <HAL_SUBGHZ_IRQHandler+0x86>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 802559a:	0663      	lsls	r3, r4, #25
 802559c:	d429      	bmi.n	80255f2 <HAL_SUBGHZ_IRQHandler+0x8e>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 802559e:	0623      	lsls	r3, r4, #24
 80255a0:	d505      	bpl.n	80255ae <HAL_SUBGHZ_IRQHandler+0x4a>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 80255a2:	05e3      	lsls	r3, r4, #23
 80255a4:	d529      	bpl.n	80255fa <HAL_SUBGHZ_IRQHandler+0x96>
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 80255a6:	2101      	movs	r1, #1
 80255a8:	0028      	movs	r0, r5
 80255aa:	f00e f8ff 	bl	80337ac <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 80255ae:	05a3      	lsls	r3, r4, #22
 80255b0:	d428      	bmi.n	8025604 <HAL_SUBGHZ_IRQHandler+0xa0>
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2);
 80255b2:	2302      	movs	r3, #2
 80255b4:	aa01      	add	r2, sp, #4
 80255b6:	2102      	movs	r1, #2
 80255b8:	0028      	movs	r0, r5
 80255ba:	f7ff ff2f 	bl	802541c <HAL_SUBGHZ_ExecSetCmd>
}
 80255be:	b002      	add	sp, #8
 80255c0:	bd70      	pop	{r4, r5, r6, pc}
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 80255c2:	0028      	movs	r0, r5
 80255c4:	f00e f8da 	bl	803377c <HAL_SUBGHZ_TxCpltCallback>
 80255c8:	e7dd      	b.n	8025586 <HAL_SUBGHZ_IRQHandler+0x22>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 80255ca:	0028      	movs	r0, r5
 80255cc:	f00e f8de 	bl	803378c <HAL_SUBGHZ_RxCpltCallback>
 80255d0:	e7db      	b.n	802558a <HAL_SUBGHZ_IRQHandler+0x26>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 80255d2:	0028      	movs	r0, r5
 80255d4:	f00e f910 	bl	80337f8 <HAL_SUBGHZ_PreambleDetectedCallback>
 80255d8:	e7d9      	b.n	802558e <HAL_SUBGHZ_IRQHandler+0x2a>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 80255da:	0028      	movs	r0, r5
 80255dc:	f00e f914 	bl	8033808 <HAL_SUBGHZ_SyncWordValidCallback>
 80255e0:	e7d7      	b.n	8025592 <HAL_SUBGHZ_IRQHandler+0x2e>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 80255e2:	0028      	movs	r0, r5
 80255e4:	f00e f918 	bl	8033818 <HAL_SUBGHZ_HeaderValidCallback>
 80255e8:	e7d5      	b.n	8025596 <HAL_SUBGHZ_IRQHandler+0x32>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 80255ea:	0028      	movs	r0, r5
 80255ec:	f00e f8fc 	bl	80337e8 <HAL_SUBGHZ_HeaderErrorCallback>
 80255f0:	e7d3      	b.n	802559a <HAL_SUBGHZ_IRQHandler+0x36>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 80255f2:	0028      	movs	r0, r5
 80255f4:	f00e f8d2 	bl	803379c <HAL_SUBGHZ_CRCErrorCallback>
 80255f8:	e7d1      	b.n	802559e <HAL_SUBGHZ_IRQHandler+0x3a>
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 80255fa:	2100      	movs	r1, #0
 80255fc:	0028      	movs	r0, r5
 80255fe:	f00e f8d5 	bl	80337ac <HAL_SUBGHZ_CADStatusCallback>
 8025602:	e7d4      	b.n	80255ae <HAL_SUBGHZ_IRQHandler+0x4a>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 8025604:	0028      	movs	r0, r5
 8025606:	f00e f8e5 	bl	80337d4 <HAL_SUBGHZ_RxTxTimeoutCallback>
 802560a:	e7d2      	b.n	80255b2 <HAL_SUBGHZ_IRQHandler+0x4e>

0802560c <HAL_SUBGHZ_WriteBuffer>:
{
 802560c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802560e:	46c6      	mov	lr, r8
 8025610:	b500      	push	{lr}
 8025612:	0005      	movs	r5, r0
 8025614:	000c      	movs	r4, r1
 8025616:	0017      	movs	r7, r2
 8025618:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802561a:	7983      	ldrb	r3, [r0, #6]
 802561c:	b2da      	uxtb	r2, r3
 802561e:	4690      	mov	r8, r2
 8025620:	2b01      	cmp	r3, #1
 8025622:	d134      	bne.n	802568e <HAL_SUBGHZ_WriteBuffer+0x82>
    __HAL_LOCK(hsubghz);
 8025624:	7943      	ldrb	r3, [r0, #5]
 8025626:	2b01      	cmp	r3, #1
 8025628:	d034      	beq.n	8025694 <HAL_SUBGHZ_WriteBuffer+0x88>
 802562a:	2301      	movs	r3, #1
 802562c:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802562e:	f7ff fe25 	bl	802527c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025632:	491a      	ldr	r1, [pc, #104]	; (802569c <HAL_SUBGHZ_WriteBuffer+0x90>)
 8025634:	2290      	movs	r2, #144	; 0x90
 8025636:	588b      	ldr	r3, [r1, r2]
 8025638:	4819      	ldr	r0, [pc, #100]	; (80256a0 <HAL_SUBGHZ_WriteBuffer+0x94>)
 802563a:	4003      	ands	r3, r0
 802563c:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 802563e:	210e      	movs	r1, #14
 8025640:	0028      	movs	r0, r5
 8025642:	f7ff fd6d 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 8025646:	0021      	movs	r1, r4
 8025648:	0028      	movs	r0, r5
 802564a:	f7ff fd69 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802564e:	2400      	movs	r4, #0
 8025650:	e005      	b.n	802565e <HAL_SUBGHZ_WriteBuffer+0x52>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8025652:	5d39      	ldrb	r1, [r7, r4]
 8025654:	0028      	movs	r0, r5
 8025656:	f7ff fd63 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802565a:	3401      	adds	r4, #1
 802565c:	b2a4      	uxth	r4, r4
 802565e:	42b4      	cmp	r4, r6
 8025660:	d3f7      	bcc.n	8025652 <HAL_SUBGHZ_WriteBuffer+0x46>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025662:	490e      	ldr	r1, [pc, #56]	; (802569c <HAL_SUBGHZ_WriteBuffer+0x90>)
 8025664:	2290      	movs	r2, #144	; 0x90
 8025666:	5888      	ldr	r0, [r1, r2]
 8025668:	2380      	movs	r3, #128	; 0x80
 802566a:	021b      	lsls	r3, r3, #8
 802566c:	4303      	orrs	r3, r0
 802566e:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8025670:	0028      	movs	r0, r5
 8025672:	f7ff fdd3 	bl	802521c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8025676:	68ab      	ldr	r3, [r5, #8]
 8025678:	2b00      	cmp	r3, #0
 802567a:	d100      	bne.n	802567e <HAL_SUBGHZ_WriteBuffer+0x72>
      status = HAL_OK;
 802567c:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802567e:	2301      	movs	r3, #1
 8025680:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8025682:	2300      	movs	r3, #0
 8025684:	716b      	strb	r3, [r5, #5]
}
 8025686:	4640      	mov	r0, r8
 8025688:	bc80      	pop	{r7}
 802568a:	46b8      	mov	r8, r7
 802568c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 802568e:	2302      	movs	r3, #2
 8025690:	4698      	mov	r8, r3
 8025692:	e7f8      	b.n	8025686 <HAL_SUBGHZ_WriteBuffer+0x7a>
    __HAL_LOCK(hsubghz);
 8025694:	2302      	movs	r3, #2
 8025696:	4698      	mov	r8, r3
 8025698:	e7f5      	b.n	8025686 <HAL_SUBGHZ_WriteBuffer+0x7a>
 802569a:	46c0      	nop			; (mov r8, r8)
 802569c:	58000400 	.word	0x58000400
 80256a0:	ffff7fff 	.word	0xffff7fff

080256a4 <HAL_SUBGHZ_ReadBuffer>:
{
 80256a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80256a6:	46c6      	mov	lr, r8
 80256a8:	b500      	push	{lr}
 80256aa:	0006      	movs	r6, r0
 80256ac:	000c      	movs	r4, r1
 80256ae:	0015      	movs	r5, r2
 80256b0:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80256b2:	7983      	ldrb	r3, [r0, #6]
 80256b4:	b2da      	uxtb	r2, r3
 80256b6:	4690      	mov	r8, r2
 80256b8:	2b01      	cmp	r3, #1
 80256ba:	d139      	bne.n	8025730 <HAL_SUBGHZ_ReadBuffer+0x8c>
    __HAL_LOCK(hsubghz);
 80256bc:	7943      	ldrb	r3, [r0, #5]
 80256be:	2b01      	cmp	r3, #1
 80256c0:	d039      	beq.n	8025736 <HAL_SUBGHZ_ReadBuffer+0x92>
 80256c2:	2301      	movs	r3, #1
 80256c4:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80256c6:	f7ff fdd9 	bl	802527c <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80256ca:	491c      	ldr	r1, [pc, #112]	; (802573c <HAL_SUBGHZ_ReadBuffer+0x98>)
 80256cc:	2290      	movs	r2, #144	; 0x90
 80256ce:	588b      	ldr	r3, [r1, r2]
 80256d0:	481b      	ldr	r0, [pc, #108]	; (8025740 <HAL_SUBGHZ_ReadBuffer+0x9c>)
 80256d2:	4003      	ands	r3, r0
 80256d4:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 80256d6:	211e      	movs	r1, #30
 80256d8:	0030      	movs	r0, r6
 80256da:	f7ff fd21 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 80256de:	0021      	movs	r1, r4
 80256e0:	0030      	movs	r0, r6
 80256e2:	f7ff fd1d 	bl	8025120 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 80256e6:	2100      	movs	r1, #0
 80256e8:	0030      	movs	r0, r6
 80256ea:	f7ff fd19 	bl	8025120 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80256ee:	2400      	movs	r4, #0
 80256f0:	e006      	b.n	8025700 <HAL_SUBGHZ_ReadBuffer+0x5c>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 80256f2:	0029      	movs	r1, r5
 80256f4:	0030      	movs	r0, r6
 80256f6:	f7ff fd51 	bl	802519c <SUBGHZSPI_Receive>
      pData++;
 80256fa:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 80256fc:	3401      	adds	r4, #1
 80256fe:	b2a4      	uxth	r4, r4
 8025700:	42bc      	cmp	r4, r7
 8025702:	d3f6      	bcc.n	80256f2 <HAL_SUBGHZ_ReadBuffer+0x4e>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025704:	490d      	ldr	r1, [pc, #52]	; (802573c <HAL_SUBGHZ_ReadBuffer+0x98>)
 8025706:	2290      	movs	r2, #144	; 0x90
 8025708:	5888      	ldr	r0, [r1, r2]
 802570a:	2380      	movs	r3, #128	; 0x80
 802570c:	021b      	lsls	r3, r3, #8
 802570e:	4303      	orrs	r3, r0
 8025710:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8025712:	0030      	movs	r0, r6
 8025714:	f7ff fd82 	bl	802521c <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8025718:	68b3      	ldr	r3, [r6, #8]
 802571a:	2b00      	cmp	r3, #0
 802571c:	d100      	bne.n	8025720 <HAL_SUBGHZ_ReadBuffer+0x7c>
      status = HAL_OK;
 802571e:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8025720:	2301      	movs	r3, #1
 8025722:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 8025724:	2300      	movs	r3, #0
 8025726:	7173      	strb	r3, [r6, #5]
}
 8025728:	4640      	mov	r0, r8
 802572a:	bc80      	pop	{r7}
 802572c:	46b8      	mov	r8, r7
 802572e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8025730:	2302      	movs	r3, #2
 8025732:	4698      	mov	r8, r3
 8025734:	e7f8      	b.n	8025728 <HAL_SUBGHZ_ReadBuffer+0x84>
    __HAL_LOCK(hsubghz);
 8025736:	2302      	movs	r3, #2
 8025738:	4698      	mov	r8, r3
 802573a:	e7f5      	b.n	8025728 <HAL_SUBGHZ_ReadBuffer+0x84>
 802573c:	58000400 	.word	0x58000400
 8025740:	ffff7fff 	.word	0xffff7fff

08025744 <load_block>:
  * @retval  None
  */
static void load_block(const uint8_t *input_start,
                       uint32_t num_els,
                       uint32_t *load_buffer)
{
 8025744:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025746:	46ce      	mov	lr, r9
 8025748:	4647      	mov	r7, r8
 802574a:	b580      	push	{r7, lr}
 802574c:	468c      	mov	ip, r1
  uint32_t i;
  uint32_t j;
  uint32_t full_words = num_els / 4u;
 802574e:	088d      	lsrs	r5, r1, #2

  uint32_t remaining_bytes = num_els % 4u;
 8025750:	2603      	movs	r6, #3
 8025752:	400e      	ands	r6, r1
 8025754:	46b1      	mov	r9, r6
  uint32_t temp_word;

  /* Convert any 4 bytes in one 32 bits word */
  for (i = 0; i < full_words; i++)
 8025756:	2400      	movs	r4, #0
 8025758:	42ac      	cmp	r4, r5
 802575a:	d20e      	bcs.n	802577a <load_block+0x36>
  {
    load_buffer[i] = BYTES_TO_WORD(input_start, 4u * i);
 802575c:	00a7      	lsls	r7, r4, #2
 802575e:	5dc3      	ldrb	r3, [r0, r7]
 8025760:	061b      	lsls	r3, r3, #24
 8025762:	19c1      	adds	r1, r0, r7
 8025764:	784e      	ldrb	r6, [r1, #1]
 8025766:	0436      	lsls	r6, r6, #16
 8025768:	4333      	orrs	r3, r6
 802576a:	788e      	ldrb	r6, [r1, #2]
 802576c:	0236      	lsls	r6, r6, #8
 802576e:	4333      	orrs	r3, r6
 8025770:	78c9      	ldrb	r1, [r1, #3]
 8025772:	430b      	orrs	r3, r1
 8025774:	51d3      	str	r3, [r2, r7]
  for (i = 0; i < full_words; i++)
 8025776:	3401      	adds	r4, #1
 8025778:	e7ee      	b.n	8025758 <load_block+0x14>
  }

  /* If the block is not multiple of 16 bytes, pad the buffer */
  if ((num_els == 0u) || (full_words < 4u))
 802577a:	4663      	mov	r3, ip
 802577c:	2b00      	cmp	r3, #0
 802577e:	d001      	beq.n	8025784 <load_block+0x40>
 8025780:	2b0f      	cmp	r3, #15
 8025782:	d823      	bhi.n	80257cc <load_block+0x88>
  {
    /* last block: 0x [remaining data] 80 00 00 .. 00 */
    temp_word = 0x80u;

    /* Insert the 0x80 byte in the correct position */
    load_buffer[full_words] = temp_word << (24u - (8u * remaining_bytes));
 8025784:	2303      	movs	r3, #3
 8025786:	4649      	mov	r1, r9
 8025788:	1a5c      	subs	r4, r3, r1
 802578a:	00e4      	lsls	r4, r4, #3
 802578c:	4661      	mov	r1, ip
 802578e:	4399      	bics	r1, r3
 8025790:	468c      	mov	ip, r1
 8025792:	1851      	adds	r1, r2, r1
 8025794:	2380      	movs	r3, #128	; 0x80
 8025796:	40a3      	lsls	r3, r4
 8025798:	600b      	str	r3, [r1, #0]

    /* Include the remaining bytes of data */
    for (j = 0u; j < remaining_bytes; j++)
 802579a:	2400      	movs	r4, #0
 802579c:	454c      	cmp	r4, r9
 802579e:	d20c      	bcs.n	80257ba <load_block+0x76>
    {
      load_buffer[full_words]
      |= (uint32_t)(input_start[(4u * full_words) + j]) << (24u - (8u * j));
 80257a0:	4663      	mov	r3, ip
 80257a2:	191b      	adds	r3, r3, r4
 80257a4:	5cc7      	ldrb	r7, [r0, r3]
 80257a6:	2303      	movs	r3, #3
 80257a8:	1b1b      	subs	r3, r3, r4
 80257aa:	00db      	lsls	r3, r3, #3
 80257ac:	409f      	lsls	r7, r3
 80257ae:	003b      	movs	r3, r7
 80257b0:	680e      	ldr	r6, [r1, #0]
 80257b2:	4333      	orrs	r3, r6
 80257b4:	600b      	str	r3, [r1, #0]
    for (j = 0u; j < remaining_bytes; j++)
 80257b6:	3401      	adds	r4, #1
 80257b8:	e7f0      	b.n	802579c <load_block+0x58>
    }

    /* Fill the rest of the block with zeros */
    for (i = full_words + 1u; i < 4u; i++)
 80257ba:	3501      	adds	r5, #1
 80257bc:	e004      	b.n	80257c8 <load_block+0x84>
    {
      load_buffer[i] = 0u;
 80257be:	00ab      	lsls	r3, r5, #2
 80257c0:	18d3      	adds	r3, r2, r3
 80257c2:	2100      	movs	r1, #0
 80257c4:	6019      	str	r1, [r3, #0]
    for (i = full_words + 1u; i < 4u; i++)
 80257c6:	3501      	adds	r5, #1
 80257c8:	2d03      	cmp	r5, #3
 80257ca:	d9f8      	bls.n	80257be <load_block+0x7a>
    }
  }
}
 80257cc:	bcc0      	pop	{r6, r7}
 80257ce:	46b9      	mov	r9, r7
 80257d0:	46b0      	mov	r8, r6
 80257d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080257d4 <derive_subkey2>:
  * @param   output_buffer Buffer that will contain the computed K2 subkey
  *
  * @retval  None
  */
static void derive_subkey2(const uint32_t *sub_key1, uint32_t *output_buffer)
{
 80257d4:	b510      	push	{r4, lr}
  uint32_t carry = ((sub_key1[0] >> 31) & 1u) * 0x00000087u;
 80257d6:	6803      	ldr	r3, [r0, #0]
 80257d8:	0fdc      	lsrs	r4, r3, #31
 80257da:	00e2      	lsls	r2, r4, #3
 80257dc:	1912      	adds	r2, r2, r4
 80257de:	0114      	lsls	r4, r2, #4
 80257e0:	1aa4      	subs	r4, r4, r2

  output_buffer[0] = ((sub_key1[0] << 1) | (sub_key1[1] >> 31));
 80257e2:	005b      	lsls	r3, r3, #1
 80257e4:	6842      	ldr	r2, [r0, #4]
 80257e6:	0fd2      	lsrs	r2, r2, #31
 80257e8:	4313      	orrs	r3, r2
 80257ea:	600b      	str	r3, [r1, #0]
  output_buffer[1] = ((sub_key1[1] << 1) | (sub_key1[2] >> 31));
 80257ec:	6843      	ldr	r3, [r0, #4]
 80257ee:	005a      	lsls	r2, r3, #1
 80257f0:	6883      	ldr	r3, [r0, #8]
 80257f2:	0fdb      	lsrs	r3, r3, #31
 80257f4:	431a      	orrs	r2, r3
 80257f6:	604a      	str	r2, [r1, #4]
  output_buffer[2] = ((sub_key1[2] << 1) | (sub_key1[3] >> 31));
 80257f8:	6883      	ldr	r3, [r0, #8]
 80257fa:	005a      	lsls	r2, r3, #1
 80257fc:	68c3      	ldr	r3, [r0, #12]
 80257fe:	0fdb      	lsrs	r3, r3, #31
 8025800:	431a      	orrs	r2, r3
 8025802:	608a      	str	r2, [r1, #8]
  output_buffer[3] = (sub_key1[3] << 1) ^ carry;
 8025804:	68c3      	ldr	r3, [r0, #12]
 8025806:	005b      	lsls	r3, r3, #1
 8025808:	4063      	eors	r3, r4
 802580a:	60cb      	str	r3, [r1, #12]

}
 802580c:	bd10      	pop	{r4, pc}

0802580e <xor_key>:
  * @param   key Buffer containing the key
  *
  * @retval  None
  */
static void xor_key(uint32_t *block, const uint32_t *key)
{
 802580e:	b530      	push	{r4, r5, lr}
  uint32_t i;

  for (i = 0u; i < 4u; i++)
 8025810:	2300      	movs	r3, #0
 8025812:	e006      	b.n	8025822 <xor_key+0x14>
  {
    block[i] ^= key[i];
 8025814:	009a      	lsls	r2, r3, #2
 8025816:	1884      	adds	r4, r0, r2
 8025818:	588a      	ldr	r2, [r1, r2]
 802581a:	6825      	ldr	r5, [r4, #0]
 802581c:	406a      	eors	r2, r5
 802581e:	6022      	str	r2, [r4, #0]
  for (i = 0u; i < 4u; i++)
 8025820:	3301      	adds	r3, #1
 8025822:	2b03      	cmp	r3, #3
 8025824:	d9f6      	bls.n	8025814 <xor_key+0x6>
  }
}
 8025826:	bd30      	pop	{r4, r5, pc}

08025828 <cleanup_handle>:
/* Private function prototypes -----------------------------------------------*/
static void cleanup_handle(CRYP_HandleTypeDef *CrypHandle);

/* Private function definitions -----------------------------------------------*/
static void cleanup_handle(CRYP_HandleTypeDef *CrypHandle)
{
 8025828:	b510      	push	{r4, lr}
  (void)memset(CrypHandle, 0, sizeof(CRYP_HandleTypeDef));
 802582a:	2286      	movs	r2, #134	; 0x86
 802582c:	0052      	lsls	r2, r2, #1
 802582e:	2100      	movs	r1, #0
 8025830:	f00e ff79 	bl	8034726 <memset>
}
 8025834:	bd10      	pop	{r4, pc}

08025836 <AES_Encrypt>:
{
 8025836:	b500      	push	{lr}
 8025838:	b083      	sub	sp, #12
  hcryp->Init.pKey = key;
 802583a:	60c3      	str	r3, [r0, #12]
  hcryp->Init.pInitVect = iv;
 802583c:	9b04      	ldr	r3, [sp, #16]
 802583e:	6103      	str	r3, [r0, #16]
  periph_retval = HAL_CRYP_Encrypt(hcryp, input, (uint16_t)inputSize,
 8025840:	b292      	uxth	r2, r2
 8025842:	23ff      	movs	r3, #255	; 0xff
 8025844:	9300      	str	r3, [sp, #0]
 8025846:	9b05      	ldr	r3, [sp, #20]
 8025848:	f7fe f9c0 	bl	8023bcc <HAL_CRYP_Encrypt>
  if (periph_retval != HAL_OK)
 802584c:	2800      	cmp	r0, #0
 802584e:	d101      	bne.n	8025854 <AES_Encrypt+0x1e>
}
 8025850:	b003      	add	sp, #12
 8025852:	bd00      	pop	{pc}
    retval = MAC_ERROR_HW_FAILURE;
 8025854:	2004      	movs	r0, #4
 8025856:	e7fb      	b.n	8025850 <AES_Encrypt+0x1a>

08025858 <derive_subkey1>:
{
 8025858:	b530      	push	{r4, r5, lr}
 802585a:	b083      	sub	sp, #12
 802585c:	000b      	movs	r3, r1
 802585e:	0014      	movs	r4, r2
  retval = AES_Encrypt(hcryp, output_buffer, 4u,
 8025860:	9201      	str	r2, [sp, #4]
 8025862:	9200      	str	r2, [sp, #0]
 8025864:	2204      	movs	r2, #4
 8025866:	0021      	movs	r1, r4
 8025868:	f7ff ffe5 	bl	8025836 <AES_Encrypt>
 802586c:	1e05      	subs	r5, r0, #0
  if (retval == MAC_SUCCESS)
 802586e:	d002      	beq.n	8025876 <derive_subkey1+0x1e>
}
 8025870:	0028      	movs	r0, r5
 8025872:	b003      	add	sp, #12
 8025874:	bd30      	pop	{r4, r5, pc}
    derive_subkey2(output_buffer, output_buffer);
 8025876:	0021      	movs	r1, r4
 8025878:	0020      	movs	r0, r4
 802587a:	f7ff ffab 	bl	80257d4 <derive_subkey2>
 802587e:	e7f7      	b.n	8025870 <derive_subkey1+0x18>

08025880 <CMAC_compute>:
                         uint32_t inputDataLength,
                         const uint8_t *key,
                         uint32_t keySize,
                         uint32_t macSize,
                         uint8_t *macBuff)
{
 8025880:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025882:	46de      	mov	lr, fp
 8025884:	4657      	mov	r7, sl
 8025886:	464e      	mov	r6, r9
 8025888:	4645      	mov	r5, r8
 802588a:	b5e0      	push	{r5, r6, r7, lr}
 802588c:	4c87      	ldr	r4, [pc, #540]	; (8025aac <CMAC_compute+0x22c>)
 802588e:	44a5      	add	sp, r4
 8025890:	0005      	movs	r5, r0
 8025892:	9103      	str	r1, [sp, #12]
 8025894:	0014      	movs	r4, r2
 8025896:	001e      	movs	r6, r3
  mac_error_t retval;

  /* Internal variables, buffers */
  uint32_t temp_iv[4] = {0,};
 8025898:	2210      	movs	r2, #16
 802589a:	2100      	movs	r1, #0
 802589c:	a89a      	add	r0, sp, #616	; 0x268
 802589e:	f00e ff42 	bl	8034726 <memset>
  uint32_t temp_key[8] = {0,};
 80258a2:	2220      	movs	r2, #32
 80258a4:	2100      	movs	r1, #0
 80258a6:	a892      	add	r0, sp, #584	; 0x248
 80258a8:	f00e ff3d 	bl	8034726 <memset>
  uint32_t temp_buffer[4u * MAX_PROCESSED_BLOCKS];

  uint32_t k1[4] = {0,};
 80258ac:	2210      	movs	r2, #16
 80258ae:	2100      	movs	r1, #0
 80258b0:	a84e      	add	r0, sp, #312	; 0x138
 80258b2:	f00e ff38 	bl	8034726 <memset>
  uint32_t k2[4] = {0,};
 80258b6:	2210      	movs	r2, #16
 80258b8:	2100      	movs	r1, #0
 80258ba:	a84a      	add	r0, sp, #296	; 0x128
 80258bc:	f00e ff33 	bl	8034726 <memset>

  CRYP_HandleTypeDef hcryp;
  HAL_StatusTypeDef periph_retval;

  /* Check that pointers to buffers are not null */
  if ((key == NULL) || (macBuff == NULL))
 80258c0:	2c00      	cmp	r4, #0
 80258c2:	d100      	bne.n	80258c6 <CMAC_compute+0x46>
 80258c4:	e0d4      	b.n	8025a70 <CMAC_compute+0x1f0>
 80258c6:	9ba9      	ldr	r3, [sp, #676]	; 0x2a4
 80258c8:	2b00      	cmp	r3, #0
 80258ca:	d100      	bne.n	80258ce <CMAC_compute+0x4e>
 80258cc:	e0dc      	b.n	8025a88 <CMAC_compute+0x208>
  {
    return MAC_ERROR_BAD_PARAMETER;
  }

  /* Plaintext buffer can be null only when there is no data to authenticate */
  if ((inputData == NULL) && (inputDataLength > 0u))
 80258ce:	2d00      	cmp	r5, #0
 80258d0:	d013      	beq.n	80258fa <CMAC_compute+0x7a>
  {
    return MAC_ERROR_BAD_PARAMETER;
  }

  /* check that the requested mac size is less or equal than the block size */
  if (macSize > AES_BLOCK_SIZE)
 80258d2:	9ba8      	ldr	r3, [sp, #672]	; 0x2a0
 80258d4:	2b10      	cmp	r3, #16
 80258d6:	d900      	bls.n	80258da <CMAC_compute+0x5a>
 80258d8:	e0d9      	b.n	8025a8e <CMAC_compute+0x20e>
  {
    return MAC_ERROR_WRONG_MAC_SIZE;
  }
  /* check that the requested mac size is greater than 0 */
  if (macSize == 0u)
 80258da:	2b00      	cmp	r3, #0
 80258dc:	d100      	bne.n	80258e0 <CMAC_compute+0x60>
 80258de:	e0d9      	b.n	8025a94 <CMAC_compute+0x214>
  {
    return MAC_ERROR_WRONG_MAC_SIZE;
  }

  /* Initialize the AES peripheral */
  (void)memset((uint8_t *)&hcryp, 0, sizeof(CRYP_HandleTypeDef));
 80258e0:	2286      	movs	r2, #134	; 0x86
 80258e2:	0052      	lsls	r2, r2, #1
 80258e4:	2100      	movs	r1, #0
 80258e6:	a807      	add	r0, sp, #28
 80258e8:	f00e ff1d 	bl	8034726 <memset>

  /* check that the provided key size is acceptable */
  switch (keySize)
 80258ec:	2e10      	cmp	r6, #16
 80258ee:	d00a      	beq.n	8025906 <CMAC_compute+0x86>
 80258f0:	2e20      	cmp	r6, #32
 80258f2:	d038      	beq.n	8025966 <CMAC_compute+0xe6>
 80258f4:	2303      	movs	r3, #3
 80258f6:	4698      	mov	r8, r3
 80258f8:	e0bc      	b.n	8025a74 <CMAC_compute+0x1f4>
  if ((inputData == NULL) && (inputDataLength > 0u))
 80258fa:	9b03      	ldr	r3, [sp, #12]
 80258fc:	2b00      	cmp	r3, #0
 80258fe:	d0e8      	beq.n	80258d2 <CMAC_compute+0x52>
    return MAC_ERROR_BAD_PARAMETER;
 8025900:	2301      	movs	r3, #1
 8025902:	4698      	mov	r8, r3
 8025904:	e0b6      	b.n	8025a74 <CMAC_compute+0x1f4>
  {
    case AES128_KEY:
      hcryp.Init.KeySize = CRYP_KEYSIZE_128B;
 8025906:	2300      	movs	r3, #0
 8025908:	9309      	str	r3, [sp, #36]	; 0x24
      return MAC_ERROR_UNSUPPORTED_KEY_SIZE;
      break;
  }

  /* Complete the configuration of the AES peripheral */
  hcryp.Instance = CA_AES_INSTANCE;
 802590a:	4b69      	ldr	r3, [pc, #420]	; (8025ab0 <CMAC_compute+0x230>)
 802590c:	9307      	str	r3, [sp, #28]
  hcryp.Init.DataType = CRYP_DATATYPE_32B;
 802590e:	2300      	movs	r3, #0
 8025910:	9308      	str	r3, [sp, #32]
  hcryp.Init.Algorithm = CRYP_AES_CBC;
 8025912:	2220      	movs	r2, #32
 8025914:	920c      	str	r2, [sp, #48]	; 0x30
  hcryp.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_WORD;
 8025916:	9310      	str	r3, [sp, #64]	; 0x40

  /* Initialize the CRYP peripheral */
  periph_retval = HAL_CRYP_Init(&hcryp);
 8025918:	a807      	add	r0, sp, #28
 802591a:	f7fd fdc1 	bl	80234a0 <HAL_CRYP_Init>
  if (periph_retval != HAL_OK)
 802591e:	2800      	cmp	r0, #0
 8025920:	d000      	beq.n	8025924 <CMAC_compute+0xa4>
 8025922:	e0ba      	b.n	8025a9a <CMAC_compute+0x21a>
  {
    return MAC_ERROR_HW_FAILURE;
  }

  /* Generate the subkeys K1 and K2 */
  load_block(key, keySize, temp_key);
 8025924:	aa92      	add	r2, sp, #584	; 0x248
 8025926:	0031      	movs	r1, r6
 8025928:	0020      	movs	r0, r4
 802592a:	f7ff ff0b 	bl	8025744 <load_block>
  retval = derive_subkey1(&hcryp, temp_key, k1);
 802592e:	aa4e      	add	r2, sp, #312	; 0x138
 8025930:	a992      	add	r1, sp, #584	; 0x248
 8025932:	a807      	add	r0, sp, #28
 8025934:	f7ff ff90 	bl	8025858 <derive_subkey1>
 8025938:	4680      	mov	r8, r0
  if (retval != MAC_SUCCESS)
 802593a:	2800      	cmp	r0, #0
 802593c:	d000      	beq.n	8025940 <CMAC_compute+0xc0>
 802593e:	e099      	b.n	8025a74 <CMAC_compute+0x1f4>
  {
    return retval;
  }
  derive_subkey2(k1, k2);
 8025940:	a94a      	add	r1, sp, #296	; 0x128
 8025942:	a84e      	add	r0, sp, #312	; 0x138
 8025944:	f7ff ff46 	bl	80257d4 <derive_subkey2>

  /* get the number of AES blocks included into the input */
  num_blocks = inputDataLength / AES_BLOCK_SIZE;
 8025948:	9a03      	ldr	r2, [sp, #12]
 802594a:	0913      	lsrs	r3, r2, #4
  remaining_bytes = inputDataLength % AES_BLOCK_SIZE;
  if (remaining_bytes > 0u)
 802594c:	0712      	lsls	r2, r2, #28
 802594e:	d000      	beq.n	8025952 <CMAC_compute+0xd2>
  {
    num_blocks++;
 8025950:	3301      	adds	r3, #1
  }

  /* Transform the number of blocks in number of bytes */
  num_blocks *= AES_BLOCK_SIZE;
 8025952:	011b      	lsls	r3, r3, #4
 8025954:	9304      	str	r3, [sp, #16]
  uint32_t encrypt = 0u;
 8025956:	2300      	movs	r3, #0
  uint32_t processed_block = 0u;
 8025958:	2400      	movs	r4, #0

  i = 0u;
 802595a:	2600      	movs	r6, #0
 802595c:	469a      	mov	sl, r3
 802595e:	4643      	mov	r3, r8
 8025960:	9305      	str	r3, [sp, #20]
 8025962:	46ab      	mov	fp, r5
 8025964:	e014      	b.n	8025990 <CMAC_compute+0x110>
      hcryp.Init.KeySize = CRYP_KEYSIZE_256B;
 8025966:	2380      	movs	r3, #128	; 0x80
 8025968:	02db      	lsls	r3, r3, #11
 802596a:	9309      	str	r3, [sp, #36]	; 0x24
      break;
 802596c:	e7cd      	b.n	802590a <CMAC_compute+0x8a>
      block_size = inputDataLength - i;
      encrypt = 1u;
    }
    else
    {
      block_size = AES_BLOCK_SIZE;
 802596e:	2310      	movs	r3, #16
 8025970:	4698      	mov	r8, r3
 8025972:	e014      	b.n	802599e <CMAC_compute+0x11e>
    load_block(&inputData[i], block_size, &temp_buffer[processed_block * 4u]);

    /* If needed, include the subkey into the block of data to process */
    if (block_size < AES_BLOCK_SIZE)
    {
      xor_key(&temp_buffer[processed_block * 4u], k2);
 8025974:	a94a      	add	r1, sp, #296	; 0x128
 8025976:	0038      	movs	r0, r7
 8025978:	f7ff ff49 	bl	802580e <xor_key>
    {
      /* do nothing */
    }

    /* If the buffer is full, let's encrypt it */
    if (processed_block == (MAX_PROCESSED_BLOCKS - 1u))
 802597c:	2c0f      	cmp	r4, #15
 802597e:	d026      	beq.n	80259ce <CMAC_compute+0x14e>
    else
    {
      /* do nothing */
    }

    if (encrypt == 0u)
 8025980:	4653      	mov	r3, sl
 8025982:	2b00      	cmp	r3, #0
 8025984:	d123      	bne.n	80259ce <CMAC_compute+0x14e>
    {
      processed_block++;
 8025986:	3401      	adds	r4, #1
      encrypt = 0u;
      processed_block = 0u;
    }

    /* Ready for the next iteration */
    i += AES_BLOCK_SIZE;
 8025988:	3610      	adds	r6, #16

  } while (i < num_blocks);
 802598a:	9b04      	ldr	r3, [sp, #16]
 802598c:	42b3      	cmp	r3, r6
 802598e:	d93b      	bls.n	8025a08 <CMAC_compute+0x188>
    if ((inputDataLength - i) < AES_BLOCK_SIZE)
 8025990:	9b03      	ldr	r3, [sp, #12]
 8025992:	1b9d      	subs	r5, r3, r6
 8025994:	2d0f      	cmp	r5, #15
 8025996:	d8ea      	bhi.n	802596e <CMAC_compute+0xee>
      block_size = inputDataLength - i;
 8025998:	46a8      	mov	r8, r5
      encrypt = 1u;
 802599a:	2301      	movs	r3, #1
 802599c:	469a      	mov	sl, r3
    load_block(&inputData[i], block_size, &temp_buffer[processed_block * 4u]);
 802599e:	00a3      	lsls	r3, r4, #2
 80259a0:	4699      	mov	r9, r3
 80259a2:	0127      	lsls	r7, r4, #4
 80259a4:	ab52      	add	r3, sp, #328	; 0x148
 80259a6:	469c      	mov	ip, r3
 80259a8:	4467      	add	r7, ip
 80259aa:	465b      	mov	r3, fp
 80259ac:	1998      	adds	r0, r3, r6
 80259ae:	003a      	movs	r2, r7
 80259b0:	4641      	mov	r1, r8
 80259b2:	f7ff fec7 	bl	8025744 <load_block>
    if (block_size < AES_BLOCK_SIZE)
 80259b6:	4643      	mov	r3, r8
 80259b8:	2b0f      	cmp	r3, #15
 80259ba:	d9db      	bls.n	8025974 <CMAC_compute+0xf4>
    else if ((inputDataLength - i) == AES_BLOCK_SIZE)
 80259bc:	2d10      	cmp	r5, #16
 80259be:	d1dd      	bne.n	802597c <CMAC_compute+0xfc>
      xor_key(&temp_buffer[processed_block * 4u], k1);
 80259c0:	a94e      	add	r1, sp, #312	; 0x138
 80259c2:	0038      	movs	r0, r7
 80259c4:	f7ff ff23 	bl	802580e <xor_key>
      encrypt = 1u;
 80259c8:	2301      	movs	r3, #1
 80259ca:	469a      	mov	sl, r3
 80259cc:	e7d6      	b.n	802597c <CMAC_compute+0xfc>
      retval = AES_Encrypt(&hcryp, temp_buffer, 4u * (processed_block + 1u),
 80259ce:	1c62      	adds	r2, r4, #1
 80259d0:	0092      	lsls	r2, r2, #2
 80259d2:	a952      	add	r1, sp, #328	; 0x148
 80259d4:	9101      	str	r1, [sp, #4]
 80259d6:	ab9a      	add	r3, sp, #616	; 0x268
 80259d8:	9300      	str	r3, [sp, #0]
 80259da:	ab92      	add	r3, sp, #584	; 0x248
 80259dc:	a807      	add	r0, sp, #28
 80259de:	f7ff ff2a 	bl	8025836 <AES_Encrypt>
 80259e2:	1e03      	subs	r3, r0, #0
 80259e4:	9005      	str	r0, [sp, #20]
      if (retval != MAC_SUCCESS)
 80259e6:	d15e      	bne.n	8025aa6 <CMAC_compute+0x226>
 80259e8:	464c      	mov	r4, r9
 80259ea:	e007      	b.n	80259fc <CMAC_compute+0x17c>
        temp_iv[j] = temp_buffer[(processed_block * 4u) + j];
 80259ec:	18e2      	adds	r2, r4, r3
 80259ee:	0092      	lsls	r2, r2, #2
 80259f0:	a952      	add	r1, sp, #328	; 0x148
 80259f2:	5850      	ldr	r0, [r2, r1]
 80259f4:	0099      	lsls	r1, r3, #2
 80259f6:	aa9a      	add	r2, sp, #616	; 0x268
 80259f8:	5088      	str	r0, [r1, r2]
      for (j = 0; j < 4u; j++)
 80259fa:	3301      	adds	r3, #1
 80259fc:	2b03      	cmp	r3, #3
 80259fe:	d9f5      	bls.n	80259ec <CMAC_compute+0x16c>
      encrypt = 0u;
 8025a00:	2300      	movs	r3, #0
 8025a02:	469a      	mov	sl, r3
      processed_block = 0u;
 8025a04:	2400      	movs	r4, #0
 8025a06:	e7bf      	b.n	8025988 <CMAC_compute+0x108>
 8025a08:	9b05      	ldr	r3, [sp, #20]
 8025a0a:	4698      	mov	r8, r3

  /* The CRYP peripheral isno more needed. Let's deinit it */
  periph_retval = HAL_CRYP_DeInit(&hcryp);
 8025a0c:	a807      	add	r0, sp, #28
 8025a0e:	f7fd fd6d 	bl	80234ec <HAL_CRYP_DeInit>
  if (periph_retval != HAL_OK)
 8025a12:	2800      	cmp	r0, #0
 8025a14:	d144      	bne.n	8025aa0 <CMAC_compute+0x220>
  {
    return MAC_ERROR_HW_FAILURE;
  }

  /* Extract the MAC */
  for (i = 0u; i < (macSize / 4u); i++)
 8025a16:	2100      	movs	r1, #0
 8025a18:	e00f      	b.n	8025a3a <CMAC_compute+0x1ba>
  {
    WORD_TO_BYTES(temp_iv[i], macBuff[(4u * i) + 3u], macBuff[(4u * i) + 2u],
 8025a1a:	008a      	lsls	r2, r1, #2
 8025a1c:	ab9a      	add	r3, sp, #616	; 0x268
 8025a1e:	58d3      	ldr	r3, [r2, r3]
 8025a20:	1cd0      	adds	r0, r2, #3
 8025a22:	9ca9      	ldr	r4, [sp, #676]	; 0x2a4
 8025a24:	5423      	strb	r3, [r4, r0]
 8025a26:	0a1c      	lsrs	r4, r3, #8
 8025a28:	1c90      	adds	r0, r2, #2
 8025a2a:	9da9      	ldr	r5, [sp, #676]	; 0x2a4
 8025a2c:	542c      	strb	r4, [r5, r0]
 8025a2e:	0c1c      	lsrs	r4, r3, #16
 8025a30:	1c50      	adds	r0, r2, #1
 8025a32:	542c      	strb	r4, [r5, r0]
 8025a34:	0e1b      	lsrs	r3, r3, #24
 8025a36:	54ab      	strb	r3, [r5, r2]
  for (i = 0u; i < (macSize / 4u); i++)
 8025a38:	3101      	adds	r1, #1
 8025a3a:	9ba8      	ldr	r3, [sp, #672]	; 0x2a0
 8025a3c:	0898      	lsrs	r0, r3, #2
 8025a3e:	4288      	cmp	r0, r1
 8025a40:	d8eb      	bhi.n	8025a1a <CMAC_compute+0x19a>
                  macBuff[(4u * i) + 1u], macBuff[(4u * i) + 0u]);
  }

  if (macSize < 16u)
 8025a42:	2b0f      	cmp	r3, #15
 8025a44:	d816      	bhi.n	8025a74 <CMAC_compute+0x1f4>
  {
    /* copy remaining bytes */
    for (i = 0; i < (macSize % 4u); i++)
 8025a46:	2300      	movs	r3, #0
 8025a48:	e00c      	b.n	8025a64 <CMAC_compute+0x1e4>
    {
      macBuff[((macSize / 4u) * 4u) + i] = BYTE_X(temp_iv[macSize / 4u], i);
 8025a4a:	0082      	lsls	r2, r0, #2
 8025a4c:	a99a      	add	r1, sp, #616	; 0x268
 8025a4e:	5851      	ldr	r1, [r2, r1]
 8025a50:	2403      	movs	r4, #3
 8025a52:	1ae2      	subs	r2, r4, r3
 8025a54:	00d2      	lsls	r2, r2, #3
 8025a56:	40d1      	lsrs	r1, r2
 8025a58:	9aa8      	ldr	r2, [sp, #672]	; 0x2a0
 8025a5a:	43a2      	bics	r2, r4
 8025a5c:	18d2      	adds	r2, r2, r3
 8025a5e:	9ca9      	ldr	r4, [sp, #676]	; 0x2a4
 8025a60:	54a1      	strb	r1, [r4, r2]
    for (i = 0; i < (macSize % 4u); i++)
 8025a62:	3301      	adds	r3, #1
 8025a64:	2203      	movs	r2, #3
 8025a66:	99a8      	ldr	r1, [sp, #672]	; 0x2a0
 8025a68:	400a      	ands	r2, r1
 8025a6a:	429a      	cmp	r2, r3
 8025a6c:	d8ed      	bhi.n	8025a4a <CMAC_compute+0x1ca>
 8025a6e:	e001      	b.n	8025a74 <CMAC_compute+0x1f4>
    return MAC_ERROR_BAD_PARAMETER;
 8025a70:	2301      	movs	r3, #1
 8025a72:	4698      	mov	r8, r3
    }
  }

  return retval;
}
 8025a74:	4640      	mov	r0, r8
 8025a76:	239f      	movs	r3, #159	; 0x9f
 8025a78:	009b      	lsls	r3, r3, #2
 8025a7a:	449d      	add	sp, r3
 8025a7c:	bcf0      	pop	{r4, r5, r6, r7}
 8025a7e:	46bb      	mov	fp, r7
 8025a80:	46b2      	mov	sl, r6
 8025a82:	46a9      	mov	r9, r5
 8025a84:	46a0      	mov	r8, r4
 8025a86:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return MAC_ERROR_BAD_PARAMETER;
 8025a88:	2301      	movs	r3, #1
 8025a8a:	4698      	mov	r8, r3
 8025a8c:	e7f2      	b.n	8025a74 <CMAC_compute+0x1f4>
    return MAC_ERROR_WRONG_MAC_SIZE;
 8025a8e:	2302      	movs	r3, #2
 8025a90:	4698      	mov	r8, r3
 8025a92:	e7ef      	b.n	8025a74 <CMAC_compute+0x1f4>
    return MAC_ERROR_WRONG_MAC_SIZE;
 8025a94:	2302      	movs	r3, #2
 8025a96:	4698      	mov	r8, r3
 8025a98:	e7ec      	b.n	8025a74 <CMAC_compute+0x1f4>
    return MAC_ERROR_HW_FAILURE;
 8025a9a:	2304      	movs	r3, #4
 8025a9c:	4698      	mov	r8, r3
 8025a9e:	e7e9      	b.n	8025a74 <CMAC_compute+0x1f4>
    return MAC_ERROR_HW_FAILURE;
 8025aa0:	2304      	movs	r3, #4
 8025aa2:	4698      	mov	r8, r3
 8025aa4:	e7e6      	b.n	8025a74 <CMAC_compute+0x1f4>
 8025aa6:	9b05      	ldr	r3, [sp, #20]
 8025aa8:	4698      	mov	r8, r3
 8025aaa:	e7e3      	b.n	8025a74 <CMAC_compute+0x1f4>
 8025aac:	fffffd84 	.word	0xfffffd84
 8025ab0:	58001800 	.word	0x58001800

08025ab4 <CA_AES_CBC_Encrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_CBC_Encrypt_Init(CA_AESCBCctx_stt *P_pAESCBCctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8025ab4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025ab6:	46de      	mov	lr, fp
 8025ab8:	4657      	mov	r7, sl
 8025aba:	464e      	mov	r6, r9
 8025abc:	4645      	mov	r5, r8
 8025abe:	b5e0      	push	{r5, r6, r7, lr}
 8025ac0:	b085      	sub	sp, #20
 8025ac2:	0004      	movs	r4, r0
 8025ac4:	000d      	movs	r5, r1
 8025ac6:	0017      	movs	r7, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESCBCctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 8025ac8:	2800      	cmp	r0, #0
 8025aca:	d100      	bne.n	8025ace <CA_AES_CBC_Encrypt_Init+0x1a>
 8025acc:	e094      	b.n	8025bf8 <CA_AES_CBC_Encrypt_Init+0x144>
 8025ace:	2900      	cmp	r1, #0
 8025ad0:	d100      	bne.n	8025ad4 <CA_AES_CBC_Encrypt_Init+0x20>
 8025ad2:	e094      	b.n	8025bfe <CA_AES_CBC_Encrypt_Init+0x14a>
 8025ad4:	2a00      	cmp	r2, #0
 8025ad6:	d100      	bne.n	8025ada <CA_AES_CBC_Encrypt_Init+0x26>
 8025ad8:	e094      	b.n	8025c04 <CA_AES_CBC_Encrypt_Init+0x150>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESCBCctx->mKeySize == 0)
 8025ada:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8025adc:	2b00      	cmp	r3, #0
 8025ade:	d100      	bne.n	8025ae2 <CA_AES_CBC_Encrypt_Init+0x2e>
 8025ae0:	e093      	b.n	8025c0a <CA_AES_CBC_Encrypt_Init+0x156>
      || (P_pAESCBCctx->mIvSize == 0))
 8025ae2:	6903      	ldr	r3, [r0, #16]
 8025ae4:	2b00      	cmp	r3, #0
 8025ae6:	d100      	bne.n	8025aea <CA_AES_CBC_Encrypt_Init+0x36>
 8025ae8:	e091      	b.n	8025c0e <CA_AES_CBC_Encrypt_Init+0x15a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESCBCctx->CrypHandle));
 8025aea:	232c      	movs	r3, #44	; 0x2c
 8025aec:	469c      	mov	ip, r3
 8025aee:	4484      	add	ip, r0
 8025af0:	4663      	mov	r3, ip
 8025af2:	4666      	mov	r6, ip
 8025af4:	9303      	str	r3, [sp, #12]
 8025af6:	4660      	mov	r0, ip
 8025af8:	f7ff fe96 	bl	8025828 <cleanup_handle>
  P_pAESCBCctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8025afc:	4b4a      	ldr	r3, [pc, #296]	; (8025c28 <CA_AES_CBC_Encrypt_Init+0x174>)
 8025afe:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025b00:	0030      	movs	r0, r6
 8025b02:	f7fd fcf3 	bl	80234ec <HAL_CRYP_DeInit>
 8025b06:	1e01      	subs	r1, r0, #0
 8025b08:	d000      	beq.n	8025b0c <CA_AES_CBC_Encrypt_Init+0x58>
 8025b0a:	e088      	b.n	8025c1e <CA_AES_CBC_Encrypt_Init+0x16a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESCBCctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 8025b0c:	2304      	movs	r3, #4
 8025b0e:	6323      	str	r3, [r4, #48]	; 0x30
  if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8025b10:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8025b12:	9301      	str	r3, [sp, #4]
 8025b14:	2b10      	cmp	r3, #16
 8025b16:	d007      	beq.n	8025b28 <CA_AES_CBC_Encrypt_Init+0x74>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 8025b18:	9b01      	ldr	r3, [sp, #4]
 8025b1a:	2b20      	cmp	r3, #32
 8025b1c:	d000      	beq.n	8025b20 <CA_AES_CBC_Encrypt_Init+0x6c>
 8025b1e:	e080      	b.n	8025c22 <CA_AES_CBC_Encrypt_Init+0x16e>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8025b20:	2380      	movs	r3, #128	; 0x80
 8025b22:	02db      	lsls	r3, r3, #11
 8025b24:	6363      	str	r3, [r4, #52]	; 0x34
 8025b26:	e02b      	b.n	8025b80 <CA_AES_CBC_Encrypt_Init+0xcc>
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8025b28:	2300      	movs	r3, #0
 8025b2a:	6363      	str	r3, [r4, #52]	; 0x34
 8025b2c:	e028      	b.n	8025b80 <CA_AES_CBC_Encrypt_Init+0xcc>
  }

  /* Init IV and key here because of endianness */
  for (uint8_t i = 0; i < 4U; i++)
  {
    P_pAESCBCctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 8025b2e:	0083      	lsls	r3, r0, #2
 8025b30:	4698      	mov	r8, r3
 8025b32:	3303      	adds	r3, #3
 8025b34:	9302      	str	r3, [sp, #8]
 8025b36:	5cfa      	ldrb	r2, [r7, r3]
 8025b38:	4691      	mov	r9, r2
 8025b3a:	4642      	mov	r2, r8
 8025b3c:	18a2      	adds	r2, r4, r2
 8025b3e:	3239      	adds	r2, #57	; 0x39
 8025b40:	32ff      	adds	r2, #255	; 0xff
 8025b42:	464e      	mov	r6, r9
 8025b44:	7016      	strb	r6, [r2, #0]
    P_pAESCBCctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 8025b46:	4642      	mov	r2, r8
 8025b48:	3202      	adds	r2, #2
 8025b4a:	2601      	movs	r6, #1
 8025b4c:	4446      	add	r6, r8
 8025b4e:	46b2      	mov	sl, r6
 8025b50:	5cbe      	ldrb	r6, [r7, r2]
 8025b52:	46b3      	mov	fp, r6
 8025b54:	46a1      	mov	r9, r4
 8025b56:	44d1      	add	r9, sl
 8025b58:	269c      	movs	r6, #156	; 0x9c
 8025b5a:	0076      	lsls	r6, r6, #1
 8025b5c:	46b4      	mov	ip, r6
 8025b5e:	44e1      	add	r9, ip
 8025b60:	464e      	mov	r6, r9
 8025b62:	465b      	mov	r3, fp
 8025b64:	7033      	strb	r3, [r6, #0]
    P_pAESCBCctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 8025b66:	4653      	mov	r3, sl
 8025b68:	5cfb      	ldrb	r3, [r7, r3]
 8025b6a:	18a2      	adds	r2, r4, r2
 8025b6c:	4462      	add	r2, ip
 8025b6e:	7013      	strb	r3, [r2, #0]
    P_pAESCBCctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 8025b70:	4643      	mov	r3, r8
 8025b72:	5cfa      	ldrb	r2, [r7, r3]
 8025b74:	9b02      	ldr	r3, [sp, #8]
 8025b76:	18e3      	adds	r3, r4, r3
 8025b78:	4463      	add	r3, ip
 8025b7a:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 4U; i++)
 8025b7c:	3001      	adds	r0, #1
 8025b7e:	b2c0      	uxtb	r0, r0
 8025b80:	2803      	cmp	r0, #3
 8025b82:	d9d4      	bls.n	8025b2e <CA_AES_CBC_Encrypt_Init+0x7a>
 8025b84:	e01e      	b.n	8025bc4 <CA_AES_CBC_Encrypt_Init+0x110>
  }

  for (uint8_t i = 0; i < ((uint32_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
  {
    P_pAESCBCctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 8025b86:	0088      	lsls	r0, r1, #2
 8025b88:	1cc3      	adds	r3, r0, #3
 8025b8a:	5cef      	ldrb	r7, [r5, r3]
 8025b8c:	1822      	adds	r2, r4, r0
 8025b8e:	3249      	adds	r2, #73	; 0x49
 8025b90:	32ff      	adds	r2, #255	; 0xff
 8025b92:	7017      	strb	r7, [r2, #0]
    P_pAESCBCctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 8025b94:	1c82      	adds	r2, r0, #2
 8025b96:	1c47      	adds	r7, r0, #1
 8025b98:	46b8      	mov	r8, r7
 8025b9a:	5caf      	ldrb	r7, [r5, r2]
 8025b9c:	46b9      	mov	r9, r7
 8025b9e:	4647      	mov	r7, r8
 8025ba0:	19e7      	adds	r7, r4, r7
 8025ba2:	3749      	adds	r7, #73	; 0x49
 8025ba4:	37ff      	adds	r7, #255	; 0xff
 8025ba6:	464e      	mov	r6, r9
 8025ba8:	703e      	strb	r6, [r7, #0]
    P_pAESCBCctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8025baa:	4646      	mov	r6, r8
 8025bac:	5daf      	ldrb	r7, [r5, r6]
 8025bae:	18a2      	adds	r2, r4, r2
 8025bb0:	3249      	adds	r2, #73	; 0x49
 8025bb2:	32ff      	adds	r2, #255	; 0xff
 8025bb4:	7017      	strb	r7, [r2, #0]
    P_pAESCBCctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 8025bb6:	5c2a      	ldrb	r2, [r5, r0]
 8025bb8:	18e3      	adds	r3, r4, r3
 8025bba:	3349      	adds	r3, #73	; 0x49
 8025bbc:	33ff      	adds	r3, #255	; 0xff
 8025bbe:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint32_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
 8025bc0:	3101      	adds	r1, #1
 8025bc2:	b2c9      	uxtb	r1, r1
 8025bc4:	9b01      	ldr	r3, [sp, #4]
 8025bc6:	089b      	lsrs	r3, r3, #2
 8025bc8:	4299      	cmp	r1, r3
 8025bca:	d3dc      	bcc.n	8025b86 <CA_AES_CBC_Encrypt_Init+0xd2>
  }

  P_pAESCBCctx->CrypHandle.Init.Algorithm       = CRYP_AES_CBC;
 8025bcc:	2320      	movs	r3, #32
 8025bce:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESCBCctx->CrypHandle.Init.pKey = (uint32_t *)(uint32_t)(P_pAESCBCctx->Key_endian);
 8025bd0:	0023      	movs	r3, r4
 8025bd2:	3349      	adds	r3, #73	; 0x49
 8025bd4:	33ff      	adds	r3, #255	; 0xff
 8025bd6:	63a3      	str	r3, [r4, #56]	; 0x38
  P_pAESCBCctx->CrypHandle.Init.pInitVect = (uint32_t *)(uint32_t)(P_pAESCBCctx->Iv_endian);
 8025bd8:	3b10      	subs	r3, #16
 8025bda:	63e3      	str	r3, [r4, #60]	; 0x3c

  P_pAESCBCctx->CrypHandle.Init.Header = NULL;
 8025bdc:	2300      	movs	r3, #0
 8025bde:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESCBCctx->CrypHandle.Init.HeaderSize = 0;
 8025be0:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESCBCctx->CrypHandle.Init.B0 = NULL;
 8025be2:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESCBCctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8025be4:	3301      	adds	r3, #1
 8025be6:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESCBCctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 8025be8:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025bea:	9803      	ldr	r0, [sp, #12]
 8025bec:	f7fd fc58 	bl	80234a0 <HAL_CRYP_Init>
 8025bf0:	2800      	cmp	r0, #0
 8025bf2:	d00d      	beq.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 8025bf4:	480d      	ldr	r0, [pc, #52]	; (8025c2c <CA_AES_CBC_Encrypt_Init+0x178>)
 8025bf6:	e00b      	b.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
    return CA_AES_ERR_BAD_PARAMETER;
 8025bf8:	20c2      	movs	r0, #194	; 0xc2
 8025bfa:	0100      	lsls	r0, r0, #4
 8025bfc:	e008      	b.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025bfe:	20c2      	movs	r0, #194	; 0xc2
 8025c00:	0100      	lsls	r0, r0, #4
 8025c02:	e005      	b.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025c04:	20c2      	movs	r0, #194	; 0xc2
 8025c06:	0100      	lsls	r0, r0, #4
 8025c08:	e002      	b.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
    return CA_AES_ERR_BAD_CONTEXT;
 8025c0a:	4808      	ldr	r0, [pc, #32]	; (8025c2c <CA_AES_CBC_Encrypt_Init+0x178>)
 8025c0c:	e000      	b.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025c0e:	4807      	ldr	r0, [pc, #28]	; (8025c2c <CA_AES_CBC_Encrypt_Init+0x178>)
  }
  return aes_ret_status;
}
 8025c10:	b005      	add	sp, #20
 8025c12:	bcf0      	pop	{r4, r5, r6, r7}
 8025c14:	46bb      	mov	fp, r7
 8025c16:	46b2      	mov	sl, r6
 8025c18:	46a9      	mov	r9, r5
 8025c1a:	46a0      	mov	r8, r4
 8025c1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 8025c1e:	4803      	ldr	r0, [pc, #12]	; (8025c2c <CA_AES_CBC_Encrypt_Init+0x178>)
 8025c20:	e7f6      	b.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
    return CA_AES_ERR_BAD_CONTEXT;
 8025c22:	4802      	ldr	r0, [pc, #8]	; (8025c2c <CA_AES_CBC_Encrypt_Init+0x178>)
 8025c24:	e7f4      	b.n	8025c10 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025c26:	46c0      	nop			; (mov r8, r8)
 8025c28:	58001800 	.word	0x58001800
 8025c2c:	00000c1f 	.word	0x00000c1f

08025c30 <CA_AES_CBC_Encrypt_Append>:
int32_t CA_AES_CBC_Encrypt_Append(CA_AESCBCctx_stt *P_pAESCBCctx,
                                  const uint8_t *P_pInputBuffer,
                                  int32_t P_inputSize,
                                  uint8_t *P_pOutputBuffer,
                                  int32_t *P_pOutputSize)
{
 8025c30:	b530      	push	{r4, r5, lr}
 8025c32:	b083      	sub	sp, #12
 8025c34:	0014      	movs	r4, r2

  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESCBCctx == NULL)
 8025c36:	2800      	cmp	r0, #0
 8025c38:	d014      	beq.n	8025c64 <CA_AES_CBC_Encrypt_Append+0x34>
      || (P_pInputBuffer == NULL)
 8025c3a:	2900      	cmp	r1, #0
 8025c3c:	d015      	beq.n	8025c6a <CA_AES_CBC_Encrypt_Append+0x3a>
      || (P_pOutputBuffer == NULL)
 8025c3e:	2b00      	cmp	r3, #0
 8025c40:	d016      	beq.n	8025c70 <CA_AES_CBC_Encrypt_Append+0x40>
      || (P_pOutputSize == NULL))
 8025c42:	9a06      	ldr	r2, [sp, #24]
 8025c44:	2a00      	cmp	r2, #0
 8025c46:	d016      	beq.n	8025c76 <CA_AES_CBC_Encrypt_Append+0x46>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if (P_inputSize < (int32_t)CA_CRL_AES_BLOCK)
 8025c48:	2c0f      	cmp	r4, #15
 8025c4a:	dd17      	ble.n	8025c7c <CA_AES_CBC_Encrypt_Append+0x4c>
  {
    return CA_AES_ERR_BAD_INPUT_SIZE;
  }

  if (HAL_CRYP_Encrypt(&P_pAESCBCctx->CrypHandle, (uint32_t *)(uint32_t)P_pInputBuffer, (uint16_t)P_inputSize,
 8025c4c:	b2a2      	uxth	r2, r4
 8025c4e:	302c      	adds	r0, #44	; 0x2c
 8025c50:	25ff      	movs	r5, #255	; 0xff
 8025c52:	9500      	str	r5, [sp, #0]
 8025c54:	f7fd ffba 	bl	8023bcc <HAL_CRYP_Encrypt>
 8025c58:	2800      	cmp	r0, #0
 8025c5a:	d111      	bne.n	8025c80 <CA_AES_CBC_Encrypt_Append+0x50>
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
  }
  else
  {
    *P_pOutputSize = P_inputSize;
 8025c5c:	9b06      	ldr	r3, [sp, #24]
 8025c5e:	601c      	str	r4, [r3, #0]
  }

  return aes_ret_status;
}
 8025c60:	b003      	add	sp, #12
 8025c62:	bd30      	pop	{r4, r5, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 8025c64:	20c2      	movs	r0, #194	; 0xc2
 8025c66:	0100      	lsls	r0, r0, #4
 8025c68:	e7fa      	b.n	8025c60 <CA_AES_CBC_Encrypt_Append+0x30>
 8025c6a:	20c2      	movs	r0, #194	; 0xc2
 8025c6c:	0100      	lsls	r0, r0, #4
 8025c6e:	e7f7      	b.n	8025c60 <CA_AES_CBC_Encrypt_Append+0x30>
 8025c70:	20c2      	movs	r0, #194	; 0xc2
 8025c72:	0100      	lsls	r0, r0, #4
 8025c74:	e7f4      	b.n	8025c60 <CA_AES_CBC_Encrypt_Append+0x30>
 8025c76:	20c2      	movs	r0, #194	; 0xc2
 8025c78:	0100      	lsls	r0, r0, #4
 8025c7a:	e7f1      	b.n	8025c60 <CA_AES_CBC_Encrypt_Append+0x30>
    return CA_AES_ERR_BAD_INPUT_SIZE;
 8025c7c:	4801      	ldr	r0, [pc, #4]	; (8025c84 <CA_AES_CBC_Encrypt_Append+0x54>)
 8025c7e:	e7ef      	b.n	8025c60 <CA_AES_CBC_Encrypt_Append+0x30>
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8025c80:	4801      	ldr	r0, [pc, #4]	; (8025c88 <CA_AES_CBC_Encrypt_Append+0x58>)
 8025c82:	e7ed      	b.n	8025c60 <CA_AES_CBC_Encrypt_Append+0x30>
 8025c84:	00000c1d 	.word	0x00000c1d
 8025c88:	00000c1e 	.word	0x00000c1e

08025c8c <CA_AES_CBC_Encrypt_Finish>:
  * @retval     CA_AES_ERR_BAD_PARAMETER: At least one parameter is a NULL pointer
  */
int32_t CA_AES_CBC_Encrypt_Finish(CA_AESCBCctx_stt *P_pAESCBCctx,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 8025c8c:	b570      	push	{r4, r5, r6, lr}
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pOutputBuffer;
  (void)P_pOutputSize;

  if (HAL_CRYP_DeInit(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025c8e:	302c      	adds	r0, #44	; 0x2c
 8025c90:	0004      	movs	r4, r0
 8025c92:	f7fd fc2b 	bl	80234ec <HAL_CRYP_DeInit>
 8025c96:	2800      	cmp	r0, #0
 8025c98:	d105      	bne.n	8025ca6 <CA_AES_CBC_Encrypt_Finish+0x1a>
  int32_t aes_ret_status = CA_AES_SUCCESS;
 8025c9a:	2500      	movs	r5, #0
  {
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
  }
  cleanup_handle(&(P_pAESCBCctx->CrypHandle));
 8025c9c:	0020      	movs	r0, r4
 8025c9e:	f7ff fdc3 	bl	8025828 <cleanup_handle>

  return aes_ret_status;
}
 8025ca2:	0028      	movs	r0, r5
 8025ca4:	bd70      	pop	{r4, r5, r6, pc}
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
 8025ca6:	25c2      	movs	r5, #194	; 0xc2
 8025ca8:	012d      	lsls	r5, r5, #4
 8025caa:	e7f7      	b.n	8025c9c <CA_AES_CBC_Encrypt_Finish+0x10>

08025cac <CA_AES_CBC_Decrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_CBC_Decrypt_Init(CA_AESCBCctx_stt *P_pAESCBCctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8025cac:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025cae:	46de      	mov	lr, fp
 8025cb0:	4657      	mov	r7, sl
 8025cb2:	464e      	mov	r6, r9
 8025cb4:	4645      	mov	r5, r8
 8025cb6:	b5e0      	push	{r5, r6, r7, lr}
 8025cb8:	b085      	sub	sp, #20
 8025cba:	0004      	movs	r4, r0
 8025cbc:	000d      	movs	r5, r1
 8025cbe:	0016      	movs	r6, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESCBCctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 8025cc0:	2800      	cmp	r0, #0
 8025cc2:	d100      	bne.n	8025cc6 <CA_AES_CBC_Decrypt_Init+0x1a>
 8025cc4:	e08f      	b.n	8025de6 <CA_AES_CBC_Decrypt_Init+0x13a>
 8025cc6:	2900      	cmp	r1, #0
 8025cc8:	d100      	bne.n	8025ccc <CA_AES_CBC_Decrypt_Init+0x20>
 8025cca:	e08f      	b.n	8025dec <CA_AES_CBC_Decrypt_Init+0x140>
 8025ccc:	2a00      	cmp	r2, #0
 8025cce:	d100      	bne.n	8025cd2 <CA_AES_CBC_Decrypt_Init+0x26>
 8025cd0:	e08f      	b.n	8025df2 <CA_AES_CBC_Decrypt_Init+0x146>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESCBCctx->mKeySize == 0)
 8025cd2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8025cd4:	2b00      	cmp	r3, #0
 8025cd6:	d100      	bne.n	8025cda <CA_AES_CBC_Decrypt_Init+0x2e>
 8025cd8:	e08e      	b.n	8025df8 <CA_AES_CBC_Decrypt_Init+0x14c>
      || (P_pAESCBCctx->mIvSize == 0))
 8025cda:	6903      	ldr	r3, [r0, #16]
 8025cdc:	2b00      	cmp	r3, #0
 8025cde:	d100      	bne.n	8025ce2 <CA_AES_CBC_Decrypt_Init+0x36>
 8025ce0:	e08c      	b.n	8025dfc <CA_AES_CBC_Decrypt_Init+0x150>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESCBCctx->CrypHandle));
 8025ce2:	232c      	movs	r3, #44	; 0x2c
 8025ce4:	4698      	mov	r8, r3
 8025ce6:	4480      	add	r8, r0
 8025ce8:	4640      	mov	r0, r8
 8025cea:	f7ff fd9d 	bl	8025828 <cleanup_handle>
  P_pAESCBCctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8025cee:	4b49      	ldr	r3, [pc, #292]	; (8025e14 <CA_AES_CBC_Decrypt_Init+0x168>)
 8025cf0:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025cf2:	4640      	mov	r0, r8
 8025cf4:	f7fd fbfa 	bl	80234ec <HAL_CRYP_DeInit>
 8025cf8:	1e03      	subs	r3, r0, #0
 8025cfa:	9001      	str	r0, [sp, #4]
 8025cfc:	d000      	beq.n	8025d00 <CA_AES_CBC_Decrypt_Init+0x54>
 8025cfe:	e085      	b.n	8025e0c <CA_AES_CBC_Decrypt_Init+0x160>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESCBCctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 8025d00:	3304      	adds	r3, #4
 8025d02:	6323      	str	r3, [r4, #48]	; 0x30
  if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8025d04:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8025d06:	9302      	str	r3, [sp, #8]
 8025d08:	2b10      	cmp	r3, #16
 8025d0a:	d007      	beq.n	8025d1c <CA_AES_CBC_Decrypt_Init+0x70>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 8025d0c:	9b02      	ldr	r3, [sp, #8]
 8025d0e:	2b20      	cmp	r3, #32
 8025d10:	d000      	beq.n	8025d14 <CA_AES_CBC_Decrypt_Init+0x68>
 8025d12:	e07d      	b.n	8025e10 <CA_AES_CBC_Decrypt_Init+0x164>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8025d14:	2380      	movs	r3, #128	; 0x80
 8025d16:	02db      	lsls	r3, r3, #11
 8025d18:	6363      	str	r3, [r4, #52]	; 0x34
 8025d1a:	e026      	b.n	8025d6a <CA_AES_CBC_Decrypt_Init+0xbe>
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8025d1c:	2300      	movs	r3, #0
 8025d1e:	6363      	str	r3, [r4, #52]	; 0x34
 8025d20:	e023      	b.n	8025d6a <CA_AES_CBC_Decrypt_Init+0xbe>
  }

  /* Init IV and key here because of endianness */
  for (uint8_t i = 0; i < 4U; i++)
  {
    P_pAESCBCctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 8025d22:	0081      	lsls	r1, r0, #2
 8025d24:	1ccb      	adds	r3, r1, #3
 8025d26:	9303      	str	r3, [sp, #12]
 8025d28:	5cf2      	ldrb	r2, [r6, r3]
 8025d2a:	4691      	mov	r9, r2
 8025d2c:	1862      	adds	r2, r4, r1
 8025d2e:	3239      	adds	r2, #57	; 0x39
 8025d30:	32ff      	adds	r2, #255	; 0xff
 8025d32:	464f      	mov	r7, r9
 8025d34:	7017      	strb	r7, [r2, #0]
    P_pAESCBCctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 8025d36:	1c8a      	adds	r2, r1, #2
 8025d38:	1c4f      	adds	r7, r1, #1
 8025d3a:	46ba      	mov	sl, r7
 8025d3c:	5cb7      	ldrb	r7, [r6, r2]
 8025d3e:	46bb      	mov	fp, r7
 8025d40:	46a1      	mov	r9, r4
 8025d42:	44d1      	add	r9, sl
 8025d44:	279c      	movs	r7, #156	; 0x9c
 8025d46:	007f      	lsls	r7, r7, #1
 8025d48:	46bc      	mov	ip, r7
 8025d4a:	44e1      	add	r9, ip
 8025d4c:	464f      	mov	r7, r9
 8025d4e:	465b      	mov	r3, fp
 8025d50:	703b      	strb	r3, [r7, #0]
    P_pAESCBCctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 8025d52:	4653      	mov	r3, sl
 8025d54:	5cf3      	ldrb	r3, [r6, r3]
 8025d56:	18a2      	adds	r2, r4, r2
 8025d58:	4462      	add	r2, ip
 8025d5a:	7013      	strb	r3, [r2, #0]
    P_pAESCBCctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 8025d5c:	5c72      	ldrb	r2, [r6, r1]
 8025d5e:	9b03      	ldr	r3, [sp, #12]
 8025d60:	18e3      	adds	r3, r4, r3
 8025d62:	4463      	add	r3, ip
 8025d64:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 4U; i++)
 8025d66:	3001      	adds	r0, #1
 8025d68:	b2c0      	uxtb	r0, r0
 8025d6a:	2803      	cmp	r0, #3
 8025d6c:	d9d9      	bls.n	8025d22 <CA_AES_CBC_Decrypt_Init+0x76>
 8025d6e:	e01e      	b.n	8025dae <CA_AES_CBC_Decrypt_Init+0x102>
  }

  for (uint8_t i = 0; i < ((uint8_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
  {
    P_pAESCBCctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 8025d70:	9f01      	ldr	r7, [sp, #4]
 8025d72:	00b8      	lsls	r0, r7, #2
 8025d74:	1cc3      	adds	r3, r0, #3
 8025d76:	5ce9      	ldrb	r1, [r5, r3]
 8025d78:	1822      	adds	r2, r4, r0
 8025d7a:	3249      	adds	r2, #73	; 0x49
 8025d7c:	32ff      	adds	r2, #255	; 0xff
 8025d7e:	7011      	strb	r1, [r2, #0]
    P_pAESCBCctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 8025d80:	1c82      	adds	r2, r0, #2
 8025d82:	1c46      	adds	r6, r0, #1
 8025d84:	5ca9      	ldrb	r1, [r5, r2]
 8025d86:	4689      	mov	r9, r1
 8025d88:	19a1      	adds	r1, r4, r6
 8025d8a:	3149      	adds	r1, #73	; 0x49
 8025d8c:	31ff      	adds	r1, #255	; 0xff
 8025d8e:	464f      	mov	r7, r9
 8025d90:	700f      	strb	r7, [r1, #0]
    P_pAESCBCctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8025d92:	5dae      	ldrb	r6, [r5, r6]
 8025d94:	18a2      	adds	r2, r4, r2
 8025d96:	3249      	adds	r2, #73	; 0x49
 8025d98:	32ff      	adds	r2, #255	; 0xff
 8025d9a:	7016      	strb	r6, [r2, #0]
    P_pAESCBCctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 8025d9c:	5c2a      	ldrb	r2, [r5, r0]
 8025d9e:	18e3      	adds	r3, r4, r3
 8025da0:	3349      	adds	r3, #73	; 0x49
 8025da2:	33ff      	adds	r3, #255	; 0xff
 8025da4:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
 8025da6:	9f01      	ldr	r7, [sp, #4]
 8025da8:	3701      	adds	r7, #1
 8025daa:	b2fb      	uxtb	r3, r7
 8025dac:	9301      	str	r3, [sp, #4]
 8025dae:	466b      	mov	r3, sp
 8025db0:	7a1b      	ldrb	r3, [r3, #8]
 8025db2:	089b      	lsrs	r3, r3, #2
 8025db4:	9a01      	ldr	r2, [sp, #4]
 8025db6:	4293      	cmp	r3, r2
 8025db8:	d8da      	bhi.n	8025d70 <CA_AES_CBC_Decrypt_Init+0xc4>
  }

  P_pAESCBCctx->CrypHandle.Init.Algorithm       = CRYP_AES_CBC;
 8025dba:	2320      	movs	r3, #32
 8025dbc:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESCBCctx->CrypHandle.Init.pKey = (uint32_t *)(uint32_t)(P_pAESCBCctx->Key_endian);
 8025dbe:	0023      	movs	r3, r4
 8025dc0:	3349      	adds	r3, #73	; 0x49
 8025dc2:	33ff      	adds	r3, #255	; 0xff
 8025dc4:	63a3      	str	r3, [r4, #56]	; 0x38
  P_pAESCBCctx->CrypHandle.Init.pInitVect = (uint32_t *)(uint32_t)(P_pAESCBCctx->Iv_endian);
 8025dc6:	3b10      	subs	r3, #16
 8025dc8:	63e3      	str	r3, [r4, #60]	; 0x3c

  P_pAESCBCctx->CrypHandle.Init.Header = NULL;
 8025dca:	2300      	movs	r3, #0
 8025dcc:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESCBCctx->CrypHandle.Init.HeaderSize = 0;
 8025dce:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESCBCctx->CrypHandle.Init.B0 = NULL;
 8025dd0:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESCBCctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8025dd2:	3301      	adds	r3, #1
 8025dd4:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESCBCctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 8025dd6:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025dd8:	4640      	mov	r0, r8
 8025dda:	f7fd fb61 	bl	80234a0 <HAL_CRYP_Init>
 8025dde:	2800      	cmp	r0, #0
 8025de0:	d00d      	beq.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 8025de2:	480d      	ldr	r0, [pc, #52]	; (8025e18 <CA_AES_CBC_Decrypt_Init+0x16c>)
 8025de4:	e00b      	b.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
    return CA_AES_ERR_BAD_PARAMETER;
 8025de6:	20c2      	movs	r0, #194	; 0xc2
 8025de8:	0100      	lsls	r0, r0, #4
 8025dea:	e008      	b.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
 8025dec:	20c2      	movs	r0, #194	; 0xc2
 8025dee:	0100      	lsls	r0, r0, #4
 8025df0:	e005      	b.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
 8025df2:	20c2      	movs	r0, #194	; 0xc2
 8025df4:	0100      	lsls	r0, r0, #4
 8025df6:	e002      	b.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
    return CA_AES_ERR_BAD_CONTEXT;
 8025df8:	4807      	ldr	r0, [pc, #28]	; (8025e18 <CA_AES_CBC_Decrypt_Init+0x16c>)
 8025dfa:	e000      	b.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
 8025dfc:	4806      	ldr	r0, [pc, #24]	; (8025e18 <CA_AES_CBC_Decrypt_Init+0x16c>)
  }
  return aes_ret_status;
}
 8025dfe:	b005      	add	sp, #20
 8025e00:	bcf0      	pop	{r4, r5, r6, r7}
 8025e02:	46bb      	mov	fp, r7
 8025e04:	46b2      	mov	sl, r6
 8025e06:	46a9      	mov	r9, r5
 8025e08:	46a0      	mov	r8, r4
 8025e0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 8025e0c:	4802      	ldr	r0, [pc, #8]	; (8025e18 <CA_AES_CBC_Decrypt_Init+0x16c>)
 8025e0e:	e7f6      	b.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
    return CA_AES_ERR_BAD_CONTEXT;
 8025e10:	4801      	ldr	r0, [pc, #4]	; (8025e18 <CA_AES_CBC_Decrypt_Init+0x16c>)
 8025e12:	e7f4      	b.n	8025dfe <CA_AES_CBC_Decrypt_Init+0x152>
 8025e14:	58001800 	.word	0x58001800
 8025e18:	00000c1f 	.word	0x00000c1f

08025e1c <CA_AES_CMAC_Encrypt_Init>:
  * @retval     CA_AES_ERR_BAD_PARAMETER: At least one parameter is a NULL pointer
  * @retval     CA_AES_ERR_BAD_CONTEXT: Context not initialized with valid values
  */
int32_t CA_AES_CMAC_Encrypt_Init(CA_AESCMACctx_stt *P_pAESCMACctx)
{
  if (P_pAESCMACctx == NULL)
 8025e1c:	2800      	cmp	r0, #0
 8025e1e:	d00d      	beq.n	8025e3c <CA_AES_CMAC_Encrypt_Init+0x20>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if (P_pAESCMACctx->pmKey == NULL)
 8025e20:	6883      	ldr	r3, [r0, #8]
 8025e22:	2b00      	cmp	r3, #0
 8025e24:	d00d      	beq.n	8025e42 <CA_AES_CMAC_Encrypt_Init+0x26>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES128_KEY)
 8025e26:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8025e28:	2b10      	cmp	r3, #16
 8025e2a:	d001      	beq.n	8025e30 <CA_AES_CMAC_Encrypt_Init+0x14>
      && (P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES256_KEY))
 8025e2c:	2b20      	cmp	r3, #32
 8025e2e:	d10a      	bne.n	8025e46 <CA_AES_CMAC_Encrypt_Init+0x2a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mTagSize <= 0) || (P_pAESCMACctx->mTagSize > (int32_t)CA_CRL_AES_BLOCK))
 8025e30:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8025e32:	3b01      	subs	r3, #1
 8025e34:	2b0f      	cmp	r3, #15
 8025e36:	d808      	bhi.n	8025e4a <CA_AES_CMAC_Encrypt_Init+0x2e>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  return CA_AES_SUCCESS;
 8025e38:	2000      	movs	r0, #0
}
 8025e3a:	4770      	bx	lr
    return CA_AES_ERR_BAD_PARAMETER;
 8025e3c:	20c2      	movs	r0, #194	; 0xc2
 8025e3e:	0100      	lsls	r0, r0, #4
 8025e40:	e7fb      	b.n	8025e3a <CA_AES_CMAC_Encrypt_Init+0x1e>
    return CA_AES_ERR_BAD_CONTEXT;
 8025e42:	4803      	ldr	r0, [pc, #12]	; (8025e50 <CA_AES_CMAC_Encrypt_Init+0x34>)
 8025e44:	e7f9      	b.n	8025e3a <CA_AES_CMAC_Encrypt_Init+0x1e>
    return CA_AES_ERR_BAD_CONTEXT;
 8025e46:	4802      	ldr	r0, [pc, #8]	; (8025e50 <CA_AES_CMAC_Encrypt_Init+0x34>)
 8025e48:	e7f7      	b.n	8025e3a <CA_AES_CMAC_Encrypt_Init+0x1e>
    return CA_AES_ERR_BAD_CONTEXT;
 8025e4a:	4801      	ldr	r0, [pc, #4]	; (8025e50 <CA_AES_CMAC_Encrypt_Init+0x34>)
 8025e4c:	e7f5      	b.n	8025e3a <CA_AES_CMAC_Encrypt_Init+0x1e>
 8025e4e:	46c0      	nop			; (mov r8, r8)
 8025e50:	00000c1f 	.word	0x00000c1f

08025e54 <CA_AES_CMAC_Encrypt_Append>:
  * @retval     CA_AES_ERR_BAD_OPERATION: Append not allowed
  */
int32_t CA_AES_CMAC_Encrypt_Append(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   const uint8_t  *P_pInputBuffer,
                                   int32_t         P_inputSize)
{
 8025e54:	b570      	push	{r4, r5, r6, lr}
 8025e56:	b082      	sub	sp, #8
 8025e58:	0004      	movs	r4, r0
 8025e5a:	0008      	movs	r0, r1
 8025e5c:	0011      	movs	r1, r2
  mac_error_t error;
  if ((P_pAESCMACctx == NULL) || (P_pInputBuffer == NULL) || (P_inputSize == 0))
 8025e5e:	2c00      	cmp	r4, #0
 8025e60:	d010      	beq.n	8025e84 <CA_AES_CMAC_Encrypt_Append+0x30>
 8025e62:	2800      	cmp	r0, #0
 8025e64:	d011      	beq.n	8025e8a <CA_AES_CMAC_Encrypt_Append+0x36>
 8025e66:	2a00      	cmp	r2, #0
 8025e68:	d012      	beq.n	8025e90 <CA_AES_CMAC_Encrypt_Append+0x3c>
    return CA_AES_ERR_BAD_PARAMETER;
  }
  error = CMAC_compute(P_pInputBuffer,
                       (uint32_t)P_inputSize,
                       P_pAESCMACctx->pmKey,
                       (uint32_t)(P_pAESCMACctx->mKeySize),
 8025e6a:	6a63      	ldr	r3, [r4, #36]	; 0x24
                       (uint32_t)(P_pAESCMACctx->mTagSize),
 8025e6c:	6b25      	ldr	r5, [r4, #48]	; 0x30
                       P_pAESCMACctx->mac);
 8025e6e:	0026      	movs	r6, r4
 8025e70:	3634      	adds	r6, #52	; 0x34
  error = CMAC_compute(P_pInputBuffer,
 8025e72:	68a2      	ldr	r2, [r4, #8]
 8025e74:	9601      	str	r6, [sp, #4]
 8025e76:	9500      	str	r5, [sp, #0]
 8025e78:	f7ff fd02 	bl	8025880 <CMAC_compute>
  if (error == MAC_SUCCESS)
 8025e7c:	2800      	cmp	r0, #0
 8025e7e:	d10a      	bne.n	8025e96 <CA_AES_CMAC_Encrypt_Append+0x42>
  }
  else
  {
    return CA_AES_ERR_BAD_OPERATION;
  }
}
 8025e80:	b002      	add	sp, #8
 8025e82:	bd70      	pop	{r4, r5, r6, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 8025e84:	20c2      	movs	r0, #194	; 0xc2
 8025e86:	0100      	lsls	r0, r0, #4
 8025e88:	e7fa      	b.n	8025e80 <CA_AES_CMAC_Encrypt_Append+0x2c>
 8025e8a:	20c2      	movs	r0, #194	; 0xc2
 8025e8c:	0100      	lsls	r0, r0, #4
 8025e8e:	e7f7      	b.n	8025e80 <CA_AES_CMAC_Encrypt_Append+0x2c>
 8025e90:	20c2      	movs	r0, #194	; 0xc2
 8025e92:	0100      	lsls	r0, r0, #4
 8025e94:	e7f4      	b.n	8025e80 <CA_AES_CMAC_Encrypt_Append+0x2c>
    return CA_AES_ERR_BAD_OPERATION;
 8025e96:	4801      	ldr	r0, [pc, #4]	; (8025e9c <CA_AES_CMAC_Encrypt_Append+0x48>)
 8025e98:	e7f2      	b.n	8025e80 <CA_AES_CMAC_Encrypt_Append+0x2c>
 8025e9a:	46c0      	nop			; (mov r8, r8)
 8025e9c:	00000c1e 	.word	0x00000c1e

08025ea0 <CA_AES_CMAC_Encrypt_Finish>:
  *             see note
  */
int32_t CA_AES_CMAC_Encrypt_Finish(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   uint8_t        *P_pOutputBuffer,
                                   int32_t        *P_pOutputSize)
{
 8025ea0:	b570      	push	{r4, r5, r6, lr}
 8025ea2:	0004      	movs	r4, r0
 8025ea4:	0008      	movs	r0, r1
 8025ea6:	0015      	movs	r5, r2
  if ((P_pAESCMACctx == NULL) || (P_pOutputBuffer == NULL) || (P_pOutputSize == NULL))
 8025ea8:	2c00      	cmp	r4, #0
 8025eaa:	d00c      	beq.n	8025ec6 <CA_AES_CMAC_Encrypt_Finish+0x26>
 8025eac:	2900      	cmp	r1, #0
 8025eae:	d00d      	beq.n	8025ecc <CA_AES_CMAC_Encrypt_Finish+0x2c>
 8025eb0:	2a00      	cmp	r2, #0
 8025eb2:	d00e      	beq.n	8025ed2 <CA_AES_CMAC_Encrypt_Finish+0x32>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  (void)memcpy(P_pOutputBuffer, P_pAESCMACctx->mac, (uint32_t)(P_pAESCMACctx->mTagSize));
 8025eb4:	0021      	movs	r1, r4
 8025eb6:	3134      	adds	r1, #52	; 0x34
 8025eb8:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8025eba:	f00e fc2b 	bl	8034714 <memcpy>
  *P_pOutputSize = P_pAESCMACctx->mTagSize;
 8025ebe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8025ec0:	602b      	str	r3, [r5, #0]
  return CA_AES_SUCCESS;
 8025ec2:	2000      	movs	r0, #0
}
 8025ec4:	bd70      	pop	{r4, r5, r6, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 8025ec6:	20c2      	movs	r0, #194	; 0xc2
 8025ec8:	0100      	lsls	r0, r0, #4
 8025eca:	e7fb      	b.n	8025ec4 <CA_AES_CMAC_Encrypt_Finish+0x24>
 8025ecc:	20c2      	movs	r0, #194	; 0xc2
 8025ece:	0100      	lsls	r0, r0, #4
 8025ed0:	e7f8      	b.n	8025ec4 <CA_AES_CMAC_Encrypt_Finish+0x24>
 8025ed2:	20c2      	movs	r0, #194	; 0xc2
 8025ed4:	0100      	lsls	r0, r0, #4
 8025ed6:	e7f5      	b.n	8025ec4 <CA_AES_CMAC_Encrypt_Finish+0x24>

08025ed8 <CA_AES_CMAC_Decrypt_Init>:
  * @retval     CA_AES_ERR_BAD_CONTEXT: Context not initialized with valid values,
  *                                   see the note below
  */
int32_t CA_AES_CMAC_Decrypt_Init(CA_AESCMACctx_stt *P_pAESCMACctx)
{
  if (P_pAESCMACctx == NULL)
 8025ed8:	2800      	cmp	r0, #0
 8025eda:	d010      	beq.n	8025efe <CA_AES_CMAC_Decrypt_Init+0x26>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if (P_pAESCMACctx->pmKey == NULL)
 8025edc:	6883      	ldr	r3, [r0, #8]
 8025ede:	2b00      	cmp	r3, #0
 8025ee0:	d010      	beq.n	8025f04 <CA_AES_CMAC_Decrypt_Init+0x2c>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES128_KEY)
 8025ee2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8025ee4:	2b10      	cmp	r3, #16
 8025ee6:	d001      	beq.n	8025eec <CA_AES_CMAC_Decrypt_Init+0x14>
      && (P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES256_KEY))
 8025ee8:	2b20      	cmp	r3, #32
 8025eea:	d10d      	bne.n	8025f08 <CA_AES_CMAC_Decrypt_Init+0x30>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if (P_pAESCMACctx->pmTag == NULL)
 8025eec:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8025eee:	2b00      	cmp	r3, #0
 8025ef0:	d00c      	beq.n	8025f0c <CA_AES_CMAC_Decrypt_Init+0x34>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mTagSize <= 0) || (P_pAESCMACctx->mTagSize > (int32_t)CA_CRL_AES_BLOCK))
 8025ef2:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8025ef4:	3b01      	subs	r3, #1
 8025ef6:	2b0f      	cmp	r3, #15
 8025ef8:	d80a      	bhi.n	8025f10 <CA_AES_CMAC_Decrypt_Init+0x38>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  return CA_AES_SUCCESS;
 8025efa:	2000      	movs	r0, #0
}
 8025efc:	4770      	bx	lr
    return CA_AES_ERR_BAD_PARAMETER;
 8025efe:	20c2      	movs	r0, #194	; 0xc2
 8025f00:	0100      	lsls	r0, r0, #4
 8025f02:	e7fb      	b.n	8025efc <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 8025f04:	4803      	ldr	r0, [pc, #12]	; (8025f14 <CA_AES_CMAC_Decrypt_Init+0x3c>)
 8025f06:	e7f9      	b.n	8025efc <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 8025f08:	4802      	ldr	r0, [pc, #8]	; (8025f14 <CA_AES_CMAC_Decrypt_Init+0x3c>)
 8025f0a:	e7f7      	b.n	8025efc <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 8025f0c:	4801      	ldr	r0, [pc, #4]	; (8025f14 <CA_AES_CMAC_Decrypt_Init+0x3c>)
 8025f0e:	e7f5      	b.n	8025efc <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 8025f10:	4800      	ldr	r0, [pc, #0]	; (8025f14 <CA_AES_CMAC_Decrypt_Init+0x3c>)
 8025f12:	e7f3      	b.n	8025efc <CA_AES_CMAC_Decrypt_Init+0x24>
 8025f14:	00000c1f 	.word	0x00000c1f

08025f18 <CA_AES_CMAC_Decrypt_Append>:
  * @retval     CA_AES_ERR_BAD_OPERATION: Append not allowed
  */
int32_t CA_AES_CMAC_Decrypt_Append(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   const uint8_t  *P_pInputBuffer,
                                   int32_t         P_inputSize)
{
 8025f18:	b570      	push	{r4, r5, r6, lr}
 8025f1a:	b082      	sub	sp, #8
 8025f1c:	0004      	movs	r4, r0
 8025f1e:	0008      	movs	r0, r1
 8025f20:	0011      	movs	r1, r2
  mac_error_t error;
  if ((P_pAESCMACctx == NULL) || (P_pInputBuffer == NULL) || (P_inputSize == 0))
 8025f22:	2c00      	cmp	r4, #0
 8025f24:	d010      	beq.n	8025f48 <CA_AES_CMAC_Decrypt_Append+0x30>
 8025f26:	2800      	cmp	r0, #0
 8025f28:	d011      	beq.n	8025f4e <CA_AES_CMAC_Decrypt_Append+0x36>
 8025f2a:	2a00      	cmp	r2, #0
 8025f2c:	d012      	beq.n	8025f54 <CA_AES_CMAC_Decrypt_Append+0x3c>
    return CA_AES_ERR_BAD_PARAMETER;
  }
  error = CMAC_compute(P_pInputBuffer,
                       (uint32_t)P_inputSize,
                       P_pAESCMACctx->pmKey,
                       (uint32_t)(P_pAESCMACctx->mKeySize),
 8025f2e:	6a63      	ldr	r3, [r4, #36]	; 0x24
                       (uint32_t)(P_pAESCMACctx->mTagSize),
 8025f30:	6b25      	ldr	r5, [r4, #48]	; 0x30
                       P_pAESCMACctx->mac);
 8025f32:	0026      	movs	r6, r4
 8025f34:	3634      	adds	r6, #52	; 0x34
  error = CMAC_compute(P_pInputBuffer,
 8025f36:	68a2      	ldr	r2, [r4, #8]
 8025f38:	9601      	str	r6, [sp, #4]
 8025f3a:	9500      	str	r5, [sp, #0]
 8025f3c:	f7ff fca0 	bl	8025880 <CMAC_compute>
  if (error == MAC_SUCCESS)
 8025f40:	2800      	cmp	r0, #0
 8025f42:	d10a      	bne.n	8025f5a <CA_AES_CMAC_Decrypt_Append+0x42>
  }
  else
  {
    return CA_AES_ERR_BAD_OPERATION;
  }
}
 8025f44:	b002      	add	sp, #8
 8025f46:	bd70      	pop	{r4, r5, r6, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 8025f48:	20c2      	movs	r0, #194	; 0xc2
 8025f4a:	0100      	lsls	r0, r0, #4
 8025f4c:	e7fa      	b.n	8025f44 <CA_AES_CMAC_Decrypt_Append+0x2c>
 8025f4e:	20c2      	movs	r0, #194	; 0xc2
 8025f50:	0100      	lsls	r0, r0, #4
 8025f52:	e7f7      	b.n	8025f44 <CA_AES_CMAC_Decrypt_Append+0x2c>
 8025f54:	20c2      	movs	r0, #194	; 0xc2
 8025f56:	0100      	lsls	r0, r0, #4
 8025f58:	e7f4      	b.n	8025f44 <CA_AES_CMAC_Decrypt_Append+0x2c>
    return CA_AES_ERR_BAD_OPERATION;
 8025f5a:	4801      	ldr	r0, [pc, #4]	; (8025f60 <CA_AES_CMAC_Decrypt_Append+0x48>)
 8025f5c:	e7f2      	b.n	8025f44 <CA_AES_CMAC_Decrypt_Append+0x2c>
 8025f5e:	46c0      	nop			; (mov r8, r8)
 8025f60:	00000c1e 	.word	0x00000c1e

08025f64 <CA_AES_CMAC_Decrypt_Finish>:
  *             see note
  */
int32_t CA_AES_CMAC_Decrypt_Finish(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   uint8_t        *P_pOutputBuffer,
                                   int32_t        *P_pOutputSize)
{
 8025f64:	b510      	push	{r4, lr}
 8025f66:	1e03      	subs	r3, r0, #0
  (void)P_pOutputBuffer;
  if ((P_pAESCMACctx == NULL) || (P_pOutputSize == NULL))
 8025f68:	d00e      	beq.n	8025f88 <CA_AES_CMAC_Decrypt_Finish+0x24>
 8025f6a:	2a00      	cmp	r2, #0
 8025f6c:	d00f      	beq.n	8025f8e <CA_AES_CMAC_Decrypt_Finish+0x2a>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  *P_pOutputSize = 0;
 8025f6e:	2100      	movs	r1, #0
 8025f70:	6011      	str	r1, [r2, #0]
  if (memcmp(P_pAESCMACctx->pmTag, P_pAESCMACctx->mac, (uint32_t)(P_pAESCMACctx->mTagSize)) != 0)
 8025f72:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8025f74:	0019      	movs	r1, r3
 8025f76:	3134      	adds	r1, #52	; 0x34
 8025f78:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8025f7a:	f00e fbbd 	bl	80346f8 <memcmp>
 8025f7e:	2800      	cmp	r0, #0
 8025f80:	d008      	beq.n	8025f94 <CA_AES_CMAC_Decrypt_Finish+0x30>
  {
    return CA_AUTHENTICATION_FAILED;
 8025f82:	20fb      	movs	r0, #251	; 0xfb
 8025f84:	0080      	lsls	r0, r0, #2
  }
  else
  {
    return CA_AUTHENTICATION_SUCCESSFUL;
  }
}
 8025f86:	bd10      	pop	{r4, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 8025f88:	20c2      	movs	r0, #194	; 0xc2
 8025f8a:	0100      	lsls	r0, r0, #4
 8025f8c:	e7fb      	b.n	8025f86 <CA_AES_CMAC_Decrypt_Finish+0x22>
 8025f8e:	20c2      	movs	r0, #194	; 0xc2
 8025f90:	0100      	lsls	r0, r0, #4
 8025f92:	e7f8      	b.n	8025f86 <CA_AES_CMAC_Decrypt_Finish+0x22>
    return CA_AUTHENTICATION_SUCCESSFUL;
 8025f94:	4800      	ldr	r0, [pc, #0]	; (8025f98 <CA_AES_CMAC_Decrypt_Finish+0x34>)
 8025f96:	e7f6      	b.n	8025f86 <CA_AES_CMAC_Decrypt_Finish+0x22>
 8025f98:	000003eb 	.word	0x000003eb

08025f9c <CA_AES_ECB_Encrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_ECB_Encrypt_Init(CA_AESECBctx_stt *P_pAESECBctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8025f9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025f9e:	46ce      	mov	lr, r9
 8025fa0:	4647      	mov	r7, r8
 8025fa2:	b580      	push	{r7, lr}
 8025fa4:	b083      	sub	sp, #12
 8025fa6:	0004      	movs	r4, r0
 8025fa8:	000d      	movs	r5, r1
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pIv;

  if ((P_pAESECBctx == NULL) || (P_pKey == NULL))
 8025faa:	2800      	cmp	r0, #0
 8025fac:	d059      	beq.n	8026062 <CA_AES_ECB_Encrypt_Init+0xc6>
 8025fae:	2900      	cmp	r1, #0
 8025fb0:	d05a      	beq.n	8026068 <CA_AES_ECB_Encrypt_Init+0xcc>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if (P_pAESECBctx->mKeySize == 0)
 8025fb2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8025fb4:	2b00      	cmp	r3, #0
 8025fb6:	d05a      	beq.n	802606e <CA_AES_ECB_Encrypt_Init+0xd2>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESECBctx->CrypHandle));
 8025fb8:	232c      	movs	r3, #44	; 0x2c
 8025fba:	4698      	mov	r8, r3
 8025fbc:	4480      	add	r8, r0
 8025fbe:	4640      	mov	r0, r8
 8025fc0:	f7ff fc32 	bl	8025828 <cleanup_handle>
  P_pAESECBctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8025fc4:	4b2f      	ldr	r3, [pc, #188]	; (8026084 <CA_AES_ECB_Encrypt_Init+0xe8>)
 8025fc6:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESECBctx->CrypHandle) != HAL_OK)
 8025fc8:	4640      	mov	r0, r8
 8025fca:	f7fd fa8f 	bl	80234ec <HAL_CRYP_DeInit>
 8025fce:	2800      	cmp	r0, #0
 8025fd0:	d153      	bne.n	802607a <CA_AES_ECB_Encrypt_Init+0xde>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESECBctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 8025fd2:	2304      	movs	r3, #4
 8025fd4:	6323      	str	r3, [r4, #48]	; 0x30
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_WORD;
 8025fd6:	2300      	movs	r3, #0
 8025fd8:	6523      	str	r3, [r4, #80]	; 0x50
  if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8025fda:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8025fdc:	9301      	str	r3, [sp, #4]
 8025fde:	2b10      	cmp	r3, #16
 8025fe0:	d029      	beq.n	8026036 <CA_AES_ECB_Encrypt_Init+0x9a>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 8025fe2:	9b01      	ldr	r3, [sp, #4]
 8025fe4:	2b20      	cmp	r3, #32
 8025fe6:	d14a      	bne.n	802607e <CA_AES_ECB_Encrypt_Init+0xe2>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8025fe8:	2380      	movs	r3, #128	; 0x80
 8025fea:	02db      	lsls	r3, r3, #11
 8025fec:	6363      	str	r3, [r4, #52]	; 0x34
    /* Not supported by HW accelerator*/
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Init key here because of endianness */
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
 8025fee:	466b      	mov	r3, sp
 8025ff0:	791b      	ldrb	r3, [r3, #4]
 8025ff2:	089b      	lsrs	r3, r3, #2
 8025ff4:	4283      	cmp	r3, r0
 8025ff6:	d921      	bls.n	802603c <CA_AES_ECB_Encrypt_Init+0xa0>
  {
    P_pAESECBctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 8025ff8:	0087      	lsls	r7, r0, #2
 8025ffa:	1cfb      	adds	r3, r7, #3
 8025ffc:	469c      	mov	ip, r3
 8025ffe:	5ce9      	ldrb	r1, [r5, r3]
 8026000:	19e2      	adds	r2, r4, r7
 8026002:	3249      	adds	r2, #73	; 0x49
 8026004:	32ff      	adds	r2, #255	; 0xff
 8026006:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 8026008:	1cba      	adds	r2, r7, #2
 802600a:	1c79      	adds	r1, r7, #1
 802600c:	5cae      	ldrb	r6, [r5, r2]
 802600e:	46b1      	mov	r9, r6
 8026010:	1866      	adds	r6, r4, r1
 8026012:	3649      	adds	r6, #73	; 0x49
 8026014:	36ff      	adds	r6, #255	; 0xff
 8026016:	464b      	mov	r3, r9
 8026018:	7033      	strb	r3, [r6, #0]
    P_pAESECBctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 802601a:	5c69      	ldrb	r1, [r5, r1]
 802601c:	18a2      	adds	r2, r4, r2
 802601e:	3249      	adds	r2, #73	; 0x49
 8026020:	32ff      	adds	r2, #255	; 0xff
 8026022:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 8026024:	5dea      	ldrb	r2, [r5, r7]
 8026026:	4663      	mov	r3, ip
 8026028:	18e3      	adds	r3, r4, r3
 802602a:	3349      	adds	r3, #73	; 0x49
 802602c:	33ff      	adds	r3, #255	; 0xff
 802602e:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
 8026030:	3001      	adds	r0, #1
 8026032:	b2c0      	uxtb	r0, r0
 8026034:	e7db      	b.n	8025fee <CA_AES_ECB_Encrypt_Init+0x52>
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8026036:	2300      	movs	r3, #0
 8026038:	6363      	str	r3, [r4, #52]	; 0x34
 802603a:	e7d8      	b.n	8025fee <CA_AES_ECB_Encrypt_Init+0x52>
  }

  P_pAESECBctx->CrypHandle.Init.Algorithm       = CRYP_AES_ECB;
 802603c:	2300      	movs	r3, #0
 802603e:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESECBctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESECBctx->Key_endian);
 8026040:	0022      	movs	r2, r4
 8026042:	3249      	adds	r2, #73	; 0x49
 8026044:	32ff      	adds	r2, #255	; 0xff
 8026046:	63a2      	str	r2, [r4, #56]	; 0x38

  P_pAESECBctx->CrypHandle.Init.Header = NULL;
 8026048:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESECBctx->CrypHandle.Init.HeaderSize = 0;
 802604a:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESECBctx->CrypHandle.Init.B0 = NULL;
 802604c:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 802604e:	3301      	adds	r3, #1
 8026050:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESECBctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 8026052:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESECBctx->CrypHandle) != HAL_OK)
 8026054:	4640      	mov	r0, r8
 8026056:	f7fd fa23 	bl	80234a0 <HAL_CRYP_Init>
 802605a:	2800      	cmp	r0, #0
 802605c:	d008      	beq.n	8026070 <CA_AES_ECB_Encrypt_Init+0xd4>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 802605e:	480a      	ldr	r0, [pc, #40]	; (8026088 <CA_AES_ECB_Encrypt_Init+0xec>)
 8026060:	e006      	b.n	8026070 <CA_AES_ECB_Encrypt_Init+0xd4>
    return CA_AES_ERR_BAD_PARAMETER;
 8026062:	20c2      	movs	r0, #194	; 0xc2
 8026064:	0100      	lsls	r0, r0, #4
 8026066:	e003      	b.n	8026070 <CA_AES_ECB_Encrypt_Init+0xd4>
 8026068:	20c2      	movs	r0, #194	; 0xc2
 802606a:	0100      	lsls	r0, r0, #4
 802606c:	e000      	b.n	8026070 <CA_AES_ECB_Encrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 802606e:	4806      	ldr	r0, [pc, #24]	; (8026088 <CA_AES_ECB_Encrypt_Init+0xec>)
  }
  return aes_ret_status;
}
 8026070:	b003      	add	sp, #12
 8026072:	bcc0      	pop	{r6, r7}
 8026074:	46b9      	mov	r9, r7
 8026076:	46b0      	mov	r8, r6
 8026078:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 802607a:	4803      	ldr	r0, [pc, #12]	; (8026088 <CA_AES_ECB_Encrypt_Init+0xec>)
 802607c:	e7f8      	b.n	8026070 <CA_AES_ECB_Encrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 802607e:	4802      	ldr	r0, [pc, #8]	; (8026088 <CA_AES_ECB_Encrypt_Init+0xec>)
 8026080:	e7f6      	b.n	8026070 <CA_AES_ECB_Encrypt_Init+0xd4>
 8026082:	46c0      	nop			; (mov r8, r8)
 8026084:	58001800 	.word	0x58001800
 8026088:	00000c1f 	.word	0x00000c1f

0802608c <CA_AES_ECB_Encrypt_Append>:
int32_t CA_AES_ECB_Encrypt_Append(CA_AESECBctx_stt *P_pAESECBctx,
                                  const uint8_t *P_pInputBuffer,
                                  int32_t        P_inputSize,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 802608c:	b530      	push	{r4, r5, lr}
 802608e:	b083      	sub	sp, #12
 8026090:	0014      	movs	r4, r2

  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESECBctx == NULL)
 8026092:	2800      	cmp	r0, #0
 8026094:	d014      	beq.n	80260c0 <CA_AES_ECB_Encrypt_Append+0x34>
      || (P_pInputBuffer == NULL)
 8026096:	2900      	cmp	r1, #0
 8026098:	d015      	beq.n	80260c6 <CA_AES_ECB_Encrypt_Append+0x3a>
      || (P_pOutputBuffer == NULL)
 802609a:	2b00      	cmp	r3, #0
 802609c:	d016      	beq.n	80260cc <CA_AES_ECB_Encrypt_Append+0x40>
      || (P_pOutputSize == NULL))
 802609e:	9a06      	ldr	r2, [sp, #24]
 80260a0:	2a00      	cmp	r2, #0
 80260a2:	d016      	beq.n	80260d2 <CA_AES_ECB_Encrypt_Append+0x46>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if ((P_inputSize % (int32_t)CA_CRL_AES_BLOCK) != 0)
 80260a4:	0722      	lsls	r2, r4, #28
 80260a6:	d117      	bne.n	80260d8 <CA_AES_ECB_Encrypt_Append+0x4c>
  {
    return CA_AES_ERR_BAD_INPUT_SIZE;
  }

  if (HAL_CRYP_Encrypt(&P_pAESECBctx->CrypHandle, (uint32_t *)(uint32_t)P_pInputBuffer, (uint16_t)P_inputSize,
 80260a8:	b2a2      	uxth	r2, r4
 80260aa:	302c      	adds	r0, #44	; 0x2c
 80260ac:	25ff      	movs	r5, #255	; 0xff
 80260ae:	9500      	str	r5, [sp, #0]
 80260b0:	f7fd fd8c 	bl	8023bcc <HAL_CRYP_Encrypt>
 80260b4:	2800      	cmp	r0, #0
 80260b6:	d111      	bne.n	80260dc <CA_AES_ECB_Encrypt_Append+0x50>
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
  }
  else
  {
    *P_pOutputSize = P_inputSize;
 80260b8:	9b06      	ldr	r3, [sp, #24]
 80260ba:	601c      	str	r4, [r3, #0]
  }

  return aes_ret_status;
}
 80260bc:	b003      	add	sp, #12
 80260be:	bd30      	pop	{r4, r5, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 80260c0:	20c2      	movs	r0, #194	; 0xc2
 80260c2:	0100      	lsls	r0, r0, #4
 80260c4:	e7fa      	b.n	80260bc <CA_AES_ECB_Encrypt_Append+0x30>
 80260c6:	20c2      	movs	r0, #194	; 0xc2
 80260c8:	0100      	lsls	r0, r0, #4
 80260ca:	e7f7      	b.n	80260bc <CA_AES_ECB_Encrypt_Append+0x30>
 80260cc:	20c2      	movs	r0, #194	; 0xc2
 80260ce:	0100      	lsls	r0, r0, #4
 80260d0:	e7f4      	b.n	80260bc <CA_AES_ECB_Encrypt_Append+0x30>
 80260d2:	20c2      	movs	r0, #194	; 0xc2
 80260d4:	0100      	lsls	r0, r0, #4
 80260d6:	e7f1      	b.n	80260bc <CA_AES_ECB_Encrypt_Append+0x30>
    return CA_AES_ERR_BAD_INPUT_SIZE;
 80260d8:	4801      	ldr	r0, [pc, #4]	; (80260e0 <CA_AES_ECB_Encrypt_Append+0x54>)
 80260da:	e7ef      	b.n	80260bc <CA_AES_ECB_Encrypt_Append+0x30>
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 80260dc:	4801      	ldr	r0, [pc, #4]	; (80260e4 <CA_AES_ECB_Encrypt_Append+0x58>)
 80260de:	e7ed      	b.n	80260bc <CA_AES_ECB_Encrypt_Append+0x30>
 80260e0:	00000c1d 	.word	0x00000c1d
 80260e4:	00000c1e 	.word	0x00000c1e

080260e8 <CA_AES_ECB_Encrypt_Finish>:
  * @retval     CA_AES_SUCCESS: Operation Successful
  */
int32_t CA_AES_ECB_Encrypt_Finish(CA_AESECBctx_stt *P_pAESECBctx,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 80260e8:	b570      	push	{r4, r5, r6, lr}
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pOutputBuffer;
  (void)P_pOutputSize;

  if (HAL_CRYP_DeInit(&P_pAESECBctx->CrypHandle) != HAL_OK)
 80260ea:	302c      	adds	r0, #44	; 0x2c
 80260ec:	0004      	movs	r4, r0
 80260ee:	f7fd f9fd 	bl	80234ec <HAL_CRYP_DeInit>
 80260f2:	2800      	cmp	r0, #0
 80260f4:	d105      	bne.n	8026102 <CA_AES_ECB_Encrypt_Finish+0x1a>
  int32_t aes_ret_status = CA_AES_SUCCESS;
 80260f6:	2500      	movs	r5, #0
  {
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
  }
  cleanup_handle(&(P_pAESECBctx->CrypHandle));
 80260f8:	0020      	movs	r0, r4
 80260fa:	f7ff fb95 	bl	8025828 <cleanup_handle>

  return aes_ret_status;
}
 80260fe:	0028      	movs	r0, r5
 8026100:	bd70      	pop	{r4, r5, r6, pc}
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
 8026102:	25c2      	movs	r5, #194	; 0xc2
 8026104:	012d      	lsls	r5, r5, #4
 8026106:	e7f7      	b.n	80260f8 <CA_AES_ECB_Encrypt_Finish+0x10>

08026108 <CA_AES_ECB_Decrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_ECB_Decrypt_Init(CA_AESECBctx_stt *P_pAESECBctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8026108:	b5f0      	push	{r4, r5, r6, r7, lr}
 802610a:	46ce      	mov	lr, r9
 802610c:	4647      	mov	r7, r8
 802610e:	b580      	push	{r7, lr}
 8026110:	b083      	sub	sp, #12
 8026112:	0004      	movs	r4, r0
 8026114:	000d      	movs	r5, r1
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pIv;

  if ((P_pAESECBctx == NULL) || (P_pKey == NULL))
 8026116:	2800      	cmp	r0, #0
 8026118:	d059      	beq.n	80261ce <CA_AES_ECB_Decrypt_Init+0xc6>
 802611a:	2900      	cmp	r1, #0
 802611c:	d05a      	beq.n	80261d4 <CA_AES_ECB_Decrypt_Init+0xcc>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if (P_pAESECBctx->mKeySize == 0)
 802611e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8026120:	2b00      	cmp	r3, #0
 8026122:	d05a      	beq.n	80261da <CA_AES_ECB_Decrypt_Init+0xd2>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESECBctx->CrypHandle));
 8026124:	232c      	movs	r3, #44	; 0x2c
 8026126:	4698      	mov	r8, r3
 8026128:	4480      	add	r8, r0
 802612a:	4640      	mov	r0, r8
 802612c:	f7ff fb7c 	bl	8025828 <cleanup_handle>
  P_pAESECBctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8026130:	4b2f      	ldr	r3, [pc, #188]	; (80261f0 <CA_AES_ECB_Decrypt_Init+0xe8>)
 8026132:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESECBctx->CrypHandle) != HAL_OK)
 8026134:	4640      	mov	r0, r8
 8026136:	f7fd f9d9 	bl	80234ec <HAL_CRYP_DeInit>
 802613a:	2800      	cmp	r0, #0
 802613c:	d153      	bne.n	80261e6 <CA_AES_ECB_Decrypt_Init+0xde>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESECBctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 802613e:	2304      	movs	r3, #4
 8026140:	6323      	str	r3, [r4, #48]	; 0x30
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_WORD;
 8026142:	2300      	movs	r3, #0
 8026144:	6523      	str	r3, [r4, #80]	; 0x50
  if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8026146:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8026148:	9301      	str	r3, [sp, #4]
 802614a:	2b10      	cmp	r3, #16
 802614c:	d029      	beq.n	80261a2 <CA_AES_ECB_Decrypt_Init+0x9a>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 802614e:	9b01      	ldr	r3, [sp, #4]
 8026150:	2b20      	cmp	r3, #32
 8026152:	d14a      	bne.n	80261ea <CA_AES_ECB_Decrypt_Init+0xe2>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8026154:	2380      	movs	r3, #128	; 0x80
 8026156:	02db      	lsls	r3, r3, #11
 8026158:	6363      	str	r3, [r4, #52]	; 0x34
    /* Not supported by HW accelerator*/
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Init key here because of endianness */
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
 802615a:	466b      	mov	r3, sp
 802615c:	791b      	ldrb	r3, [r3, #4]
 802615e:	089b      	lsrs	r3, r3, #2
 8026160:	4283      	cmp	r3, r0
 8026162:	d921      	bls.n	80261a8 <CA_AES_ECB_Decrypt_Init+0xa0>
  {
    P_pAESECBctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 8026164:	0087      	lsls	r7, r0, #2
 8026166:	1cfb      	adds	r3, r7, #3
 8026168:	469c      	mov	ip, r3
 802616a:	5ce9      	ldrb	r1, [r5, r3]
 802616c:	19e2      	adds	r2, r4, r7
 802616e:	3249      	adds	r2, #73	; 0x49
 8026170:	32ff      	adds	r2, #255	; 0xff
 8026172:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 8026174:	1cba      	adds	r2, r7, #2
 8026176:	1c79      	adds	r1, r7, #1
 8026178:	5cae      	ldrb	r6, [r5, r2]
 802617a:	46b1      	mov	r9, r6
 802617c:	1866      	adds	r6, r4, r1
 802617e:	3649      	adds	r6, #73	; 0x49
 8026180:	36ff      	adds	r6, #255	; 0xff
 8026182:	464b      	mov	r3, r9
 8026184:	7033      	strb	r3, [r6, #0]
    P_pAESECBctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8026186:	5c69      	ldrb	r1, [r5, r1]
 8026188:	18a2      	adds	r2, r4, r2
 802618a:	3249      	adds	r2, #73	; 0x49
 802618c:	32ff      	adds	r2, #255	; 0xff
 802618e:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 8026190:	5dea      	ldrb	r2, [r5, r7]
 8026192:	4663      	mov	r3, ip
 8026194:	18e3      	adds	r3, r4, r3
 8026196:	3349      	adds	r3, #73	; 0x49
 8026198:	33ff      	adds	r3, #255	; 0xff
 802619a:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
 802619c:	3001      	adds	r0, #1
 802619e:	b2c0      	uxtb	r0, r0
 80261a0:	e7db      	b.n	802615a <CA_AES_ECB_Decrypt_Init+0x52>
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 80261a2:	2300      	movs	r3, #0
 80261a4:	6363      	str	r3, [r4, #52]	; 0x34
 80261a6:	e7d8      	b.n	802615a <CA_AES_ECB_Decrypt_Init+0x52>
  }
  P_pAESECBctx->CrypHandle.Init.Algorithm       = CRYP_AES_ECB;
 80261a8:	2300      	movs	r3, #0
 80261aa:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESECBctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESECBctx->Key_endian);
 80261ac:	0022      	movs	r2, r4
 80261ae:	3249      	adds	r2, #73	; 0x49
 80261b0:	32ff      	adds	r2, #255	; 0xff
 80261b2:	63a2      	str	r2, [r4, #56]	; 0x38

  P_pAESECBctx->CrypHandle.Init.Header = NULL;
 80261b4:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESECBctx->CrypHandle.Init.HeaderSize = 0;
 80261b6:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESECBctx->CrypHandle.Init.B0 = NULL;
 80261b8:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 80261ba:	3301      	adds	r3, #1
 80261bc:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESECBctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 80261be:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESECBctx->CrypHandle) != HAL_OK)
 80261c0:	4640      	mov	r0, r8
 80261c2:	f7fd f96d 	bl	80234a0 <HAL_CRYP_Init>
 80261c6:	2800      	cmp	r0, #0
 80261c8:	d008      	beq.n	80261dc <CA_AES_ECB_Decrypt_Init+0xd4>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 80261ca:	480a      	ldr	r0, [pc, #40]	; (80261f4 <CA_AES_ECB_Decrypt_Init+0xec>)
 80261cc:	e006      	b.n	80261dc <CA_AES_ECB_Decrypt_Init+0xd4>
    return CA_AES_ERR_BAD_PARAMETER;
 80261ce:	20c2      	movs	r0, #194	; 0xc2
 80261d0:	0100      	lsls	r0, r0, #4
 80261d2:	e003      	b.n	80261dc <CA_AES_ECB_Decrypt_Init+0xd4>
 80261d4:	20c2      	movs	r0, #194	; 0xc2
 80261d6:	0100      	lsls	r0, r0, #4
 80261d8:	e000      	b.n	80261dc <CA_AES_ECB_Decrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 80261da:	4806      	ldr	r0, [pc, #24]	; (80261f4 <CA_AES_ECB_Decrypt_Init+0xec>)
  }
  return aes_ret_status;
}
 80261dc:	b003      	add	sp, #12
 80261de:	bcc0      	pop	{r6, r7}
 80261e0:	46b9      	mov	r9, r7
 80261e2:	46b0      	mov	r8, r6
 80261e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 80261e6:	4803      	ldr	r0, [pc, #12]	; (80261f4 <CA_AES_ECB_Decrypt_Init+0xec>)
 80261e8:	e7f8      	b.n	80261dc <CA_AES_ECB_Decrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 80261ea:	4802      	ldr	r0, [pc, #8]	; (80261f4 <CA_AES_ECB_Decrypt_Init+0xec>)
 80261ec:	e7f6      	b.n	80261dc <CA_AES_ECB_Decrypt_Init+0xd4>
 80261ee:	46c0      	nop			; (mov r8, r8)
 80261f0:	58001800 	.word	0x58001800
 80261f4:	00000c1f 	.word	0x00000c1f

080261f8 <CA_AES_GCM_Encrypt_Init>:
  *                                  see note
  */
int32_t CA_AES_GCM_Encrypt_Init(CA_AESGCMctx_stt *P_pAESGCMctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 80261f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80261fa:	46de      	mov	lr, fp
 80261fc:	4657      	mov	r7, sl
 80261fe:	464e      	mov	r6, r9
 8026200:	4645      	mov	r5, r8
 8026202:	b5e0      	push	{r5, r6, r7, lr}
 8026204:	b083      	sub	sp, #12
 8026206:	0004      	movs	r4, r0
 8026208:	000d      	movs	r5, r1
 802620a:	0017      	movs	r7, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESGCMctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 802620c:	2800      	cmp	r0, #0
 802620e:	d100      	bne.n	8026212 <CA_AES_GCM_Encrypt_Init+0x1a>
 8026210:	e0a0      	b.n	8026354 <CA_AES_GCM_Encrypt_Init+0x15c>
 8026212:	2900      	cmp	r1, #0
 8026214:	d100      	bne.n	8026218 <CA_AES_GCM_Encrypt_Init+0x20>
 8026216:	e0a0      	b.n	802635a <CA_AES_GCM_Encrypt_Init+0x162>
 8026218:	2a00      	cmp	r2, #0
 802621a:	d100      	bne.n	802621e <CA_AES_GCM_Encrypt_Init+0x26>
 802621c:	e0a0      	b.n	8026360 <CA_AES_GCM_Encrypt_Init+0x168>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->mKeySize == 0) || (P_pAESGCMctx->mIvSize != 12))
 802621e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8026220:	2b00      	cmp	r3, #0
 8026222:	d100      	bne.n	8026226 <CA_AES_GCM_Encrypt_Init+0x2e>
 8026224:	e09f      	b.n	8026366 <CA_AES_GCM_Encrypt_Init+0x16e>
 8026226:	6903      	ldr	r3, [r0, #16]
 8026228:	2b0c      	cmp	r3, #12
 802622a:	d007      	beq.n	802623c <CA_AES_GCM_Encrypt_Init+0x44>
  {
    return CA_AES_ERR_BAD_CONTEXT;
 802622c:	4851      	ldr	r0, [pc, #324]	; (8026374 <CA_AES_GCM_Encrypt_Init+0x17c>)
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;

  P_pAESGCMctx->flags = GCM_ENCRYPTION_ONGOING | GCM_INIT_NOT_DONE;
  return aes_ret_status;
}
 802622e:	b003      	add	sp, #12
 8026230:	bcf0      	pop	{r4, r5, r6, r7}
 8026232:	46bb      	mov	fp, r7
 8026234:	46b2      	mov	sl, r6
 8026236:	46a9      	mov	r9, r5
 8026238:	46a0      	mov	r8, r4
 802623a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleanup_handle(&(P_pAESGCMctx->CrypHandle));
 802623c:	0006      	movs	r6, r0
 802623e:	3634      	adds	r6, #52	; 0x34
 8026240:	0030      	movs	r0, r6
 8026242:	f7ff faf1 	bl	8025828 <cleanup_handle>
  P_pAESGCMctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8026246:	4b4c      	ldr	r3, [pc, #304]	; (8026378 <CA_AES_GCM_Encrypt_Init+0x180>)
 8026248:	6363      	str	r3, [r4, #52]	; 0x34
  if (HAL_CRYP_DeInit(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 802624a:	0030      	movs	r0, r6
 802624c:	f7fd f94e 	bl	80234ec <HAL_CRYP_DeInit>
 8026250:	4683      	mov	fp, r0
 8026252:	1e03      	subs	r3, r0, #0
 8026254:	d000      	beq.n	8026258 <CA_AES_GCM_Encrypt_Init+0x60>
 8026256:	e088      	b.n	802636a <CA_AES_GCM_Encrypt_Init+0x172>
  P_pAESGCMctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 8026258:	3304      	adds	r3, #4
 802625a:	63a3      	str	r3, [r4, #56]	; 0x38
  if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 802625c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802625e:	9300      	str	r3, [sp, #0]
 8026260:	2b10      	cmp	r3, #16
 8026262:	d007      	beq.n	8026274 <CA_AES_GCM_Encrypt_Init+0x7c>
  else if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 8026264:	9b00      	ldr	r3, [sp, #0]
 8026266:	2b20      	cmp	r3, #32
 8026268:	d000      	beq.n	802626c <CA_AES_GCM_Encrypt_Init+0x74>
 802626a:	e080      	b.n	802636e <CA_AES_GCM_Encrypt_Init+0x176>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 802626c:	2380      	movs	r3, #128	; 0x80
 802626e:	02db      	lsls	r3, r3, #11
 8026270:	63e3      	str	r3, [r4, #60]	; 0x3c
 8026272:	e026      	b.n	80262c2 <CA_AES_GCM_Encrypt_Init+0xca>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8026274:	2300      	movs	r3, #0
 8026276:	63e3      	str	r3, [r4, #60]	; 0x3c
 8026278:	e023      	b.n	80262c2 <CA_AES_GCM_Encrypt_Init+0xca>
    P_pAESGCMctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 802627a:	0081      	lsls	r1, r0, #2
 802627c:	1ccb      	adds	r3, r1, #3
 802627e:	9301      	str	r3, [sp, #4]
 8026280:	5cfa      	ldrb	r2, [r7, r3]
 8026282:	4690      	mov	r8, r2
 8026284:	1862      	adds	r2, r4, r1
 8026286:	3241      	adds	r2, #65	; 0x41
 8026288:	32ff      	adds	r2, #255	; 0xff
 802628a:	4646      	mov	r6, r8
 802628c:	7016      	strb	r6, [r2, #0]
    P_pAESGCMctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 802628e:	1c8a      	adds	r2, r1, #2
 8026290:	1c4e      	adds	r6, r1, #1
 8026292:	46b1      	mov	r9, r6
 8026294:	5cbe      	ldrb	r6, [r7, r2]
 8026296:	46b2      	mov	sl, r6
 8026298:	46a0      	mov	r8, r4
 802629a:	44c8      	add	r8, r9
 802629c:	26a0      	movs	r6, #160	; 0xa0
 802629e:	0076      	lsls	r6, r6, #1
 80262a0:	46b4      	mov	ip, r6
 80262a2:	44e0      	add	r8, ip
 80262a4:	4646      	mov	r6, r8
 80262a6:	4653      	mov	r3, sl
 80262a8:	7033      	strb	r3, [r6, #0]
    P_pAESGCMctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 80262aa:	464b      	mov	r3, r9
 80262ac:	5cfb      	ldrb	r3, [r7, r3]
 80262ae:	18a2      	adds	r2, r4, r2
 80262b0:	4462      	add	r2, ip
 80262b2:	7013      	strb	r3, [r2, #0]
    P_pAESGCMctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 80262b4:	5c7a      	ldrb	r2, [r7, r1]
 80262b6:	9b01      	ldr	r3, [sp, #4]
 80262b8:	18e3      	adds	r3, r4, r3
 80262ba:	4463      	add	r3, ip
 80262bc:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 3U; i++)
 80262be:	3001      	adds	r0, #1
 80262c0:	b2c0      	uxtb	r0, r0
 80262c2:	2802      	cmp	r0, #2
 80262c4:	d9d9      	bls.n	802627a <CA_AES_GCM_Encrypt_Init+0x82>
  P_pAESGCMctx->Iv_endian[12] = 2;
 80262c6:	23a6      	movs	r3, #166	; 0xa6
 80262c8:	005b      	lsls	r3, r3, #1
 80262ca:	2202      	movs	r2, #2
 80262cc:	54e2      	strb	r2, [r4, r3]
  P_pAESGCMctx->Iv_endian[13] = 0;
 80262ce:	2300      	movs	r3, #0
 80262d0:	224e      	movs	r2, #78	; 0x4e
 80262d2:	32ff      	adds	r2, #255	; 0xff
 80262d4:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[14] = 0;
 80262d6:	3201      	adds	r2, #1
 80262d8:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[15] = 0;
 80262da:	2250      	movs	r2, #80	; 0x50
 80262dc:	32ff      	adds	r2, #255	; 0xff
 80262de:	54a3      	strb	r3, [r4, r2]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 80262e0:	e01e      	b.n	8026320 <CA_AES_GCM_Encrypt_Init+0x128>
    P_pAESGCMctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 80262e2:	465b      	mov	r3, fp
 80262e4:	0098      	lsls	r0, r3, #2
 80262e6:	1cc3      	adds	r3, r0, #3
 80262e8:	5cef      	ldrb	r7, [r5, r3]
 80262ea:	1822      	adds	r2, r4, r0
 80262ec:	3251      	adds	r2, #81	; 0x51
 80262ee:	32ff      	adds	r2, #255	; 0xff
 80262f0:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 80262f2:	1c82      	adds	r2, r0, #2
 80262f4:	1c41      	adds	r1, r0, #1
 80262f6:	5caf      	ldrb	r7, [r5, r2]
 80262f8:	46b8      	mov	r8, r7
 80262fa:	1867      	adds	r7, r4, r1
 80262fc:	3751      	adds	r7, #81	; 0x51
 80262fe:	37ff      	adds	r7, #255	; 0xff
 8026300:	4646      	mov	r6, r8
 8026302:	703e      	strb	r6, [r7, #0]
    P_pAESGCMctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8026304:	5c6f      	ldrb	r7, [r5, r1]
 8026306:	18a2      	adds	r2, r4, r2
 8026308:	3251      	adds	r2, #81	; 0x51
 802630a:	32ff      	adds	r2, #255	; 0xff
 802630c:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 802630e:	5c2a      	ldrb	r2, [r5, r0]
 8026310:	18e3      	adds	r3, r4, r3
 8026312:	3351      	adds	r3, #81	; 0x51
 8026314:	33ff      	adds	r3, #255	; 0xff
 8026316:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 8026318:	465e      	mov	r6, fp
 802631a:	3601      	adds	r6, #1
 802631c:	b2f3      	uxtb	r3, r6
 802631e:	469b      	mov	fp, r3
 8026320:	466b      	mov	r3, sp
 8026322:	781b      	ldrb	r3, [r3, #0]
 8026324:	089b      	lsrs	r3, r3, #2
 8026326:	455b      	cmp	r3, fp
 8026328:	d8db      	bhi.n	80262e2 <CA_AES_GCM_Encrypt_Init+0xea>
  P_pAESGCMctx->CrypHandle.Init.Algorithm       = CRYP_AES_GCM_GMAC;
 802632a:	2360      	movs	r3, #96	; 0x60
 802632c:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESGCMctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESGCMctx->Key_endian);
 802632e:	0023      	movs	r3, r4
 8026330:	3351      	adds	r3, #81	; 0x51
 8026332:	33ff      	adds	r3, #255	; 0xff
 8026334:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESGCMctx->CrypHandle.Init.pInitVect       = (uint32_t *)(uint32_t)(P_pAESGCMctx->Iv_endian);
 8026336:	3b10      	subs	r3, #16
 8026338:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESGCMctx->CrypHandle.Init.Header = NULL;
 802633a:	2300      	movs	r3, #0
 802633c:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESGCMctx->CrypHandle.Init.HeaderSize = 0;
 802633e:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESGCMctx->CrypHandle.Init.B0 = NULL;
 8026340:	6563      	str	r3, [r4, #84]	; 0x54
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8026342:	3301      	adds	r3, #1
 8026344:	65a3      	str	r3, [r4, #88]	; 0x58
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 8026346:	6623      	str	r3, [r4, #96]	; 0x60
  P_pAESGCMctx->flags = GCM_ENCRYPTION_ONGOING | GCM_INIT_NOT_DONE;
 8026348:	3370      	adds	r3, #112	; 0x70
 802634a:	33ff      	adds	r3, #255	; 0xff
 802634c:	2209      	movs	r2, #9
 802634e:	50e2      	str	r2, [r4, r3]
  return aes_ret_status;
 8026350:	2000      	movs	r0, #0
 8026352:	e76c      	b.n	802622e <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_PARAMETER;
 8026354:	20c2      	movs	r0, #194	; 0xc2
 8026356:	0100      	lsls	r0, r0, #4
 8026358:	e769      	b.n	802622e <CA_AES_GCM_Encrypt_Init+0x36>
 802635a:	20c2      	movs	r0, #194	; 0xc2
 802635c:	0100      	lsls	r0, r0, #4
 802635e:	e766      	b.n	802622e <CA_AES_GCM_Encrypt_Init+0x36>
 8026360:	20c2      	movs	r0, #194	; 0xc2
 8026362:	0100      	lsls	r0, r0, #4
 8026364:	e763      	b.n	802622e <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 8026366:	4803      	ldr	r0, [pc, #12]	; (8026374 <CA_AES_GCM_Encrypt_Init+0x17c>)
 8026368:	e761      	b.n	802622e <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 802636a:	4802      	ldr	r0, [pc, #8]	; (8026374 <CA_AES_GCM_Encrypt_Init+0x17c>)
 802636c:	e75f      	b.n	802622e <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 802636e:	4801      	ldr	r0, [pc, #4]	; (8026374 <CA_AES_GCM_Encrypt_Init+0x17c>)
 8026370:	e75d      	b.n	802622e <CA_AES_GCM_Encrypt_Init+0x36>
 8026372:	46c0      	nop			; (mov r8, r8)
 8026374:	00000c1f 	.word	0x00000c1f
 8026378:	58001800 	.word	0x58001800

0802637c <CA_AES_GCM_Encrypt_Append>:
int32_t CA_AES_GCM_Encrypt_Append(CA_AESGCMctx_stt *P_pAESGCMctx,
                                  const uint8_t *P_pInputBuffer,
                                  int32_t        P_inputSize,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 802637c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802637e:	b083      	sub	sp, #12
 8026380:	0004      	movs	r4, r0
 8026382:	000d      	movs	r5, r1
 8026384:	0016      	movs	r6, r2
 8026386:	001f      	movs	r7, r3
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESGCMctx == NULL)
 8026388:	2800      	cmp	r0, #0
 802638a:	d02b      	beq.n	80263e4 <CA_AES_GCM_Encrypt_Append+0x68>
      || (P_pInputBuffer == NULL)
 802638c:	2900      	cmp	r1, #0
 802638e:	d02c      	beq.n	80263ea <CA_AES_GCM_Encrypt_Append+0x6e>
      || (P_pOutputBuffer == NULL)
 8026390:	2b00      	cmp	r3, #0
 8026392:	d02d      	beq.n	80263f0 <CA_AES_GCM_Encrypt_Append+0x74>
      || (P_pOutputSize == NULL))
 8026394:	9b08      	ldr	r3, [sp, #32]
 8026396:	2b00      	cmp	r3, #0
 8026398:	d02d      	beq.n	80263f6 <CA_AES_GCM_Encrypt_Append+0x7a>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->flags & GCM_INIT_NOT_DONE) == GCM_INIT_NOT_DONE)
 802639a:	23b8      	movs	r3, #184	; 0xb8
 802639c:	005b      	lsls	r3, r3, #1
 802639e:	58c3      	ldr	r3, [r0, r3]
 80263a0:	071b      	lsls	r3, r3, #28
 80263a2:	d50a      	bpl.n	80263ba <CA_AES_GCM_Encrypt_Append+0x3e>
  {
    if (HAL_CRYP_Init(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 80263a4:	3034      	adds	r0, #52	; 0x34
 80263a6:	f7fd f87b 	bl	80234a0 <HAL_CRYP_Init>
 80263aa:	2800      	cmp	r0, #0
 80263ac:	d115      	bne.n	80263da <CA_AES_GCM_Encrypt_Append+0x5e>
    {
      *P_pOutputSize = 0;
      return CA_AES_ERR_BAD_OPERATION;
    }
    P_pAESGCMctx->flags &= ~ GCM_INIT_NOT_DONE;
 80263ae:	22b8      	movs	r2, #184	; 0xb8
 80263b0:	0052      	lsls	r2, r2, #1
 80263b2:	2308      	movs	r3, #8
 80263b4:	58a1      	ldr	r1, [r4, r2]
 80263b6:	4399      	bics	r1, r3
 80263b8:	50a1      	str	r1, [r4, r2]
  }
  if (HAL_CRYP_Encrypt(&P_pAESGCMctx->CrypHandle, (uint32_t *)(uint32_t)P_pInputBuffer, (uint16_t)P_inputSize,
 80263ba:	b2b2      	uxth	r2, r6
 80263bc:	0020      	movs	r0, r4
 80263be:	3034      	adds	r0, #52	; 0x34
 80263c0:	23ff      	movs	r3, #255	; 0xff
 80263c2:	9300      	str	r3, [sp, #0]
 80263c4:	003b      	movs	r3, r7
 80263c6:	0029      	movs	r1, r5
 80263c8:	f7fd fc00 	bl	8023bcc <HAL_CRYP_Encrypt>
 80263cc:	2800      	cmp	r0, #0
 80263ce:	d000      	beq.n	80263d2 <CA_AES_GCM_Encrypt_Append+0x56>
                       (uint32_t *)(uint32_t)P_pOutputBuffer,
                       TIMEOUT_VALUE) != HAL_OK)
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 80263d0:	480a      	ldr	r0, [pc, #40]	; (80263fc <CA_AES_GCM_Encrypt_Append+0x80>)
  }

  *P_pOutputSize = P_inputSize;
 80263d2:	9b08      	ldr	r3, [sp, #32]
 80263d4:	601e      	str	r6, [r3, #0]
  return aes_ret_status;
}
 80263d6:	b003      	add	sp, #12
 80263d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *P_pOutputSize = 0;
 80263da:	2300      	movs	r3, #0
 80263dc:	9a08      	ldr	r2, [sp, #32]
 80263de:	6013      	str	r3, [r2, #0]
      return CA_AES_ERR_BAD_OPERATION;
 80263e0:	4806      	ldr	r0, [pc, #24]	; (80263fc <CA_AES_GCM_Encrypt_Append+0x80>)
 80263e2:	e7f8      	b.n	80263d6 <CA_AES_GCM_Encrypt_Append+0x5a>
    return CA_AES_ERR_BAD_PARAMETER;
 80263e4:	20c2      	movs	r0, #194	; 0xc2
 80263e6:	0100      	lsls	r0, r0, #4
 80263e8:	e7f5      	b.n	80263d6 <CA_AES_GCM_Encrypt_Append+0x5a>
 80263ea:	20c2      	movs	r0, #194	; 0xc2
 80263ec:	0100      	lsls	r0, r0, #4
 80263ee:	e7f2      	b.n	80263d6 <CA_AES_GCM_Encrypt_Append+0x5a>
 80263f0:	20c2      	movs	r0, #194	; 0xc2
 80263f2:	0100      	lsls	r0, r0, #4
 80263f4:	e7ef      	b.n	80263d6 <CA_AES_GCM_Encrypt_Append+0x5a>
 80263f6:	20c2      	movs	r0, #194	; 0xc2
 80263f8:	0100      	lsls	r0, r0, #4
 80263fa:	e7ec      	b.n	80263d6 <CA_AES_GCM_Encrypt_Append+0x5a>
 80263fc:	00000c1e 	.word	0x00000c1e

08026400 <CA_AES_GCM_Encrypt_Finish>:
  *                                  See note
  */
int32_t CA_AES_GCM_Encrypt_Finish(CA_AESGCMctx_stt *P_pAESGCMctx,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 8026400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8026402:	0004      	movs	r4, r0
 8026404:	0015      	movs	r5, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;


  if ((P_pAESGCMctx == NULL) || (P_pOutputBuffer == NULL) || (P_pOutputSize == NULL))
 8026406:	2800      	cmp	r0, #0
 8026408:	d01e      	beq.n	8026448 <CA_AES_GCM_Encrypt_Finish+0x48>
 802640a:	2900      	cmp	r1, #0
 802640c:	d01f      	beq.n	802644e <CA_AES_GCM_Encrypt_Finish+0x4e>
 802640e:	2a00      	cmp	r2, #0
 8026410:	d020      	beq.n	8026454 <CA_AES_GCM_Encrypt_Finish+0x54>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->mTagSize < 0) || (P_pAESGCMctx->mTagSize > 16))
 8026412:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8026414:	2b10      	cmp	r3, #16
 8026416:	d820      	bhi.n	802645a <CA_AES_GCM_Encrypt_Finish+0x5a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  if (HAL_CRYPEx_AESGCM_GenerateAuthTAG(&P_pAESGCMctx->CrypHandle,
 8026418:	0007      	movs	r7, r0
 802641a:	3734      	adds	r7, #52	; 0x34
 802641c:	22ff      	movs	r2, #255	; 0xff
 802641e:	0038      	movs	r0, r7
 8026420:	f7fd fc8e 	bl	8023d40 <HAL_CRYPEx_AESGCM_GenerateAuthTAG>
 8026424:	2800      	cmp	r0, #0
 8026426:	d10d      	bne.n	8026444 <CA_AES_GCM_Encrypt_Finish+0x44>
  int32_t aes_ret_status = CA_AES_SUCCESS;
 8026428:	2600      	movs	r6, #0
                                        (uint32_t *)(uint32_t)P_pOutputBuffer, TIMEOUT_VALUE) != HAL_OK)
  {
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
  }

  if (HAL_CRYP_DeInit(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 802642a:	0038      	movs	r0, r7
 802642c:	f7fd f85e 	bl	80234ec <HAL_CRYP_DeInit>
 8026430:	2800      	cmp	r0, #0
 8026432:	d000      	beq.n	8026436 <CA_AES_GCM_Encrypt_Finish+0x36>
  {
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 8026434:	4e0a      	ldr	r6, [pc, #40]	; (8026460 <CA_AES_GCM_Encrypt_Finish+0x60>)
  }
  cleanup_handle(&(P_pAESGCMctx->CrypHandle));
 8026436:	0038      	movs	r0, r7
 8026438:	f7ff f9f6 	bl	8025828 <cleanup_handle>

  *P_pOutputSize = P_pAESGCMctx->mTagSize;
 802643c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 802643e:	602b      	str	r3, [r5, #0]

  return aes_ret_status;
}
 8026440:	0030      	movs	r0, r6
 8026442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 8026444:	4e06      	ldr	r6, [pc, #24]	; (8026460 <CA_AES_GCM_Encrypt_Finish+0x60>)
 8026446:	e7f0      	b.n	802642a <CA_AES_GCM_Encrypt_Finish+0x2a>
    return CA_AES_ERR_BAD_PARAMETER;
 8026448:	26c2      	movs	r6, #194	; 0xc2
 802644a:	0136      	lsls	r6, r6, #4
 802644c:	e7f8      	b.n	8026440 <CA_AES_GCM_Encrypt_Finish+0x40>
 802644e:	26c2      	movs	r6, #194	; 0xc2
 8026450:	0136      	lsls	r6, r6, #4
 8026452:	e7f5      	b.n	8026440 <CA_AES_GCM_Encrypt_Finish+0x40>
 8026454:	26c2      	movs	r6, #194	; 0xc2
 8026456:	0136      	lsls	r6, r6, #4
 8026458:	e7f2      	b.n	8026440 <CA_AES_GCM_Encrypt_Finish+0x40>
    return CA_AES_ERR_BAD_CONTEXT;
 802645a:	4e01      	ldr	r6, [pc, #4]	; (8026460 <CA_AES_GCM_Encrypt_Finish+0x60>)
 802645c:	e7f0      	b.n	8026440 <CA_AES_GCM_Encrypt_Finish+0x40>
 802645e:	46c0      	nop			; (mov r8, r8)
 8026460:	00000c1f 	.word	0x00000c1f

08026464 <CA_AES_GCM_Decrypt_Init>:
  *                                  see note
  */
int32_t CA_AES_GCM_Decrypt_Init(CA_AESGCMctx_stt *P_pAESGCMctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8026464:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026466:	46de      	mov	lr, fp
 8026468:	4657      	mov	r7, sl
 802646a:	464e      	mov	r6, r9
 802646c:	4645      	mov	r5, r8
 802646e:	b5e0      	push	{r5, r6, r7, lr}
 8026470:	b083      	sub	sp, #12
 8026472:	0004      	movs	r4, r0
 8026474:	000d      	movs	r5, r1
 8026476:	0017      	movs	r7, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESGCMctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 8026478:	2800      	cmp	r0, #0
 802647a:	d100      	bne.n	802647e <CA_AES_GCM_Decrypt_Init+0x1a>
 802647c:	e0a0      	b.n	80265c0 <CA_AES_GCM_Decrypt_Init+0x15c>
 802647e:	2900      	cmp	r1, #0
 8026480:	d100      	bne.n	8026484 <CA_AES_GCM_Decrypt_Init+0x20>
 8026482:	e0a0      	b.n	80265c6 <CA_AES_GCM_Decrypt_Init+0x162>
 8026484:	2a00      	cmp	r2, #0
 8026486:	d100      	bne.n	802648a <CA_AES_GCM_Decrypt_Init+0x26>
 8026488:	e0a0      	b.n	80265cc <CA_AES_GCM_Decrypt_Init+0x168>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->mKeySize == 0) || (P_pAESGCMctx->mIvSize != 12))
 802648a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 802648c:	2b00      	cmp	r3, #0
 802648e:	d100      	bne.n	8026492 <CA_AES_GCM_Decrypt_Init+0x2e>
 8026490:	e09f      	b.n	80265d2 <CA_AES_GCM_Decrypt_Init+0x16e>
 8026492:	6903      	ldr	r3, [r0, #16]
 8026494:	2b0c      	cmp	r3, #12
 8026496:	d007      	beq.n	80264a8 <CA_AES_GCM_Decrypt_Init+0x44>
  {
    return CA_AES_ERR_BAD_CONTEXT;
 8026498:	4851      	ldr	r0, [pc, #324]	; (80265e0 <CA_AES_GCM_Decrypt_Init+0x17c>)
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;

  P_pAESGCMctx->flags = GCM_DECRYPTION_ONGOING | GCM_INIT_NOT_DONE;
  return aes_ret_status;
}
 802649a:	b003      	add	sp, #12
 802649c:	bcf0      	pop	{r4, r5, r6, r7}
 802649e:	46bb      	mov	fp, r7
 80264a0:	46b2      	mov	sl, r6
 80264a2:	46a9      	mov	r9, r5
 80264a4:	46a0      	mov	r8, r4
 80264a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleanup_handle(&(P_pAESGCMctx->CrypHandle));
 80264a8:	0006      	movs	r6, r0
 80264aa:	3634      	adds	r6, #52	; 0x34
 80264ac:	0030      	movs	r0, r6
 80264ae:	f7ff f9bb 	bl	8025828 <cleanup_handle>
  P_pAESGCMctx->CrypHandle.Instance = CA_AES_INSTANCE;
 80264b2:	4b4c      	ldr	r3, [pc, #304]	; (80265e4 <CA_AES_GCM_Decrypt_Init+0x180>)
 80264b4:	6363      	str	r3, [r4, #52]	; 0x34
  if (HAL_CRYP_DeInit(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 80264b6:	0030      	movs	r0, r6
 80264b8:	f7fd f818 	bl	80234ec <HAL_CRYP_DeInit>
 80264bc:	4683      	mov	fp, r0
 80264be:	1e03      	subs	r3, r0, #0
 80264c0:	d000      	beq.n	80264c4 <CA_AES_GCM_Decrypt_Init+0x60>
 80264c2:	e088      	b.n	80265d6 <CA_AES_GCM_Decrypt_Init+0x172>
  P_pAESGCMctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 80264c4:	3304      	adds	r3, #4
 80264c6:	63a3      	str	r3, [r4, #56]	; 0x38
  if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 80264c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80264ca:	9300      	str	r3, [sp, #0]
 80264cc:	2b10      	cmp	r3, #16
 80264ce:	d007      	beq.n	80264e0 <CA_AES_GCM_Decrypt_Init+0x7c>
  else if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 80264d0:	9b00      	ldr	r3, [sp, #0]
 80264d2:	2b20      	cmp	r3, #32
 80264d4:	d000      	beq.n	80264d8 <CA_AES_GCM_Decrypt_Init+0x74>
 80264d6:	e080      	b.n	80265da <CA_AES_GCM_Decrypt_Init+0x176>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 80264d8:	2380      	movs	r3, #128	; 0x80
 80264da:	02db      	lsls	r3, r3, #11
 80264dc:	63e3      	str	r3, [r4, #60]	; 0x3c
 80264de:	e026      	b.n	802652e <CA_AES_GCM_Decrypt_Init+0xca>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 80264e0:	2300      	movs	r3, #0
 80264e2:	63e3      	str	r3, [r4, #60]	; 0x3c
 80264e4:	e023      	b.n	802652e <CA_AES_GCM_Decrypt_Init+0xca>
    P_pAESGCMctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 80264e6:	0081      	lsls	r1, r0, #2
 80264e8:	1ccb      	adds	r3, r1, #3
 80264ea:	9301      	str	r3, [sp, #4]
 80264ec:	5cfa      	ldrb	r2, [r7, r3]
 80264ee:	4690      	mov	r8, r2
 80264f0:	1862      	adds	r2, r4, r1
 80264f2:	3241      	adds	r2, #65	; 0x41
 80264f4:	32ff      	adds	r2, #255	; 0xff
 80264f6:	4646      	mov	r6, r8
 80264f8:	7016      	strb	r6, [r2, #0]
    P_pAESGCMctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 80264fa:	1c8a      	adds	r2, r1, #2
 80264fc:	1c4e      	adds	r6, r1, #1
 80264fe:	46b1      	mov	r9, r6
 8026500:	5cbe      	ldrb	r6, [r7, r2]
 8026502:	46b2      	mov	sl, r6
 8026504:	46a0      	mov	r8, r4
 8026506:	44c8      	add	r8, r9
 8026508:	26a0      	movs	r6, #160	; 0xa0
 802650a:	0076      	lsls	r6, r6, #1
 802650c:	46b4      	mov	ip, r6
 802650e:	44e0      	add	r8, ip
 8026510:	4646      	mov	r6, r8
 8026512:	4653      	mov	r3, sl
 8026514:	7033      	strb	r3, [r6, #0]
    P_pAESGCMctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 8026516:	464b      	mov	r3, r9
 8026518:	5cfb      	ldrb	r3, [r7, r3]
 802651a:	18a2      	adds	r2, r4, r2
 802651c:	4462      	add	r2, ip
 802651e:	7013      	strb	r3, [r2, #0]
    P_pAESGCMctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 8026520:	5c7a      	ldrb	r2, [r7, r1]
 8026522:	9b01      	ldr	r3, [sp, #4]
 8026524:	18e3      	adds	r3, r4, r3
 8026526:	4463      	add	r3, ip
 8026528:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 3U; i++)
 802652a:	3001      	adds	r0, #1
 802652c:	b2c0      	uxtb	r0, r0
 802652e:	2802      	cmp	r0, #2
 8026530:	d9d9      	bls.n	80264e6 <CA_AES_GCM_Decrypt_Init+0x82>
  P_pAESGCMctx->Iv_endian[12] = 2;
 8026532:	23a6      	movs	r3, #166	; 0xa6
 8026534:	005b      	lsls	r3, r3, #1
 8026536:	2202      	movs	r2, #2
 8026538:	54e2      	strb	r2, [r4, r3]
  P_pAESGCMctx->Iv_endian[13] = 0;
 802653a:	2300      	movs	r3, #0
 802653c:	224e      	movs	r2, #78	; 0x4e
 802653e:	32ff      	adds	r2, #255	; 0xff
 8026540:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[14] = 0;
 8026542:	3201      	adds	r2, #1
 8026544:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[15] = 0;
 8026546:	2250      	movs	r2, #80	; 0x50
 8026548:	32ff      	adds	r2, #255	; 0xff
 802654a:	54a3      	strb	r3, [r4, r2]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 802654c:	e01e      	b.n	802658c <CA_AES_GCM_Decrypt_Init+0x128>
    P_pAESGCMctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 802654e:	465b      	mov	r3, fp
 8026550:	0098      	lsls	r0, r3, #2
 8026552:	1cc3      	adds	r3, r0, #3
 8026554:	5cef      	ldrb	r7, [r5, r3]
 8026556:	1822      	adds	r2, r4, r0
 8026558:	3251      	adds	r2, #81	; 0x51
 802655a:	32ff      	adds	r2, #255	; 0xff
 802655c:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 802655e:	1c82      	adds	r2, r0, #2
 8026560:	1c41      	adds	r1, r0, #1
 8026562:	5caf      	ldrb	r7, [r5, r2]
 8026564:	46b8      	mov	r8, r7
 8026566:	1867      	adds	r7, r4, r1
 8026568:	3751      	adds	r7, #81	; 0x51
 802656a:	37ff      	adds	r7, #255	; 0xff
 802656c:	4646      	mov	r6, r8
 802656e:	703e      	strb	r6, [r7, #0]
    P_pAESGCMctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8026570:	5c6f      	ldrb	r7, [r5, r1]
 8026572:	18a2      	adds	r2, r4, r2
 8026574:	3251      	adds	r2, #81	; 0x51
 8026576:	32ff      	adds	r2, #255	; 0xff
 8026578:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 802657a:	5c2a      	ldrb	r2, [r5, r0]
 802657c:	18e3      	adds	r3, r4, r3
 802657e:	3351      	adds	r3, #81	; 0x51
 8026580:	33ff      	adds	r3, #255	; 0xff
 8026582:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 8026584:	465e      	mov	r6, fp
 8026586:	3601      	adds	r6, #1
 8026588:	b2f3      	uxtb	r3, r6
 802658a:	469b      	mov	fp, r3
 802658c:	466b      	mov	r3, sp
 802658e:	781b      	ldrb	r3, [r3, #0]
 8026590:	089b      	lsrs	r3, r3, #2
 8026592:	455b      	cmp	r3, fp
 8026594:	d8db      	bhi.n	802654e <CA_AES_GCM_Decrypt_Init+0xea>
  P_pAESGCMctx->CrypHandle.Init.Algorithm       = CRYP_AES_GCM_GMAC;
 8026596:	2360      	movs	r3, #96	; 0x60
 8026598:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESGCMctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESGCMctx->Key_endian);
 802659a:	0023      	movs	r3, r4
 802659c:	3351      	adds	r3, #81	; 0x51
 802659e:	33ff      	adds	r3, #255	; 0xff
 80265a0:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESGCMctx->CrypHandle.Init.pInitVect       = (uint32_t *)(uint32_t)(P_pAESGCMctx->Iv_endian);
 80265a2:	3b10      	subs	r3, #16
 80265a4:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESGCMctx->CrypHandle.Init.Header = NULL;
 80265a6:	2300      	movs	r3, #0
 80265a8:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESGCMctx->CrypHandle.Init.HeaderSize = 0;
 80265aa:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESGCMctx->CrypHandle.Init.B0 = NULL;
 80265ac:	6563      	str	r3, [r4, #84]	; 0x54
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 80265ae:	3301      	adds	r3, #1
 80265b0:	65a3      	str	r3, [r4, #88]	; 0x58
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 80265b2:	6623      	str	r3, [r4, #96]	; 0x60
  P_pAESGCMctx->flags = GCM_DECRYPTION_ONGOING | GCM_INIT_NOT_DONE;
 80265b4:	3370      	adds	r3, #112	; 0x70
 80265b6:	33ff      	adds	r3, #255	; 0xff
 80265b8:	220a      	movs	r2, #10
 80265ba:	50e2      	str	r2, [r4, r3]
  return aes_ret_status;
 80265bc:	2000      	movs	r0, #0
 80265be:	e76c      	b.n	802649a <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_PARAMETER;
 80265c0:	20c2      	movs	r0, #194	; 0xc2
 80265c2:	0100      	lsls	r0, r0, #4
 80265c4:	e769      	b.n	802649a <CA_AES_GCM_Decrypt_Init+0x36>
 80265c6:	20c2      	movs	r0, #194	; 0xc2
 80265c8:	0100      	lsls	r0, r0, #4
 80265ca:	e766      	b.n	802649a <CA_AES_GCM_Decrypt_Init+0x36>
 80265cc:	20c2      	movs	r0, #194	; 0xc2
 80265ce:	0100      	lsls	r0, r0, #4
 80265d0:	e763      	b.n	802649a <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 80265d2:	4803      	ldr	r0, [pc, #12]	; (80265e0 <CA_AES_GCM_Decrypt_Init+0x17c>)
 80265d4:	e761      	b.n	802649a <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 80265d6:	4802      	ldr	r0, [pc, #8]	; (80265e0 <CA_AES_GCM_Decrypt_Init+0x17c>)
 80265d8:	e75f      	b.n	802649a <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 80265da:	4801      	ldr	r0, [pc, #4]	; (80265e0 <CA_AES_GCM_Decrypt_Init+0x17c>)
 80265dc:	e75d      	b.n	802649a <CA_AES_GCM_Decrypt_Init+0x36>
 80265de:	46c0      	nop			; (mov r8, r8)
 80265e0:	00000c1f 	.word	0x00000c1f
 80265e4:	58001800 	.word	0x58001800

080265e8 <CA_AES_GCM_Header_Append>:
  * @retval     CA_AES_ERR_BAD_OPERATION Append not allowed
  */
int32_t CA_AES_GCM_Header_Append(CA_AESGCMctx_stt *P_pAESGCMctx,
                                 const uint8_t *P_pInputBuffer,
                                 int32_t        P_inputSize)
{
 80265e8:	b530      	push	{r4, r5, lr}
 80265ea:	b083      	sub	sp, #12
 80265ec:	1e04      	subs	r4, r0, #0
  int32_t aes_ret_status = CA_AES_SUCCESS;


  if ((P_pAESGCMctx == NULL) || (P_pInputBuffer == NULL))
 80265ee:	d02d      	beq.n	802664c <CA_AES_GCM_Header_Append+0x64>
 80265f0:	2900      	cmp	r1, #0
 80265f2:	d02e      	beq.n	8026652 <CA_AES_GCM_Header_Append+0x6a>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  P_pAESGCMctx->mAADsize = P_inputSize;
 80265f4:	6302      	str	r2, [r0, #48]	; 0x30
  P_pAESGCMctx->CrypHandle.Init.HeaderSize = (uint32_t)(P_inputSize) / 4U;
 80265f6:	0892      	lsrs	r2, r2, #2
 80265f8:	6502      	str	r2, [r0, #80]	; 0x50
  P_pAESGCMctx->CrypHandle.Init.Header     = (uint32_t *)(uint32_t)P_pInputBuffer;
 80265fa:	64c1      	str	r1, [r0, #76]	; 0x4c

  if (HAL_CRYP_Init(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 80265fc:	0005      	movs	r5, r0
 80265fe:	3534      	adds	r5, #52	; 0x34
 8026600:	0028      	movs	r0, r5
 8026602:	f7fc ff4d 	bl	80234a0 <HAL_CRYP_Init>
 8026606:	2800      	cmp	r0, #0
 8026608:	d126      	bne.n	8026658 <CA_AES_GCM_Header_Append+0x70>
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
  }
  else
  {
    P_pAESGCMctx->flags &= ~ GCM_INIT_NOT_DONE;
 802660a:	22b8      	movs	r2, #184	; 0xb8
 802660c:	0052      	lsls	r2, r2, #1
 802660e:	2308      	movs	r3, #8
 8026610:	58a1      	ldr	r1, [r4, r2]
 8026612:	4399      	bics	r1, r3
 8026614:	000b      	movs	r3, r1
 8026616:	50a1      	str	r1, [r4, r2]
    if ((P_pAESGCMctx->flags & GCM_ENCRYPTION_ONGOING) == GCM_ENCRYPTION_ONGOING)
 8026618:	07db      	lsls	r3, r3, #31
 802661a:	d50b      	bpl.n	8026634 <CA_AES_GCM_Header_Append+0x4c>
    {
      if (HAL_CRYP_Encrypt(&(P_pAESGCMctx->CrypHandle), (uint32_t *)NULL, 0, (uint32_t *)NULL,
 802661c:	23ff      	movs	r3, #255	; 0xff
 802661e:	9300      	str	r3, [sp, #0]
 8026620:	2300      	movs	r3, #0
 8026622:	2200      	movs	r2, #0
 8026624:	2100      	movs	r1, #0
 8026626:	0028      	movs	r0, r5
 8026628:	f7fd fad0 	bl	8023bcc <HAL_CRYP_Encrypt>
 802662c:	2800      	cmp	r0, #0
 802662e:	d014      	beq.n	802665a <CA_AES_GCM_Header_Append+0x72>
                           TIMEOUT_VALUE) != HAL_OK)
      {
        aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8026630:	480b      	ldr	r0, [pc, #44]	; (8026660 <CA_AES_GCM_Header_Append+0x78>)
 8026632:	e012      	b.n	802665a <CA_AES_GCM_Header_Append+0x72>
      }
    }
    else
    {
      if (HAL_CRYP_Decrypt(&(P_pAESGCMctx->CrypHandle), (uint32_t *)NULL, 0, (uint32_t *)NULL,
 8026634:	23ff      	movs	r3, #255	; 0xff
 8026636:	9300      	str	r3, [sp, #0]
 8026638:	2300      	movs	r3, #0
 802663a:	2200      	movs	r2, #0
 802663c:	2100      	movs	r1, #0
 802663e:	0028      	movs	r0, r5
 8026640:	f7fd fb20 	bl	8023c84 <HAL_CRYP_Decrypt>
 8026644:	2800      	cmp	r0, #0
 8026646:	d008      	beq.n	802665a <CA_AES_GCM_Header_Append+0x72>
                           TIMEOUT_VALUE) != HAL_OK)
      {
        aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8026648:	4805      	ldr	r0, [pc, #20]	; (8026660 <CA_AES_GCM_Header_Append+0x78>)
 802664a:	e006      	b.n	802665a <CA_AES_GCM_Header_Append+0x72>
    return CA_AES_ERR_BAD_PARAMETER;
 802664c:	20c2      	movs	r0, #194	; 0xc2
 802664e:	0100      	lsls	r0, r0, #4
 8026650:	e003      	b.n	802665a <CA_AES_GCM_Header_Append+0x72>
 8026652:	20c2      	movs	r0, #194	; 0xc2
 8026654:	0100      	lsls	r0, r0, #4
 8026656:	e000      	b.n	802665a <CA_AES_GCM_Header_Append+0x72>
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8026658:	4801      	ldr	r0, [pc, #4]	; (8026660 <CA_AES_GCM_Header_Append+0x78>)
      }
    }
  }
  return aes_ret_status;
}
 802665a:	b003      	add	sp, #12
 802665c:	bd30      	pop	{r4, r5, pc}
 802665e:	46c0      	nop			; (mov r8, r8)
 8026660:	00000c1e 	.word	0x00000c1e

08026664 <CA_Init>:
  {
    ecc_ret_status = CA_SUCCESS;
  }
#endif /* CA_MBED_CRYPTOLIB_SUPP && CA_USES_PSA_CRYPTO */
  return ecc_ret_status;
}
 8026664:	2000      	movs	r0, #0
 8026666:	4770      	bx	lr

08026668 <KMS_CreateObject>:
  */
CK_RV  KMS_CreateObject(CK_SESSION_HANDLE hSession,
                        CK_ATTRIBUTE_PTR pTemplate,
                        CK_ULONG ulCount,
                        CK_OBJECT_HANDLE_PTR phObject)
{
 8026668:	b5f0      	push	{r4, r5, r6, r7, lr}
 802666a:	b085      	sub	sp, #20
 802666c:	0004      	movs	r4, r0
 802666e:	000d      	movs	r5, r1
 8026670:	0016      	movs	r6, r2
 8026672:	001f      	movs	r7, r3
#if defined(KMS_OBJECTS)
  CK_ATTRIBUTE_PTR  p_attribut_value = NULL_PTR;
 8026674:	2300      	movs	r3, #0
 8026676:	9303      	str	r3, [sp, #12]
  CK_RV e_ret_status;

  if (!KMS_IS_INITIALIZED())
 8026678:	4b23      	ldr	r3, [pc, #140]	; (8026708 <KMS_CreateObject+0xa0>)
 802667a:	781b      	ldrb	r3, [r3, #0]
 802667c:	2b00      	cmp	r3, #0
 802667e:	d039      	beq.n	80266f4 <KMS_CreateObject+0x8c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026680:	f000 fdc8 	bl	8027214 <KMS_CheckSessionHdle>
 8026684:	2800      	cmp	r0, #0
 8026686:	d139      	bne.n	80266fc <KMS_CreateObject+0x94>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8026688:	1e62      	subs	r2, r4, #1
 802668a:	00d3      	lsls	r3, r2, #3
 802668c:	189b      	adds	r3, r3, r2
 802668e:	009b      	lsls	r3, r3, #2
 8026690:	4a1d      	ldr	r2, [pc, #116]	; (8026708 <KMS_CreateObject+0xa0>)
 8026692:	18d3      	adds	r3, r2, r3
 8026694:	68db      	ldr	r3, [r3, #12]
 8026696:	2b00      	cmp	r3, #0
 8026698:	d132      	bne.n	8026700 <KMS_CreateObject+0x98>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Control CLASS ATTRIBUTE */
  if (CKR_OK != KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_CLASS, &p_attribut_value))
 802669a:	ab03      	add	r3, sp, #12
 802669c:	2200      	movs	r2, #0
 802669e:	0031      	movs	r1, r6
 80266a0:	0028      	movs	r0, r5
 80266a2:	f001 fd9a 	bl	80281da <KMS_FindAttributeInTemplate>
 80266a6:	2800      	cmp	r0, #0
 80266a8:	d12c      	bne.n	8026704 <KMS_CreateObject+0x9c>
  }

  /* The provided creation template should at least include one of the following:
   * CKA_CERTIFICATE_TYPE, CKA_HW_FEATURE_TYPE or CKA_KEY_TYPE
   */
  if (KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_CERTIFICATE_TYPE, &p_attribut_value) != CKR_OK)
 80266aa:	ab03      	add	r3, sp, #12
 80266ac:	2280      	movs	r2, #128	; 0x80
 80266ae:	0031      	movs	r1, r6
 80266b0:	0028      	movs	r0, r5
 80266b2:	f001 fd92 	bl	80281da <KMS_FindAttributeInTemplate>
 80266b6:	2800      	cmp	r0, #0
 80266b8:	d008      	beq.n	80266cc <KMS_CreateObject+0x64>
  {
    if (KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_HW_FEATURE_TYPE, &p_attribut_value) != CKR_OK)
 80266ba:	22c0      	movs	r2, #192	; 0xc0
 80266bc:	ab03      	add	r3, sp, #12
 80266be:	0092      	lsls	r2, r2, #2
 80266c0:	0031      	movs	r1, r6
 80266c2:	0028      	movs	r0, r5
 80266c4:	f001 fd89 	bl	80281da <KMS_FindAttributeInTemplate>
 80266c8:	2800      	cmp	r0, #0
 80266ca:	d108      	bne.n	80266de <KMS_CreateObject+0x76>
      }
    }
  }

  /* Allocate blob object to fill it with template data */
  e_ret_status = KMS_Objects_CreateNStoreBlobFromTemplates(hSession, pTemplate, ulCount, NULL_PTR, 0, phObject);
 80266cc:	9701      	str	r7, [sp, #4]
 80266ce:	2300      	movs	r3, #0
 80266d0:	9300      	str	r3, [sp, #0]
 80266d2:	0032      	movs	r2, r6
 80266d4:	0029      	movs	r1, r5
 80266d6:	0020      	movs	r0, r4
 80266d8:	f001 fec0 	bl	802845c <KMS_Objects_CreateNStoreBlobFromTemplates>

  return e_ret_status;
 80266dc:	e00c      	b.n	80266f8 <KMS_CreateObject+0x90>
      if (KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_KEY_TYPE, &p_attribut_value) != CKR_OK)
 80266de:	2280      	movs	r2, #128	; 0x80
 80266e0:	ab03      	add	r3, sp, #12
 80266e2:	0052      	lsls	r2, r2, #1
 80266e4:	0031      	movs	r1, r6
 80266e6:	0028      	movs	r0, r5
 80266e8:	f001 fd77 	bl	80281da <KMS_FindAttributeInTemplate>
 80266ec:	2800      	cmp	r0, #0
 80266ee:	d0ed      	beq.n	80266cc <KMS_CreateObject+0x64>
        return CKR_TEMPLATE_INCOMPLETE;
 80266f0:	20d0      	movs	r0, #208	; 0xd0
 80266f2:	e001      	b.n	80266f8 <KMS_CreateObject+0x90>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 80266f4:	20c8      	movs	r0, #200	; 0xc8
 80266f6:	0040      	lsls	r0, r0, #1
#else /* KMS_OBJECTS */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_OBJECTS */
}
 80266f8:	b005      	add	sp, #20
 80266fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 80266fc:	20b3      	movs	r0, #179	; 0xb3
 80266fe:	e7fb      	b.n	80266f8 <KMS_CreateObject+0x90>
    return CKR_SESSION_HANDLE_INVALID;
 8026700:	20b3      	movs	r0, #179	; 0xb3
 8026702:	e7f9      	b.n	80266f8 <KMS_CreateObject+0x90>
    return CKR_TEMPLATE_INCOMPLETE;
 8026704:	20d0      	movs	r0, #208	; 0xd0
 8026706:	e7f7      	b.n	80266f8 <KMS_CreateObject+0x90>
 8026708:	2000a200 	.word	0x2000a200

0802670c <KMS_DestroyObject>:
  *         @ref KMS_PlatfObjects_NvmRemoveObject returned values
  *         @ref KMS_PlatfObjects_VmRemoveObject returned values
  */
CK_RV  KMS_DestroyObject(CK_SESSION_HANDLE hSession,
                         CK_OBJECT_HANDLE hObject)
{
 802670c:	b530      	push	{r4, r5, lr}
 802670e:	b083      	sub	sp, #12
 8026710:	0004      	movs	r4, r0
 8026712:	000d      	movs	r5, r1
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  kms_obj_keyhead_t *pkms_object;
  kms_attr_t  *pAttribute;
  kms_obj_range_t  ObjectRange;

  if (!KMS_IS_INITIALIZED())
 8026714:	4b1b      	ldr	r3, [pc, #108]	; (8026784 <KMS_DestroyObject+0x78>)
 8026716:	781b      	ldrb	r3, [r3, #0]
 8026718:	2b00      	cmp	r3, #0
 802671a:	d025      	beq.n	8026768 <KMS_DestroyObject+0x5c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 802671c:	f000 fd7a 	bl	8027214 <KMS_CheckSessionHdle>
 8026720:	2800      	cmp	r0, #0
 8026722:	d125      	bne.n	8026770 <KMS_DestroyObject+0x64>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8026724:	3c01      	subs	r4, #1
 8026726:	00e0      	lsls	r0, r4, #3
 8026728:	1904      	adds	r4, r0, r4
 802672a:	00a4      	lsls	r4, r4, #2
 802672c:	4815      	ldr	r0, [pc, #84]	; (8026784 <KMS_DestroyObject+0x78>)
 802672e:	1904      	adds	r4, r0, r4
 8026730:	68e3      	ldr	r3, [r4, #12]
 8026732:	2b00      	cmp	r3, #0
 8026734:	d11e      	bne.n	8026774 <KMS_DestroyObject+0x68>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Verify that the object is removable, embedded objects are not */
  ObjectRange = KMS_Objects_GetRange(hObject);
 8026736:	0028      	movs	r0, r5
 8026738:	f001 fce2 	bl	8028100 <KMS_Objects_GetRange>
  if (ObjectRange == KMS_OBJECT_RANGE_EMBEDDED)
 802673c:	2800      	cmp	r0, #0
 802673e:	d01b      	beq.n	8026778 <KMS_DestroyObject+0x6c>

  /* Verify that the object is removable, reading the attributes */

  /* Read the key value from the Key Handle                 */
  /* Key Handle is the index to one of static or nvm        */
  pkms_object = KMS_Objects_GetPointer(hObject);
 8026740:	0028      	movs	r0, r5
 8026742:	f001 fd0b 	bl	802815c <KMS_Objects_GetPointer>
 8026746:	1e01      	subs	r1, r0, #0

  /* Check that hKey is valid */
  if (pkms_object != NULL_PTR)
 8026748:	d018      	beq.n	802677c <KMS_DestroyObject+0x70>
  {
    /* Check the CKA_DESTROYABLE attribute = CK_TRUE      */
    e_ret_status = KMS_Objects_SearchAttributes(CKA_DESTROYABLE, pkms_object, &pAttribute);
 802674a:	20b9      	movs	r0, #185	; 0xb9
 802674c:	aa01      	add	r2, sp, #4
 802674e:	0040      	lsls	r0, r0, #1
 8026750:	f001 fd61 	bl	8028216 <KMS_Objects_SearchAttributes>

    if (e_ret_status == CKR_OK)
 8026754:	2800      	cmp	r0, #0
 8026756:	d103      	bne.n	8026760 <KMS_DestroyObject+0x54>
    {
      if (*pAttribute->data != CK_TRUE)
 8026758:	9b01      	ldr	r3, [sp, #4]
 802675a:	689b      	ldr	r3, [r3, #8]
 802675c:	2b01      	cmp	r3, #1
 802675e:	d10f      	bne.n	8026780 <KMS_DestroyObject+0x74>

    /* Object is removable */
#ifdef KMS_VM_DYNAMIC_ENABLED
    e_ret_status = KMS_PlatfObjects_VmRemoveObject(hObject);
#else /* KMS_VM_DYNAMIC_ENABLED */
    e_ret_status = KMS_PlatfObjects_NvmRemoveObject(hObject);
 8026760:	0028      	movs	r0, r5
 8026762:	f002 f88c 	bl	802887e <KMS_PlatfObjects_NvmRemoveObject>
 8026766:	e001      	b.n	802676c <KMS_DestroyObject+0x60>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026768:	20c8      	movs	r0, #200	; 0xc8
 802676a:	0040      	lsls	r0, r0, #1

  return e_ret_status;
#else /* KMS_OBJECTS */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_OBJECTS */
}
 802676c:	b003      	add	sp, #12
 802676e:	bd30      	pop	{r4, r5, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026770:	20b3      	movs	r0, #179	; 0xb3
 8026772:	e7fb      	b.n	802676c <KMS_DestroyObject+0x60>
    return CKR_SESSION_HANDLE_INVALID;
 8026774:	20b3      	movs	r0, #179	; 0xb3
 8026776:	e7f9      	b.n	802676c <KMS_DestroyObject+0x60>
    return (CKR_ACTION_PROHIBITED);
 8026778:	201b      	movs	r0, #27
 802677a:	e7f7      	b.n	802676c <KMS_DestroyObject+0x60>
    e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 802677c:	2082      	movs	r0, #130	; 0x82
 802677e:	e7f5      	b.n	802676c <KMS_DestroyObject+0x60>
        return (CKR_ACTION_PROHIBITED);
 8026780:	201b      	movs	r0, #27
 8026782:	e7f3      	b.n	802676c <KMS_DestroyObject+0x60>
 8026784:	2000a200 	.word	0x2000a200

08026788 <KMS_GetAttributeValue>:
  *         CKR_SESSION_HANDLE_INVALID
  *         @ref KMS_Objects_SearchAttributes returned values
  */
CK_RV KMS_GetAttributeValue(CK_SESSION_HANDLE hSession,  CK_OBJECT_HANDLE  hObject,
                            CK_ATTRIBUTE_PTR  pTemplate, CK_ULONG          ulCount)
{
 8026788:	b5f0      	push	{r4, r5, r6, r7, lr}
 802678a:	46d6      	mov	lr, sl
 802678c:	464f      	mov	r7, r9
 802678e:	4646      	mov	r6, r8
 8026790:	b5c0      	push	{r6, r7, lr}
 8026792:	b082      	sub	sp, #8
 8026794:	0005      	movs	r5, r0
 8026796:	000c      	movs	r4, r1
 8026798:	4691      	mov	r9, r2
 802679a:	001e      	movs	r6, r3
#if defined(KMS_ATTRIBUTES)
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  kms_obj_keyhead_t *pkms_object;

  if (!KMS_IS_INITIALIZED())
 802679c:	4b49      	ldr	r3, [pc, #292]	; (80268c4 <KMS_GetAttributeValue+0x13c>)
 802679e:	781b      	ldrb	r3, [r3, #0]
 80267a0:	2b00      	cmp	r3, #0
 80267a2:	d100      	bne.n	80267a6 <KMS_GetAttributeValue+0x1e>
 80267a4:	e07e      	b.n	80268a4 <KMS_GetAttributeValue+0x11c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80267a6:	f000 fd35 	bl	8027214 <KMS_CheckSessionHdle>
 80267aa:	2800      	cmp	r0, #0
 80267ac:	d000      	beq.n	80267b0 <KMS_GetAttributeValue+0x28>
 80267ae:	e082      	b.n	80268b6 <KMS_GetAttributeValue+0x12e>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 80267b0:	1e68      	subs	r0, r5, #1
 80267b2:	00c3      	lsls	r3, r0, #3
 80267b4:	1818      	adds	r0, r3, r0
 80267b6:	0080      	lsls	r0, r0, #2
 80267b8:	4b42      	ldr	r3, [pc, #264]	; (80268c4 <KMS_GetAttributeValue+0x13c>)
 80267ba:	1818      	adds	r0, r3, r0
 80267bc:	68c5      	ldr	r5, [r0, #12]
 80267be:	2d00      	cmp	r5, #0
 80267c0:	d000      	beq.n	80267c4 <KMS_GetAttributeValue+0x3c>
 80267c2:	e07a      	b.n	80268ba <KMS_GetAttributeValue+0x132>
  /* GetAttribute() is only authorised for objects with attribute EXTRACTABLE = TRUE or without EXTRACTABLE attribute */
  /* Verify that the object is extractable, reading the attributes */

  /* Read the key value from the Key Handle                 */
  /* Key Handle is the index to one of static or nvm        */
  pkms_object = KMS_Objects_GetPointer(hObject);
 80267c4:	0020      	movs	r0, r4
 80267c6:	f001 fcc9 	bl	802815c <KMS_Objects_GetPointer>
 80267ca:	4680      	mov	r8, r0

  /* Check that hObject is valid */
  if (pkms_object != NULL_PTR)
 80267cc:	2800      	cmp	r0, #0
 80267ce:	d100      	bne.n	80267d2 <KMS_GetAttributeValue+0x4a>
 80267d0:	e075      	b.n	80268be <KMS_GetAttributeValue+0x136>
  {
    kms_attr_t  *pAttribute;

    /* Check the CKA_EXTRACTABLE attribute = CK_TRUE      */
    e_ret_status = KMS_Objects_SearchAttributes(CKA_EXTRACTABLE, pkms_object, &pAttribute);
 80267d2:	20b1      	movs	r0, #177	; 0xb1
 80267d4:	466a      	mov	r2, sp
 80267d6:	4641      	mov	r1, r8
 80267d8:	0040      	lsls	r0, r0, #1
 80267da:	f001 fd1c 	bl	8028216 <KMS_Objects_SearchAttributes>

    /* If attribute not found or object not extractable */
    if ((e_ret_status == CKR_OK) && (*pAttribute->data != CK_TRUE))
 80267de:	2800      	cmp	r0, #0
 80267e0:	d103      	bne.n	80267ea <KMS_GetAttributeValue+0x62>
 80267e2:	9b00      	ldr	r3, [sp, #0]
 80267e4:	689b      	ldr	r3, [r3, #8]
 80267e6:	2b01      	cmp	r3, #1
 80267e8:	d115      	bne.n	8026816 <KMS_GetAttributeValue+0x8e>
      /* Object cannot be extracted  */
      return (CKR_ATTRIBUTE_SENSITIVE);
    }

    /* Double check to avoid fault attack: Check the CKA_EXTRACTABLE attribute = CK_TRUE */
    e_ret_status = KMS_Objects_SearchAttributes(CKA_EXTRACTABLE, pkms_object, &pAttribute);
 80267ea:	20b1      	movs	r0, #177	; 0xb1
 80267ec:	466a      	mov	r2, sp
 80267ee:	4641      	mov	r1, r8
 80267f0:	0040      	lsls	r0, r0, #1
 80267f2:	f001 fd10 	bl	8028216 <KMS_Objects_SearchAttributes>
 80267f6:	1e07      	subs	r7, r0, #0

    /* If attribute not found or object not extractable */
    if ((e_ret_status == CKR_OK) && (*pAttribute->data != CK_TRUE))
 80267f8:	d12e      	bne.n	8026858 <KMS_GetAttributeValue+0xd0>
 80267fa:	9b00      	ldr	r3, [sp, #0]
 80267fc:	689b      	ldr	r3, [r3, #8]
 80267fe:	2b01      	cmp	r3, #1
 8026800:	d115      	bne.n	802682e <KMS_GetAttributeValue+0xa6>
 8026802:	0005      	movs	r5, r0
 8026804:	e028      	b.n	8026858 <KMS_GetAttributeValue+0xd0>
        pTemplate[i].ulValueLen = CK_UNAVAILABLE_INFORMATION;
 8026806:	0043      	lsls	r3, r0, #1
 8026808:	181b      	adds	r3, r3, r0
 802680a:	009b      	lsls	r3, r3, #2
 802680c:	444b      	add	r3, r9
 802680e:	2201      	movs	r2, #1
 8026810:	4252      	negs	r2, r2
 8026812:	609a      	str	r2, [r3, #8]
      for (uint32_t i = 0; i < ulCount; i++)
 8026814:	3001      	adds	r0, #1
 8026816:	42b0      	cmp	r0, r6
 8026818:	d3f5      	bcc.n	8026806 <KMS_GetAttributeValue+0x7e>
      return (CKR_ATTRIBUTE_SENSITIVE);
 802681a:	2711      	movs	r7, #17
 802681c:	e044      	b.n	80268a8 <KMS_GetAttributeValue+0x120>
    {
      for (uint32_t i = 0; i < ulCount; i++)
      {
        pTemplate[i].ulValueLen = CK_UNAVAILABLE_INFORMATION;
 802681e:	007b      	lsls	r3, r7, #1
 8026820:	19db      	adds	r3, r3, r7
 8026822:	009b      	lsls	r3, r3, #2
 8026824:	444b      	add	r3, r9
 8026826:	2201      	movs	r2, #1
 8026828:	4252      	negs	r2, r2
 802682a:	609a      	str	r2, [r3, #8]
      for (uint32_t i = 0; i < ulCount; i++)
 802682c:	3701      	adds	r7, #1
 802682e:	42b7      	cmp	r7, r6
 8026830:	d3f5      	bcc.n	802681e <KMS_GetAttributeValue+0x96>
 8026832:	e7f2      	b.n	802681a <KMS_GetAttributeValue+0x92>
        if (e_ret_status == CKR_OK)
        {
          if (ptemp->pValue == NULL_PTR)
          {
            /* case 3 */
            ptemp->ulValueLen = pfound_attribute->size;
 8026834:	9b01      	ldr	r3, [sp, #4]
 8026836:	685b      	ldr	r3, [r3, #4]
 8026838:	60a3      	str	r3, [r4, #8]
 802683a:	e00c      	b.n	8026856 <KMS_GetAttributeValue+0xce>
                                          pfound_attribute->size,
                                          (uint8_t *)(ptemp->pValue));
            }
            else
            {
              (void)memcpy((uint8_t *)ptemp->pValue, (uint8_t *)(pfound_attribute->data), pfound_attribute->size);
 802683c:	3308      	adds	r3, #8
 802683e:	000a      	movs	r2, r1
 8026840:	0019      	movs	r1, r3
 8026842:	f00d ff67 	bl	8034714 <memcpy>
 8026846:	e029      	b.n	802689c <KMS_GetAttributeValue+0x114>
            ptemp->ulValueLen = pfound_attribute->size;
          }
          else
          {
            /* case 4 - section 5.2 */
            ptemp->ulValueLen = CKR_BUFFER_TOO_SMALL;
 8026848:	23a8      	movs	r3, #168	; 0xa8
 802684a:	005b      	lsls	r3, r3, #1
 802684c:	60a3      	str	r3, [r4, #8]
 802684e:	e002      	b.n	8026856 <KMS_GetAttributeValue+0xce>
          }
        }
        else
        {
          /* case 2 */
          ptemp->ulValueLen = CK_UNAVAILABLE_INFORMATION;
 8026850:	2301      	movs	r3, #1
 8026852:	425b      	negs	r3, r3
 8026854:	60a3      	str	r3, [r4, #8]
      for (index = 0; index < ulCount; index++)
 8026856:	3501      	adds	r5, #1
 8026858:	42b5      	cmp	r5, r6
 802685a:	d225      	bcs.n	80268a8 <KMS_GetAttributeValue+0x120>
        ptemp = &(pTemplate[index]);
 802685c:	006c      	lsls	r4, r5, #1
 802685e:	1964      	adds	r4, r4, r5
 8026860:	00a4      	lsls	r4, r4, #2
 8026862:	444c      	add	r4, r9
        e_ret_status = KMS_Objects_SearchAttributes(ptemp->type, pkms_object, &pfound_attribute);
 8026864:	aa01      	add	r2, sp, #4
 8026866:	4641      	mov	r1, r8
 8026868:	6820      	ldr	r0, [r4, #0]
 802686a:	f001 fcd4 	bl	8028216 <KMS_Objects_SearchAttributes>
 802686e:	1e07      	subs	r7, r0, #0
        if (e_ret_status == CKR_OK)
 8026870:	d1ee      	bne.n	8026850 <KMS_GetAttributeValue+0xc8>
          if (ptemp->pValue == NULL_PTR)
 8026872:	6860      	ldr	r0, [r4, #4]
 8026874:	2800      	cmp	r0, #0
 8026876:	d0dd      	beq.n	8026834 <KMS_GetAttributeValue+0xac>
          else if (ptemp->ulValueLen >= pfound_attribute->size)
 8026878:	9b01      	ldr	r3, [sp, #4]
 802687a:	6859      	ldr	r1, [r3, #4]
 802687c:	68a2      	ldr	r2, [r4, #8]
 802687e:	428a      	cmp	r2, r1
 8026880:	d3e2      	bcc.n	8026848 <KMS_GetAttributeValue+0xc0>
            if ((ptemp->type == CKA_VALUE) || (ptemp->type == CKA_EC_POINT))
 8026882:	6822      	ldr	r2, [r4, #0]
 8026884:	4692      	mov	sl, r2
 8026886:	2a11      	cmp	r2, #17
 8026888:	d003      	beq.n	8026892 <KMS_GetAttributeValue+0x10a>
 802688a:	2282      	movs	r2, #130	; 0x82
 802688c:	32ff      	adds	r2, #255	; 0xff
 802688e:	4592      	cmp	sl, r2
 8026890:	d1d4      	bne.n	802683c <KMS_GetAttributeValue+0xb4>
              KMS_Objects_BlobU32_2_u8ptr(&(pfound_attribute->data[0]),
 8026892:	3308      	adds	r3, #8
 8026894:	0002      	movs	r2, r0
 8026896:	0018      	movs	r0, r3
 8026898:	f001 fda3 	bl	80283e2 <KMS_Objects_BlobU32_2_u8ptr>
            ptemp->ulValueLen = pfound_attribute->size;
 802689c:	9b01      	ldr	r3, [sp, #4]
 802689e:	685b      	ldr	r3, [r3, #4]
 80268a0:	60a3      	str	r3, [r4, #8]
 80268a2:	e7d8      	b.n	8026856 <KMS_GetAttributeValue+0xce>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 80268a4:	27c8      	movs	r7, #200	; 0xc8
 80268a6:	007f      	lsls	r7, r7, #1

  return e_ret_status;
#else /* KMS_ATTRIBUTES */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ATTRIBUTES */
}
 80268a8:	0038      	movs	r0, r7
 80268aa:	b002      	add	sp, #8
 80268ac:	bce0      	pop	{r5, r6, r7}
 80268ae:	46ba      	mov	sl, r7
 80268b0:	46b1      	mov	r9, r6
 80268b2:	46a8      	mov	r8, r5
 80268b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 80268b6:	27b3      	movs	r7, #179	; 0xb3
 80268b8:	e7f6      	b.n	80268a8 <KMS_GetAttributeValue+0x120>
    return CKR_SESSION_HANDLE_INVALID;
 80268ba:	27b3      	movs	r7, #179	; 0xb3
 80268bc:	e7f4      	b.n	80268a8 <KMS_GetAttributeValue+0x120>
    e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 80268be:	2782      	movs	r7, #130	; 0x82
 80268c0:	e7f2      	b.n	80268a8 <KMS_GetAttributeValue+0x120>
 80268c2:	46c0      	nop			; (mov r8, r8)
 80268c4:	2000a200 	.word	0x2000a200

080268c8 <KMS_FindObjectsInit>:
  *         CKR_SESSION_HANDLE_INVALID
  *         @ref KMS_FindObjectsFromTemplate returned values
  */
CK_RV KMS_FindObjectsInit(CK_SESSION_HANDLE hSession, CK_ATTRIBUTE_PTR pTemplate,
                          CK_ULONG ulCount)
{
 80268c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80268ca:	46d6      	mov	lr, sl
 80268cc:	464f      	mov	r7, r9
 80268ce:	b580      	push	{r7, lr}
 80268d0:	b087      	sub	sp, #28
 80268d2:	0006      	movs	r6, r0
 80268d4:	4689      	mov	r9, r1
 80268d6:	9203      	str	r2, [sp, #12]
  CK_RV e_ret_status;
  kms_find_ctx_t *p_ctx;

  /* ========== Check active operation status ========== */

  if (!KMS_IS_INITIALIZED())
 80268d8:	4b2e      	ldr	r3, [pc, #184]	; (8026994 <KMS_FindObjectsInit+0xcc>)
 80268da:	781b      	ldrb	r3, [r3, #0]
 80268dc:	2b00      	cmp	r3, #0
 80268de:	d04a      	beq.n	8026976 <KMS_FindObjectsInit+0xae>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80268e0:	f000 fc98 	bl	8027214 <KMS_CheckSessionHdle>
 80268e4:	2800      	cmp	r0, #0
 80268e6:	d14e      	bne.n	8026986 <KMS_FindObjectsInit+0xbe>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 80268e8:	1e73      	subs	r3, r6, #1
 80268ea:	469a      	mov	sl, r3
 80268ec:	00db      	lsls	r3, r3, #3
 80268ee:	4453      	add	r3, sl
 80268f0:	009b      	lsls	r3, r3, #2
 80268f2:	4a28      	ldr	r2, [pc, #160]	; (8026994 <KMS_FindObjectsInit+0xcc>)
 80268f4:	18d3      	adds	r3, r2, r3
 80268f6:	68dc      	ldr	r4, [r3, #12]
 80268f8:	2c00      	cmp	r4, #0
 80268fa:	d146      	bne.n	802698a <KMS_FindObjectsInit+0xc2>
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Check input parameters */
  /* Note: pTemplate = NULL_PTR is ok only if ulCount = 0 */
  if (((pTemplate == NULL_PTR) && (ulCount > 0U)) || ((pTemplate != NULL_PTR) && (ulCount == 0U)))
 80268fc:	464b      	mov	r3, r9
 80268fe:	2b00      	cmp	r3, #0
 8026900:	d00e      	beq.n	8026920 <KMS_FindObjectsInit+0x58>
 8026902:	464b      	mov	r3, r9
 8026904:	2b00      	cmp	r3, #0
 8026906:	d002      	beq.n	802690e <KMS_FindObjectsInit+0x46>
 8026908:	9b03      	ldr	r3, [sp, #12]
 802690a:	2b00      	cmp	r3, #0
 802690c:	d03f      	beq.n	802698e <KMS_FindObjectsInit+0xc6>
  {
    return CKR_ARGUMENTS_BAD;
  }

  p_ctx = KMS_Alloc(hSession, sizeof(kms_find_ctx_t));
 802690e:	218c      	movs	r1, #140	; 0x8c
 8026910:	0049      	lsls	r1, r1, #1
 8026912:	0030      	movs	r0, r6
 8026914:	f000 fdd4 	bl	80274c0 <KMS_Alloc>
 8026918:	1e07      	subs	r7, r0, #0
  if (p_ctx == NULL_PTR)
 802691a:	d10a      	bne.n	8026932 <KMS_FindObjectsInit+0x6a>
  {
    return CKR_DEVICE_MEMORY;
 802691c:	2431      	movs	r4, #49	; 0x31
 802691e:	e02c      	b.n	802697a <KMS_FindObjectsInit+0xb2>
  if (((pTemplate == NULL_PTR) && (ulCount > 0U)) || ((pTemplate != NULL_PTR) && (ulCount == 0U)))
 8026920:	9b03      	ldr	r3, [sp, #12]
 8026922:	2b00      	cmp	r3, #0
 8026924:	d0ed      	beq.n	8026902 <KMS_FindObjectsInit+0x3a>
    return CKR_ARGUMENTS_BAD;
 8026926:	2407      	movs	r4, #7
 8026928:	e027      	b.n	802697a <KMS_FindObjectsInit+0xb2>
  }

  /* ========== Look for the objects  ========== */
  for (uint32_t i = 0; i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)); i++)
  {
    p_ctx->searchHandles[i] = KMS_HANDLE_KEY_NOT_KNOWN;
 802692a:	00a3      	lsls	r3, r4, #2
 802692c:	2500      	movs	r5, #0
 802692e:	51dd      	str	r5, [r3, r7]
  for (uint32_t i = 0; i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)); i++)
 8026930:	3401      	adds	r4, #1
 8026932:	2c44      	cmp	r4, #68	; 0x44
 8026934:	d9f9      	bls.n	802692a <KMS_FindObjectsInit+0x62>
  }

  /* Note: if ulCount was 0, searchHandles will be filled with a list of all objects handles */
  e_ret_status = KMS_FindObjectsFromTemplate(hSession,
 8026936:	9b03      	ldr	r3, [sp, #12]
 8026938:	9301      	str	r3, [sp, #4]
 802693a:	464b      	mov	r3, r9
 802693c:	9300      	str	r3, [sp, #0]
 802693e:	ab05      	add	r3, sp, #20
 8026940:	2245      	movs	r2, #69	; 0x45
 8026942:	0039      	movs	r1, r7
 8026944:	0030      	movs	r0, r6
 8026946:	f001 fc80 	bl	802824a <KMS_FindObjectsFromTemplate>
 802694a:	1e04      	subs	r4, r0, #0
                                             sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE),
                                             &tmp,
                                             pTemplate,
                                             ulCount);

  if (e_ret_status == CKR_OK)
 802694c:	d10e      	bne.n	802696c <KMS_FindObjectsInit+0xa4>
  {
    p_ctx->searchIndex = 0;
 802694e:	238a      	movs	r3, #138	; 0x8a
 8026950:	005b      	lsls	r3, r3, #1
 8026952:	2200      	movs	r2, #0
 8026954:	50fa      	str	r2, [r7, r3]
    KMS_GETSESSION(hSession).state = KMS_SESSION_SEARCH;
 8026956:	490f      	ldr	r1, [pc, #60]	; (8026994 <KMS_FindObjectsInit+0xcc>)
 8026958:	4653      	mov	r3, sl
 802695a:	00db      	lsls	r3, r3, #3
 802695c:	4652      	mov	r2, sl
 802695e:	189a      	adds	r2, r3, r2
 8026960:	0092      	lsls	r2, r2, #2
 8026962:	188a      	adds	r2, r1, r2
 8026964:	2006      	movs	r0, #6
 8026966:	60d0      	str	r0, [r2, #12]
    KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026968:	6297      	str	r7, [r2, #40]	; 0x28
 802696a:	e006      	b.n	802697a <KMS_FindObjectsInit+0xb2>
  }
  else
  {
    KMS_Free(hSession, p_ctx);
 802696c:	0039      	movs	r1, r7
 802696e:	0030      	movs	r0, r6
 8026970:	f000 fdcc 	bl	802750c <KMS_Free>
 8026974:	e001      	b.n	802697a <KMS_FindObjectsInit+0xb2>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026976:	24c8      	movs	r4, #200	; 0xc8
 8026978:	0064      	lsls	r4, r4, #1

  return e_ret_status;
#else /* KMS_SEARCH */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SEARCH */
}
 802697a:	0020      	movs	r0, r4
 802697c:	b007      	add	sp, #28
 802697e:	bcc0      	pop	{r6, r7}
 8026980:	46ba      	mov	sl, r7
 8026982:	46b1      	mov	r9, r6
 8026984:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026986:	24b3      	movs	r4, #179	; 0xb3
 8026988:	e7f7      	b.n	802697a <KMS_FindObjectsInit+0xb2>
    return CKR_SESSION_HANDLE_INVALID;
 802698a:	24b3      	movs	r4, #179	; 0xb3
 802698c:	e7f5      	b.n	802697a <KMS_FindObjectsInit+0xb2>
    return CKR_ARGUMENTS_BAD;
 802698e:	2407      	movs	r4, #7
 8026990:	e7f3      	b.n	802697a <KMS_FindObjectsInit+0xb2>
 8026992:	46c0      	nop			; (mov r8, r8)
 8026994:	2000a200 	.word	0x2000a200

08026998 <KMS_FindObjects>:
  *         CKR_FUNCTION_NOT_SUPPORTED
  *         CKR_SESSION_HANDLE_INVALID
  */
CK_RV KMS_FindObjects(CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE_PTR phObject,
                      CK_ULONG ulMaxObjectCount,  CK_ULONG_PTR pulObjectCount)
{
 8026998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802699a:	0004      	movs	r4, r0
 802699c:	000f      	movs	r7, r1
 802699e:	0016      	movs	r6, r2
 80269a0:	001d      	movs	r5, r3
#if defined(KMS_SEARCH)
  kms_find_ctx_t *p_ctx;
  uint32_t i;

  if (!KMS_IS_INITIALIZED())
 80269a2:	4b22      	ldr	r3, [pc, #136]	; (8026a2c <KMS_FindObjects+0x94>)
 80269a4:	781b      	ldrb	r3, [r3, #0]
 80269a6:	2b00      	cmp	r3, #0
 80269a8:	d031      	beq.n	8026a0e <KMS_FindObjects+0x76>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80269aa:	f000 fc33 	bl	8027214 <KMS_CheckSessionHdle>
 80269ae:	2800      	cmp	r0, #0
 80269b0:	d130      	bne.n	8026a14 <KMS_FindObjects+0x7c>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if there is a pending operation: i.e. FindObjectInit was called */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_SEARCH)
 80269b2:	3c01      	subs	r4, #1
 80269b4:	00e3      	lsls	r3, r4, #3
 80269b6:	191b      	adds	r3, r3, r4
 80269b8:	009b      	lsls	r3, r3, #2
 80269ba:	4a1c      	ldr	r2, [pc, #112]	; (8026a2c <KMS_FindObjects+0x94>)
 80269bc:	18d3      	adds	r3, r2, r3
 80269be:	68db      	ldr	r3, [r3, #12]
 80269c0:	2b06      	cmp	r3, #6
 80269c2:	d129      	bne.n	8026a18 <KMS_FindObjects+0x80>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }

  /* Check input parameters */
  if ((phObject == NULL_PTR) || (pulObjectCount == NULL_PTR) || (ulMaxObjectCount <= 0UL))
 80269c4:	2f00      	cmp	r7, #0
 80269c6:	d02a      	beq.n	8026a1e <KMS_FindObjects+0x86>
 80269c8:	2d00      	cmp	r5, #0
 80269ca:	d02a      	beq.n	8026a22 <KMS_FindObjects+0x8a>
 80269cc:	2e00      	cmp	r6, #0
 80269ce:	d02a      	beq.n	8026a26 <KMS_FindObjects+0x8e>
  {
    return CKR_ARGUMENTS_BAD;
  }

  /* ========== Get active operation objects ========== */
  p_ctx = KMS_GETSESSION(hSession).pCtx;
 80269d0:	00e3      	lsls	r3, r4, #3
 80269d2:	191c      	adds	r4, r3, r4
 80269d4:	00a4      	lsls	r4, r4, #2
 80269d6:	1914      	adds	r4, r2, r4
 80269d8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  *pulObjectCount = 0;
 80269da:	2300      	movs	r3, #0
 80269dc:	602b      	str	r3, [r5, #0]
  for (i = p_ctx->searchIndex; (i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)))
 80269de:	3315      	adds	r3, #21
 80269e0:	33ff      	adds	r3, #255	; 0xff
 80269e2:	58cc      	ldr	r4, [r1, r3]
 80269e4:	e000      	b.n	80269e8 <KMS_FindObjects+0x50>
       && (*pulObjectCount < ulMaxObjectCount); i++)
 80269e6:	3401      	adds	r4, #1
  for (i = p_ctx->searchIndex; (i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)))
 80269e8:	2c44      	cmp	r4, #68	; 0x44
 80269ea:	d80c      	bhi.n	8026a06 <KMS_FindObjects+0x6e>
       && (*pulObjectCount < ulMaxObjectCount); i++)
 80269ec:	682b      	ldr	r3, [r5, #0]
 80269ee:	42b3      	cmp	r3, r6
 80269f0:	d209      	bcs.n	8026a06 <KMS_FindObjects+0x6e>
  {
    if (p_ctx->searchHandles[i] != KMS_HANDLE_KEY_NOT_KNOWN)
 80269f2:	00a2      	lsls	r2, r4, #2
 80269f4:	5852      	ldr	r2, [r2, r1]
 80269f6:	2a00      	cmp	r2, #0
 80269f8:	d0f5      	beq.n	80269e6 <KMS_FindObjects+0x4e>
    {
      phObject[*pulObjectCount] = p_ctx->searchHandles[i];
 80269fa:	009b      	lsls	r3, r3, #2
 80269fc:	50fa      	str	r2, [r7, r3]
      *pulObjectCount += 1UL;
 80269fe:	682b      	ldr	r3, [r5, #0]
 8026a00:	3301      	adds	r3, #1
 8026a02:	602b      	str	r3, [r5, #0]
 8026a04:	e7ef      	b.n	80269e6 <KMS_FindObjects+0x4e>
    }
  }
  /* Update searchIndex to filter out already transmitted values */
  p_ctx->searchIndex = i;
 8026a06:	238a      	movs	r3, #138	; 0x8a
 8026a08:	005b      	lsls	r3, r3, #1
 8026a0a:	50cc      	str	r4, [r1, r3]

  return CKR_OK;
 8026a0c:	e001      	b.n	8026a12 <KMS_FindObjects+0x7a>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026a0e:	20c8      	movs	r0, #200	; 0xc8
 8026a10:	0040      	lsls	r0, r0, #1
#else /* KMS_SEARCH */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SEARCH */
}
 8026a12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026a14:	20b3      	movs	r0, #179	; 0xb3
 8026a16:	e7fc      	b.n	8026a12 <KMS_FindObjects+0x7a>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026a18:	20c8      	movs	r0, #200	; 0xc8
 8026a1a:	0040      	lsls	r0, r0, #1
 8026a1c:	e7f9      	b.n	8026a12 <KMS_FindObjects+0x7a>
    return CKR_ARGUMENTS_BAD;
 8026a1e:	2007      	movs	r0, #7
 8026a20:	e7f7      	b.n	8026a12 <KMS_FindObjects+0x7a>
 8026a22:	2007      	movs	r0, #7
 8026a24:	e7f5      	b.n	8026a12 <KMS_FindObjects+0x7a>
 8026a26:	2007      	movs	r0, #7
 8026a28:	e7f3      	b.n	8026a12 <KMS_FindObjects+0x7a>
 8026a2a:	46c0      	nop			; (mov r8, r8)
 8026a2c:	2000a200 	.word	0x2000a200

08026a30 <KMS_FindObjectsFinal>:
  *         CKR_CRYPTOKI_NOT_INITIALIZED
  *         CKR_FUNCTION_NOT_SUPPORTED
  *         CKR_SESSION_HANDLE_INVALID
  */
CK_RV KMS_FindObjectsFinal(CK_SESSION_HANDLE hSession)
{
 8026a30:	b570      	push	{r4, r5, r6, lr}
 8026a32:	0004      	movs	r4, r0
#if defined(KMS_SEARCH)
  /* ========== Check active operation status ========== */

  if (!KMS_IS_INITIALIZED())
 8026a34:	4b17      	ldr	r3, [pc, #92]	; (8026a94 <KMS_FindObjectsFinal+0x64>)
 8026a36:	781b      	ldrb	r3, [r3, #0]
 8026a38:	2b00      	cmp	r3, #0
 8026a3a:	d021      	beq.n	8026a80 <KMS_FindObjectsFinal+0x50>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026a3c:	f000 fbea 	bl	8027214 <KMS_CheckSessionHdle>
 8026a40:	1e05      	subs	r5, r0, #0
 8026a42:	d121      	bne.n	8026a88 <KMS_FindObjectsFinal+0x58>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if there is a pending operation: i.e. FindObjectInit was called*/
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_SEARCH)
 8026a44:	1e66      	subs	r6, r4, #1
 8026a46:	00f3      	lsls	r3, r6, #3
 8026a48:	199b      	adds	r3, r3, r6
 8026a4a:	009b      	lsls	r3, r3, #2
 8026a4c:	4a11      	ldr	r2, [pc, #68]	; (8026a94 <KMS_FindObjectsFinal+0x64>)
 8026a4e:	18d3      	adds	r3, r2, r3
 8026a50:	68db      	ldr	r3, [r3, #12]
 8026a52:	2b06      	cmp	r3, #6
 8026a54:	d11a      	bne.n	8026a8c <KMS_FindObjectsFinal+0x5c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }

  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8026a56:	00f3      	lsls	r3, r6, #3
 8026a58:	199b      	adds	r3, r3, r6
 8026a5a:	009b      	lsls	r3, r3, #2
 8026a5c:	18d3      	adds	r3, r2, r3
 8026a5e:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8026a60:	2900      	cmp	r1, #0
 8026a62:	d009      	beq.n	8026a78 <KMS_FindObjectsFinal+0x48>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8026a64:	0020      	movs	r0, r4
 8026a66:	f000 fd51 	bl	802750c <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026a6a:	00f3      	lsls	r3, r6, #3
 8026a6c:	199e      	adds	r6, r3, r6
 8026a6e:	00b6      	lsls	r6, r6, #2
 8026a70:	4b08      	ldr	r3, [pc, #32]	; (8026a94 <KMS_FindObjectsFinal+0x64>)
 8026a72:	199e      	adds	r6, r3, r6
 8026a74:	2300      	movs	r3, #0
 8026a76:	62b3      	str	r3, [r6, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 8026a78:	0020      	movs	r0, r4
 8026a7a:	f000 fc13 	bl	80272a4 <KMS_SetStateIdle>

  return CKR_OK;
 8026a7e:	e001      	b.n	8026a84 <KMS_FindObjectsFinal+0x54>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026a80:	25c8      	movs	r5, #200	; 0xc8
 8026a82:	006d      	lsls	r5, r5, #1
#else /* KMS_SEARCH */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SEARCH */
}
 8026a84:	0028      	movs	r0, r5
 8026a86:	bd70      	pop	{r4, r5, r6, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026a88:	25b3      	movs	r5, #179	; 0xb3
 8026a8a:	e7fb      	b.n	8026a84 <KMS_FindObjectsFinal+0x54>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026a8c:	25c8      	movs	r5, #200	; 0xc8
 8026a8e:	006d      	lsls	r5, r5, #1
 8026a90:	e7f8      	b.n	8026a84 <KMS_FindObjectsFinal+0x54>
 8026a92:	46c0      	nop			; (mov r8, r8)
 8026a94:	2000a200 	.word	0x2000a200

08026a98 <encrypt_decrypt_init>:
  */
static CK_RV encrypt_decrypt_init(CK_SESSION_HANDLE hSession,
                                  CK_MECHANISM_PTR pMechanism,
                                  CK_OBJECT_HANDLE hKey,
                                  int32_t encdec_flag)
{
 8026a98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026a9a:	46d6      	mov	lr, sl
 8026a9c:	b500      	push	{lr}
 8026a9e:	b084      	sub	sp, #16
 8026aa0:	0004      	movs	r4, r0
 8026aa2:	000d      	movs	r5, r1
 8026aa4:	9200      	str	r2, [sp, #0]
 8026aa6:	9301      	str	r3, [sp, #4]
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;

  if (!KMS_IS_INITIALIZED())
 8026aa8:	4ba6      	ldr	r3, [pc, #664]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026aaa:	781b      	ldrb	r3, [r3, #0]
 8026aac:	2b00      	cmp	r3, #0
 8026aae:	d100      	bne.n	8026ab2 <encrypt_decrypt_init+0x1a>
 8026ab0:	e1d8      	b.n	8026e64 <encrypt_decrypt_init+0x3cc>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026ab2:	f000 fbaf 	bl	8027214 <KMS_CheckSessionHdle>
 8026ab6:	2800      	cmp	r0, #0
 8026ab8:	d000      	beq.n	8026abc <encrypt_decrypt_init+0x24>
 8026aba:	e1da      	b.n	8026e72 <encrypt_decrypt_init+0x3da>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8026abc:	1e66      	subs	r6, r4, #1
 8026abe:	00f3      	lsls	r3, r6, #3
 8026ac0:	199b      	adds	r3, r3, r6
 8026ac2:	009b      	lsls	r3, r3, #2
 8026ac4:	4a9f      	ldr	r2, [pc, #636]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026ac6:	18d3      	adds	r3, r2, r3
 8026ac8:	68db      	ldr	r3, [r3, #12]
 8026aca:	2b00      	cmp	r3, #0
 8026acc:	d000      	beq.n	8026ad0 <encrypt_decrypt_init+0x38>
 8026ace:	e1d2      	b.n	8026e76 <encrypt_decrypt_init+0x3de>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check parameter */
  if (pMechanism == NULL_PTR)
 8026ad0:	2d00      	cmp	r5, #0
 8026ad2:	d100      	bne.n	8026ad6 <encrypt_decrypt_init+0x3e>
 8026ad4:	e1d1      	b.n	8026e7a <encrypt_decrypt_init+0x3e2>
  {
    return CKR_ARGUMENTS_BAD;
  }
  switch (pMechanism->mechanism)
 8026ad6:	682b      	ldr	r3, [r5, #0]
 8026ad8:	4a9b      	ldr	r2, [pc, #620]	; (8026d48 <encrypt_decrypt_init+0x2b0>)
 8026ada:	4293      	cmp	r3, r2
 8026adc:	d009      	beq.n	8026af2 <encrypt_decrypt_init+0x5a>
 8026ade:	4a9b      	ldr	r2, [pc, #620]	; (8026d4c <encrypt_decrypt_init+0x2b4>)
 8026ae0:	4293      	cmp	r3, r2
 8026ae2:	d100      	bne.n	8026ae6 <encrypt_decrypt_init+0x4e>
 8026ae4:	e100      	b.n	8026ce8 <encrypt_decrypt_init+0x250>
 8026ae6:	4a9a      	ldr	r2, [pc, #616]	; (8026d50 <encrypt_decrypt_init+0x2b8>)
 8026ae8:	4293      	cmp	r3, r2
 8026aea:	d100      	bne.n	8026aee <encrypt_decrypt_init+0x56>
 8026aec:	e081      	b.n	8026bf2 <encrypt_decrypt_init+0x15a>
 8026aee:	2770      	movs	r7, #112	; 0x70
 8026af0:	e1ba      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
      kms_attr_t *P_pKeyAttribute;
      kms_aes_cbc_ec_ctx_t *p_ctx;

      /* Read the key value from the Key Handle                 */
      /* Key Handle is the index to one of static or nvm        */
      pkms_object = KMS_Objects_GetPointer(hKey);
 8026af2:	9800      	ldr	r0, [sp, #0]
 8026af4:	f001 fb32 	bl	802815c <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL_PTR) &&
 8026af8:	2800      	cmp	r0, #0
 8026afa:	d005      	beq.n	8026b08 <encrypt_decrypt_init+0x70>
 8026afc:	4b95      	ldr	r3, [pc, #596]	; (8026d54 <encrypt_decrypt_init+0x2bc>)
 8026afe:	6802      	ldr	r2, [r0, #0]
 8026b00:	429a      	cmp	r2, r3
 8026b02:	d003      	beq.n	8026b0c <encrypt_decrypt_init+0x74>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026b04:	2782      	movs	r7, #130	; 0x82
 8026b06:	e1af      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
 8026b08:	2782      	movs	r7, #130	; 0x82
 8026b0a:	e1ad      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8026b0c:	4b92      	ldr	r3, [pc, #584]	; (8026d58 <encrypt_decrypt_init+0x2c0>)
 8026b0e:	6842      	ldr	r2, [r0, #4]
 8026b10:	429a      	cmp	r2, r3
 8026b12:	d001      	beq.n	8026b18 <encrypt_decrypt_init+0x80>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026b14:	2782      	movs	r7, #130	; 0x82
 8026b16:	e1a7      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter != NULL_PTR) &&
 8026b18:	686b      	ldr	r3, [r5, #4]
 8026b1a:	2b00      	cmp	r3, #0
 8026b1c:	d004      	beq.n	8026b28 <encrypt_decrypt_init+0x90>
 8026b1e:	68ab      	ldr	r3, [r5, #8]
 8026b20:	2b00      	cmp	r3, #0
 8026b22:	d103      	bne.n	8026b2c <encrypt_decrypt_init+0x94>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026b24:	2707      	movs	r7, #7
 8026b26:	e19f      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
 8026b28:	2707      	movs	r7, #7
 8026b2a:	e19d      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8026b2c:	aa03      	add	r2, sp, #12
 8026b2e:	0001      	movs	r1, r0
 8026b30:	2011      	movs	r0, #17
 8026b32:	f001 fb70 	bl	8028216 <KMS_Objects_SearchAttributes>
 8026b36:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 8026b38:	d000      	beq.n	8026b3c <encrypt_decrypt_init+0xa4>
 8026b3a:	e149      	b.n	8026dd0 <encrypt_decrypt_init+0x338>
            if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8026b3c:	9b03      	ldr	r3, [sp, #12]
 8026b3e:	685b      	ldr	r3, [r3, #4]
 8026b40:	2b10      	cmp	r3, #16
 8026b42:	d005      	beq.n	8026b50 <encrypt_decrypt_init+0xb8>
 8026b44:	2b18      	cmp	r3, #24
 8026b46:	d003      	beq.n	8026b50 <encrypt_decrypt_init+0xb8>
                (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8026b48:	2b20      	cmp	r3, #32
 8026b4a:	d001      	beq.n	8026b50 <encrypt_decrypt_init+0xb8>
              e_ret_status = CKR_ARGUMENTS_BAD;
 8026b4c:	3707      	adds	r7, #7
 8026b4e:	e18b      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
              p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_cbc_ec_ctx_t));
 8026b50:	21c4      	movs	r1, #196	; 0xc4
 8026b52:	0049      	lsls	r1, r1, #1
 8026b54:	0020      	movs	r0, r4
 8026b56:	f000 fcb3 	bl	80274c0 <KMS_Alloc>
 8026b5a:	4682      	mov	sl, r0
              if (p_ctx == NULL_PTR)
 8026b5c:	2800      	cmp	r0, #0
 8026b5e:	d046      	beq.n	8026bee <encrypt_decrypt_init+0x156>
              KMS_GETSESSION(hSession).hKey = hKey;
 8026b60:	00f3      	lsls	r3, r6, #3
 8026b62:	199b      	adds	r3, r3, r6
 8026b64:	009a      	lsls	r2, r3, #2
 8026b66:	4b77      	ldr	r3, [pc, #476]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026b68:	189b      	adds	r3, r3, r2
 8026b6a:	9a00      	ldr	r2, [sp, #0]
 8026b6c:	625a      	str	r2, [r3, #36]	; 0x24
              KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8026b6e:	682a      	ldr	r2, [r5, #0]
 8026b70:	621a      	str	r2, [r3, #32]
              KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026b72:	6298      	str	r0, [r3, #40]	; 0x28
              p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 8026b74:	2324      	movs	r3, #36	; 0x24
 8026b76:	2200      	movs	r2, #0
 8026b78:	0001      	movs	r1, r0
 8026b7a:	54c2      	strb	r2, [r0, r3]
              p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 8026b7c:	9803      	ldr	r0, [sp, #12]
 8026b7e:	6842      	ldr	r2, [r0, #4]
 8026b80:	644a      	str	r2, [r1, #68]	; 0x44
              p_ctx->ca_ctx.pmKey = p_ctx->key;
 8026b82:	6289      	str	r1, [r1, #40]	; 0x28
              KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 8026b84:	6841      	ldr	r1, [r0, #4]
 8026b86:	3008      	adds	r0, #8
 8026b88:	4652      	mov	r2, sl
 8026b8a:	f001 fc2a 	bl	80283e2 <KMS_Objects_BlobU32_2_u8ptr>
              p_ctx->ca_ctx.mIvSize = (int32_t)pMechanism->ulParameterLen;
 8026b8e:	4653      	mov	r3, sl
 8026b90:	68aa      	ldr	r2, [r5, #8]
 8026b92:	631a      	str	r2, [r3, #48]	; 0x30
              if (encdec_flag == KMS_FLAG_ENCRYPT)
 8026b94:	9b01      	ldr	r3, [sp, #4]
 8026b96:	2b00      	cmp	r3, #0
 8026b98:	d114      	bne.n	8026bc4 <encrypt_decrypt_init+0x12c>
                                            pMechanism->pParameter) == CA_AES_SUCCESS)
 8026b9a:	686a      	ldr	r2, [r5, #4]
                if (CA_AES_CBC_Encrypt_Init(&(p_ctx->ca_ctx),
 8026b9c:	4650      	mov	r0, sl
 8026b9e:	3020      	adds	r0, #32
 8026ba0:	4651      	mov	r1, sl
 8026ba2:	f7fe ff87 	bl	8025ab4 <CA_AES_CBC_Encrypt_Init>
 8026ba6:	2800      	cmp	r0, #0
 8026ba8:	d100      	bne.n	8026bac <encrypt_decrypt_init+0x114>
 8026baa:	e113      	b.n	8026dd4 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026bac:	4651      	mov	r1, sl
 8026bae:	0020      	movs	r0, r4
 8026bb0:	f000 fcac 	bl	802750c <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026bb4:	2324      	movs	r3, #36	; 0x24
 8026bb6:	435e      	muls	r6, r3
 8026bb8:	4b62      	ldr	r3, [pc, #392]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026bba:	199b      	adds	r3, r3, r6
 8026bbc:	2200      	movs	r2, #0
 8026bbe:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026bc0:	2706      	movs	r7, #6
 8026bc2:	e151      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
                                            pMechanism->pParameter) == CA_AES_SUCCESS)
 8026bc4:	686a      	ldr	r2, [r5, #4]
                if (CA_AES_CBC_Decrypt_Init(&(p_ctx->ca_ctx),
 8026bc6:	4650      	mov	r0, sl
 8026bc8:	3020      	adds	r0, #32
 8026bca:	4651      	mov	r1, sl
 8026bcc:	f7ff f86e 	bl	8025cac <CA_AES_CBC_Decrypt_Init>
 8026bd0:	2800      	cmp	r0, #0
 8026bd2:	d100      	bne.n	8026bd6 <encrypt_decrypt_init+0x13e>
 8026bd4:	e0fe      	b.n	8026dd4 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026bd6:	4651      	mov	r1, sl
 8026bd8:	0020      	movs	r0, r4
 8026bda:	f000 fc97 	bl	802750c <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026bde:	2324      	movs	r3, #36	; 0x24
 8026be0:	435e      	muls	r6, r3
 8026be2:	4b58      	ldr	r3, [pc, #352]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026be4:	199b      	adds	r3, r3, r6
 8026be6:	2200      	movs	r2, #0
 8026be8:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026bea:	2706      	movs	r7, #6
 8026bec:	e13c      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
                e_ret_status = CKR_DEVICE_MEMORY;
 8026bee:	2731      	movs	r7, #49	; 0x31
 8026bf0:	e13a      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
      kms_obj_keyhead_t *pkms_object;
      kms_attr_t *P_pKeyAttribute;
      kms_aes_ecb_ec_ctx_t *p_ctx;

      /* Read the key value from the Key Handle                 */
      pkms_object = KMS_Objects_GetPointer(hKey);
 8026bf2:	9800      	ldr	r0, [sp, #0]
 8026bf4:	f001 fab2 	bl	802815c <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL_PTR) &&
 8026bf8:	2800      	cmp	r0, #0
 8026bfa:	d005      	beq.n	8026c08 <encrypt_decrypt_init+0x170>
 8026bfc:	4b55      	ldr	r3, [pc, #340]	; (8026d54 <encrypt_decrypt_init+0x2bc>)
 8026bfe:	6802      	ldr	r2, [r0, #0]
 8026c00:	429a      	cmp	r2, r3
 8026c02:	d003      	beq.n	8026c0c <encrypt_decrypt_init+0x174>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026c04:	2782      	movs	r7, #130	; 0x82
 8026c06:	e12f      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
 8026c08:	2782      	movs	r7, #130	; 0x82
 8026c0a:	e12d      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8026c0c:	4b52      	ldr	r3, [pc, #328]	; (8026d58 <encrypt_decrypt_init+0x2c0>)
 8026c0e:	6842      	ldr	r2, [r0, #4]
 8026c10:	429a      	cmp	r2, r3
 8026c12:	d001      	beq.n	8026c18 <encrypt_decrypt_init+0x180>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026c14:	2782      	movs	r7, #130	; 0x82
 8026c16:	e127      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter == NULL_PTR) &&
 8026c18:	686b      	ldr	r3, [r5, #4]
 8026c1a:	2b00      	cmp	r3, #0
 8026c1c:	d001      	beq.n	8026c22 <encrypt_decrypt_init+0x18a>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026c1e:	2707      	movs	r7, #7
 8026c20:	e122      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter == NULL_PTR) &&
 8026c22:	68ab      	ldr	r3, [r5, #8]
 8026c24:	2b00      	cmp	r3, #0
 8026c26:	d001      	beq.n	8026c2c <encrypt_decrypt_init+0x194>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026c28:	2707      	movs	r7, #7
 8026c2a:	e11d      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8026c2c:	aa03      	add	r2, sp, #12
 8026c2e:	0001      	movs	r1, r0
 8026c30:	2011      	movs	r0, #17
 8026c32:	f001 faf0 	bl	8028216 <KMS_Objects_SearchAttributes>
 8026c36:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 8026c38:	d000      	beq.n	8026c3c <encrypt_decrypt_init+0x1a4>
 8026c3a:	e0c9      	b.n	8026dd0 <encrypt_decrypt_init+0x338>
            if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8026c3c:	9b03      	ldr	r3, [sp, #12]
 8026c3e:	685b      	ldr	r3, [r3, #4]
 8026c40:	2b10      	cmp	r3, #16
 8026c42:	d005      	beq.n	8026c50 <encrypt_decrypt_init+0x1b8>
 8026c44:	2b18      	cmp	r3, #24
 8026c46:	d003      	beq.n	8026c50 <encrypt_decrypt_init+0x1b8>
                (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8026c48:	2b20      	cmp	r3, #32
 8026c4a:	d001      	beq.n	8026c50 <encrypt_decrypt_init+0x1b8>
              e_ret_status = CKR_ARGUMENTS_BAD;
 8026c4c:	3707      	adds	r7, #7
 8026c4e:	e10b      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
              p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_ecb_ec_ctx_t));
 8026c50:	21c4      	movs	r1, #196	; 0xc4
 8026c52:	0049      	lsls	r1, r1, #1
 8026c54:	0020      	movs	r0, r4
 8026c56:	f000 fc33 	bl	80274c0 <KMS_Alloc>
 8026c5a:	4682      	mov	sl, r0
              if (p_ctx == NULL_PTR)
 8026c5c:	2800      	cmp	r0, #0
 8026c5e:	d041      	beq.n	8026ce4 <encrypt_decrypt_init+0x24c>
              KMS_GETSESSION(hSession).hKey = hKey;
 8026c60:	2224      	movs	r2, #36	; 0x24
 8026c62:	0011      	movs	r1, r2
 8026c64:	4371      	muls	r1, r6
 8026c66:	4b37      	ldr	r3, [pc, #220]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026c68:	185b      	adds	r3, r3, r1
 8026c6a:	9900      	ldr	r1, [sp, #0]
 8026c6c:	6259      	str	r1, [r3, #36]	; 0x24
              KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8026c6e:	6829      	ldr	r1, [r5, #0]
 8026c70:	6219      	str	r1, [r3, #32]
              KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026c72:	6298      	str	r0, [r3, #40]	; 0x28
              p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 8026c74:	2300      	movs	r3, #0
 8026c76:	5483      	strb	r3, [r0, r2]
              p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 8026c78:	9b03      	ldr	r3, [sp, #12]
 8026c7a:	0002      	movs	r2, r0
 8026c7c:	6859      	ldr	r1, [r3, #4]
 8026c7e:	6441      	str	r1, [r0, #68]	; 0x44
              KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 8026c80:	0018      	movs	r0, r3
 8026c82:	3008      	adds	r0, #8
 8026c84:	6859      	ldr	r1, [r3, #4]
 8026c86:	f001 fbac 	bl	80283e2 <KMS_Objects_BlobU32_2_u8ptr>
              if (encdec_flag == KMS_FLAG_ENCRYPT)
 8026c8a:	9b01      	ldr	r3, [sp, #4]
 8026c8c:	2b00      	cmp	r3, #0
 8026c8e:	d114      	bne.n	8026cba <encrypt_decrypt_init+0x222>
                if (CA_AES_ECB_Encrypt_Init(&(p_ctx->ca_ctx),
 8026c90:	4650      	mov	r0, sl
 8026c92:	3020      	adds	r0, #32
 8026c94:	2200      	movs	r2, #0
 8026c96:	4651      	mov	r1, sl
 8026c98:	f7ff f980 	bl	8025f9c <CA_AES_ECB_Encrypt_Init>
 8026c9c:	2800      	cmp	r0, #0
 8026c9e:	d100      	bne.n	8026ca2 <encrypt_decrypt_init+0x20a>
 8026ca0:	e098      	b.n	8026dd4 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026ca2:	4651      	mov	r1, sl
 8026ca4:	0020      	movs	r0, r4
 8026ca6:	f000 fc31 	bl	802750c <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026caa:	2324      	movs	r3, #36	; 0x24
 8026cac:	435e      	muls	r6, r3
 8026cae:	4b25      	ldr	r3, [pc, #148]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026cb0:	199b      	adds	r3, r3, r6
 8026cb2:	2200      	movs	r2, #0
 8026cb4:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026cb6:	2706      	movs	r7, #6
 8026cb8:	e0d6      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
                if (CA_AES_ECB_Decrypt_Init(&(p_ctx->ca_ctx),
 8026cba:	4650      	mov	r0, sl
 8026cbc:	3020      	adds	r0, #32
 8026cbe:	2200      	movs	r2, #0
 8026cc0:	4651      	mov	r1, sl
 8026cc2:	f7ff fa21 	bl	8026108 <CA_AES_ECB_Decrypt_Init>
 8026cc6:	2800      	cmp	r0, #0
 8026cc8:	d100      	bne.n	8026ccc <encrypt_decrypt_init+0x234>
 8026cca:	e083      	b.n	8026dd4 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026ccc:	4651      	mov	r1, sl
 8026cce:	0020      	movs	r0, r4
 8026cd0:	f000 fc1c 	bl	802750c <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026cd4:	2324      	movs	r3, #36	; 0x24
 8026cd6:	435e      	muls	r6, r3
 8026cd8:	4b1a      	ldr	r3, [pc, #104]	; (8026d44 <encrypt_decrypt_init+0x2ac>)
 8026cda:	199b      	adds	r3, r3, r6
 8026cdc:	2200      	movs	r2, #0
 8026cde:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026ce0:	2706      	movs	r7, #6
 8026ce2:	e0c1      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
                e_ret_status = CKR_DEVICE_MEMORY;
 8026ce4:	2731      	movs	r7, #49	; 0x31
 8026ce6:	e0bf      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
      kms_aes_gcm_ec_ctx_t *p_ctx;
      CK_GCM_PARAMS *pGCMParams;

      /* Read the key value from the Key Handle                 */
      /* Key Handle is the index to one of static or nvm        */
      pkms_object = KMS_Objects_GetPointer(hKey);
 8026ce8:	9800      	ldr	r0, [sp, #0]
 8026cea:	f001 fa37 	bl	802815c <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL_PTR) &&
 8026cee:	2800      	cmp	r0, #0
 8026cf0:	d005      	beq.n	8026cfe <encrypt_decrypt_init+0x266>
 8026cf2:	4b18      	ldr	r3, [pc, #96]	; (8026d54 <encrypt_decrypt_init+0x2bc>)
 8026cf4:	6802      	ldr	r2, [r0, #0]
 8026cf6:	429a      	cmp	r2, r3
 8026cf8:	d003      	beq.n	8026d02 <encrypt_decrypt_init+0x26a>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026cfa:	2782      	movs	r7, #130	; 0x82
 8026cfc:	e0b4      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
 8026cfe:	2782      	movs	r7, #130	; 0x82
 8026d00:	e0b2      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8026d02:	4b15      	ldr	r3, [pc, #84]	; (8026d58 <encrypt_decrypt_init+0x2c0>)
 8026d04:	6842      	ldr	r2, [r0, #4]
 8026d06:	429a      	cmp	r2, r3
 8026d08:	d001      	beq.n	8026d0e <encrypt_decrypt_init+0x276>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026d0a:	2782      	movs	r7, #130	; 0x82
 8026d0c:	e0ac      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter != NULL_PTR) &&
 8026d0e:	686b      	ldr	r3, [r5, #4]
 8026d10:	2b00      	cmp	r3, #0
 8026d12:	d004      	beq.n	8026d1e <encrypt_decrypt_init+0x286>
 8026d14:	68ab      	ldr	r3, [r5, #8]
 8026d16:	2b00      	cmp	r3, #0
 8026d18:	d103      	bne.n	8026d22 <encrypt_decrypt_init+0x28a>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026d1a:	2707      	movs	r7, #7
 8026d1c:	e0a4      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
 8026d1e:	2707      	movs	r7, #7
 8026d20:	e0a2      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8026d22:	aa03      	add	r2, sp, #12
 8026d24:	0001      	movs	r1, r0
 8026d26:	2011      	movs	r0, #17
 8026d28:	f001 fa75 	bl	8028216 <KMS_Objects_SearchAttributes>
 8026d2c:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 8026d2e:	d14f      	bne.n	8026dd0 <encrypt_decrypt_init+0x338>
            if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8026d30:	9b03      	ldr	r3, [sp, #12]
 8026d32:	685b      	ldr	r3, [r3, #4]
 8026d34:	2b10      	cmp	r3, #16
 8026d36:	d011      	beq.n	8026d5c <encrypt_decrypt_init+0x2c4>
 8026d38:	2b18      	cmp	r3, #24
 8026d3a:	d00f      	beq.n	8026d5c <encrypt_decrypt_init+0x2c4>
                (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8026d3c:	2b20      	cmp	r3, #32
 8026d3e:	d00d      	beq.n	8026d5c <encrypt_decrypt_init+0x2c4>
              e_ret_status = CKR_ARGUMENTS_BAD;
 8026d40:	3707      	adds	r7, #7
 8026d42:	e091      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
 8026d44:	2000a200 	.word	0x2000a200
 8026d48:	00001082 	.word	0x00001082
 8026d4c:	00001087 	.word	0x00001087
 8026d50:	00001081 	.word	0x00001081
 8026d54:	b10b0240 	.word	0xb10b0240
 8026d58:	b10b0003 	.word	0xb10b0003
              p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_gcm_ec_ctx_t));
 8026d5c:	21ca      	movs	r1, #202	; 0xca
 8026d5e:	0049      	lsls	r1, r1, #1
 8026d60:	0020      	movs	r0, r4
 8026d62:	f000 fbad 	bl	80274c0 <KMS_Alloc>
 8026d66:	4682      	mov	sl, r0
              if (p_ctx == NULL_PTR)
 8026d68:	2800      	cmp	r0, #0
 8026d6a:	d071      	beq.n	8026e50 <encrypt_decrypt_init+0x3b8>
              KMS_GETSESSION(hSession).hKey = hKey;
 8026d6c:	00f3      	lsls	r3, r6, #3
 8026d6e:	199b      	adds	r3, r3, r6
 8026d70:	009a      	lsls	r2, r3, #2
 8026d72:	4b43      	ldr	r3, [pc, #268]	; (8026e80 <encrypt_decrypt_init+0x3e8>)
 8026d74:	189b      	adds	r3, r3, r2
 8026d76:	9a00      	ldr	r2, [sp, #0]
 8026d78:	625a      	str	r2, [r3, #36]	; 0x24
              KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8026d7a:	682a      	ldr	r2, [r5, #0]
 8026d7c:	621a      	str	r2, [r3, #32]
              KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026d7e:	6298      	str	r0, [r3, #40]	; 0x28
              pGCMParams = (CK_GCM_PARAMS *)pMechanism->pParameter;
 8026d80:	686d      	ldr	r5, [r5, #4]
              p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 8026d82:	2324      	movs	r3, #36	; 0x24
 8026d84:	2200      	movs	r2, #0
 8026d86:	0001      	movs	r1, r0
 8026d88:	54c2      	strb	r2, [r0, r3]
              p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 8026d8a:	9803      	ldr	r0, [sp, #12]
 8026d8c:	6842      	ldr	r2, [r0, #4]
 8026d8e:	644a      	str	r2, [r1, #68]	; 0x44
              KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 8026d90:	6841      	ldr	r1, [r0, #4]
 8026d92:	3008      	adds	r0, #8
 8026d94:	4652      	mov	r2, sl
 8026d96:	f001 fb24 	bl	80283e2 <KMS_Objects_BlobU32_2_u8ptr>
              p_ctx->ca_ctx.pmKey = p_ctx->key;
 8026d9a:	4653      	mov	r3, sl
 8026d9c:	629b      	str	r3, [r3, #40]	; 0x28
              p_ctx->ca_ctx.mIvSize = (int32_t)pGCMParams->ulIvLen;
 8026d9e:	686a      	ldr	r2, [r5, #4]
 8026da0:	631a      	str	r2, [r3, #48]	; 0x30
              p_ctx->ca_ctx.mTagSize = ((int32_t)(pGCMParams->ulTagBits) / 8L);
 8026da2:	692a      	ldr	r2, [r5, #16]
 8026da4:	17d1      	asrs	r1, r2, #31
 8026da6:	2307      	movs	r3, #7
 8026da8:	400b      	ands	r3, r1
 8026daa:	189b      	adds	r3, r3, r2
 8026dac:	10db      	asrs	r3, r3, #3
 8026dae:	4652      	mov	r2, sl
 8026db0:	64d3      	str	r3, [r2, #76]	; 0x4c
              if (encdec_flag == KMS_FLAG_ENCRYPT)
 8026db2:	9b01      	ldr	r3, [sp, #4]
 8026db4:	2b00      	cmp	r3, #0
 8026db6:	d124      	bne.n	8026e02 <encrypt_decrypt_init+0x36a>
                if (CA_AES_GCM_Encrypt_Init(&(p_ctx->ca_ctx),
 8026db8:	4650      	mov	r0, sl
 8026dba:	3020      	adds	r0, #32
 8026dbc:	682a      	ldr	r2, [r5, #0]
 8026dbe:	4651      	mov	r1, sl
 8026dc0:	f7ff fa1a 	bl	80261f8 <CA_AES_GCM_Encrypt_Init>
 8026dc4:	2800      	cmp	r0, #0
 8026dc6:	d110      	bne.n	8026dea <encrypt_decrypt_init+0x352>
              if ((e_ret_status == CKR_OK) && (pGCMParams->ulAADLen != 0UL))
 8026dc8:	68ea      	ldr	r2, [r5, #12]
 8026dca:	2a00      	cmp	r2, #0
 8026dcc:	d12d      	bne.n	8026e2a <encrypt_decrypt_init+0x392>
 8026dce:	0017      	movs	r7, r2
    {
      e_ret_status = CKR_MECHANISM_INVALID;
      break;
    }
  }
  if (e_ret_status == CKR_OK)
 8026dd0:	2f00      	cmp	r7, #0
 8026dd2:	d149      	bne.n	8026e68 <encrypt_decrypt_init+0x3d0>
  {
    /* If successful, set processing state of the session */
    if (encdec_flag == KMS_FLAG_ENCRYPT)
 8026dd4:	9b01      	ldr	r3, [sp, #4]
 8026dd6:	2b00      	cmp	r3, #0
 8026dd8:	d13c      	bne.n	8026e54 <encrypt_decrypt_init+0x3bc>
    {
      KMS_GETSESSION(hSession).state = KMS_SESSION_ENCRYPT;
 8026dda:	00f3      	lsls	r3, r6, #3
 8026ddc:	199b      	adds	r3, r3, r6
 8026dde:	009b      	lsls	r3, r3, #2
 8026de0:	4a27      	ldr	r2, [pc, #156]	; (8026e80 <encrypt_decrypt_init+0x3e8>)
 8026de2:	18d3      	adds	r3, r2, r3
 8026de4:	2202      	movs	r2, #2
 8026de6:	60da      	str	r2, [r3, #12]
 8026de8:	e03e      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
                  KMS_Free(hSession, p_ctx);
 8026dea:	4651      	mov	r1, sl
 8026dec:	0020      	movs	r0, r4
 8026dee:	f000 fb8d 	bl	802750c <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026df2:	2224      	movs	r2, #36	; 0x24
 8026df4:	4372      	muls	r2, r6
 8026df6:	4b22      	ldr	r3, [pc, #136]	; (8026e80 <encrypt_decrypt_init+0x3e8>)
 8026df8:	189b      	adds	r3, r3, r2
 8026dfa:	2200      	movs	r2, #0
 8026dfc:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026dfe:	2706      	movs	r7, #6
 8026e00:	e7e6      	b.n	8026dd0 <encrypt_decrypt_init+0x338>
                if (CA_AES_GCM_Decrypt_Init(&(p_ctx->ca_ctx),
 8026e02:	4650      	mov	r0, sl
 8026e04:	3020      	adds	r0, #32
 8026e06:	682a      	ldr	r2, [r5, #0]
 8026e08:	4651      	mov	r1, sl
 8026e0a:	f7ff fb2b 	bl	8026464 <CA_AES_GCM_Decrypt_Init>
 8026e0e:	2800      	cmp	r0, #0
 8026e10:	d0da      	beq.n	8026dc8 <encrypt_decrypt_init+0x330>
                  KMS_Free(hSession, p_ctx);
 8026e12:	4651      	mov	r1, sl
 8026e14:	0020      	movs	r0, r4
 8026e16:	f000 fb79 	bl	802750c <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026e1a:	2224      	movs	r2, #36	; 0x24
 8026e1c:	4372      	muls	r2, r6
 8026e1e:	4b18      	ldr	r3, [pc, #96]	; (8026e80 <encrypt_decrypt_init+0x3e8>)
 8026e20:	189b      	adds	r3, r3, r2
 8026e22:	2200      	movs	r2, #0
 8026e24:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026e26:	2706      	movs	r7, #6
 8026e28:	e7d2      	b.n	8026dd0 <encrypt_decrypt_init+0x338>
                                             pGCMParams->pAAD,
 8026e2a:	68a9      	ldr	r1, [r5, #8]
                if (CA_AES_GCM_Header_Append(&(p_ctx->ca_ctx),
 8026e2c:	4650      	mov	r0, sl
 8026e2e:	3020      	adds	r0, #32
 8026e30:	f7ff fbda 	bl	80265e8 <CA_AES_GCM_Header_Append>
 8026e34:	2800      	cmp	r0, #0
 8026e36:	d0cd      	beq.n	8026dd4 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026e38:	4651      	mov	r1, sl
 8026e3a:	0020      	movs	r0, r4
 8026e3c:	f000 fb66 	bl	802750c <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026e40:	2324      	movs	r3, #36	; 0x24
 8026e42:	435e      	muls	r6, r3
 8026e44:	4b0e      	ldr	r3, [pc, #56]	; (8026e80 <encrypt_decrypt_init+0x3e8>)
 8026e46:	199b      	adds	r3, r3, r6
 8026e48:	2200      	movs	r2, #0
 8026e4a:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026e4c:	2706      	movs	r7, #6
 8026e4e:	e00b      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
                e_ret_status = CKR_DEVICE_MEMORY;
 8026e50:	2731      	movs	r7, #49	; 0x31
 8026e52:	e009      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
    }
    else
    {
      KMS_GETSESSION(hSession).state = KMS_SESSION_DECRYPT;
 8026e54:	00f3      	lsls	r3, r6, #3
 8026e56:	199b      	adds	r3, r3, r6
 8026e58:	009b      	lsls	r3, r3, #2
 8026e5a:	4a09      	ldr	r2, [pc, #36]	; (8026e80 <encrypt_decrypt_init+0x3e8>)
 8026e5c:	18d3      	adds	r3, r2, r3
 8026e5e:	2203      	movs	r2, #3
 8026e60:	60da      	str	r2, [r3, #12]
 8026e62:	e001      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026e64:	27c8      	movs	r7, #200	; 0xc8
 8026e66:	007f      	lsls	r7, r7, #1
    }
  }

  return e_ret_status;
}
 8026e68:	0038      	movs	r0, r7
 8026e6a:	b004      	add	sp, #16
 8026e6c:	bc80      	pop	{r7}
 8026e6e:	46ba      	mov	sl, r7
 8026e70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026e72:	27b3      	movs	r7, #179	; 0xb3
 8026e74:	e7f8      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
    return CKR_SESSION_HANDLE_INVALID;
 8026e76:	27b3      	movs	r7, #179	; 0xb3
 8026e78:	e7f6      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
    return CKR_ARGUMENTS_BAD;
 8026e7a:	2707      	movs	r7, #7
 8026e7c:	e7f4      	b.n	8026e68 <encrypt_decrypt_init+0x3d0>
 8026e7e:	46c0      	nop			; (mov r8, r8)
 8026e80:	2000a200 	.word	0x2000a200

08026e84 <KMS_EncryptInit>:
  *         CKR_FUNCTION_NOT_SUPPORTED
  *         @ref encrypt_decrypt_init returned values
  */
CK_RV          KMS_EncryptInit(CK_SESSION_HANDLE hSession,
                               CK_MECHANISM_PTR pMechanism, CK_OBJECT_HANDLE hKey)
{
 8026e84:	b510      	push	{r4, lr}
#if defined(KMS_ENCRYPT)
  CK_RV e_ret_status;

  /* We reuse similar code between Encrypt & Decrypt Init */
  e_ret_status = encrypt_decrypt_init(hSession, pMechanism, hKey, KMS_FLAG_ENCRYPT);
 8026e86:	2300      	movs	r3, #0
 8026e88:	f7ff fe06 	bl	8026a98 <encrypt_decrypt_init>

  return (e_ret_status) ;
#else /* KMS_ENCRYPT */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ENCRYPT */
}
 8026e8c:	bd10      	pop	{r4, pc}
	...

08026e90 <KMS_EncryptUpdate>:
  */
CK_RV          KMS_EncryptUpdate(CK_SESSION_HANDLE hSession,
                                 CK_BYTE_PTR pPart, CK_ULONG ulPartLen,
                                 CK_BYTE_PTR pEncryptedPart,
                                 CK_ULONG_PTR pulEncryptedPartLen)
{
 8026e90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026e92:	b089      	sub	sp, #36	; 0x24
 8026e94:	0007      	movs	r7, r0
 8026e96:	9104      	str	r1, [sp, #16]
 8026e98:	0015      	movs	r5, r2
 8026e9a:	9303      	str	r3, [sp, #12]
#if defined(KMS_ENCRYPT)
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  int32_t lEncryptPartLen = 0;
 8026e9c:	2300      	movs	r3, #0
 8026e9e:	9307      	str	r3, [sp, #28]

  if (!KMS_IS_INITIALIZED())
 8026ea0:	4b48      	ldr	r3, [pc, #288]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026ea2:	781b      	ldrb	r3, [r3, #0]
 8026ea4:	2b00      	cmp	r3, #0
 8026ea6:	d100      	bne.n	8026eaa <KMS_EncryptUpdate+0x1a>
 8026ea8:	e082      	b.n	8026fb0 <KMS_EncryptUpdate+0x120>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026eaa:	f000 f9b3 	bl	8027214 <KMS_CheckSessionHdle>
 8026eae:	1e04      	subs	r4, r0, #0
 8026eb0:	d000      	beq.n	8026eb4 <KMS_EncryptUpdate+0x24>
 8026eb2:	e082      	b.n	8026fba <KMS_EncryptUpdate+0x12a>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if DigestInit has been called previously */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_ENCRYPT)
 8026eb4:	1e7e      	subs	r6, r7, #1
 8026eb6:	00f3      	lsls	r3, r6, #3
 8026eb8:	199b      	adds	r3, r3, r6
 8026eba:	009b      	lsls	r3, r3, #2
 8026ebc:	4a41      	ldr	r2, [pc, #260]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026ebe:	18d3      	adds	r3, r2, r3
 8026ec0:	68db      	ldr	r3, [r3, #12]
 8026ec2:	2b02      	cmp	r3, #2
 8026ec4:	d000      	beq.n	8026ec8 <KMS_EncryptUpdate+0x38>
 8026ec6:	e07a      	b.n	8026fbe <KMS_EncryptUpdate+0x12e>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  KMS_CHECK_BUFFER_SECTION5_2(pEncryptedPart, pulEncryptedPartLen, ulPartLen);
 8026ec8:	9b03      	ldr	r3, [sp, #12]
 8026eca:	2b00      	cmp	r3, #0
 8026ecc:	d02e      	beq.n	8026f2c <KMS_EncryptUpdate+0x9c>
 8026ece:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026ed0:	681b      	ldr	r3, [r3, #0]
 8026ed2:	9305      	str	r3, [sp, #20]
 8026ed4:	42ab      	cmp	r3, r5
 8026ed6:	d32c      	bcc.n	8026f32 <KMS_EncryptUpdate+0xa2>

  switch (KMS_GETSESSION(hSession).Mechanism)
 8026ed8:	00f3      	lsls	r3, r6, #3
 8026eda:	199b      	adds	r3, r3, r6
 8026edc:	009b      	lsls	r3, r3, #2
 8026ede:	4a39      	ldr	r2, [pc, #228]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026ee0:	18d3      	adds	r3, r2, r3
 8026ee2:	6a1b      	ldr	r3, [r3, #32]
 8026ee4:	4a38      	ldr	r2, [pc, #224]	; (8026fc8 <KMS_EncryptUpdate+0x138>)
 8026ee6:	4293      	cmp	r3, r2
 8026ee8:	d028      	beq.n	8026f3c <KMS_EncryptUpdate+0xac>
 8026eea:	4a38      	ldr	r2, [pc, #224]	; (8026fcc <KMS_EncryptUpdate+0x13c>)
 8026eec:	4293      	cmp	r3, r2
 8026eee:	d049      	beq.n	8026f84 <KMS_EncryptUpdate+0xf4>
 8026ef0:	4a37      	ldr	r2, [pc, #220]	; (8026fd0 <KMS_EncryptUpdate+0x140>)
 8026ef2:	4293      	cmp	r3, r2
 8026ef4:	d034      	beq.n	8026f60 <KMS_EncryptUpdate+0xd0>
 8026ef6:	2470      	movs	r4, #112	; 0x70
    *pulEncryptedPartLen = (uint32_t)lEncryptPartLen;
  }
  else
  {
    /* Return a 0-length value to upper layer */
    *pulEncryptedPartLen = 0UL;
 8026ef8:	2100      	movs	r1, #0
 8026efa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026efc:	6019      	str	r1, [r3, #0]
    /* In case of error:
     * - free the allocated context
     * - release the session
     */
    KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8026efe:	00f3      	lsls	r3, r6, #3
 8026f00:	199b      	adds	r3, r3, r6
 8026f02:	009b      	lsls	r3, r3, #2
 8026f04:	4a2f      	ldr	r2, [pc, #188]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026f06:	18d3      	adds	r3, r2, r3
 8026f08:	6259      	str	r1, [r3, #36]	; 0x24
    if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8026f0a:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8026f0c:	2900      	cmp	r1, #0
 8026f0e:	d009      	beq.n	8026f24 <KMS_EncryptUpdate+0x94>
    {
      KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8026f10:	0038      	movs	r0, r7
 8026f12:	f000 fafb 	bl	802750c <KMS_Free>
      KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026f16:	00f3      	lsls	r3, r6, #3
 8026f18:	199b      	adds	r3, r3, r6
 8026f1a:	009b      	lsls	r3, r3, #2
 8026f1c:	4a29      	ldr	r2, [pc, #164]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026f1e:	18d3      	adds	r3, r2, r3
 8026f20:	2200      	movs	r2, #0
 8026f22:	629a      	str	r2, [r3, #40]	; 0x28
    }
    KMS_SetStateIdle(hSession);
 8026f24:	0038      	movs	r0, r7
 8026f26:	f000 f9bd 	bl	80272a4 <KMS_SetStateIdle>
 8026f2a:	e043      	b.n	8026fb4 <KMS_EncryptUpdate+0x124>
  KMS_CHECK_BUFFER_SECTION5_2(pEncryptedPart, pulEncryptedPartLen, ulPartLen);
 8026f2c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026f2e:	601d      	str	r5, [r3, #0]
 8026f30:	e040      	b.n	8026fb4 <KMS_EncryptUpdate+0x124>
 8026f32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026f34:	601d      	str	r5, [r3, #0]
 8026f36:	24a8      	movs	r4, #168	; 0xa8
 8026f38:	0064      	lsls	r4, r4, #1
 8026f3a:	e03b      	b.n	8026fb4 <KMS_EncryptUpdate+0x124>
      kms_aes_cbc_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8026f3c:	00f3      	lsls	r3, r6, #3
 8026f3e:	199b      	adds	r3, r3, r6
 8026f40:	009b      	lsls	r3, r3, #2
 8026f42:	4a20      	ldr	r2, [pc, #128]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026f44:	18d3      	adds	r3, r2, r3
 8026f46:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_CBC_Encrypt_Append(&(p_ctx->ca_ctx),
 8026f48:	3020      	adds	r0, #32
 8026f4a:	ab07      	add	r3, sp, #28
 8026f4c:	9300      	str	r3, [sp, #0]
 8026f4e:	9b03      	ldr	r3, [sp, #12]
 8026f50:	002a      	movs	r2, r5
 8026f52:	9904      	ldr	r1, [sp, #16]
 8026f54:	f7fe fe6c 	bl	8025c30 <CA_AES_CBC_Encrypt_Append>
 8026f58:	2800      	cmp	r0, #0
 8026f5a:	d023      	beq.n	8026fa4 <KMS_EncryptUpdate+0x114>
        e_ret_status = CKR_FUNCTION_FAILED;
 8026f5c:	2406      	movs	r4, #6
 8026f5e:	e7cb      	b.n	8026ef8 <KMS_EncryptUpdate+0x68>
      kms_aes_ecb_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8026f60:	00f3      	lsls	r3, r6, #3
 8026f62:	199b      	adds	r3, r3, r6
 8026f64:	009b      	lsls	r3, r3, #2
 8026f66:	4a17      	ldr	r2, [pc, #92]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026f68:	18d3      	adds	r3, r2, r3
 8026f6a:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_ECB_Encrypt_Append(&(p_ctx->ca_ctx),
 8026f6c:	3020      	adds	r0, #32
 8026f6e:	ab07      	add	r3, sp, #28
 8026f70:	9300      	str	r3, [sp, #0]
 8026f72:	9b03      	ldr	r3, [sp, #12]
 8026f74:	002a      	movs	r2, r5
 8026f76:	9904      	ldr	r1, [sp, #16]
 8026f78:	f7ff f888 	bl	802608c <CA_AES_ECB_Encrypt_Append>
 8026f7c:	2800      	cmp	r0, #0
 8026f7e:	d011      	beq.n	8026fa4 <KMS_EncryptUpdate+0x114>
        e_ret_status = CKR_FUNCTION_FAILED;
 8026f80:	2406      	movs	r4, #6
 8026f82:	e7b9      	b.n	8026ef8 <KMS_EncryptUpdate+0x68>
      kms_aes_gcm_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8026f84:	00f3      	lsls	r3, r6, #3
 8026f86:	199b      	adds	r3, r3, r6
 8026f88:	009b      	lsls	r3, r3, #2
 8026f8a:	4a0e      	ldr	r2, [pc, #56]	; (8026fc4 <KMS_EncryptUpdate+0x134>)
 8026f8c:	18d3      	adds	r3, r2, r3
 8026f8e:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_GCM_Encrypt_Append(&(p_ctx->ca_ctx),
 8026f90:	3020      	adds	r0, #32
 8026f92:	ab07      	add	r3, sp, #28
 8026f94:	9300      	str	r3, [sp, #0]
 8026f96:	9b03      	ldr	r3, [sp, #12]
 8026f98:	002a      	movs	r2, r5
 8026f9a:	9904      	ldr	r1, [sp, #16]
 8026f9c:	f7ff f9ee 	bl	802637c <CA_AES_GCM_Encrypt_Append>
 8026fa0:	2800      	cmp	r0, #0
 8026fa2:	d103      	bne.n	8026fac <KMS_EncryptUpdate+0x11c>
    *pulEncryptedPartLen = (uint32_t)lEncryptPartLen;
 8026fa4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026fa6:	9a07      	ldr	r2, [sp, #28]
 8026fa8:	601a      	str	r2, [r3, #0]
 8026faa:	e003      	b.n	8026fb4 <KMS_EncryptUpdate+0x124>
        e_ret_status = CKR_FUNCTION_FAILED;
 8026fac:	2406      	movs	r4, #6
 8026fae:	e7a3      	b.n	8026ef8 <KMS_EncryptUpdate+0x68>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026fb0:	24c8      	movs	r4, #200	; 0xc8
 8026fb2:	0064      	lsls	r4, r4, #1

  return e_ret_status;
#else /* KMS_ENCRYPT */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ENCRYPT */
}
 8026fb4:	0020      	movs	r0, r4
 8026fb6:	b009      	add	sp, #36	; 0x24
 8026fb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026fba:	24b3      	movs	r4, #179	; 0xb3
 8026fbc:	e7fa      	b.n	8026fb4 <KMS_EncryptUpdate+0x124>
    return CKR_OPERATION_NOT_INITIALIZED;
 8026fbe:	2491      	movs	r4, #145	; 0x91
 8026fc0:	e7f8      	b.n	8026fb4 <KMS_EncryptUpdate+0x124>
 8026fc2:	46c0      	nop			; (mov r8, r8)
 8026fc4:	2000a200 	.word	0x2000a200
 8026fc8:	00001082 	.word	0x00001082
 8026fcc:	00001087 	.word	0x00001087
 8026fd0:	00001081 	.word	0x00001081

08026fd4 <KMS_Encrypt>:
{
 8026fd4:	b570      	push	{r4, r5, r6, lr}
 8026fd6:	b082      	sub	sp, #8
 8026fd8:	0004      	movs	r4, r0
  e_ret_status = KMS_EncryptUpdate(hSession, pData, ulDataLen, pEncryptedData,
 8026fda:	9806      	ldr	r0, [sp, #24]
 8026fdc:	9000      	str	r0, [sp, #0]
 8026fde:	0020      	movs	r0, r4
 8026fe0:	f7ff ff56 	bl	8026e90 <KMS_EncryptUpdate>
 8026fe4:	0006      	movs	r6, r0
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8026fe6:	1e65      	subs	r5, r4, #1
 8026fe8:	00eb      	lsls	r3, r5, #3
 8026fea:	195b      	adds	r3, r3, r5
 8026fec:	009b      	lsls	r3, r3, #2
 8026fee:	4a0b      	ldr	r2, [pc, #44]	; (802701c <KMS_Encrypt+0x48>)
 8026ff0:	18d3      	adds	r3, r2, r3
 8026ff2:	2200      	movs	r2, #0
 8026ff4:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8026ff6:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8026ff8:	2900      	cmp	r1, #0
 8026ffa:	d009      	beq.n	8027010 <KMS_Encrypt+0x3c>
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8026ffc:	0020      	movs	r0, r4
 8026ffe:	f000 fa85 	bl	802750c <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8027002:	00eb      	lsls	r3, r5, #3
 8027004:	195d      	adds	r5, r3, r5
 8027006:	00ad      	lsls	r5, r5, #2
 8027008:	4b04      	ldr	r3, [pc, #16]	; (802701c <KMS_Encrypt+0x48>)
 802700a:	195d      	adds	r5, r3, r5
 802700c:	2300      	movs	r3, #0
 802700e:	62ab      	str	r3, [r5, #40]	; 0x28
  KMS_SetStateIdle(hSession);
 8027010:	0020      	movs	r0, r4
 8027012:	f000 f947 	bl	80272a4 <KMS_SetStateIdle>
}
 8027016:	0030      	movs	r0, r6
 8027018:	b002      	add	sp, #8
 802701a:	bd70      	pop	{r4, r5, r6, pc}
 802701c:	2000a200 	.word	0x2000a200

08027020 <KMS_EncryptFinal>:
  *         CKR_OPERATION_NOT_INITIALIZED
  *         CKR_SESSION_HANDLE_INVALID
  */
CK_RV          KMS_EncryptFinal(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pLastEncryptedPart,
                                CK_ULONG_PTR pulLastEncryptedPartLen)
{
 8027020:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027022:	b085      	sub	sp, #20
 8027024:	0004      	movs	r4, r0
 8027026:	9101      	str	r1, [sp, #4]
 8027028:	0017      	movs	r7, r2
#if defined(KMS_ENCRYPT)
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  int32_t lEncryptPartLen = 0;
 802702a:	2300      	movs	r3, #0
 802702c:	9303      	str	r3, [sp, #12]

  if (!KMS_IS_INITIALIZED())
 802702e:	4b40      	ldr	r3, [pc, #256]	; (8027130 <KMS_EncryptFinal+0x110>)
 8027030:	781b      	ldrb	r3, [r3, #0]
 8027032:	2b00      	cmp	r3, #0
 8027034:	d073      	beq.n	802711e <KMS_EncryptFinal+0xfe>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8027036:	f000 f8ed 	bl	8027214 <KMS_CheckSessionHdle>
 802703a:	1e05      	subs	r5, r0, #0
 802703c:	d000      	beq.n	8027040 <KMS_EncryptFinal+0x20>
 802703e:	e073      	b.n	8027128 <KMS_EncryptFinal+0x108>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if DigestInit has been called previously */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_ENCRYPT)
 8027040:	1e66      	subs	r6, r4, #1
 8027042:	00f3      	lsls	r3, r6, #3
 8027044:	199b      	adds	r3, r3, r6
 8027046:	009b      	lsls	r3, r3, #2
 8027048:	4a39      	ldr	r2, [pc, #228]	; (8027130 <KMS_EncryptFinal+0x110>)
 802704a:	18d3      	adds	r3, r2, r3
 802704c:	68db      	ldr	r3, [r3, #12]
 802704e:	2b02      	cmp	r3, #2
 8027050:	d000      	beq.n	8027054 <KMS_EncryptFinal+0x34>
 8027052:	e06b      	b.n	802712c <KMS_EncryptFinal+0x10c>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  switch (KMS_GETSESSION(hSession).Mechanism)
 8027054:	00f3      	lsls	r3, r6, #3
 8027056:	199b      	adds	r3, r3, r6
 8027058:	009b      	lsls	r3, r3, #2
 802705a:	18d3      	adds	r3, r2, r3
 802705c:	6a1b      	ldr	r3, [r3, #32]
 802705e:	4a35      	ldr	r2, [pc, #212]	; (8027134 <KMS_EncryptFinal+0x114>)
 8027060:	4293      	cmp	r3, r2
 8027062:	d01e      	beq.n	80270a2 <KMS_EncryptFinal+0x82>
 8027064:	4a34      	ldr	r2, [pc, #208]	; (8027138 <KMS_EncryptFinal+0x118>)
 8027066:	4293      	cmp	r3, r2
 8027068:	d039      	beq.n	80270de <KMS_EncryptFinal+0xbe>
 802706a:	4a34      	ldr	r2, [pc, #208]	; (802713c <KMS_EncryptFinal+0x11c>)
 802706c:	4293      	cmp	r3, r2
 802706e:	d027      	beq.n	80270c0 <KMS_EncryptFinal+0xa0>
 8027070:	3570      	adds	r5, #112	; 0x70

  /* Upon completion:
   * - free the allocated context
   * - release the session
   */
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8027072:	00f3      	lsls	r3, r6, #3
 8027074:	199b      	adds	r3, r3, r6
 8027076:	009b      	lsls	r3, r3, #2
 8027078:	4a2d      	ldr	r2, [pc, #180]	; (8027130 <KMS_EncryptFinal+0x110>)
 802707a:	18d3      	adds	r3, r2, r3
 802707c:	2200      	movs	r2, #0
 802707e:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8027080:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8027082:	2900      	cmp	r1, #0
 8027084:	d009      	beq.n	802709a <KMS_EncryptFinal+0x7a>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8027086:	0020      	movs	r0, r4
 8027088:	f000 fa40 	bl	802750c <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 802708c:	00f3      	lsls	r3, r6, #3
 802708e:	199b      	adds	r3, r3, r6
 8027090:	009b      	lsls	r3, r3, #2
 8027092:	4a27      	ldr	r2, [pc, #156]	; (8027130 <KMS_EncryptFinal+0x110>)
 8027094:	18d3      	adds	r3, r2, r3
 8027096:	2200      	movs	r2, #0
 8027098:	629a      	str	r2, [r3, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 802709a:	0020      	movs	r0, r4
 802709c:	f000 f902 	bl	80272a4 <KMS_SetStateIdle>

  return e_ret_status;
 80270a0:	e03f      	b.n	8027122 <KMS_EncryptFinal+0x102>
      kms_aes_cbc_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 80270a2:	00f3      	lsls	r3, r6, #3
 80270a4:	199b      	adds	r3, r3, r6
 80270a6:	009b      	lsls	r3, r3, #2
 80270a8:	4a21      	ldr	r2, [pc, #132]	; (8027130 <KMS_EncryptFinal+0x110>)
 80270aa:	18d3      	adds	r3, r2, r3
 80270ac:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_CBC_Encrypt_Finish(&(p_ctx->ca_ctx),
 80270ae:	3020      	adds	r0, #32
 80270b0:	aa03      	add	r2, sp, #12
 80270b2:	9901      	ldr	r1, [sp, #4]
 80270b4:	f7fe fdea 	bl	8025c8c <CA_AES_CBC_Encrypt_Finish>
 80270b8:	2800      	cmp	r0, #0
 80270ba:	d0da      	beq.n	8027072 <KMS_EncryptFinal+0x52>
        e_ret_status = CKR_FUNCTION_FAILED;
 80270bc:	2506      	movs	r5, #6
 80270be:	e7d8      	b.n	8027072 <KMS_EncryptFinal+0x52>
      kms_aes_ecb_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 80270c0:	00f3      	lsls	r3, r6, #3
 80270c2:	199b      	adds	r3, r3, r6
 80270c4:	009b      	lsls	r3, r3, #2
 80270c6:	4a1a      	ldr	r2, [pc, #104]	; (8027130 <KMS_EncryptFinal+0x110>)
 80270c8:	18d3      	adds	r3, r2, r3
 80270ca:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_ECB_Encrypt_Finish(&(p_ctx->ca_ctx),
 80270cc:	3020      	adds	r0, #32
 80270ce:	aa03      	add	r2, sp, #12
 80270d0:	9901      	ldr	r1, [sp, #4]
 80270d2:	f7ff f809 	bl	80260e8 <CA_AES_ECB_Encrypt_Finish>
 80270d6:	2800      	cmp	r0, #0
 80270d8:	d0cb      	beq.n	8027072 <KMS_EncryptFinal+0x52>
        e_ret_status = CKR_FUNCTION_FAILED;
 80270da:	2506      	movs	r5, #6
 80270dc:	e7c9      	b.n	8027072 <KMS_EncryptFinal+0x52>
      kms_aes_gcm_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 80270de:	00f3      	lsls	r3, r6, #3
 80270e0:	199b      	adds	r3, r3, r6
 80270e2:	009b      	lsls	r3, r3, #2
 80270e4:	4a12      	ldr	r2, [pc, #72]	; (8027130 <KMS_EncryptFinal+0x110>)
 80270e6:	18d3      	adds	r3, r2, r3
 80270e8:	6a98      	ldr	r0, [r3, #40]	; 0x28
      KMS_CHECK_BUFFER_SECTION5_2(pLastEncryptedPart, pulLastEncryptedPartLen, (uint32_t)(p_ctx->ca_ctx.mTagSize));
 80270ea:	9b01      	ldr	r3, [sp, #4]
 80270ec:	2b00      	cmp	r3, #0
 80270ee:	d00d      	beq.n	802710c <KMS_EncryptFinal+0xec>
 80270f0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80270f2:	683a      	ldr	r2, [r7, #0]
 80270f4:	429a      	cmp	r2, r3
 80270f6:	d30c      	bcc.n	8027112 <KMS_EncryptFinal+0xf2>
      if (CA_AES_GCM_Encrypt_Finish(&(p_ctx->ca_ctx),
 80270f8:	3020      	adds	r0, #32
 80270fa:	aa03      	add	r2, sp, #12
 80270fc:	9901      	ldr	r1, [sp, #4]
 80270fe:	f7ff f97f 	bl	8026400 <CA_AES_GCM_Encrypt_Finish>
 8027102:	2800      	cmp	r0, #0
 8027104:	d109      	bne.n	802711a <KMS_EncryptFinal+0xfa>
        *pulLastEncryptedPartLen = (uint32_t)lEncryptPartLen;
 8027106:	9b03      	ldr	r3, [sp, #12]
 8027108:	603b      	str	r3, [r7, #0]
        e_ret_status = CKR_OK;
 802710a:	e7b2      	b.n	8027072 <KMS_EncryptFinal+0x52>
      KMS_CHECK_BUFFER_SECTION5_2(pLastEncryptedPart, pulLastEncryptedPartLen, (uint32_t)(p_ctx->ca_ctx.mTagSize));
 802710c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802710e:	603b      	str	r3, [r7, #0]
 8027110:	e007      	b.n	8027122 <KMS_EncryptFinal+0x102>
 8027112:	603b      	str	r3, [r7, #0]
 8027114:	25a8      	movs	r5, #168	; 0xa8
 8027116:	006d      	lsls	r5, r5, #1
 8027118:	e003      	b.n	8027122 <KMS_EncryptFinal+0x102>
        e_ret_status = CKR_FUNCTION_FAILED;
 802711a:	2506      	movs	r5, #6
 802711c:	e7a9      	b.n	8027072 <KMS_EncryptFinal+0x52>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 802711e:	25c8      	movs	r5, #200	; 0xc8
 8027120:	006d      	lsls	r5, r5, #1
#else /* KMS_ENCRYPT */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ENCRYPT */
}
 8027122:	0028      	movs	r0, r5
 8027124:	b005      	add	sp, #20
 8027126:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8027128:	25b3      	movs	r5, #179	; 0xb3
 802712a:	e7fa      	b.n	8027122 <KMS_EncryptFinal+0x102>
    return CKR_OPERATION_NOT_INITIALIZED;
 802712c:	2591      	movs	r5, #145	; 0x91
 802712e:	e7f8      	b.n	8027122 <KMS_EncryptFinal+0x102>
 8027130:	2000a200 	.word	0x2000a200
 8027134:	00001082 	.word	0x00001082
 8027138:	00001087 	.word	0x00001087
 802713c:	00001081 	.word	0x00001081

08027140 <KMS_Initialize>:
  *         CKR_CANT_LOCK
  *         CKR_CRYPTOKI_ALREADY_INITIALIZED
  *         CKR_FUNCTION_FAILED
  */
CK_RV  KMS_Initialize(CK_VOID_PTR pInitArgs)
{
 8027140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  CK_RV e_ret_status;

  /* Check parameters */
  if (pInitArgs != NULL)
 8027142:	2800      	cmp	r0, #0
 8027144:	d132      	bne.n	80271ac <KMS_Initialize+0x6c>
    return CKR_ARGUMENTS_BAD;
#endif /* KMS_PKCS11_COMPLIANCE */
  }

  /* Check if PKCS11 module has already been initialized */
  if (KMS_Manager.initialized == 0xFFU) /* Ensure C_Initialize is not called too many times */
 8027146:	4b1b      	ldr	r3, [pc, #108]	; (80271b4 <KMS_Initialize+0x74>)
 8027148:	781b      	ldrb	r3, [r3, #0]
 802714a:	2bff      	cmp	r3, #255	; 0xff
 802714c:	d030      	beq.n	80271b0 <KMS_Initialize+0x70>
  {
    e_ret_status = CKR_FUNCTION_FAILED;
  }
  else if (KMS_Manager.initialized > 0U)
 802714e:	2b00      	cmp	r3, #0
 8027150:	d005      	beq.n	802715e <KMS_Initialize+0x1e>
  {
    KMS_Manager.initialized++;  /* Increase initialization counter to reflect number of C_Initialize calls */
 8027152:	3301      	adds	r3, #1
 8027154:	4a17      	ldr	r2, [pc, #92]	; (80271b4 <KMS_Initialize+0x74>)
 8027156:	7013      	strb	r3, [r2, #0]
    e_ret_status = CKR_CRYPTOKI_ALREADY_INITIALIZED;
 8027158:	2092      	movs	r0, #146	; 0x92
 802715a:	30ff      	adds	r0, #255	; 0xff
 802715c:	e027      	b.n	80271ae <KMS_Initialize+0x6e>
  }
  else
  {
    /* Initialize KMS */
    KMS_Manager.sessionNb = 0;
 802715e:	4b15      	ldr	r3, [pc, #84]	; (80271b4 <KMS_Initialize+0x74>)
 8027160:	2200      	movs	r2, #0
 8027162:	605a      	str	r2, [r3, #4]

    /* Initialize SessionList */
    for (uint32_t i = 1 ; i <= KMS_NB_SESSIONS_MAX; i++)
 8027164:	2501      	movs	r5, #1
 8027166:	2d01      	cmp	r5, #1
 8027168:	d90a      	bls.n	8027180 <KMS_Initialize+0x40>
      KMS_GETSESSION(i).state = KMS_SESSION_NOT_USED;
      KMS_GETSESSION(i).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
    }

    /* This is to initialize the memory manager */
    KMS_MemInit();
 802716a:	f000 f991 	bl	8027490 <KMS_MemInit>
    /* This is to initialize the crypto api */
    (void)CA_Init();
 802716e:	f7ff fa79 	bl	8026664 <CA_Init>

    /* Call the Platform Init function */
    KMS_PlatfObjects_Init();
 8027172:	f001 fb4f 	bl	8028814 <KMS_PlatfObjects_Init>

    /* Marking module as initialized */
    KMS_Manager.initialized = 1U;
 8027176:	4b0f      	ldr	r3, [pc, #60]	; (80271b4 <KMS_Initialize+0x74>)
 8027178:	2201      	movs	r2, #1
 802717a:	701a      	strb	r2, [r3, #0]

    e_ret_status = CKR_OK;
 802717c:	2000      	movs	r0, #0
 802717e:	e016      	b.n	80271ae <KMS_Initialize+0x6e>
      (void)memset((void *) & (KMS_GETSESSION(i)), 0, sizeof(kms_session_desc_t));
 8027180:	1e6f      	subs	r7, r5, #1
 8027182:	4e0c      	ldr	r6, [pc, #48]	; (80271b4 <KMS_Initialize+0x74>)
 8027184:	00fc      	lsls	r4, r7, #3
 8027186:	19e0      	adds	r0, r4, r7
 8027188:	0080      	lsls	r0, r0, #2
 802718a:	3008      	adds	r0, #8
 802718c:	1830      	adds	r0, r6, r0
 802718e:	2224      	movs	r2, #36	; 0x24
 8027190:	2100      	movs	r1, #0
 8027192:	f00d fac8 	bl	8034726 <memset>
      KMS_GETSESSION(i).state = KMS_SESSION_NOT_USED;
 8027196:	19e3      	adds	r3, r4, r7
 8027198:	009b      	lsls	r3, r3, #2
 802719a:	18f3      	adds	r3, r6, r3
 802719c:	2201      	movs	r2, #1
 802719e:	4252      	negs	r2, r2
 80271a0:	60da      	str	r2, [r3, #12]
      KMS_GETSESSION(i).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 80271a2:	001c      	movs	r4, r3
 80271a4:	2300      	movs	r3, #0
 80271a6:	6263      	str	r3, [r4, #36]	; 0x24
    for (uint32_t i = 1 ; i <= KMS_NB_SESSIONS_MAX; i++)
 80271a8:	3501      	adds	r5, #1
 80271aa:	e7dc      	b.n	8027166 <KMS_Initialize+0x26>
    return CKR_ARGUMENTS_BAD;
 80271ac:	2007      	movs	r0, #7
  }

  return e_ret_status;
}
 80271ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e_ret_status = CKR_FUNCTION_FAILED;
 80271b0:	2006      	movs	r0, #6
 80271b2:	e7fc      	b.n	80271ae <KMS_Initialize+0x6e>
 80271b4:	2000a200 	.word	0x2000a200

080271b8 <KMS_OpenSession>:
  *         CKR_SESSION_PARALLEL_NOT_SUPPORTED
  */
CK_RV KMS_OpenSession(CK_SLOT_ID slotID, CK_FLAGS flags,
                      CK_VOID_PTR pApplication, CK_NOTIFY Notify,
                      CK_SESSION_HANDLE_PTR phSession)
{
 80271b8:	b570      	push	{r4, r5, r6, lr}
 80271ba:	0004      	movs	r4, r0

  /* As defined in PKCS11 spec: For legacy reasons, the CKF_SERIAL_SESSION bit MUST
     always be set; if a call to C_OpenSession does not have this bit set, the call
     should return unsuccessfully with the error code CKR_SESSION_PARALLEL_NOT_SUPPORTED.
  */
  if ((flags & CKF_SERIAL_SESSION) == 0UL)
 80271bc:	0748      	lsls	r0, r1, #29
 80271be:	d51f      	bpl.n	8027200 <KMS_OpenSession+0x48>
  {
    e_ret_status = CKR_SESSION_PARALLEL_NOT_SUPPORTED;
  }
  else if (!KMS_IS_INITIALIZED())
 80271c0:	4813      	ldr	r0, [pc, #76]	; (8027210 <KMS_OpenSession+0x58>)
 80271c2:	7800      	ldrb	r0, [r0, #0]
 80271c4:	2800      	cmp	r0, #0
 80271c6:	d01d      	beq.n	8027204 <KMS_OpenSession+0x4c>
  {
    e_ret_status = CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  /* We reach the max number of opened sessions */
  else if (KMS_Manager.sessionNb >=  KMS_NB_SESSIONS_MAX)
 80271c8:	4811      	ldr	r0, [pc, #68]	; (8027210 <KMS_OpenSession+0x58>)
 80271ca:	6840      	ldr	r0, [r0, #4]
 80271cc:	2800      	cmp	r0, #0
 80271ce:	d11c      	bne.n	802720a <KMS_OpenSession+0x52>
  {
    /* Find a slot for a Session */
    session_index = 1;
    do
    {
      if (KMS_GETSESSION(session_index).state == KMS_SESSION_NOT_USED)
 80271d0:	4d0f      	ldr	r5, [pc, #60]	; (8027210 <KMS_OpenSession+0x58>)
 80271d2:	68ed      	ldr	r5, [r5, #12]
 80271d4:	3501      	adds	r5, #1
 80271d6:	d001      	beq.n	80271dc <KMS_OpenSession+0x24>
 80271d8:	2006      	movs	r0, #6
    } while ((e_ret_status != CKR_OK)
             && (session_index <= KMS_NB_SESSIONS_MAX)); /* Session index are going from 1 to KMS_NB_SESSIONS_MAX */
  }

  /* All sessions are in used */
  return e_ret_status;
 80271da:	e012      	b.n	8027202 <KMS_OpenSession+0x4a>
        *phSession = session_index;
 80271dc:	9d04      	ldr	r5, [sp, #16]
 80271de:	2601      	movs	r6, #1
 80271e0:	602e      	str	r6, [r5, #0]
        KMS_GETSESSION(session_index).slotID = slotID;
 80271e2:	4d0b      	ldr	r5, [pc, #44]	; (8027210 <KMS_OpenSession+0x58>)
 80271e4:	60ac      	str	r4, [r5, #8]
        KMS_GETSESSION(session_index).state = KMS_SESSION_IDLE;      /* Initialized */
 80271e6:	2400      	movs	r4, #0
 80271e8:	60ec      	str	r4, [r5, #12]
        KMS_GETSESSION(session_index).flags = flags;
 80271ea:	6129      	str	r1, [r5, #16]
        KMS_GETSESSION(session_index).pApplication = pApplication;
 80271ec:	61aa      	str	r2, [r5, #24]
        KMS_GETSESSION(session_index).Notify = Notify;
 80271ee:	61eb      	str	r3, [r5, #28]
        KMS_GETSESSION(session_index).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 80271f0:	626c      	str	r4, [r5, #36]	; 0x24
        KMS_GETSESSION(session_index).Mechanism = CKM_VENDOR_DEFINED;
 80271f2:	2380      	movs	r3, #128	; 0x80
 80271f4:	061b      	lsls	r3, r3, #24
 80271f6:	622b      	str	r3, [r5, #32]
        KMS_Manager.sessionNb++;
 80271f8:	686b      	ldr	r3, [r5, #4]
 80271fa:	3301      	adds	r3, #1
 80271fc:	606b      	str	r3, [r5, #4]
        e_ret_status = CKR_OK;
 80271fe:	e000      	b.n	8027202 <KMS_OpenSession+0x4a>
    e_ret_status = CKR_SESSION_PARALLEL_NOT_SUPPORTED;
 8027200:	20b4      	movs	r0, #180	; 0xb4
}
 8027202:	bd70      	pop	{r4, r5, r6, pc}
    e_ret_status = CKR_CRYPTOKI_NOT_INITIALIZED;
 8027204:	20c8      	movs	r0, #200	; 0xc8
 8027206:	0040      	lsls	r0, r0, #1
 8027208:	e7fb      	b.n	8027202 <KMS_OpenSession+0x4a>
    e_ret_status = CKR_SESSION_COUNT;
 802720a:	20b1      	movs	r0, #177	; 0xb1
 802720c:	e7f9      	b.n	8027202 <KMS_OpenSession+0x4a>
 802720e:	46c0      	nop			; (mov r8, r8)
 8027210:	2000a200 	.word	0x2000a200

08027214 <KMS_CheckSessionHdle>:
  */
CK_RV     KMS_CheckSessionHdle(CK_SESSION_HANDLE hSession)
{
  CK_RV e_ret_status = CKR_SESSION_HANDLE_INVALID;

  if ((hSession >= 1UL) &&
 8027214:	2801      	cmp	r0, #1
 8027216:	d001      	beq.n	802721c <KMS_CheckSessionHdle+0x8>
  CK_RV e_ret_status = CKR_SESSION_HANDLE_INVALID;
 8027218:	20b3      	movs	r0, #179	; 0xb3
      (KMS_GETSESSION(hSession).state != KMS_SESSION_NOT_USED))
  {
    e_ret_status = CKR_OK;
  }
  return e_ret_status;
}
 802721a:	4770      	bx	lr
      (KMS_GETSESSION(hSession).state != KMS_SESSION_NOT_USED))
 802721c:	3801      	subs	r0, #1
 802721e:	00c3      	lsls	r3, r0, #3
 8027220:	1818      	adds	r0, r3, r0
 8027222:	0080      	lsls	r0, r0, #2
 8027224:	4b04      	ldr	r3, [pc, #16]	; (8027238 <KMS_CheckSessionHdle+0x24>)
 8027226:	1818      	adds	r0, r3, r0
 8027228:	68c3      	ldr	r3, [r0, #12]
      (hSession <= KMS_NB_SESSIONS_MAX) &&
 802722a:	3301      	adds	r3, #1
 802722c:	d001      	beq.n	8027232 <KMS_CheckSessionHdle+0x1e>
    e_ret_status = CKR_OK;
 802722e:	2000      	movs	r0, #0
  return e_ret_status;
 8027230:	e7f3      	b.n	802721a <KMS_CheckSessionHdle+0x6>
  CK_RV e_ret_status = CKR_SESSION_HANDLE_INVALID;
 8027232:	20b3      	movs	r0, #179	; 0xb3
 8027234:	e7f1      	b.n	802721a <KMS_CheckSessionHdle+0x6>
 8027236:	46c0      	nop			; (mov r8, r8)
 8027238:	2000a200 	.word	0x2000a200

0802723c <KMS_CloseSession>:
{
 802723c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802723e:	0004      	movs	r4, r0
  if (!KMS_IS_INITIALIZED())
 8027240:	4b17      	ldr	r3, [pc, #92]	; (80272a0 <KMS_CloseSession+0x64>)
 8027242:	781b      	ldrb	r3, [r3, #0]
 8027244:	2b00      	cmp	r3, #0
 8027246:	d025      	beq.n	8027294 <KMS_CloseSession+0x58>
  else if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8027248:	f7ff ffe4 	bl	8027214 <KMS_CheckSessionHdle>
 802724c:	2800      	cmp	r0, #0
 802724e:	d125      	bne.n	802729c <KMS_CloseSession+0x60>
  else if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8027250:	3c01      	subs	r4, #1
 8027252:	00e3      	lsls	r3, r4, #3
 8027254:	191b      	adds	r3, r3, r4
 8027256:	009b      	lsls	r3, r3, #2
 8027258:	4a11      	ldr	r2, [pc, #68]	; (80272a0 <KMS_CloseSession+0x64>)
 802725a:	18d3      	adds	r3, r2, r3
 802725c:	68dd      	ldr	r5, [r3, #12]
 802725e:	2d00      	cmp	r5, #0
 8027260:	d001      	beq.n	8027266 <KMS_CloseSession+0x2a>
    e_ret_status = CKR_SESSION_HANDLE_INVALID;
 8027262:	25b3      	movs	r5, #179	; 0xb3
  return e_ret_status;
 8027264:	e018      	b.n	8027298 <KMS_CloseSession+0x5c>
    (void)memset((void *) & (KMS_GETSESSION(hSession)), 0, sizeof(kms_session_desc_t));
 8027266:	0017      	movs	r7, r2
 8027268:	00e6      	lsls	r6, r4, #3
 802726a:	1930      	adds	r0, r6, r4
 802726c:	0080      	lsls	r0, r0, #2
 802726e:	3008      	adds	r0, #8
 8027270:	1810      	adds	r0, r2, r0
 8027272:	2224      	movs	r2, #36	; 0x24
 8027274:	2100      	movs	r1, #0
 8027276:	f00d fa56 	bl	8034726 <memset>
    KMS_GETSESSION(hSession).state = KMS_SESSION_NOT_USED;
 802727a:	1933      	adds	r3, r6, r4
 802727c:	009b      	lsls	r3, r3, #2
 802727e:	18fb      	adds	r3, r7, r3
 8027280:	2201      	movs	r2, #1
 8027282:	4252      	negs	r2, r2
 8027284:	60da      	str	r2, [r3, #12]
    KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8027286:	001c      	movs	r4, r3
 8027288:	2300      	movs	r3, #0
 802728a:	6263      	str	r3, [r4, #36]	; 0x24
    KMS_Manager.sessionNb--;
 802728c:	687b      	ldr	r3, [r7, #4]
 802728e:	189b      	adds	r3, r3, r2
 8027290:	607b      	str	r3, [r7, #4]
    e_ret_status = CKR_OK;
 8027292:	e001      	b.n	8027298 <KMS_CloseSession+0x5c>
    e_ret_status = CKR_CRYPTOKI_NOT_INITIALIZED;
 8027294:	25c8      	movs	r5, #200	; 0xc8
 8027296:	006d      	lsls	r5, r5, #1
}
 8027298:	0028      	movs	r0, r5
 802729a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e_ret_status = CKR_SESSION_HANDLE_INVALID;
 802729c:	25b3      	movs	r5, #179	; 0xb3
 802729e:	e7fb      	b.n	8027298 <KMS_CloseSession+0x5c>
 80272a0:	2000a200 	.word	0x2000a200

080272a4 <KMS_SetStateIdle>:
  * @param  hSession session handle
  * @retval None
  */
void     KMS_SetStateIdle(CK_SESSION_HANDLE hSession)
{
  KMS_GETSESSION(hSession).state = KMS_SESSION_IDLE;
 80272a4:	1e43      	subs	r3, r0, #1
 80272a6:	00d8      	lsls	r0, r3, #3
 80272a8:	18c0      	adds	r0, r0, r3
 80272aa:	0080      	lsls	r0, r0, #2
 80272ac:	4b02      	ldr	r3, [pc, #8]	; (80272b8 <KMS_SetStateIdle+0x14>)
 80272ae:	1818      	adds	r0, r3, r0
 80272b0:	2300      	movs	r3, #0
 80272b2:	60c3      	str	r3, [r0, #12]
}
 80272b4:	4770      	bx	lr
 80272b6:	46c0      	nop			; (mov r8, r8)
 80272b8:	2000a200 	.word	0x2000a200

080272bc <KMS_DeriveKey>:
  *         @ref KMS_ECC_LoadCurve returned values
  */
CK_RV          KMS_DeriveKey(CK_SESSION_HANDLE hSession, CK_MECHANISM_PTR pMechanism,
                             CK_OBJECT_HANDLE hBaseKey, CK_ATTRIBUTE_PTR  pTemplate,
                             CK_ULONG  ulAttributeCount, CK_OBJECT_HANDLE_PTR  phKey)
{
 80272bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80272be:	46d6      	mov	lr, sl
 80272c0:	b500      	push	{lr}
 80272c2:	b08a      	sub	sp, #40	; 0x28
 80272c4:	0004      	movs	r4, r0
 80272c6:	000d      	movs	r5, r1
 80272c8:	9202      	str	r2, [sp, #8]
 80272ca:	9303      	str	r3, [sp, #12]
#ifdef KMS_DERIVE_KEY
  CK_RV e_ret_status;
  kms_obj_keyhead_t *pkms_object;
  kms_attr_t *P_pKeyAttribute = NULL;
 80272cc:	2300      	movs	r3, #0
 80272ce:	9309      	str	r3, [sp, #36]	; 0x24

  if (!KMS_IS_INITIALIZED())
 80272d0:	4b55      	ldr	r3, [pc, #340]	; (8027428 <KMS_DeriveKey+0x16c>)
 80272d2:	781b      	ldrb	r3, [r3, #0]
 80272d4:	2b00      	cmp	r3, #0
 80272d6:	d100      	bne.n	80272da <KMS_DeriveKey+0x1e>
 80272d8:	e099      	b.n	802740e <KMS_DeriveKey+0x152>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80272da:	f7ff ff9b 	bl	8027214 <KMS_CheckSessionHdle>
 80272de:	2800      	cmp	r0, #0
 80272e0:	d000      	beq.n	80272e4 <KMS_DeriveKey+0x28>
 80272e2:	e09b      	b.n	802741c <KMS_DeriveKey+0x160>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 80272e4:	1e66      	subs	r6, r4, #1
 80272e6:	00f3      	lsls	r3, r6, #3
 80272e8:	199b      	adds	r3, r3, r6
 80272ea:	009b      	lsls	r3, r3, #2
 80272ec:	4a4e      	ldr	r2, [pc, #312]	; (8027428 <KMS_DeriveKey+0x16c>)
 80272ee:	18d3      	adds	r3, r2, r3
 80272f0:	68db      	ldr	r3, [r3, #12]
 80272f2:	2b00      	cmp	r3, #0
 80272f4:	d000      	beq.n	80272f8 <KMS_DeriveKey+0x3c>
 80272f6:	e093      	b.n	8027420 <KMS_DeriveKey+0x164>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  if (pMechanism == NULL_PTR)
 80272f8:	2d00      	cmp	r5, #0
 80272fa:	d100      	bne.n	80272fe <KMS_DeriveKey+0x42>
 80272fc:	e092      	b.n	8027424 <KMS_DeriveKey+0x168>
  {
    return CKR_ARGUMENTS_BAD;
  }
  switch (pMechanism->mechanism)
 80272fe:	4b4b      	ldr	r3, [pc, #300]	; (802742c <KMS_DeriveKey+0x170>)
 8027300:	682a      	ldr	r2, [r5, #0]
 8027302:	429a      	cmp	r2, r3
 8027304:	d001      	beq.n	802730a <KMS_DeriveKey+0x4e>
      break;
    }
#endif /* KMS_ECDSA & KMS_FCT_DERIVE_KEY */

    default:
      e_ret_status = CKR_MECHANISM_INVALID;
 8027306:	2770      	movs	r7, #112	; 0x70
 8027308:	e083      	b.n	8027412 <KMS_DeriveKey+0x156>
      CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, NULL, 0 };
 802730a:	4b49      	ldr	r3, [pc, #292]	; (8027430 <KMS_DeriveKey+0x174>)
 802730c:	9306      	str	r3, [sp, #24]
 802730e:	2300      	movs	r3, #0
 8027310:	9307      	str	r3, [sp, #28]
 8027312:	9308      	str	r3, [sp, #32]
      if ((pMechanism->pParameter == NULL) ||
 8027314:	686b      	ldr	r3, [r5, #4]
 8027316:	2b00      	cmp	r3, #0
 8027318:	d075      	beq.n	8027406 <KMS_DeriveKey+0x14a>
          (pMechanism->ulParameterLen == 0UL))
 802731a:	68ab      	ldr	r3, [r5, #8]
      if ((pMechanism->pParameter == NULL) ||
 802731c:	2b00      	cmp	r3, #0
 802731e:	d074      	beq.n	802740a <KMS_DeriveKey+0x14e>
      if ((pMechanism->ulParameterLen != CA_CRL_AES128_KEY)
 8027320:	2b10      	cmp	r3, #16
 8027322:	d005      	beq.n	8027330 <KMS_DeriveKey+0x74>
          && (pMechanism->ulParameterLen != CA_CRL_AES192_KEY)
 8027324:	2b18      	cmp	r3, #24
 8027326:	d003      	beq.n	8027330 <KMS_DeriveKey+0x74>
          && (pMechanism->ulParameterLen != CA_CRL_AES256_KEY))
 8027328:	2b20      	cmp	r3, #32
 802732a:	d001      	beq.n	8027330 <KMS_DeriveKey+0x74>
        e_ret_status = CKR_MECHANISM_PARAM_INVALID;
 802732c:	2771      	movs	r7, #113	; 0x71
 802732e:	e070      	b.n	8027412 <KMS_DeriveKey+0x156>
      pkms_object = KMS_Objects_GetPointer(hBaseKey);
 8027330:	9802      	ldr	r0, [sp, #8]
 8027332:	f000 ff13 	bl	802815c <KMS_Objects_GetPointer>
 8027336:	4682      	mov	sl, r0
      if ((pkms_object != NULL) &&
 8027338:	2800      	cmp	r0, #0
 802733a:	d062      	beq.n	8027402 <KMS_DeriveKey+0x146>
 802733c:	4b3d      	ldr	r3, [pc, #244]	; (8027434 <KMS_DeriveKey+0x178>)
 802733e:	6802      	ldr	r2, [r0, #0]
 8027340:	429a      	cmp	r2, r3
 8027342:	d008      	beq.n	8027356 <KMS_DeriveKey+0x9a>
        e_ret_status = CKR_KEY_HANDLE_INVALID;
 8027344:	2760      	movs	r7, #96	; 0x60
      KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8027346:	00f3      	lsls	r3, r6, #3
 8027348:	199b      	adds	r3, r3, r6
 802734a:	009b      	lsls	r3, r3, #2
 802734c:	4a36      	ldr	r2, [pc, #216]	; (8027428 <KMS_DeriveKey+0x16c>)
 802734e:	18d3      	adds	r3, r2, r3
 8027350:	2200      	movs	r2, #0
 8027352:	625a      	str	r2, [r3, #36]	; 0x24
      break;
 8027354:	e05d      	b.n	8027412 <KMS_DeriveKey+0x156>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8027356:	4b38      	ldr	r3, [pc, #224]	; (8027438 <KMS_DeriveKey+0x17c>)
 8027358:	6842      	ldr	r2, [r0, #4]
 802735a:	429a      	cmp	r2, r3
 802735c:	d001      	beq.n	8027362 <KMS_DeriveKey+0xa6>
        e_ret_status = CKR_KEY_HANDLE_INVALID;
 802735e:	2760      	movs	r7, #96	; 0x60
 8027360:	e7f1      	b.n	8027346 <KMS_DeriveKey+0x8a>
        e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8027362:	aa09      	add	r2, sp, #36	; 0x24
 8027364:	0001      	movs	r1, r0
 8027366:	2011      	movs	r0, #17
 8027368:	f000 ff55 	bl	8028216 <KMS_Objects_SearchAttributes>
 802736c:	1e07      	subs	r7, r0, #0
        if (e_ret_status == CKR_OK)
 802736e:	d1ea      	bne.n	8027346 <KMS_DeriveKey+0x8a>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_DERIVE, pkms_object, &pDeriveAttribute);
 8027370:	2086      	movs	r0, #134	; 0x86
 8027372:	aa05      	add	r2, sp, #20
 8027374:	4651      	mov	r1, sl
 8027376:	0040      	lsls	r0, r0, #1
 8027378:	f000 ff4d 	bl	8028216 <KMS_Objects_SearchAttributes>
          if (e_ret_status == CKR_OK)
 802737c:	2800      	cmp	r0, #0
 802737e:	d105      	bne.n	802738c <KMS_DeriveKey+0xd0>
            if (*pDeriveAttribute->data != CK_TRUE)
 8027380:	9b05      	ldr	r3, [sp, #20]
 8027382:	689b      	ldr	r3, [r3, #8]
 8027384:	2b01      	cmp	r3, #1
 8027386:	d001      	beq.n	802738c <KMS_DeriveKey+0xd0>
              e_ret_status = CKR_ACTION_PROHIBITED;
 8027388:	271b      	movs	r7, #27
 802738a:	e042      	b.n	8027412 <KMS_DeriveKey+0x156>
          if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||    /* 128 bits */
 802738c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802738e:	685b      	ldr	r3, [r3, #4]
 8027390:	2b10      	cmp	r3, #16
 8027392:	d005      	beq.n	80273a0 <KMS_DeriveKey+0xe4>
 8027394:	2b18      	cmp	r3, #24
 8027396:	d003      	beq.n	80273a0 <KMS_DeriveKey+0xe4>
              (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8027398:	2b20      	cmp	r3, #32
 802739a:	d001      	beq.n	80273a0 <KMS_DeriveKey+0xe4>
            e_ret_status = CKR_ATTRIBUTE_VALUE_INVALID;
 802739c:	2713      	movs	r7, #19
 802739e:	e038      	b.n	8027412 <KMS_DeriveKey+0x156>
            pKeyBuffer = (uint8_t *)KMS_Alloc(hSession, pMechanism->ulParameterLen);
 80273a0:	68a9      	ldr	r1, [r5, #8]
 80273a2:	0020      	movs	r0, r4
 80273a4:	f000 f88c 	bl	80274c0 <KMS_Alloc>
 80273a8:	4682      	mov	sl, r0
            if (pKeyBuffer == NULL)
 80273aa:	2800      	cmp	r0, #0
 80273ac:	d027      	beq.n	80273fe <KMS_DeriveKey+0x142>
          e_ret_status = KMS_EncryptInit(hSession, &aes_ecb_mechanism, hBaseKey);
 80273ae:	9a02      	ldr	r2, [sp, #8]
 80273b0:	a906      	add	r1, sp, #24
 80273b2:	0020      	movs	r0, r4
 80273b4:	f7ff fd66 	bl	8026e84 <KMS_EncryptInit>
 80273b8:	1e07      	subs	r7, r0, #0
          if (e_ret_status != CKR_OK)
 80273ba:	d004      	beq.n	80273c6 <KMS_DeriveKey+0x10a>
            KMS_Free(hSession, pKeyBuffer);
 80273bc:	4651      	mov	r1, sl
 80273be:	0020      	movs	r0, r4
 80273c0:	f000 f8a4 	bl	802750c <KMS_Free>
            break;
 80273c4:	e025      	b.n	8027412 <KMS_DeriveKey+0x156>
          EncryptedLen = pMechanism->ulParameterLen;
 80273c6:	68aa      	ldr	r2, [r5, #8]
 80273c8:	9204      	str	r2, [sp, #16]
          e_ret_status = KMS_Encrypt(hSession, pMechanism->pParameter,
 80273ca:	6869      	ldr	r1, [r5, #4]
 80273cc:	ab04      	add	r3, sp, #16
 80273ce:	9300      	str	r3, [sp, #0]
 80273d0:	4653      	mov	r3, sl
 80273d2:	0020      	movs	r0, r4
 80273d4:	f7ff fdfe 	bl	8026fd4 <KMS_Encrypt>
 80273d8:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 80273da:	d004      	beq.n	80273e6 <KMS_DeriveKey+0x12a>
            KMS_Free(hSession, pKeyBuffer);
 80273dc:	4651      	mov	r1, sl
 80273de:	0020      	movs	r0, r4
 80273e0:	f000 f894 	bl	802750c <KMS_Free>
 80273e4:	e7af      	b.n	8027346 <KMS_DeriveKey+0x8a>
            e_ret_status = KMS_Objects_CreateNStoreBlobForAES(hSession,
 80273e6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80273e8:	9301      	str	r3, [sp, #4]
 80273ea:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80273ec:	9300      	str	r3, [sp, #0]
 80273ee:	9b03      	ldr	r3, [sp, #12]
 80273f0:	9a04      	ldr	r2, [sp, #16]
 80273f2:	4651      	mov	r1, sl
 80273f4:	0020      	movs	r0, r4
 80273f6:	f001 f919 	bl	802862c <KMS_Objects_CreateNStoreBlobForAES>
 80273fa:	0007      	movs	r7, r0
 80273fc:	e7ee      	b.n	80273dc <KMS_DeriveKey+0x120>
              e_ret_status = CKR_DEVICE_MEMORY;
 80273fe:	2731      	movs	r7, #49	; 0x31
 8027400:	e007      	b.n	8027412 <KMS_DeriveKey+0x156>
        e_ret_status = CKR_KEY_HANDLE_INVALID;
 8027402:	2760      	movs	r7, #96	; 0x60
 8027404:	e79f      	b.n	8027346 <KMS_DeriveKey+0x8a>
        e_ret_status = CKR_MECHANISM_PARAM_INVALID;
 8027406:	2771      	movs	r7, #113	; 0x71
 8027408:	e003      	b.n	8027412 <KMS_DeriveKey+0x156>
 802740a:	2771      	movs	r7, #113	; 0x71
 802740c:	e001      	b.n	8027412 <KMS_DeriveKey+0x156>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 802740e:	27c8      	movs	r7, #200	; 0xc8
 8027410:	007f      	lsls	r7, r7, #1

  return e_ret_status;
#else /* KMS_DERIVE_KEY */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_DERIVE_KEY */
}
 8027412:	0038      	movs	r0, r7
 8027414:	b00a      	add	sp, #40	; 0x28
 8027416:	bc80      	pop	{r7}
 8027418:	46ba      	mov	sl, r7
 802741a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 802741c:	27b3      	movs	r7, #179	; 0xb3
 802741e:	e7f8      	b.n	8027412 <KMS_DeriveKey+0x156>
    return CKR_SESSION_HANDLE_INVALID;
 8027420:	27b3      	movs	r7, #179	; 0xb3
 8027422:	e7f6      	b.n	8027412 <KMS_DeriveKey+0x156>
    return CKR_ARGUMENTS_BAD;
 8027424:	2707      	movs	r7, #7
 8027426:	e7f4      	b.n	8027412 <KMS_DeriveKey+0x156>
 8027428:	2000a200 	.word	0x2000a200
 802742c:	00001104 	.word	0x00001104
 8027430:	00001081 	.word	0x00001081
 8027434:	b10b0240 	.word	0xb10b0240
 8027438:	b10b0003 	.word	0xb10b0003

0802743c <mempool_init>:
/**
  * @brief  Memory pool initialization
  * @retval None
  */
static void mempool_init(kms_mem_pool_header_t *pHead, uint32_t size)
{
 802743c:	b570      	push	{r4, r5, r6, lr}
 802743e:	0003      	movs	r3, r0
 8027440:	000a      	movs	r2, r1
  uint8_t *ptr;
  kms_mem_pool_footer_t *p_foot;

  ptr = (uint8_t *)(((uint32_t)pHead) + sizeof(kms_mem_pool_header_t));
 8027442:	3020      	adds	r0, #32
  p_foot = (kms_mem_pool_footer_t *)(((uint32_t)pHead) + sizeof(kms_mem_pool_header_t) + size + (4UL - (size & 0x3UL)));
 8027444:	1859      	adds	r1, r3, r1
 8027446:	2503      	movs	r5, #3
 8027448:	4015      	ands	r5, r2
 802744a:	1b4d      	subs	r5, r1, r5
 802744c:	3524      	adds	r5, #36	; 0x24
  /* Initialize header with canaries and controls */
  for (uint32_t i = 0; i < (sizeof(pHead->canaries) / sizeof(pHead->canaries[0])); i++)
 802744e:	2400      	movs	r4, #0
 8027450:	e004      	b.n	802745c <mempool_init+0x20>
  {
    pHead->canaries[i] = normalizedHeader[i];
 8027452:	00a1      	lsls	r1, r4, #2
 8027454:	4e0c      	ldr	r6, [pc, #48]	; (8027488 <mempool_init+0x4c>)
 8027456:	598e      	ldr	r6, [r1, r6]
 8027458:	50ce      	str	r6, [r1, r3]
  for (uint32_t i = 0; i < (sizeof(pHead->canaries) / sizeof(pHead->canaries[0])); i++)
 802745a:	3401      	adds	r4, #1
 802745c:	2c01      	cmp	r4, #1
 802745e:	d9f8      	bls.n	8027452 <mempool_init+0x16>
  }
  pHead->size = size;
 8027460:	609a      	str	r2, [r3, #8]
  pHead->used = 0;
 8027462:	2100      	movs	r1, #0
 8027464:	60d9      	str	r1, [r3, #12]
#if defined(KMS_MEM_DEBUGGING)
  pHead->session = KMS_SESSION_ID_INVALID;
 8027466:	6119      	str	r1, [r3, #16]
  pHead->caller = 0;
 8027468:	6159      	str	r1, [r3, #20]
  pHead->reqSize = 0;
 802746a:	6199      	str	r1, [r3, #24]
  pHead->reserved = 0;
 802746c:	61d9      	str	r1, [r3, #28]
#endif /* KMS_MEM_DEBUGGING */
  (void)memset(ptr, 0, size);   /* Initialize pool buffer contents to 0 */
 802746e:	f00d f95a 	bl	8034726 <memset>
  /* Initialize footer with canaries */
  for (uint32_t i = 0; i < (sizeof(p_foot->canaries) / sizeof(p_foot->canaries[0])); i++)
 8027472:	2300      	movs	r3, #0
 8027474:	e004      	b.n	8027480 <mempool_init+0x44>
  {
    p_foot->canaries[i] = normalizedFooter.canaries[i];
 8027476:	009a      	lsls	r2, r3, #2
 8027478:	4904      	ldr	r1, [pc, #16]	; (802748c <mempool_init+0x50>)
 802747a:	5851      	ldr	r1, [r2, r1]
 802747c:	5151      	str	r1, [r2, r5]
  for (uint32_t i = 0; i < (sizeof(p_foot->canaries) / sizeof(p_foot->canaries[0])); i++)
 802747e:	3301      	adds	r3, #1
 8027480:	2b03      	cmp	r3, #3
 8027482:	d9f8      	bls.n	8027476 <mempool_init+0x3a>
  }
}
 8027484:	bd70      	pop	{r4, r5, r6, pc}
 8027486:	46c0      	nop			; (mov r8, r8)
 8027488:	08034c7c 	.word	0x08034c7c
 802748c:	08034c6c 	.word	0x08034c6c

08027490 <KMS_MemInit>:
  * @brief  Initialize memory management structure
  * @retval None
  */
#if !defined(KMS_MEM_USE_CUSTOM_ALLOCATOR)
void KMS_MemInit(void)
{
 8027490:	b570      	push	{r4, r5, r6, lr}
 * - Pool #2 is a 256 Bytes pool
 * - Pool #3 is a 512 Bytes pool
 */
/* USER CODE BEGIN KMS_MEM_POOL_Declare */
KMS_MEM_DECLARE_POOL_START()
KMS_MEM_DECLARE_POOL_ENTRY(1,256)
 8027492:	2580      	movs	r5, #128	; 0x80
 8027494:	006d      	lsls	r5, r5, #1
 8027496:	4c09      	ldr	r4, [pc, #36]	; (80274bc <KMS_MemInit+0x2c>)
 8027498:	0029      	movs	r1, r5
 802749a:	0020      	movs	r0, r4
 802749c:	f7ff ffce 	bl	802743c <mempool_init>
KMS_MEM_DECLARE_POOL_ENTRY(2,256)
 80274a0:	0020      	movs	r0, r4
 80274a2:	3035      	adds	r0, #53	; 0x35
 80274a4:	30ff      	adds	r0, #255	; 0xff
 80274a6:	0029      	movs	r1, r5
 80274a8:	f7ff ffc8 	bl	802743c <mempool_init>
KMS_MEM_DECLARE_POOL_ENTRY(3,512)
 80274ac:	2180      	movs	r1, #128	; 0x80
 80274ae:	239a      	movs	r3, #154	; 0x9a
 80274b0:	009b      	lsls	r3, r3, #2
 80274b2:	18e0      	adds	r0, r4, r3
 80274b4:	0089      	lsls	r1, r1, #2
 80274b6:	f7ff ffc1 	bl	802743c <mempool_init>

#endif /* KMS_MEM_USE_POOL_ALLOCATOR */
#if defined(KMS_MEM_LOGGING)
  KMS_LL_ReportMemInit();
#endif /* KMS_MEM_LOGGING */
}
 80274ba:	bd70      	pop	{r4, r5, r6, pc}
 80274bc:	2000b85c 	.word	0x2000b85c

080274c0 <KMS_Alloc>:
  * @param  Size Size of the memory to allocate
  * @retval Allocated pointer if successful to allocate, NULL_PTR if failed
  */
#if !defined(KMS_MEM_USE_CUSTOM_ALLOCATOR)
CK_VOID_PTR KMS_Alloc(CK_SESSION_HANDLE Session, size_t Size)
{
 80274c0:	b570      	push	{r4, r5, r6, lr}
    }
  }
#endif /* KMS_MEM_DEBUGGING */
#endif /* KMS_MEM_USE_HEAP_ALLOCATOR */
#if defined(KMS_MEM_USE_POOL_ALLOCATOR)
  for (uint32_t i = 0; (i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *))) && (ptr == NULL_PTR); i++)
 80274c2:	2300      	movs	r3, #0
  void *ptr = NULL_PTR;
 80274c4:	2400      	movs	r4, #0
  for (uint32_t i = 0; (i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *))) && (ptr == NULL_PTR); i++)
 80274c6:	e000      	b.n	80274ca <KMS_Alloc+0xa>
 80274c8:	3301      	adds	r3, #1
 80274ca:	2b02      	cmp	r3, #2
 80274cc:	d813      	bhi.n	80274f6 <KMS_Alloc+0x36>
 80274ce:	2c00      	cmp	r4, #0
 80274d0:	d111      	bne.n	80274f6 <KMS_Alloc+0x36>
  {
    if ((kms_mem_pool_tab[i]->used == 0UL) && (kms_mem_pool_tab[i]->size >= Size))
 80274d2:	009a      	lsls	r2, r3, #2
 80274d4:	4d0c      	ldr	r5, [pc, #48]	; (8027508 <KMS_Alloc+0x48>)
 80274d6:	5952      	ldr	r2, [r2, r5]
 80274d8:	68d5      	ldr	r5, [r2, #12]
 80274da:	2d00      	cmp	r5, #0
 80274dc:	d1f4      	bne.n	80274c8 <KMS_Alloc+0x8>
 80274de:	6895      	ldr	r5, [r2, #8]
 80274e0:	428d      	cmp	r5, r1
 80274e2:	d3f1      	bcc.n	80274c8 <KMS_Alloc+0x8>
    {
      kms_mem_pool_tab[i]->used = 1;
 80274e4:	2401      	movs	r4, #1
 80274e6:	60d4      	str	r4, [r2, #12]
#if defined(KMS_MEM_DEBUGGING)
      kms_mem_pool_tab[i]->session = Session;
 80274e8:	6110      	str	r0, [r2, #16]
      kms_mem_pool_tab[i]->caller = LR;
 80274ea:	2400      	movs	r4, #0
 80274ec:	6154      	str	r4, [r2, #20]
      kms_mem_pool_tab[i]->reqSize = Size;
 80274ee:	6191      	str	r1, [r2, #24]
#endif /* KMS_MEM_DEBUGGING */
      ptr = (void *)(uint32_t *)((uint32_t)(kms_mem_pool_tab[i]) + sizeof(kms_mem_pool_header_t));
 80274f0:	3220      	adds	r2, #32
 80274f2:	0014      	movs	r4, r2
 80274f4:	e7e8      	b.n	80274c8 <KMS_Alloc+0x8>
    }
  }
#endif /* KMS_MEM_USE_POOL_ALLOCATOR */
  if (ptr == NULL_PTR)
 80274f6:	2c00      	cmp	r4, #0
 80274f8:	d001      	beq.n	80274fe <KMS_Alloc+0x3e>
  {
    KMS_LL_ReportMemAlloc(Size, ptr);
  }
#endif /* KMS_MEM_LOGGING */
  return ptr;
}
 80274fa:	0020      	movs	r0, r4
 80274fc:	bd70      	pop	{r4, r5, r6, pc}
    KMS_LL_ReportError(KMS_LL_ERROR_MEM_ALLOC_FAILURE);
 80274fe:	2001      	movs	r0, #1
 8027500:	f7fa f8de 	bl	80216c0 <KMS_LL_ReportError>
  return ptr;
 8027504:	e7f9      	b.n	80274fa <KMS_Alloc+0x3a>
 8027506:	46c0      	nop			; (mov r8, r8)
 8027508:	08034c60 	.word	0x08034c60

0802750c <KMS_Free>:
  * @param  Ptr     Pointer to the memory to free
  * @retval None
  */
#if !defined(KMS_MEM_USE_CUSTOM_ALLOCATOR)
void KMS_Free(CK_SESSION_HANDLE Session, CK_VOID_PTR Ptr)
{
 802750c:	b570      	push	{r4, r5, r6, lr}
 802750e:	1e0d      	subs	r5, r1, #0
  uint32_t i;

  (void)Session;

  if (Ptr == NULL_PTR)
 8027510:	d01f      	beq.n	8027552 <KMS_Free+0x46>
#if defined(KMS_MEM_USE_POOL_ALLOCATOR)
    kms_mem_pool_header_t *phead;
    kms_mem_pool_footer_t *pfoot;
    uint32_t tmp_ptr = (uint32_t)Ptr;

    phead = (kms_mem_pool_header_t *)(tmp_ptr - sizeof(kms_mem_pool_header_t));
 8027512:	000e      	movs	r6, r1
 8027514:	3e20      	subs	r6, #32
    pfoot = (kms_mem_pool_footer_t *)(tmp_ptr + phead->size + 4UL - (phead->size & 0x3UL));
 8027516:	68b2      	ldr	r2, [r6, #8]
 8027518:	1853      	adds	r3, r2, r1
 802751a:	2403      	movs	r4, #3
 802751c:	4014      	ands	r4, r2
 802751e:	1b1c      	subs	r4, r3, r4
 8027520:	3404      	adds	r4, #4
    /* Check canaries */
    if (memcmp((void *)phead, &normalizedHeader, sizeof(normalizedHeader)) != 0)
 8027522:	2208      	movs	r2, #8
 8027524:	4919      	ldr	r1, [pc, #100]	; (802758c <KMS_Free+0x80>)
 8027526:	0030      	movs	r0, r6
 8027528:	f00d f8e6 	bl	80346f8 <memcmp>
 802752c:	2800      	cmp	r0, #0
 802752e:	d114      	bne.n	802755a <KMS_Free+0x4e>
    {
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
    }
    if (memcmp((void *)pfoot, &normalizedFooter, sizeof(normalizedFooter)) != 0)
 8027530:	2210      	movs	r2, #16
 8027532:	4917      	ldr	r1, [pc, #92]	; (8027590 <KMS_Free+0x84>)
 8027534:	0020      	movs	r0, r4
 8027536:	f00d f8df 	bl	80346f8 <memcmp>
 802753a:	2800      	cmp	r0, #0
 802753c:	d111      	bne.n	8027562 <KMS_Free+0x56>
    {
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
    }
    for (i = 0; i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *)); i++)
 802753e:	2400      	movs	r4, #0
 8027540:	2c02      	cmp	r4, #2
 8027542:	d81c      	bhi.n	802757e <KMS_Free+0x72>
    {
      if (phead == kms_mem_pool_tab[i])
 8027544:	00a3      	lsls	r3, r4, #2
 8027546:	4a13      	ldr	r2, [pc, #76]	; (8027594 <KMS_Free+0x88>)
 8027548:	589b      	ldr	r3, [r3, r2]
 802754a:	42b3      	cmp	r3, r6
 802754c:	d00d      	beq.n	802756a <KMS_Free+0x5e>
    for (i = 0; i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *)); i++)
 802754e:	3401      	adds	r4, #1
 8027550:	e7f6      	b.n	8027540 <KMS_Free+0x34>
    KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_NULL_PTR);
 8027552:	2003      	movs	r0, #3
 8027554:	f7fa f8b4 	bl	80216c0 <KMS_LL_ReportError>
 8027558:	e013      	b.n	8027582 <KMS_Free+0x76>
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
 802755a:	2002      	movs	r0, #2
 802755c:	f7fa f8b0 	bl	80216c0 <KMS_LL_ReportError>
 8027560:	e7e6      	b.n	8027530 <KMS_Free+0x24>
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
 8027562:	2002      	movs	r0, #2
 8027564:	f7fa f8ac 	bl	80216c0 <KMS_LL_ReportError>
 8027568:	e7e9      	b.n	802753e <KMS_Free+0x32>
      {
        phead->used = 0;
 802756a:	2300      	movs	r3, #0
 802756c:	60f3      	str	r3, [r6, #12]
#if defined(KMS_MEM_DEBUGGING)
        phead->session = KMS_SESSION_ID_INVALID;
 802756e:	6133      	str	r3, [r6, #16]
        phead->caller = 0;
 8027570:	6173      	str	r3, [r6, #20]
        phead->reqSize = 0;
 8027572:	61b3      	str	r3, [r6, #24]
#endif /* KMS_MEM_DEBUGGING */
#if defined(KMS_MEM_CLEANING)
        (void)memset(Ptr, 0, phead->size);
 8027574:	68b2      	ldr	r2, [r6, #8]
 8027576:	2100      	movs	r1, #0
 8027578:	0028      	movs	r0, r5
 802757a:	f00d f8d4 	bl	8034726 <memset>
#endif /* KMS_MEM_CLEANING */
        break;
      }
    }
    if (i >= (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *)))
 802757e:	2c02      	cmp	r4, #2
 8027580:	d800      	bhi.n	8027584 <KMS_Free+0x78>
    {
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_UNKNOWN);
    }
#endif /* KMS_MEM_USE_POOL_ALLOCATOR */
  } /* (Ptr == NULL_PTR) */
}
 8027582:	bd70      	pop	{r4, r5, r6, pc}
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_UNKNOWN);
 8027584:	2004      	movs	r0, #4
 8027586:	f7fa f89b 	bl	80216c0 <KMS_LL_ReportError>
}
 802758a:	e7fa      	b.n	8027582 <KMS_Free+0x76>
 802758c:	08034c7c 	.word	0x08034c7c
 8027590:	08034c6c 	.word	0x08034c6c
 8027594:	08034c60 	.word	0x08034c60

08027598 <reset>:
  */
static void reset(void)
{
  uint32_t i;

  nvm.header = NULL;
 8027598:	4b0a      	ldr	r3, [pc, #40]	; (80275c4 <reset+0x2c>)
 802759a:	2200      	movs	r2, #0
 802759c:	601a      	str	r2, [r3, #0]
  nvm.block = NVMS_BLOCK0;
 802759e:	711a      	strb	r2, [r3, #4]
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 80275a0:	2300      	movs	r3, #0
 80275a2:	2b31      	cmp	r3, #49	; 0x31
 80275a4:	d806      	bhi.n	80275b4 <reset+0x1c>
  {
    nvm.slots[i] = NULL;
 80275a6:	1c9a      	adds	r2, r3, #2
 80275a8:	0092      	lsls	r2, r2, #2
 80275aa:	4906      	ldr	r1, [pc, #24]	; (80275c4 <reset+0x2c>)
 80275ac:	2000      	movs	r0, #0
 80275ae:	5050      	str	r0, [r2, r1]
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 80275b0:	3301      	adds	r3, #1
 80275b2:	e7f6      	b.n	80275a2 <reset+0xa>
  }
  nvm.free_next = NULL;
 80275b4:	4b03      	ldr	r3, [pc, #12]	; (80275c4 <reset+0x2c>)
 80275b6:	2200      	movs	r2, #0
 80275b8:	21d0      	movs	r1, #208	; 0xd0
 80275ba:	505a      	str	r2, [r3, r1]
  nvm.used_size = 0;
 80275bc:	3104      	adds	r1, #4
 80275be:	505a      	str	r2, [r3, r1]
}
 80275c0:	4770      	bx	lr
 80275c2:	46c0      	nop			; (mov r8, r8)
 80275c4:	2000a22c 	.word	0x2000a22c

080275c8 <do_checksum>:
  * @param[in] data_p        pointer to the data buffer
  * @param[in] size          size of the data buffer
  * @return                  The checksum.
  */
static uint32_t do_checksum(const uint8_t *data_p, size_t size)
{
 80275c8:	0003      	movs	r3, r0
  uint32_t checksum;
  const uint8_t *p = data_p;
  size_t n = size;

  checksum = 0;
 80275ca:	2000      	movs	r0, #0
  while (n != 0UL)
 80275cc:	2900      	cmp	r1, #0
 80275ce:	d004      	beq.n	80275da <do_checksum+0x12>
  {
    checksum += *p;
 80275d0:	781a      	ldrb	r2, [r3, #0]
 80275d2:	1880      	adds	r0, r0, r2
    p++;
 80275d4:	3301      	adds	r3, #1
    n--;
 80275d6:	3901      	subs	r1, #1
 80275d8:	e7f8      	b.n	80275cc <do_checksum+0x4>
  }
  return checksum;
}
 80275da:	4770      	bx	lr

080275dc <check_slot_instance>:
  * @retval NVMS_SLOT_STATUS_CRC     if the slot does not match the CRC.
  * @retval NVMS_SLOT_STATUS_BROKEN if the header is corrupt.
  */
static nvms_slot_status_t check_slot_instance(nvms_block_t block,
                                              nvms_data_header_t *hdrp)
{
 80275dc:	b510      	push	{r4, lr}
 80275de:	000c      	movs	r4, r1
  const uint8_t *endp;
  uint32_t checksum;
  uint8_t i;

  /* First check for an header in erased state */
  for (i = 0; i < 8U; i++)
 80275e0:	2300      	movs	r3, #0
 80275e2:	e003      	b.n	80275ec <check_slot_instance+0x10>
static inline uint32_t NVMS_LL_GetBlockAddress(nvms_block_t block)
{
  /* USER CODE BEGIN NVMS_LL_GetBlockAddress */
  if (block == NVMS_BLOCK0)
  {
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 80275e4:	4a24      	ldr	r2, [pc, #144]	; (8027678 <check_slot_instance+0x9c>)
 80275e6:	e00d      	b.n	8027604 <check_slot_instance+0x28>
 80275e8:	3301      	adds	r3, #1
 80275ea:	b2db      	uxtb	r3, r3
 80275ec:	2b07      	cmp	r3, #7
 80275ee:	d82e      	bhi.n	802764e <check_slot_instance+0x72>
  {

    /* If the header is not in erased state then it must be checked for
       validity */
    if (hdrp->hdr32[i] != NVMS_LL_ERASED)
 80275f0:	009a      	lsls	r2, r3, #2
 80275f2:	5912      	ldr	r2, [r2, r4]
 80275f4:	3201      	adds	r2, #1
 80275f6:	d0f7      	beq.n	80275e8 <check_slot_instance+0xc>
    {
      /* Check on the pointer to the next block, it must be aligned to an
         header boundary */
      if (((uint32_t)hdrp->fields.next & (NVMS_LL_PAGE_SIZE - 1UL)) != 0UL)
 80275f8:	6923      	ldr	r3, [r4, #16]
 80275fa:	075a      	lsls	r2, r3, #29
 80275fc:	d129      	bne.n	8027652 <check_slot_instance+0x76>
  if (block == NVMS_BLOCK0)
 80275fe:	2800      	cmp	r0, #0
 8027600:	d0f0      	beq.n	80275e4 <check_slot_instance+0x8>
  }
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027602:	4a1e      	ldr	r2, [pc, #120]	; (802767c <check_slot_instance+0xa0>)
      }

      /* Checks on the pointer to the next block, the address must be comprised
         between the next header position and the end of the flash array */
      startp = (uint8_t *)NVMS_LL_GetBlockAddress(block);
      endp = &startp[NVMS_LL_GetBlockSize()];
 8027604:	2180      	movs	r1, #128	; 0x80
 8027606:	0109      	lsls	r1, r1, #4
 8027608:	468c      	mov	ip, r1
 802760a:	4462      	add	r2, ip
      if ((hdrp->fields.next->hdr8 < (hdrp->hdr8 + sizeof(nvms_data_header_t))) ||
 802760c:	0020      	movs	r0, r4
 802760e:	3020      	adds	r0, #32
 8027610:	4283      	cmp	r3, r0
 8027612:	d320      	bcc.n	8027656 <check_slot_instance+0x7a>
 8027614:	4293      	cmp	r3, r2
 8027616:	d820      	bhi.n	802765a <check_slot_instance+0x7e>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Check on the magic numbers */
      if ((hdrp->fields.magic1 != NVMS_HEADER_MAGIC1) ||
 8027618:	4a19      	ldr	r2, [pc, #100]	; (8027680 <check_slot_instance+0xa4>)
 802761a:	6821      	ldr	r1, [r4, #0]
 802761c:	4291      	cmp	r1, r2
 802761e:	d11e      	bne.n	802765e <check_slot_instance+0x82>
 8027620:	4a18      	ldr	r2, [pc, #96]	; (8027684 <check_slot_instance+0xa8>)
 8027622:	6861      	ldr	r1, [r4, #4]
 8027624:	4291      	cmp	r1, r2
 8027626:	d11c      	bne.n	8027662 <check_slot_instance+0x86>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Check on slot identifier */
      if (hdrp->fields.slot >= NVMS_CFG_NUM_SLOTS)
 8027628:	68a2      	ldr	r2, [r4, #8]
 802762a:	2a31      	cmp	r2, #49	; 0x31
 802762c:	d81b      	bhi.n	8027666 <check_slot_instance+0x8a>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Check on the instance field */
      if (hdrp->fields.instance == NVMS_LL_ERASED)
 802762e:	68e2      	ldr	r2, [r4, #12]
 8027630:	3201      	adds	r2, #1
 8027632:	d01a      	beq.n	802766a <check_slot_instance+0x8e>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Checks on the data size */
      if ((hdrp->hdr8 + sizeof(nvms_data_header_t) + hdrp->fields.data_size) >
 8027634:	69a1      	ldr	r1, [r4, #24]
 8027636:	000a      	movs	r2, r1
 8027638:	3220      	adds	r2, #32
 802763a:	18a2      	adds	r2, r4, r2
 802763c:	4293      	cmp	r3, r2
 802763e:	d316      	bcc.n	802766e <check_slot_instance+0x92>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Payload checksum */
      checksum = do_checksum(hdrp->hdr8 + sizeof(nvms_data_header_t),
 8027640:	f7ff ffc2 	bl	80275c8 <do_checksum>
                             hdrp->fields.data_size);
      if (checksum != hdrp->fields.data_checksum)
 8027644:	69e3      	ldr	r3, [r4, #28]
 8027646:	4283      	cmp	r3, r0
 8027648:	d013      	beq.n	8027672 <check_slot_instance+0x96>
      {
        return NVMS_SLOT_STATUS_CRC;
 802764a:	2002      	movs	r0, #2
 802764c:	e000      	b.n	8027650 <check_slot_instance+0x74>

      return NVMS_SLOT_STATUS_OK;
    }
  }

  return NVMS_SLOT_STATUS_ERASED;
 802764e:	2000      	movs	r0, #0
}
 8027650:	bd10      	pop	{r4, pc}
        return NVMS_SLOT_STATUS_BROKEN;
 8027652:	2003      	movs	r0, #3
 8027654:	e7fc      	b.n	8027650 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 8027656:	2003      	movs	r0, #3
 8027658:	e7fa      	b.n	8027650 <check_slot_instance+0x74>
 802765a:	2003      	movs	r0, #3
 802765c:	e7f8      	b.n	8027650 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 802765e:	2003      	movs	r0, #3
 8027660:	e7f6      	b.n	8027650 <check_slot_instance+0x74>
 8027662:	2003      	movs	r0, #3
 8027664:	e7f4      	b.n	8027650 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 8027666:	2003      	movs	r0, #3
 8027668:	e7f2      	b.n	8027650 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 802766a:	2003      	movs	r0, #3
 802766c:	e7f0      	b.n	8027650 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 802766e:	2003      	movs	r0, #3
 8027670:	e7ee      	b.n	8027650 <check_slot_instance+0x74>
      return NVMS_SLOT_STATUS_OK;
 8027672:	2001      	movs	r0, #1
 8027674:	e7ec      	b.n	8027650 <check_slot_instance+0x74>
 8027676:	46c0      	nop			; (mov r8, r8)
 8027678:	0803d000 	.word	0x0803d000
 802767c:	0803d800 	.word	0x0803d800
 8027680:	5aa5f731 	.word	0x5aa5f731
 8027684:	137fa55a 	.word	0x137fa55a

08027688 <scan_slots>:
  *                          case.
  */
static nvms_block_status_t scan_slots(nvms_block_t block,
                                      nvms_found_slot_t slotcallback,
                                      nvms_end_slot_t endcallback)
{
 8027688:	b5f0      	push	{r4, r5, r6, r7, lr}
 802768a:	46de      	mov	lr, fp
 802768c:	4657      	mov	r7, sl
 802768e:	464e      	mov	r6, r9
 8027690:	4645      	mov	r5, r8
 8027692:	b5e0      	push	{r5, r6, r7, lr}
 8027694:	b083      	sub	sp, #12
 8027696:	1e05      	subs	r5, r0, #0
 8027698:	468a      	mov	sl, r1
 802769a:	4690      	mov	r8, r2
  if (block == NVMS_BLOCK0)
 802769c:	d012      	beq.n	80276c4 <scan_slots+0x3c>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 802769e:	492a      	ldr	r1, [pc, #168]	; (8027748 <scan_slots+0xc0>)
  bool warning = false;
  nvms_block_status_t status = NVMS_STATUS_BROKEN;
  bool status_found = false;

  /* Limits */
  startp = (uint8_t *)NVMS_LL_GetBlockAddress(block);
 80276a0:	000c      	movs	r4, r1
  endp = &startp[NVMS_LL_GetBlockSize()];
 80276a2:	2380      	movs	r3, #128	; 0x80
 80276a4:	011b      	lsls	r3, r3, #4
 80276a6:	18cf      	adds	r7, r1, r3

  /* Checking the main header */
  hdrp = (nvms_data_header_t *)(uint32_t)startp;
  slotsts = check_slot_instance(block, hdrp);
 80276a8:	0028      	movs	r0, r5
 80276aa:	f7ff ff97 	bl	80275dc <check_slot_instance>
 80276ae:	0003      	movs	r3, r0
 80276b0:	9001      	str	r0, [sp, #4]
 80276b2:	9000      	str	r0, [sp, #0]
  if (slotsts != NVMS_SLOT_STATUS_OK)
 80276b4:	2801      	cmp	r0, #1
 80276b6:	d13c      	bne.n	8027732 <scan_slots+0xaa>
  bool status_found = false;
 80276b8:	2600      	movs	r6, #0
  nvms_block_status_t status = NVMS_STATUS_BROKEN;
 80276ba:	3302      	adds	r3, #2
 80276bc:	4699      	mov	r9, r3
  bool warning = false;
 80276be:	2300      	movs	r3, #0
 80276c0:	469b      	mov	fp, r3
 80276c2:	e01f      	b.n	8027704 <scan_slots+0x7c>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 80276c4:	4921      	ldr	r1, [pc, #132]	; (802774c <scan_slots+0xc4>)
 80276c6:	e7eb      	b.n	80276a0 <scan_slots+0x18>

    /* Special case end-of-chain */
    if (hdrp->hdr8 == endp)
    {
      /* Calling end-of-scan callback if defined */
      endcallback(hdrp);
 80276c8:	0020      	movs	r0, r4
 80276ca:	47c0      	blx	r8
      if (warning)
 80276cc:	465b      	mov	r3, fp
 80276ce:	2b00      	cmp	r3, #0
 80276d0:	d102      	bne.n	80276d8 <scan_slots+0x50>
      {
        return NVMS_STATUS_PARTIAL;
      }
      else
      {
        return NVMS_STATUS_NORMAL;
 80276d2:	9b01      	ldr	r3, [sp, #4]
 80276d4:	4699      	mov	r9, r3
 80276d6:	e02e      	b.n	8027736 <scan_slots+0xae>
        return NVMS_STATUS_PARTIAL;
 80276d8:	2302      	movs	r3, #2
 80276da:	4699      	mov	r9, r3
 80276dc:	e02b      	b.n	8027736 <scan_slots+0xae>
      }
    }

    /* Header check */
    slotsts = check_slot_instance(block, hdrp);
    switch (slotsts)
 80276de:	2803      	cmp	r0, #3
 80276e0:	d110      	bne.n	8027704 <scan_slots+0x7c>
#endif /* KMS_DEBUG_MODE */
        break;

      case NVMS_SLOT_STATUS_BROKEN:
        /* Calling end-of-scan callback if defined */
        endcallback(hdrp);
 80276e2:	0020      	movs	r0, r4
 80276e4:	47c0      	blx	r8

        /* Problems, stopping the scan here */
        status = NVMS_STATUS_PARTIAL;
        status_found = true;
 80276e6:	2601      	movs	r6, #1
        status = NVMS_STATUS_PARTIAL;
 80276e8:	2302      	movs	r3, #2
 80276ea:	4699      	mov	r9, r3
        break;
 80276ec:	e00a      	b.n	8027704 <scan_slots+0x7c>
        endcallback(hdrp);
 80276ee:	0020      	movs	r0, r4
 80276f0:	47c0      	blx	r8
        if (warning)
 80276f2:	465b      	mov	r3, fp
 80276f4:	2b00      	cmp	r3, #0
 80276f6:	d018      	beq.n	802772a <scan_slots+0xa2>
          status_found = true;
 80276f8:	465e      	mov	r6, fp
          status = NVMS_STATUS_PARTIAL;
 80276fa:	2302      	movs	r3, #2
 80276fc:	4699      	mov	r9, r3
 80276fe:	e001      	b.n	8027704 <scan_slots+0x7c>
        warning = true;
 8027700:	2301      	movs	r3, #1
 8027702:	469b      	mov	fp, r3
  while (!status_found)
 8027704:	2e00      	cmp	r6, #0
 8027706:	d116      	bne.n	8027736 <scan_slots+0xae>
    hdrp = (nvms_data_header_t *)hdrp->fields.next;
 8027708:	6924      	ldr	r4, [r4, #16]
    if (hdrp->hdr8 == endp)
 802770a:	42bc      	cmp	r4, r7
 802770c:	d0dc      	beq.n	80276c8 <scan_slots+0x40>
    slotsts = check_slot_instance(block, hdrp);
 802770e:	0021      	movs	r1, r4
 8027710:	0028      	movs	r0, r5
 8027712:	f7ff ff63 	bl	80275dc <check_slot_instance>
    switch (slotsts)
 8027716:	2802      	cmp	r0, #2
 8027718:	d0f2      	beq.n	8027700 <scan_slots+0x78>
 802771a:	d8e0      	bhi.n	80276de <scan_slots+0x56>
 802771c:	2800      	cmp	r0, #0
 802771e:	d0e6      	beq.n	80276ee <scan_slots+0x66>
 8027720:	2801      	cmp	r0, #1
 8027722:	d1ef      	bne.n	8027704 <scan_slots+0x7c>
        slotcallback(hdrp);
 8027724:	0020      	movs	r0, r4
 8027726:	47d0      	blx	sl
        break;
 8027728:	e7ec      	b.n	8027704 <scan_slots+0x7c>
          status = NVMS_STATUS_NORMAL;
 802772a:	9b00      	ldr	r3, [sp, #0]
 802772c:	4699      	mov	r9, r3
          status_found = true;
 802772e:	2601      	movs	r6, #1
 8027730:	e7e8      	b.n	8027704 <scan_slots+0x7c>
    return NVMS_STATUS_BROKEN;
 8027732:	2303      	movs	r3, #3
 8027734:	4699      	mov	r9, r3
        /* No action */
        break;
    }
  }
  return status;
}
 8027736:	4648      	mov	r0, r9
 8027738:	b003      	add	sp, #12
 802773a:	bcf0      	pop	{r4, r5, r6, r7}
 802773c:	46bb      	mov	fp, r7
 802773e:	46b2      	mov	sl, r6
 8027740:	46a9      	mov	r9, r5
 8027742:	46a0      	mov	r8, r4
 8027744:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027746:	46c0      	nop			; (mov r8, r8)
 8027748:	0803d800 	.word	0x0803d800
 802774c:	0803d000 	.word	0x0803d000

08027750 <find_slot>:
  * @retval NVMS_DATA_NOT_FOUND if the slot does not exists in the block.
  */
static nvms_error_t find_slot(nvms_block_t block,
                              uint32_t slot,
                              nvms_data_header_t **hdrpp)
{
 8027750:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027752:	46de      	mov	lr, fp
 8027754:	4657      	mov	r7, sl
 8027756:	464e      	mov	r6, r9
 8027758:	4645      	mov	r5, r8
 802775a:	b5e0      	push	{r5, r6, r7, lr}
 802775c:	b083      	sub	sp, #12
 802775e:	1e07      	subs	r7, r0, #0
 8027760:	4688      	mov	r8, r1
 8027762:	4692      	mov	sl, r2
  if (block == NVMS_BLOCK0)
 8027764:	d00c      	beq.n	8027780 <find_slot+0x30>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027766:	4e2d      	ldr	r6, [pc, #180]	; (802781c <find_slot+0xcc>)
  bool crcerr;
  bool status_found = false;
  nvms_error_t status = NVMS_INTERNAL;

  /* Limits */
  startp = (uint8_t *)NVMS_LL_GetBlockAddress(block);
 8027768:	0034      	movs	r4, r6
  endp = &startp[NVMS_LL_GetBlockSize()];
 802776a:	2380      	movs	r3, #128	; 0x80
 802776c:	011b      	lsls	r3, r3, #4
 802776e:	469c      	mov	ip, r3
 8027770:	4466      	add	r6, ip
  nvms_error_t status = NVMS_INTERNAL;
 8027772:	2308      	movs	r3, #8
 8027774:	469b      	mov	fp, r3
  bool status_found = false;
 8027776:	2500      	movs	r5, #0

  /* Scanning the slots chain */
  hdrp = (nvms_data_header_t *)(uint32_t)startp;
  slotp = NULL;
  crcerr = false;
 8027778:	2300      	movs	r3, #0
 802777a:	9301      	str	r3, [sp, #4]
  slotp = NULL;
 802777c:	4699      	mov	r9, r3
  while (!status_found)
 802777e:	e028      	b.n	80277d2 <find_slot+0x82>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027780:	4e27      	ldr	r6, [pc, #156]	; (8027820 <find_slot+0xd0>)
 8027782:	e7f1      	b.n	8027768 <find_slot+0x18>
    hdrp = (nvms_data_header_t *)hdrp->fields.next;

    /* Special case end-of-chain */
    if (hdrp->hdr8 == endp)
    {
      if (slotp == NULL)
 8027784:	464b      	mov	r3, r9
 8027786:	2b00      	cmp	r3, #0
 8027788:	d045      	beq.n	8027816 <find_slot+0xc6>
      {
        return NVMS_DATA_NOT_FOUND;
      }
      *hdrpp = slotp;
 802778a:	4653      	mov	r3, sl
 802778c:	464a      	mov	r2, r9
 802778e:	601a      	str	r2, [r3, #0]
      if (crcerr)
 8027790:	9b01      	ldr	r3, [sp, #4]
 8027792:	2b00      	cmp	r3, #0
 8027794:	d109      	bne.n	80277aa <find_slot+0x5a>
      {
        return NVMS_CRC;
      }
      else
      {
        return NVMS_NOERROR;
 8027796:	2300      	movs	r3, #0
 8027798:	469b      	mov	fp, r3
        /* No action */
        break;
    }
  }
  return status;
}
 802779a:	4658      	mov	r0, fp
 802779c:	b003      	add	sp, #12
 802779e:	bcf0      	pop	{r4, r5, r6, r7}
 80277a0:	46bb      	mov	fp, r7
 80277a2:	46b2      	mov	sl, r6
 80277a4:	46a9      	mov	r9, r5
 80277a6:	46a0      	mov	r8, r4
 80277a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return NVMS_CRC;
 80277aa:	2306      	movs	r3, #6
 80277ac:	469b      	mov	fp, r3
 80277ae:	e7f4      	b.n	802779a <find_slot+0x4a>
    switch (slotsts)
 80277b0:	2803      	cmp	r0, #3
 80277b2:	d10e      	bne.n	80277d2 <find_slot+0x82>
        if (slotp == NULL)
 80277b4:	464b      	mov	r3, r9
 80277b6:	2b00      	cmp	r3, #0
 80277b8:	d021      	beq.n	80277fe <find_slot+0xae>
          *hdrpp = slotp;
 80277ba:	4653      	mov	r3, sl
 80277bc:	464a      	mov	r2, r9
 80277be:	601a      	str	r2, [r3, #0]
          if (crcerr)
 80277c0:	9d01      	ldr	r5, [sp, #4]
 80277c2:	2d00      	cmp	r5, #0
 80277c4:	d01f      	beq.n	8027806 <find_slot+0xb6>
            status = NVMS_CRC;
 80277c6:	2306      	movs	r3, #6
 80277c8:	469b      	mov	fp, r3
 80277ca:	e002      	b.n	80277d2 <find_slot+0x82>
        if (hdrp->fields.slot == slot)
 80277cc:	68a3      	ldr	r3, [r4, #8]
 80277ce:	4543      	cmp	r3, r8
 80277d0:	d01d      	beq.n	802780e <find_slot+0xbe>
  while (!status_found)
 80277d2:	2d00      	cmp	r5, #0
 80277d4:	d1e1      	bne.n	802779a <find_slot+0x4a>
    hdrp = (nvms_data_header_t *)hdrp->fields.next;
 80277d6:	6924      	ldr	r4, [r4, #16]
    if (hdrp->hdr8 == endp)
 80277d8:	42b4      	cmp	r4, r6
 80277da:	d0d3      	beq.n	8027784 <find_slot+0x34>
    slotsts = check_slot_instance(block, hdrp);
 80277dc:	0021      	movs	r1, r4
 80277de:	0038      	movs	r0, r7
 80277e0:	f7ff fefc 	bl	80275dc <check_slot_instance>
    switch (slotsts)
 80277e4:	2802      	cmp	r0, #2
 80277e6:	d0f1      	beq.n	80277cc <find_slot+0x7c>
 80277e8:	d8e2      	bhi.n	80277b0 <find_slot+0x60>
 80277ea:	2800      	cmp	r0, #0
 80277ec:	d0e2      	beq.n	80277b4 <find_slot+0x64>
 80277ee:	2801      	cmp	r0, #1
 80277f0:	d1ef      	bne.n	80277d2 <find_slot+0x82>
        if (hdrp->fields.slot == slot)
 80277f2:	68a3      	ldr	r3, [r4, #8]
 80277f4:	4543      	cmp	r3, r8
 80277f6:	d1ec      	bne.n	80277d2 <find_slot+0x82>
          crcerr = false;
 80277f8:	9501      	str	r5, [sp, #4]
          slotp = hdrp;
 80277fa:	46a1      	mov	r9, r4
 80277fc:	e7e9      	b.n	80277d2 <find_slot+0x82>
          status = NVMS_DATA_NOT_FOUND;
 80277fe:	2305      	movs	r3, #5
 8027800:	469b      	mov	fp, r3
        status_found = true;
 8027802:	2501      	movs	r5, #1
 8027804:	e7e5      	b.n	80277d2 <find_slot+0x82>
            status = NVMS_NOERROR;
 8027806:	2300      	movs	r3, #0
 8027808:	469b      	mov	fp, r3
        status_found = true;
 802780a:	2501      	movs	r5, #1
 802780c:	e7e1      	b.n	80277d2 <find_slot+0x82>
          slotp = hdrp;
 802780e:	46a1      	mov	r9, r4
          crcerr = true;
 8027810:	2301      	movs	r3, #1
 8027812:	9301      	str	r3, [sp, #4]
 8027814:	e7dd      	b.n	80277d2 <find_slot+0x82>
        return NVMS_DATA_NOT_FOUND;
 8027816:	2305      	movs	r3, #5
 8027818:	469b      	mov	fp, r3
 802781a:	e7be      	b.n	802779a <find_slot+0x4a>
 802781c:	0803d800 	.word	0x0803d800
 8027820:	0803d000 	.word	0x0803d000

08027824 <null_callback>:
  */
static void null_callback(nvms_data_header_t *hdrp)
{

  (void)(hdrp);
}
 8027824:	4770      	bx	lr
	...

08027828 <use_slot_callback>:
  * @brief   Private callback of @p use().
  */
static void use_slot_callback(nvms_data_header_t *hdrp)
{

  nvm.slots[hdrp->fields.slot] = hdrp;
 8027828:	6883      	ldr	r3, [r0, #8]
 802782a:	3302      	adds	r3, #2
 802782c:	009b      	lsls	r3, r3, #2
 802782e:	4a01      	ldr	r2, [pc, #4]	; (8027834 <use_slot_callback+0xc>)
 8027830:	5098      	str	r0, [r3, r2]
}
 8027832:	4770      	bx	lr
 8027834:	2000a22c 	.word	0x2000a22c

08027838 <use_end_callback>:
  * @brief   Private callback of @p use().
  */
static void use_end_callback(nvms_data_header_t *hdrp)
{

  nvm.free_next = hdrp;
 8027838:	4a01      	ldr	r2, [pc, #4]	; (8027840 <use_end_callback+0x8>)
 802783a:	23d0      	movs	r3, #208	; 0xd0
 802783c:	50d0      	str	r0, [r2, r3]
}
 802783e:	4770      	bx	lr
 8027840:	2000a22c 	.word	0x2000a22c

08027844 <use>:
  * @return                    The operation status.
  * @retval NVMS_NOERROR       if the operation has been successfully completed.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
static nvms_error_t use(nvms_block_t block)
{
 8027844:	b570      	push	{r4, r5, r6, lr}
 8027846:	1e04      	subs	r4, r0, #0
  if (block == NVMS_BLOCK0)
 8027848:	d014      	beq.n	8027874 <use+0x30>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 802784a:	4d1c      	ldr	r5, [pc, #112]	; (80278bc <use+0x78>)
  uint32_t i;
  nvms_block_status_t status;
  nvms_data_header_t *hdrp = (nvms_data_header_t *)NVMS_LL_GetBlockAddress(block);

  /* Resetting state */
  reset();
 802784c:	f7ff fea4 	bl	8027598 <reset>

  /* Global info */
  nvm.header    = hdrp;
 8027850:	4b1b      	ldr	r3, [pc, #108]	; (80278c0 <use+0x7c>)
 8027852:	601d      	str	r5, [r3, #0]
  nvm.block     = block;
 8027854:	711c      	strb	r4, [r3, #4]
  nvm.used_size = sizeof(nvms_data_header_t);
 8027856:	22d4      	movs	r2, #212	; 0xd4
 8027858:	2120      	movs	r1, #32
 802785a:	5099      	str	r1, [r3, r2]
  nvm.free_next = &hdrp[1];
 802785c:	3520      	adds	r5, #32
 802785e:	3a04      	subs	r2, #4
 8027860:	509d      	str	r5, [r3, r2]

  /* The block should have been checked before calling use() so any
     kind of anomaly in the block is considered an internal error */
  status = scan_slots(block, use_slot_callback, use_end_callback);
 8027862:	4a18      	ldr	r2, [pc, #96]	; (80278c4 <use+0x80>)
 8027864:	4918      	ldr	r1, [pc, #96]	; (80278c8 <use+0x84>)
 8027866:	0020      	movs	r0, r4
 8027868:	f7ff ff0e 	bl	8027688 <scan_slots>
  if (status != NVMS_STATUS_NORMAL)
 802786c:	2801      	cmp	r0, #1
 802786e:	d103      	bne.n	8027878 <use+0x34>
    reset();
    return NVMS_INTERNAL;
  }

  /* Scanning found slots */
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 8027870:	2300      	movs	r3, #0
 8027872:	e00c      	b.n	802788e <use+0x4a>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027874:	4d15      	ldr	r5, [pc, #84]	; (80278cc <use+0x88>)
 8027876:	e7e9      	b.n	802784c <use+0x8>
    reset();
 8027878:	f7ff fe8e 	bl	8027598 <reset>
    return NVMS_INTERNAL;
 802787c:	2008      	movs	r0, #8
 802787e:	e01b      	b.n	80278b8 <use+0x74>
    {
      /* Zero sized slots are discarded because indicate that the slot
         has been erased */
      if (hdrp->fields.data_size == 0UL)
      {
        nvm.slots[hdrp->fields.slot] = NULL;
 8027880:	6892      	ldr	r2, [r2, #8]
 8027882:	3202      	adds	r2, #2
 8027884:	0092      	lsls	r2, r2, #2
 8027886:	490e      	ldr	r1, [pc, #56]	; (80278c0 <use+0x7c>)
 8027888:	2000      	movs	r0, #0
 802788a:	5050      	str	r0, [r2, r1]
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 802788c:	3301      	adds	r3, #1
 802788e:	2b31      	cmp	r3, #49	; 0x31
 8027890:	d811      	bhi.n	80278b6 <use+0x72>
    hdrp = nvm.slots[i];
 8027892:	1c9a      	adds	r2, r3, #2
 8027894:	0092      	lsls	r2, r2, #2
 8027896:	490a      	ldr	r1, [pc, #40]	; (80278c0 <use+0x7c>)
 8027898:	5852      	ldr	r2, [r2, r1]
    if (hdrp != NULL)
 802789a:	2a00      	cmp	r2, #0
 802789c:	d0f6      	beq.n	802788c <use+0x48>
      if (hdrp->fields.data_size == 0UL)
 802789e:	6991      	ldr	r1, [r2, #24]
 80278a0:	2900      	cmp	r1, #0
 80278a2:	d0ed      	beq.n	8027880 <use+0x3c>
        continue;
      }

      /* Adding the slot used space to the total */
      nvm.used_size += hdrp->fields.next->hdr8 - hdrp->hdr8;
 80278a4:	6911      	ldr	r1, [r2, #16]
 80278a6:	1a8a      	subs	r2, r1, r2
 80278a8:	4805      	ldr	r0, [pc, #20]	; (80278c0 <use+0x7c>)
 80278aa:	21d4      	movs	r1, #212	; 0xd4
 80278ac:	5844      	ldr	r4, [r0, r1]
 80278ae:	46a4      	mov	ip, r4
 80278b0:	4462      	add	r2, ip
 80278b2:	5042      	str	r2, [r0, r1]
 80278b4:	e7ea      	b.n	802788c <use+0x48>
    }
  }

  return NVMS_NOERROR;
 80278b6:	2000      	movs	r0, #0
}
 80278b8:	bd70      	pop	{r4, r5, r6, pc}
 80278ba:	46c0      	nop			; (mov r8, r8)
 80278bc:	0803d800 	.word	0x0803d800
 80278c0:	2000a22c 	.word	0x2000a22c
 80278c4:	08027839 	.word	0x08027839
 80278c8:	08027829 	.word	0x08027829
 80278cc:	0803d000 	.word	0x0803d000

080278d0 <determine_block_state>:
  *                               readable.
  * @retval NVMS_STATUS_BROKEN    if the block contains unreadable garbage.
  */
static nvms_block_status_t determine_block_state(nvms_block_t block,
                                                 uint32_t *instance)
{
 80278d0:	b570      	push	{r4, r5, r6, lr}
 80278d2:	0004      	movs	r4, r0
 80278d4:	000d      	movs	r5, r1
  /* Special case where the block is fully erased */
  if (NVMS_LL_IsBlockErased(block))
 80278d6:	f7f9 ff4f 	bl	8021778 <NVMS_LL_IsBlockErased>
 80278da:	2800      	cmp	r0, #0
 80278dc:	d10c      	bne.n	80278f8 <determine_block_state+0x28>
  if (block == NVMS_BLOCK0)
 80278de:	2c00      	cmp	r4, #0
 80278e0:	d008      	beq.n	80278f4 <determine_block_state+0x24>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 80278e2:	4b06      	ldr	r3, [pc, #24]	; (80278fc <determine_block_state+0x2c>)
  {
    return NVMS_STATUS_ERASED;
  }

  /* Returning the block instance number */
  *instance = ((nvms_data_header_t *)NVMS_LL_GetBlockAddress(block))->fields.instance;
 80278e4:	68db      	ldr	r3, [r3, #12]
 80278e6:	602b      	str	r3, [r5, #0]

  /* Checking block integrity by just scanning it */
  return scan_slots(block, null_callback, null_callback);
 80278e8:	4905      	ldr	r1, [pc, #20]	; (8027900 <determine_block_state+0x30>)
 80278ea:	000a      	movs	r2, r1
 80278ec:	0020      	movs	r0, r4
 80278ee:	f7ff fecb 	bl	8027688 <scan_slots>
}
 80278f2:	bd70      	pop	{r4, r5, r6, pc}
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 80278f4:	4b03      	ldr	r3, [pc, #12]	; (8027904 <determine_block_state+0x34>)
 80278f6:	e7f5      	b.n	80278e4 <determine_block_state+0x14>
    return NVMS_STATUS_ERASED;
 80278f8:	2000      	movs	r0, #0
 80278fa:	e7fa      	b.n	80278f2 <determine_block_state+0x22>
 80278fc:	0803d800 	.word	0x0803d800
 8027900:	08027825 	.word	0x08027825
 8027904:	0803d000 	.word	0x0803d000

08027908 <copy_slot>:
{
 8027908:	b570      	push	{r4, r5, r6, lr}
 802790a:	b088      	sub	sp, #32
 802790c:	0004      	movs	r4, r0
 802790e:	000d      	movs	r5, r1
  size = rhdrp->fields.data_size;
 8027910:	6986      	ldr	r6, [r0, #24]
  p_free = &p_next[(((sizeof(nvms_data_header_t) + size - 1UL) | (NVMS_LL_PAGE_SIZE - 1UL)) + 1UL)];
 8027912:	0033      	movs	r3, r6
 8027914:	331f      	adds	r3, #31
 8027916:	2207      	movs	r2, #7
 8027918:	4313      	orrs	r3, r2
 802791a:	3301      	adds	r3, #1
 802791c:	18cb      	adds	r3, r1, r3
  hdr.fields.magic1             = NVMS_LL_ERASED;
 802791e:	3a08      	subs	r2, #8
 8027920:	9200      	str	r2, [sp, #0]
  hdr.fields.magic2             = NVMS_LL_ERASED;
 8027922:	9201      	str	r2, [sp, #4]
  hdr.fields.slot                = rhdrp->fields.slot;
 8027924:	6882      	ldr	r2, [r0, #8]
 8027926:	9202      	str	r2, [sp, #8]
  hdr.fields.instance           = 1;    /* Resetting instance number */
 8027928:	2201      	movs	r2, #1
 802792a:	9203      	str	r2, [sp, #12]
  hdr.fields.next               = (nvms_data_header_t *)(uint32_t)p_free;
 802792c:	9304      	str	r3, [sp, #16]
  hdr.fields.data_type       = rhdrp->fields.data_type;
 802792e:	6943      	ldr	r3, [r0, #20]
 8027930:	9305      	str	r3, [sp, #20]
  hdr.fields.data_size       = size;
 8027932:	9606      	str	r6, [sp, #24]
  hdr.fields.data_checksum   = rhdrp->fields.data_checksum;
 8027934:	69c3      	ldr	r3, [r0, #28]
 8027936:	9307      	str	r3, [sp, #28]
  result = NVMS_LL_Write(&((const uint8_t *)&hdr)[8], &p_next[8], sizeof(nvms_data_header_t) - 8UL);
 8027938:	3108      	adds	r1, #8
 802793a:	3217      	adds	r2, #23
 802793c:	a802      	add	r0, sp, #8
 802793e:	f7f9 ff59 	bl	80217f4 <NVMS_LL_Write>
  if (result)
 8027942:	2800      	cmp	r0, #0
 8027944:	d115      	bne.n	8027972 <copy_slot+0x6a>
  result = NVMS_LL_Write(rhdrp->hdr8 + sizeof(nvms_data_header_t),
 8027946:	0029      	movs	r1, r5
 8027948:	3120      	adds	r1, #32
 802794a:	0020      	movs	r0, r4
 802794c:	3020      	adds	r0, #32
 802794e:	0032      	movs	r2, r6
 8027950:	f7f9 ff50 	bl	80217f4 <NVMS_LL_Write>
  if (result)
 8027954:	2800      	cmp	r0, #0
 8027956:	d10f      	bne.n	8027978 <copy_slot+0x70>
  hdr.fields.magic1 = NVMS_HEADER_MAGIC1;
 8027958:	4b08      	ldr	r3, [pc, #32]	; (802797c <copy_slot+0x74>)
 802795a:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2 = NVMS_HEADER_MAGIC2;
 802795c:	4b08      	ldr	r3, [pc, #32]	; (8027980 <copy_slot+0x78>)
 802795e:	9301      	str	r3, [sp, #4]
  result = NVMS_LL_Write((const uint8_t *)&hdr, p_next, sizeof(uint32_t) * 2UL);
 8027960:	2208      	movs	r2, #8
 8027962:	0029      	movs	r1, r5
 8027964:	4668      	mov	r0, sp
 8027966:	f7f9 ff45 	bl	80217f4 <NVMS_LL_Write>
  if (result)
 802796a:	2800      	cmp	r0, #0
 802796c:	d002      	beq.n	8027974 <copy_slot+0x6c>
    return NVMS_FLASH_FAILURE;
 802796e:	2003      	movs	r0, #3
 8027970:	e000      	b.n	8027974 <copy_slot+0x6c>
    return NVMS_FLASH_FAILURE;
 8027972:	2003      	movs	r0, #3
}
 8027974:	b008      	add	sp, #32
 8027976:	bd70      	pop	{r4, r5, r6, pc}
    return NVMS_FLASH_FAILURE;
 8027978:	2003      	movs	r0, #3
 802797a:	e7fb      	b.n	8027974 <copy_slot+0x6c>
 802797c:	5aa5f731 	.word	0x5aa5f731
 8027980:	137fa55a 	.word	0x137fa55a

08027984 <copy_slots>:
{
 8027984:	b570      	push	{r4, r5, r6, lr}
 8027986:	b082      	sub	sp, #8
 8027988:	0005      	movs	r5, r0
  if (block == NVMS_BLOCK0)
 802798a:	2900      	cmp	r1, #0
 802798c:	d003      	beq.n	8027996 <copy_slots+0x12>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 802798e:	4e0f      	ldr	r6, [pc, #60]	; (80279cc <copy_slots+0x48>)
  whdrp = (nvms_data_header_t *)NVMS_LL_GetBlockAddress(dest_block) + 1;
 8027990:	3620      	adds	r6, #32
  for (slot = 0; slot < NVMS_CFG_NUM_SLOTS; slot++)
 8027992:	2400      	movs	r4, #0
 8027994:	e002      	b.n	802799c <copy_slots+0x18>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027996:	4e0e      	ldr	r6, [pc, #56]	; (80279d0 <copy_slots+0x4c>)
 8027998:	e7fa      	b.n	8027990 <copy_slots+0xc>
 802799a:	3401      	adds	r4, #1
 802799c:	2c31      	cmp	r4, #49	; 0x31
 802799e:	d811      	bhi.n	80279c4 <copy_slots+0x40>
    err = find_slot(source_block, slot, &rhdrp);
 80279a0:	aa01      	add	r2, sp, #4
 80279a2:	0021      	movs	r1, r4
 80279a4:	0028      	movs	r0, r5
 80279a6:	f7ff fed3 	bl	8027750 <find_slot>
    if ((err == NVMS_NOERROR) && (rhdrp->fields.data_size > 0UL))
 80279aa:	2800      	cmp	r0, #0
 80279ac:	d1f5      	bne.n	802799a <copy_slots+0x16>
 80279ae:	9801      	ldr	r0, [sp, #4]
 80279b0:	6983      	ldr	r3, [r0, #24]
 80279b2:	2b00      	cmp	r3, #0
 80279b4:	d0f1      	beq.n	802799a <copy_slots+0x16>
      err = copy_slot(rhdrp, whdrp);
 80279b6:	0031      	movs	r1, r6
 80279b8:	f7ff ffa6 	bl	8027908 <copy_slot>
      if (err != NVMS_NOERROR)
 80279bc:	2800      	cmp	r0, #0
 80279be:	d102      	bne.n	80279c6 <copy_slots+0x42>
      whdrp = (nvms_data_header_t *)whdrp->fields.next;
 80279c0:	6936      	ldr	r6, [r6, #16]
 80279c2:	e7ea      	b.n	802799a <copy_slots+0x16>
  return NVMS_NOERROR;
 80279c4:	2000      	movs	r0, #0
}
 80279c6:	b002      	add	sp, #8
 80279c8:	bd70      	pop	{r4, r5, r6, pc}
 80279ca:	46c0      	nop			; (mov r8, r8)
 80279cc:	0803d800 	.word	0x0803d800
 80279d0:	0803d000 	.word	0x0803d000

080279d4 <validate>:
{
 80279d4:	b510      	push	{r4, lr}
 80279d6:	b088      	sub	sp, #32
  if (block == NVMS_BLOCK0)
 80279d8:	2800      	cmp	r0, #0
 80279da:	d021      	beq.n	8027a20 <validate+0x4c>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 80279dc:	4c13      	ldr	r4, [pc, #76]	; (8027a2c <validate+0x58>)
  hdr.fields.magic1             = NVMS_LL_ERASED;
 80279de:	2201      	movs	r2, #1
 80279e0:	4252      	negs	r2, r2
 80279e2:	9200      	str	r2, [sp, #0]
  hdr.fields.magic2             = NVMS_LL_ERASED;
 80279e4:	9201      	str	r2, [sp, #4]
  hdr.fields.slot               = NVMS_SLOT_MAIN_HEADER;
 80279e6:	2300      	movs	r3, #0
 80279e8:	9302      	str	r3, [sp, #8]
  hdr.fields.instance           = instance;
 80279ea:	9103      	str	r1, [sp, #12]
  hdr.fields.next               = &((nvms_data_header_t *)(uint32_t)dp)[1];
 80279ec:	0021      	movs	r1, r4
 80279ee:	3120      	adds	r1, #32
 80279f0:	9104      	str	r1, [sp, #16]
  hdr.fields.data_type       = NVMS_LL_ERASED;
 80279f2:	9205      	str	r2, [sp, #20]
  hdr.fields.data_size       = 0;
 80279f4:	9306      	str	r3, [sp, #24]
  hdr.fields.data_checksum   = 0;
 80279f6:	9307      	str	r3, [sp, #28]
  result = NVMS_LL_Write(&hdr.hdr8[8], &dp[8], sizeof(nvms_data_header_t) - 8UL);
 80279f8:	3918      	subs	r1, #24
 80279fa:	3219      	adds	r2, #25
 80279fc:	a802      	add	r0, sp, #8
 80279fe:	f7f9 fef9 	bl	80217f4 <NVMS_LL_Write>
  if (result)
 8027a02:	2800      	cmp	r0, #0
 8027a04:	d10e      	bne.n	8027a24 <validate+0x50>
  hdr.fields.magic1 = NVMS_HEADER_MAGIC1;
 8027a06:	4b0a      	ldr	r3, [pc, #40]	; (8027a30 <validate+0x5c>)
 8027a08:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2 = NVMS_HEADER_MAGIC2;
 8027a0a:	4b0a      	ldr	r3, [pc, #40]	; (8027a34 <validate+0x60>)
 8027a0c:	9301      	str	r3, [sp, #4]
  result = NVMS_LL_Write(hdr.hdr8, dp, sizeof(uint32_t) * 2UL);
 8027a0e:	2208      	movs	r2, #8
 8027a10:	0021      	movs	r1, r4
 8027a12:	4668      	mov	r0, sp
 8027a14:	f7f9 feee 	bl	80217f4 <NVMS_LL_Write>
  if (result)
 8027a18:	2800      	cmp	r0, #0
 8027a1a:	d105      	bne.n	8027a28 <validate+0x54>
}
 8027a1c:	b008      	add	sp, #32
 8027a1e:	bd10      	pop	{r4, pc}
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027a20:	4c05      	ldr	r4, [pc, #20]	; (8027a38 <validate+0x64>)
 8027a22:	e7dc      	b.n	80279de <validate+0xa>
    return NVMS_FLASH_FAILURE;
 8027a24:	2003      	movs	r0, #3
 8027a26:	e7f9      	b.n	8027a1c <validate+0x48>
    return NVMS_FLASH_FAILURE;
 8027a28:	2003      	movs	r0, #3
 8027a2a:	e7f7      	b.n	8027a1c <validate+0x48>
 8027a2c:	0803d800 	.word	0x0803d800
 8027a30:	5aa5f731 	.word	0x5aa5f731
 8027a34:	137fa55a 	.word	0x137fa55a
 8027a38:	0803d000 	.word	0x0803d000

08027a3c <append_slot>:
  * @retval NVMS_FLASH_FAILURE if the flash memory is unusable because HW
  *                            failures.
  */
static nvms_error_t append_slot(nvms_slot_t slot, size_t size, nvms_data_type_t type,
                                const uint8_t *slotp, uint32_t instance)
{
 8027a3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027a3e:	b089      	sub	sp, #36	; 0x24
 8027a40:	000d      	movs	r5, r1
 8027a42:	001e      	movs	r6, r3
  bool result;
  nvms_data_header_t hdr;
  uint8_t *p_next;
  uint8_t *p_free;

  p_next = nvm.free_next->hdr8;
 8027a44:	4920      	ldr	r1, [pc, #128]	; (8027ac8 <append_slot+0x8c>)
 8027a46:	23d0      	movs	r3, #208	; 0xd0
 8027a48:	58cf      	ldr	r7, [r1, r3]
  p_free = &p_next[(((sizeof(nvms_data_header_t) + size - 1UL) | (NVMS_LL_PAGE_SIZE - 1UL)) + 1UL)];
 8027a4a:	002c      	movs	r4, r5
 8027a4c:	341f      	adds	r4, #31
 8027a4e:	3bc9      	subs	r3, #201	; 0xc9
 8027a50:	431c      	orrs	r4, r3
 8027a52:	3401      	adds	r4, #1
 8027a54:	193c      	adds	r4, r7, r4

  /* Writing the header without the magic numbers, this way it is
     not yet validated but the write is tested */
  hdr.fields.magic1             = NVMS_LL_ERASED;
 8027a56:	3b08      	subs	r3, #8
 8027a58:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2             = NVMS_LL_ERASED;
 8027a5a:	9301      	str	r3, [sp, #4]
  hdr.fields.slot               = slot;
 8027a5c:	9002      	str	r0, [sp, #8]
  hdr.fields.instance           = instance;
 8027a5e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027a60:	9303      	str	r3, [sp, #12]
  hdr.fields.next               = (nvms_data_header_t *)(uint32_t)p_free;
 8027a62:	9404      	str	r4, [sp, #16]
  hdr.fields.data_type          = type;
 8027a64:	9205      	str	r2, [sp, #20]
  hdr.fields.data_size          = size;
 8027a66:	9506      	str	r5, [sp, #24]
  hdr.fields.data_checksum      = do_checksum(slotp, size);
 8027a68:	0029      	movs	r1, r5
 8027a6a:	0030      	movs	r0, r6
 8027a6c:	f7ff fdac 	bl	80275c8 <do_checksum>
 8027a70:	9007      	str	r0, [sp, #28]

  /* Do not write the full structure (including the 2 initial words set to the ERASED FLASH value), but only the
  meaningful data
  Rationale : writing the erased_default value on some platform prevent any further update of the flash
  */
  result = NVMS_LL_Write(&((const uint8_t *)&hdr)[8], &p_next[8], sizeof(nvms_data_header_t) - 8UL);
 8027a72:	0039      	movs	r1, r7
 8027a74:	3108      	adds	r1, #8
 8027a76:	2218      	movs	r2, #24
 8027a78:	a802      	add	r0, sp, #8
 8027a7a:	f7f9 febb 	bl	80217f4 <NVMS_LL_Write>
  if (result)
 8027a7e:	2800      	cmp	r0, #0
 8027a80:	d11b      	bne.n	8027aba <append_slot+0x7e>
  {
    return NVMS_FLASH_FAILURE;
  }

  /* Writing data */
  if (size > 0UL)
 8027a82:	2d00      	cmp	r5, #0
 8027a84:	d007      	beq.n	8027a96 <append_slot+0x5a>
  {
    result = NVMS_LL_Write(slotp, &p_next[sizeof(nvms_data_header_t)], size);
 8027a86:	0039      	movs	r1, r7
 8027a88:	3120      	adds	r1, #32
 8027a8a:	002a      	movs	r2, r5
 8027a8c:	0030      	movs	r0, r6
 8027a8e:	f7f9 feb1 	bl	80217f4 <NVMS_LL_Write>
    if (result)
 8027a92:	2800      	cmp	r0, #0
 8027a94:	d113      	bne.n	8027abe <append_slot+0x82>
      return NVMS_FLASH_FAILURE;
    }
  }

  /* Writing the magic numbers validates the header */
  hdr.fields.magic1 = NVMS_HEADER_MAGIC1;
 8027a96:	4b0d      	ldr	r3, [pc, #52]	; (8027acc <append_slot+0x90>)
 8027a98:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2 = NVMS_HEADER_MAGIC2;
 8027a9a:	4b0d      	ldr	r3, [pc, #52]	; (8027ad0 <append_slot+0x94>)
 8027a9c:	9301      	str	r3, [sp, #4]
  result = NVMS_LL_Write((const uint8_t *)&hdr,
                         nvm.free_next->hdr8,
 8027a9e:	4a0a      	ldr	r2, [pc, #40]	; (8027ac8 <append_slot+0x8c>)
 8027aa0:	23d0      	movs	r3, #208	; 0xd0
 8027aa2:	58d1      	ldr	r1, [r2, r3]
  result = NVMS_LL_Write((const uint8_t *)&hdr,
 8027aa4:	2208      	movs	r2, #8
 8027aa6:	4668      	mov	r0, sp
 8027aa8:	f7f9 fea4 	bl	80217f4 <NVMS_LL_Write>
                         sizeof(uint32_t) * 2UL);
  if (result)
 8027aac:	2800      	cmp	r0, #0
 8027aae:	d108      	bne.n	8027ac2 <append_slot+0x86>
  {
    return NVMS_FLASH_FAILURE;
  }
  /* Updating the global pointer */
  nvm.free_next = (nvms_data_header_t *)(uint32_t)p_free;
 8027ab0:	4a05      	ldr	r2, [pc, #20]	; (8027ac8 <append_slot+0x8c>)
 8027ab2:	23d0      	movs	r3, #208	; 0xd0
 8027ab4:	50d4      	str	r4, [r2, r3]

  return NVMS_NOERROR;
}
 8027ab6:	b009      	add	sp, #36	; 0x24
 8027ab8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NVMS_FLASH_FAILURE;
 8027aba:	2003      	movs	r0, #3
 8027abc:	e7fb      	b.n	8027ab6 <append_slot+0x7a>
      return NVMS_FLASH_FAILURE;
 8027abe:	2003      	movs	r0, #3
 8027ac0:	e7f9      	b.n	8027ab6 <append_slot+0x7a>
    return NVMS_FLASH_FAILURE;
 8027ac2:	2003      	movs	r0, #3
 8027ac4:	e7f7      	b.n	8027ab6 <append_slot+0x7a>
 8027ac6:	46c0      	nop			; (mov r8, r8)
 8027ac8:	2000a22c 	.word	0x2000a22c
 8027acc:	5aa5f731 	.word	0x5aa5f731
 8027ad0:	137fa55a 	.word	0x137fa55a

08027ad4 <block_erase>:
{
 8027ad4:	b510      	push	{r4, lr}
  result = NVMS_LL_BlockErase(block);
 8027ad6:	f7f9 fe67 	bl	80217a8 <NVMS_LL_BlockErase>
  if (result)
 8027ada:	2800      	cmp	r0, #0
 8027adc:	d100      	bne.n	8027ae0 <block_erase+0xc>
}
 8027ade:	bd10      	pop	{r4, pc}
    return NVMS_FLASH_FAILURE;
 8027ae0:	2003      	movs	r0, #3
 8027ae2:	e7fc      	b.n	8027ade <block_erase+0xa>

08027ae4 <try_boot>:
  * @retval NVMS_FLASH_FAILURE if the flash memory is unusable because HW
  *                            failures.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
static nvms_error_t try_boot(void)
{
 8027ae4:	b570      	push	{r4, r5, r6, lr}
 8027ae6:	b082      	sub	sp, #8
  nvms_block_status_t sts0;
  nvms_block_status_t sts1;
  uint32_t seq0 = 0;
 8027ae8:	2300      	movs	r3, #0
 8027aea:	9301      	str	r3, [sp, #4]
  uint32_t seq1 = 0;
 8027aec:	9300      	str	r3, [sp, #0]

  sts0 = determine_block_state(NVMS_BLOCK0, &seq0);
 8027aee:	a901      	add	r1, sp, #4
 8027af0:	2000      	movs	r0, #0
 8027af2:	f7ff feed 	bl	80278d0 <determine_block_state>
 8027af6:	0005      	movs	r5, r0
 8027af8:	0006      	movs	r6, r0
  sts1 = determine_block_state(NVMS_BLOCK1, &seq1);
 8027afa:	4669      	mov	r1, sp
 8027afc:	2001      	movs	r0, #1
 8027afe:	f7ff fee7 	bl	80278d0 <determine_block_state>
 8027b02:	0004      	movs	r4, r0
 8027b04:	0002      	movs	r2, r0

  /* Case 1 - Both block erased, performs an initialization of block zero
     and starts using it */
  if ((sts0 == NVMS_STATUS_ERASED) && (sts1 == NVMS_STATUS_ERASED))
 8027b06:	002b      	movs	r3, r5
 8027b08:	4303      	orrs	r3, r0
 8027b0a:	b2db      	uxtb	r3, r3
 8027b0c:	2b00      	cmp	r3, #0
 8027b0e:	d015      	beq.n	8027b3c <try_boot+0x58>

    return NVMS_NOERROR;
  }

  /* Cases 2, 3, 4 - Block zero is erased */
  if (sts0 == NVMS_STATUS_ERASED)
 8027b10:	2d00      	cmp	r5, #0
 8027b12:	d139      	bne.n	8027b88 <try_boot+0xa4>
  {

    /* Case 2 - Block zero is erased, block one is normal */
    if (sts1 == NVMS_STATUS_NORMAL)
 8027b14:	2801      	cmp	r0, #1
 8027b16:	d01c      	beq.n	8027b52 <try_boot+0x6e>

      return NVMS_NOERROR;
    }

    /* Case 3 - Block zero is erased, block one is partially corrupted */
    if (sts1 == NVMS_STATUS_PARTIAL)
 8027b18:	2802      	cmp	r0, #2
 8027b1a:	d01e      	beq.n	8027b5a <try_boot+0x76>
      return NVMS_WARNING;
    }

    /* Case 4 - Block zero is erased, block one is broken. Note, the
       variable "sts1" is assumed to have value "NVMS_STATUS_BROKEN" */
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027b1c:	2001      	movs	r0, #1
 8027b1e:	f7ff ffd9 	bl	8027ad4 <block_erase>
 8027b22:	2800      	cmp	r0, #0
 8027b24:	d110      	bne.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK0, 1));
 8027b26:	2101      	movs	r1, #1
 8027b28:	f7ff ff54 	bl	80279d4 <validate>
 8027b2c:	2800      	cmp	r0, #0
 8027b2e:	d10b      	bne.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(use(NVMS_BLOCK0));
 8027b30:	f7ff fe88 	bl	8027844 <use>
 8027b34:	2800      	cmp	r0, #0
 8027b36:	d107      	bne.n	8027b48 <try_boot+0x64>

#if defined(KMS_DEBUG_MODE)
    latest_warning = NVMS_WARNING_ONE_BLOCK_BROKEN;
#endif /* KMS_DEBUG_MODE */
    return NVMS_WARNING;
 8027b38:	2002      	movs	r0, #2
 8027b3a:	e005      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK0, 1));
 8027b3c:	2101      	movs	r1, #1
 8027b3e:	2000      	movs	r0, #0
 8027b40:	f7ff ff48 	bl	80279d4 <validate>
 8027b44:	2800      	cmp	r0, #0
 8027b46:	d001      	beq.n	8027b4c <try_boot+0x68>
#if defined(KMS_DEBUG_MODE)
  latest_warning = NVMS_WARNING_TWO_BLOCKS_BROKEN;
#endif /* KMS_DEBUG_MODE */

  return NVMS_WARNING;
}
 8027b48:	b002      	add	sp, #8
 8027b4a:	bd70      	pop	{r4, r5, r6, pc}
    CHECK_ERROR(use(NVMS_BLOCK0));
 8027b4c:	f7ff fe7a 	bl	8027844 <use>
 8027b50:	e7fa      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027b52:	2001      	movs	r0, #1
 8027b54:	f7ff fe76 	bl	8027844 <use>
 8027b58:	e7f6      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8027b5a:	2100      	movs	r1, #0
 8027b5c:	2001      	movs	r0, #1
 8027b5e:	f7ff ff11 	bl	8027984 <copy_slots>
 8027b62:	2800      	cmp	r0, #0
 8027b64:	d1f0      	bne.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK0, seq1 + 1UL));
 8027b66:	9b00      	ldr	r3, [sp, #0]
 8027b68:	1c59      	adds	r1, r3, #1
 8027b6a:	f7ff ff33 	bl	80279d4 <validate>
 8027b6e:	2800      	cmp	r0, #0
 8027b70:	d1ea      	bne.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027b72:	3001      	adds	r0, #1
 8027b74:	f7ff ffae 	bl	8027ad4 <block_erase>
 8027b78:	2800      	cmp	r0, #0
 8027b7a:	d1e5      	bne.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027b7c:	f7ff fe62 	bl	8027844 <use>
 8027b80:	2800      	cmp	r0, #0
 8027b82:	d1e1      	bne.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027b84:	0020      	movs	r0, r4
 8027b86:	e7df      	b.n	8027b48 <try_boot+0x64>
  if (sts1 == NVMS_STATUS_ERASED)
 8027b88:	2800      	cmp	r0, #0
 8027b8a:	d105      	bne.n	8027b98 <try_boot+0xb4>
    if (sts0 == NVMS_STATUS_NORMAL)
 8027b8c:	2d01      	cmp	r5, #1
 8027b8e:	d02a      	beq.n	8027be6 <try_boot+0x102>
    if (sts0 == NVMS_STATUS_PARTIAL)
 8027b90:	2d02      	cmp	r5, #2
 8027b92:	d02c      	beq.n	8027bee <try_boot+0x10a>
    if (sts0 == NVMS_STATUS_BROKEN)
 8027b94:	2d03      	cmp	r5, #3
 8027b96:	d042      	beq.n	8027c1e <try_boot+0x13a>
  if ((sts0 == NVMS_STATUS_NORMAL) && (sts1 == NVMS_STATUS_NORMAL))
 8027b98:	2e01      	cmp	r6, #1
 8027b9a:	d055      	beq.n	8027c48 <try_boot+0x164>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_PARTIAL))
 8027b9c:	2e02      	cmp	r6, #2
 8027b9e:	d074      	beq.n	8027c8a <try_boot+0x1a6>
  if (sts0 == NVMS_STATUS_NORMAL)
 8027ba0:	2e01      	cmp	r6, #1
 8027ba2:	d100      	bne.n	8027ba6 <try_boot+0xc2>
 8027ba4:	e0b9      	b.n	8027d1a <try_boot+0x236>
  if (sts1 == NVMS_STATUS_NORMAL)
 8027ba6:	2a01      	cmp	r2, #1
 8027ba8:	d100      	bne.n	8027bac <try_boot+0xc8>
 8027baa:	e0fa      	b.n	8027da2 <try_boot+0x2be>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_BROKEN))
 8027bac:	2e02      	cmp	r6, #2
 8027bae:	d100      	bne.n	8027bb2 <try_boot+0xce>
 8027bb0:	e13d      	b.n	8027e2e <try_boot+0x34a>
  if ((sts0 == NVMS_STATUS_BROKEN) && (sts1 == NVMS_STATUS_PARTIAL))
 8027bb2:	2e03      	cmp	r6, #3
 8027bb4:	d102      	bne.n	8027bbc <try_boot+0xd8>
 8027bb6:	2a02      	cmp	r2, #2
 8027bb8:	d100      	bne.n	8027bbc <try_boot+0xd8>
 8027bba:	e15c      	b.n	8027e76 <try_boot+0x392>
  CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027bbc:	2000      	movs	r0, #0
 8027bbe:	f7ff ff89 	bl	8027ad4 <block_erase>
 8027bc2:	2800      	cmp	r0, #0
 8027bc4:	d1c0      	bne.n	8027b48 <try_boot+0x64>
  CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027bc6:	3001      	adds	r0, #1
 8027bc8:	f7ff ff84 	bl	8027ad4 <block_erase>
 8027bcc:	2800      	cmp	r0, #0
 8027bce:	d1bb      	bne.n	8027b48 <try_boot+0x64>
  CHECK_ERROR(validate(NVMS_BLOCK0, 1));
 8027bd0:	2101      	movs	r1, #1
 8027bd2:	f7ff feff 	bl	80279d4 <validate>
 8027bd6:	2800      	cmp	r0, #0
 8027bd8:	d1b6      	bne.n	8027b48 <try_boot+0x64>
  CHECK_ERROR(use(NVMS_BLOCK0));
 8027bda:	f7ff fe33 	bl	8027844 <use>
 8027bde:	2800      	cmp	r0, #0
 8027be0:	d1b2      	bne.n	8027b48 <try_boot+0x64>
  return NVMS_WARNING;
 8027be2:	3002      	adds	r0, #2
 8027be4:	e7b0      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027be6:	2000      	movs	r0, #0
 8027be8:	f7ff fe2c 	bl	8027844 <use>
 8027bec:	e7ac      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8027bee:	2101      	movs	r1, #1
 8027bf0:	2000      	movs	r0, #0
 8027bf2:	f7ff fec7 	bl	8027984 <copy_slots>
 8027bf6:	2800      	cmp	r0, #0
 8027bf8:	d1a6      	bne.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 8027bfa:	9b01      	ldr	r3, [sp, #4]
 8027bfc:	1c59      	adds	r1, r3, #1
 8027bfe:	3001      	adds	r0, #1
 8027c00:	f7ff fee8 	bl	80279d4 <validate>
 8027c04:	2800      	cmp	r0, #0
 8027c06:	d19f      	bne.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027c08:	f7ff ff64 	bl	8027ad4 <block_erase>
 8027c0c:	2800      	cmp	r0, #0
 8027c0e:	d19b      	bne.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027c10:	3001      	adds	r0, #1
 8027c12:	f7ff fe17 	bl	8027844 <use>
 8027c16:	2800      	cmp	r0, #0
 8027c18:	d196      	bne.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027c1a:	0028      	movs	r0, r5
 8027c1c:	e794      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027c1e:	2000      	movs	r0, #0
 8027c20:	f7ff ff58 	bl	8027ad4 <block_erase>
 8027c24:	2800      	cmp	r0, #0
 8027c26:	d000      	beq.n	8027c2a <try_boot+0x146>
 8027c28:	e78e      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK1, 1));
 8027c2a:	2101      	movs	r1, #1
 8027c2c:	3001      	adds	r0, #1
 8027c2e:	f7ff fed1 	bl	80279d4 <validate>
 8027c32:	2800      	cmp	r0, #0
 8027c34:	d000      	beq.n	8027c38 <try_boot+0x154>
 8027c36:	e787      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027c38:	3001      	adds	r0, #1
 8027c3a:	f7ff fe03 	bl	8027844 <use>
 8027c3e:	2800      	cmp	r0, #0
 8027c40:	d000      	beq.n	8027c44 <try_boot+0x160>
 8027c42:	e781      	b.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027c44:	2002      	movs	r0, #2
 8027c46:	e77f      	b.n	8027b48 <try_boot+0x64>
  if ((sts0 == NVMS_STATUS_NORMAL) && (sts1 == NVMS_STATUS_NORMAL))
 8027c48:	2a01      	cmp	r2, #1
 8027c4a:	d1a7      	bne.n	8027b9c <try_boot+0xb8>
    if (seq0 > seq1)
 8027c4c:	9b01      	ldr	r3, [sp, #4]
 8027c4e:	9a00      	ldr	r2, [sp, #0]
 8027c50:	4293      	cmp	r3, r2
 8027c52:	d90c      	bls.n	8027c6e <try_boot+0x18a>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027c54:	2001      	movs	r0, #1
 8027c56:	f7ff ff3d 	bl	8027ad4 <block_erase>
 8027c5a:	2800      	cmp	r0, #0
 8027c5c:	d000      	beq.n	8027c60 <try_boot+0x17c>
 8027c5e:	e773      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027c60:	f7ff fdf0 	bl	8027844 <use>
 8027c64:	2800      	cmp	r0, #0
 8027c66:	d000      	beq.n	8027c6a <try_boot+0x186>
 8027c68:	e76e      	b.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027c6a:	2002      	movs	r0, #2
 8027c6c:	e76c      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027c6e:	2000      	movs	r0, #0
 8027c70:	f7ff ff30 	bl	8027ad4 <block_erase>
 8027c74:	2800      	cmp	r0, #0
 8027c76:	d000      	beq.n	8027c7a <try_boot+0x196>
 8027c78:	e766      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027c7a:	3001      	adds	r0, #1
 8027c7c:	f7ff fde2 	bl	8027844 <use>
 8027c80:	2800      	cmp	r0, #0
 8027c82:	d000      	beq.n	8027c86 <try_boot+0x1a2>
 8027c84:	e760      	b.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027c86:	2002      	movs	r0, #2
 8027c88:	e75e      	b.n	8027b48 <try_boot+0x64>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_PARTIAL))
 8027c8a:	2a02      	cmp	r2, #2
 8027c8c:	d188      	bne.n	8027ba0 <try_boot+0xbc>
    if (seq0 > seq1)
 8027c8e:	9b01      	ldr	r3, [sp, #4]
 8027c90:	9a00      	ldr	r2, [sp, #0]
 8027c92:	4293      	cmp	r3, r2
 8027c94:	d920      	bls.n	8027cd8 <try_boot+0x1f4>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027c96:	2001      	movs	r0, #1
 8027c98:	f7ff ff1c 	bl	8027ad4 <block_erase>
 8027c9c:	2800      	cmp	r0, #0
 8027c9e:	d000      	beq.n	8027ca2 <try_boot+0x1be>
 8027ca0:	e752      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8027ca2:	2101      	movs	r1, #1
 8027ca4:	f7ff fe6e 	bl	8027984 <copy_slots>
 8027ca8:	2800      	cmp	r0, #0
 8027caa:	d000      	beq.n	8027cae <try_boot+0x1ca>
 8027cac:	e74c      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 8027cae:	9b01      	ldr	r3, [sp, #4]
 8027cb0:	1c59      	adds	r1, r3, #1
 8027cb2:	3001      	adds	r0, #1
 8027cb4:	f7ff fe8e 	bl	80279d4 <validate>
 8027cb8:	2800      	cmp	r0, #0
 8027cba:	d000      	beq.n	8027cbe <try_boot+0x1da>
 8027cbc:	e744      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027cbe:	f7ff ff09 	bl	8027ad4 <block_erase>
 8027cc2:	2800      	cmp	r0, #0
 8027cc4:	d000      	beq.n	8027cc8 <try_boot+0x1e4>
 8027cc6:	e73f      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027cc8:	3001      	adds	r0, #1
 8027cca:	f7ff fdbb 	bl	8027844 <use>
 8027cce:	2800      	cmp	r0, #0
 8027cd0:	d000      	beq.n	8027cd4 <try_boot+0x1f0>
 8027cd2:	e739      	b.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027cd4:	0020      	movs	r0, r4
 8027cd6:	e737      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027cd8:	2000      	movs	r0, #0
 8027cda:	f7ff fefb 	bl	8027ad4 <block_erase>
 8027cde:	2800      	cmp	r0, #0
 8027ce0:	d000      	beq.n	8027ce4 <try_boot+0x200>
 8027ce2:	e731      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8027ce4:	2100      	movs	r1, #0
 8027ce6:	3001      	adds	r0, #1
 8027ce8:	f7ff fe4c 	bl	8027984 <copy_slots>
 8027cec:	2800      	cmp	r0, #0
 8027cee:	d000      	beq.n	8027cf2 <try_boot+0x20e>
 8027cf0:	e72a      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK0, seq1 + 1UL));
 8027cf2:	9b00      	ldr	r3, [sp, #0]
 8027cf4:	1c59      	adds	r1, r3, #1
 8027cf6:	f7ff fe6d 	bl	80279d4 <validate>
 8027cfa:	2800      	cmp	r0, #0
 8027cfc:	d000      	beq.n	8027d00 <try_boot+0x21c>
 8027cfe:	e723      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027d00:	3001      	adds	r0, #1
 8027d02:	f7ff fee7 	bl	8027ad4 <block_erase>
 8027d06:	2800      	cmp	r0, #0
 8027d08:	d000      	beq.n	8027d0c <try_boot+0x228>
 8027d0a:	e71d      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027d0c:	f7ff fd9a 	bl	8027844 <use>
 8027d10:	2800      	cmp	r0, #0
 8027d12:	d000      	beq.n	8027d16 <try_boot+0x232>
 8027d14:	e718      	b.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027d16:	0020      	movs	r0, r4
 8027d18:	e716      	b.n	8027b48 <try_boot+0x64>
    if (sts1 == NVMS_STATUS_PARTIAL)
 8027d1a:	2a02      	cmp	r2, #2
 8027d1c:	d00f      	beq.n	8027d3e <try_boot+0x25a>
    if (sts1 == NVMS_STATUS_BROKEN)
 8027d1e:	2a03      	cmp	r2, #3
 8027d20:	d000      	beq.n	8027d24 <try_boot+0x240>
 8027d22:	e740      	b.n	8027ba6 <try_boot+0xc2>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027d24:	2001      	movs	r0, #1
 8027d26:	f7ff fed5 	bl	8027ad4 <block_erase>
 8027d2a:	2800      	cmp	r0, #0
 8027d2c:	d000      	beq.n	8027d30 <try_boot+0x24c>
 8027d2e:	e70b      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027d30:	f7ff fd88 	bl	8027844 <use>
 8027d34:	2800      	cmp	r0, #0
 8027d36:	d000      	beq.n	8027d3a <try_boot+0x256>
 8027d38:	e706      	b.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027d3a:	2002      	movs	r0, #2
 8027d3c:	e704      	b.n	8027b48 <try_boot+0x64>
      if (seq0 > seq1)
 8027d3e:	9b01      	ldr	r3, [sp, #4]
 8027d40:	9a00      	ldr	r2, [sp, #0]
 8027d42:	4293      	cmp	r3, r2
 8027d44:	d90c      	bls.n	8027d60 <try_boot+0x27c>
        CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027d46:	2001      	movs	r0, #1
 8027d48:	f7ff fec4 	bl	8027ad4 <block_erase>
 8027d4c:	2800      	cmp	r0, #0
 8027d4e:	d000      	beq.n	8027d52 <try_boot+0x26e>
 8027d50:	e6fa      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK0));
 8027d52:	f7ff fd77 	bl	8027844 <use>
 8027d56:	2800      	cmp	r0, #0
 8027d58:	d000      	beq.n	8027d5c <try_boot+0x278>
 8027d5a:	e6f5      	b.n	8027b48 <try_boot+0x64>
        return NVMS_WARNING;
 8027d5c:	0020      	movs	r0, r4
 8027d5e:	e6f3      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027d60:	2000      	movs	r0, #0
 8027d62:	f7ff feb7 	bl	8027ad4 <block_erase>
 8027d66:	2800      	cmp	r0, #0
 8027d68:	d000      	beq.n	8027d6c <try_boot+0x288>
 8027d6a:	e6ed      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8027d6c:	2100      	movs	r1, #0
 8027d6e:	3001      	adds	r0, #1
 8027d70:	f7ff fe08 	bl	8027984 <copy_slots>
 8027d74:	2800      	cmp	r0, #0
 8027d76:	d000      	beq.n	8027d7a <try_boot+0x296>
 8027d78:	e6e6      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(validate(NVMS_BLOCK0, seq1 + 1UL));
 8027d7a:	9b00      	ldr	r3, [sp, #0]
 8027d7c:	1c59      	adds	r1, r3, #1
 8027d7e:	f7ff fe29 	bl	80279d4 <validate>
 8027d82:	2800      	cmp	r0, #0
 8027d84:	d000      	beq.n	8027d88 <try_boot+0x2a4>
 8027d86:	e6df      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027d88:	3001      	adds	r0, #1
 8027d8a:	f7ff fea3 	bl	8027ad4 <block_erase>
 8027d8e:	2800      	cmp	r0, #0
 8027d90:	d000      	beq.n	8027d94 <try_boot+0x2b0>
 8027d92:	e6d9      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK0));
 8027d94:	f7ff fd56 	bl	8027844 <use>
 8027d98:	2800      	cmp	r0, #0
 8027d9a:	d000      	beq.n	8027d9e <try_boot+0x2ba>
 8027d9c:	e6d4      	b.n	8027b48 <try_boot+0x64>
        return NVMS_WARNING;
 8027d9e:	0020      	movs	r0, r4
 8027da0:	e6d2      	b.n	8027b48 <try_boot+0x64>
    if (sts0 == NVMS_STATUS_PARTIAL)
 8027da2:	2e02      	cmp	r6, #2
 8027da4:	d010      	beq.n	8027dc8 <try_boot+0x2e4>
    if (sts0 == NVMS_STATUS_BROKEN)
 8027da6:	2e03      	cmp	r6, #3
 8027da8:	d000      	beq.n	8027dac <try_boot+0x2c8>
 8027daa:	e6ff      	b.n	8027bac <try_boot+0xc8>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027dac:	2000      	movs	r0, #0
 8027dae:	f7ff fe91 	bl	8027ad4 <block_erase>
 8027db2:	2800      	cmp	r0, #0
 8027db4:	d000      	beq.n	8027db8 <try_boot+0x2d4>
 8027db6:	e6c7      	b.n	8027b48 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027db8:	3001      	adds	r0, #1
 8027dba:	f7ff fd43 	bl	8027844 <use>
 8027dbe:	2800      	cmp	r0, #0
 8027dc0:	d000      	beq.n	8027dc4 <try_boot+0x2e0>
 8027dc2:	e6c1      	b.n	8027b48 <try_boot+0x64>
      return NVMS_WARNING;
 8027dc4:	2002      	movs	r0, #2
 8027dc6:	e6bf      	b.n	8027b48 <try_boot+0x64>
      if (seq1 > seq0)
 8027dc8:	9b00      	ldr	r3, [sp, #0]
 8027dca:	9a01      	ldr	r2, [sp, #4]
 8027dcc:	4293      	cmp	r3, r2
 8027dce:	d90d      	bls.n	8027dec <try_boot+0x308>
        CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027dd0:	2000      	movs	r0, #0
 8027dd2:	f7ff fe7f 	bl	8027ad4 <block_erase>
 8027dd6:	2800      	cmp	r0, #0
 8027dd8:	d000      	beq.n	8027ddc <try_boot+0x2f8>
 8027dda:	e6b5      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK1));
 8027ddc:	3001      	adds	r0, #1
 8027dde:	f7ff fd31 	bl	8027844 <use>
 8027de2:	2800      	cmp	r0, #0
 8027de4:	d000      	beq.n	8027de8 <try_boot+0x304>
 8027de6:	e6af      	b.n	8027b48 <try_boot+0x64>
        return NVMS_WARNING;
 8027de8:	0028      	movs	r0, r5
 8027dea:	e6ad      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027dec:	2001      	movs	r0, #1
 8027dee:	f7ff fe71 	bl	8027ad4 <block_erase>
 8027df2:	2800      	cmp	r0, #0
 8027df4:	d000      	beq.n	8027df8 <try_boot+0x314>
 8027df6:	e6a7      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8027df8:	2101      	movs	r1, #1
 8027dfa:	f7ff fdc3 	bl	8027984 <copy_slots>
 8027dfe:	2800      	cmp	r0, #0
 8027e00:	d000      	beq.n	8027e04 <try_boot+0x320>
 8027e02:	e6a1      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 8027e04:	9b01      	ldr	r3, [sp, #4]
 8027e06:	1c59      	adds	r1, r3, #1
 8027e08:	3001      	adds	r0, #1
 8027e0a:	f7ff fde3 	bl	80279d4 <validate>
 8027e0e:	2800      	cmp	r0, #0
 8027e10:	d000      	beq.n	8027e14 <try_boot+0x330>
 8027e12:	e699      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027e14:	f7ff fe5e 	bl	8027ad4 <block_erase>
 8027e18:	2800      	cmp	r0, #0
 8027e1a:	d000      	beq.n	8027e1e <try_boot+0x33a>
 8027e1c:	e694      	b.n	8027b48 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK1));
 8027e1e:	3001      	adds	r0, #1
 8027e20:	f7ff fd10 	bl	8027844 <use>
 8027e24:	2800      	cmp	r0, #0
 8027e26:	d000      	beq.n	8027e2a <try_boot+0x346>
 8027e28:	e68e      	b.n	8027b48 <try_boot+0x64>
        return NVMS_WARNING;
 8027e2a:	0028      	movs	r0, r5
 8027e2c:	e68c      	b.n	8027b48 <try_boot+0x64>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_BROKEN))
 8027e2e:	2a03      	cmp	r2, #3
 8027e30:	d000      	beq.n	8027e34 <try_boot+0x350>
 8027e32:	e6be      	b.n	8027bb2 <try_boot+0xce>
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027e34:	2001      	movs	r0, #1
 8027e36:	f7ff fe4d 	bl	8027ad4 <block_erase>
 8027e3a:	2800      	cmp	r0, #0
 8027e3c:	d000      	beq.n	8027e40 <try_boot+0x35c>
 8027e3e:	e683      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8027e40:	2101      	movs	r1, #1
 8027e42:	f7ff fd9f 	bl	8027984 <copy_slots>
 8027e46:	2800      	cmp	r0, #0
 8027e48:	d000      	beq.n	8027e4c <try_boot+0x368>
 8027e4a:	e67d      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 8027e4c:	9b01      	ldr	r3, [sp, #4]
 8027e4e:	1c59      	adds	r1, r3, #1
 8027e50:	3001      	adds	r0, #1
 8027e52:	f7ff fdbf 	bl	80279d4 <validate>
 8027e56:	2800      	cmp	r0, #0
 8027e58:	d000      	beq.n	8027e5c <try_boot+0x378>
 8027e5a:	e675      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027e5c:	f7ff fe3a 	bl	8027ad4 <block_erase>
 8027e60:	2800      	cmp	r0, #0
 8027e62:	d000      	beq.n	8027e66 <try_boot+0x382>
 8027e64:	e670      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(use(NVMS_BLOCK1));
 8027e66:	3001      	adds	r0, #1
 8027e68:	f7ff fcec 	bl	8027844 <use>
 8027e6c:	2800      	cmp	r0, #0
 8027e6e:	d000      	beq.n	8027e72 <try_boot+0x38e>
 8027e70:	e66a      	b.n	8027b48 <try_boot+0x64>
    return NVMS_WARNING;
 8027e72:	0028      	movs	r0, r5
 8027e74:	e668      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027e76:	2000      	movs	r0, #0
 8027e78:	f7ff fe2c 	bl	8027ad4 <block_erase>
 8027e7c:	2800      	cmp	r0, #0
 8027e7e:	d000      	beq.n	8027e82 <try_boot+0x39e>
 8027e80:	e662      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8027e82:	2100      	movs	r1, #0
 8027e84:	3001      	adds	r0, #1
 8027e86:	f7ff fd7d 	bl	8027984 <copy_slots>
 8027e8a:	2800      	cmp	r0, #0
 8027e8c:	d000      	beq.n	8027e90 <try_boot+0x3ac>
 8027e8e:	e65b      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK0, seq0 + 1UL));
 8027e90:	9b01      	ldr	r3, [sp, #4]
 8027e92:	1c59      	adds	r1, r3, #1
 8027e94:	f7ff fd9e 	bl	80279d4 <validate>
 8027e98:	2800      	cmp	r0, #0
 8027e9a:	d000      	beq.n	8027e9e <try_boot+0x3ba>
 8027e9c:	e654      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027e9e:	3001      	adds	r0, #1
 8027ea0:	f7ff fe18 	bl	8027ad4 <block_erase>
 8027ea4:	2800      	cmp	r0, #0
 8027ea6:	d000      	beq.n	8027eaa <try_boot+0x3c6>
 8027ea8:	e64e      	b.n	8027b48 <try_boot+0x64>
    CHECK_ERROR(use(NVMS_BLOCK0));
 8027eaa:	f7ff fccb 	bl	8027844 <use>
 8027eae:	2800      	cmp	r0, #0
 8027eb0:	d000      	beq.n	8027eb4 <try_boot+0x3d0>
 8027eb2:	e649      	b.n	8027b48 <try_boot+0x64>
    return NVMS_WARNING;
 8027eb4:	0020      	movs	r0, r4
 8027eb6:	e647      	b.n	8027b48 <try_boot+0x64>

08027eb8 <garbage_collect>:
{
 8027eb8:	b510      	push	{r4, lr}
  if (nvm.block == NVMS_BLOCK0)
 8027eba:	4b19      	ldr	r3, [pc, #100]	; (8027f20 <garbage_collect+0x68>)
 8027ebc:	791b      	ldrb	r3, [r3, #4]
 8027ebe:	2b00      	cmp	r3, #0
 8027ec0:	d117      	bne.n	8027ef2 <garbage_collect+0x3a>
    CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8027ec2:	2101      	movs	r1, #1
 8027ec4:	2000      	movs	r0, #0
 8027ec6:	f7ff fd5d 	bl	8027984 <copy_slots>
 8027eca:	2800      	cmp	r0, #0
 8027ecc:	d000      	beq.n	8027ed0 <garbage_collect+0x18>
}
 8027ece:	bd10      	pop	{r4, pc}
    CHECK_ERROR(validate(NVMS_BLOCK1, nvm.header->fields.instance + 1UL));
 8027ed0:	4b13      	ldr	r3, [pc, #76]	; (8027f20 <garbage_collect+0x68>)
 8027ed2:	681b      	ldr	r3, [r3, #0]
 8027ed4:	68d9      	ldr	r1, [r3, #12]
 8027ed6:	3101      	adds	r1, #1
 8027ed8:	3001      	adds	r0, #1
 8027eda:	f7ff fd7b 	bl	80279d4 <validate>
 8027ede:	2800      	cmp	r0, #0
 8027ee0:	d1f5      	bne.n	8027ece <garbage_collect+0x16>
    CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027ee2:	f7ff fdf7 	bl	8027ad4 <block_erase>
 8027ee6:	2800      	cmp	r0, #0
 8027ee8:	d1f1      	bne.n	8027ece <garbage_collect+0x16>
    CHECK_ERROR(use(NVMS_BLOCK1));
 8027eea:	3001      	adds	r0, #1
 8027eec:	f7ff fcaa 	bl	8027844 <use>
 8027ef0:	e7ed      	b.n	8027ece <garbage_collect+0x16>
    CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8027ef2:	2100      	movs	r1, #0
 8027ef4:	2001      	movs	r0, #1
 8027ef6:	f7ff fd45 	bl	8027984 <copy_slots>
 8027efa:	2800      	cmp	r0, #0
 8027efc:	d1e7      	bne.n	8027ece <garbage_collect+0x16>
    CHECK_ERROR(validate(NVMS_BLOCK0, nvm.header->fields.instance + 1UL));
 8027efe:	4b08      	ldr	r3, [pc, #32]	; (8027f20 <garbage_collect+0x68>)
 8027f00:	681b      	ldr	r3, [r3, #0]
 8027f02:	68d9      	ldr	r1, [r3, #12]
 8027f04:	3101      	adds	r1, #1
 8027f06:	f7ff fd65 	bl	80279d4 <validate>
 8027f0a:	2800      	cmp	r0, #0
 8027f0c:	d1df      	bne.n	8027ece <garbage_collect+0x16>
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027f0e:	3001      	adds	r0, #1
 8027f10:	f7ff fde0 	bl	8027ad4 <block_erase>
 8027f14:	2800      	cmp	r0, #0
 8027f16:	d1da      	bne.n	8027ece <garbage_collect+0x16>
    CHECK_ERROR(use(NVMS_BLOCK0));
 8027f18:	f7ff fc94 	bl	8027844 <use>
 8027f1c:	e7d7      	b.n	8027ece <garbage_collect+0x16>
 8027f1e:	46c0      	nop			; (mov r8, r8)
 8027f20:	2000a22c 	.word	0x2000a22c

08027f24 <NVMS_Init>:
  * @retval NVMS_FLASH_FAILURE if the flash memory is unusable because HW
  *                            failures.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
nvms_error_t NVMS_Init(void)
{
 8027f24:	b510      	push	{r4, lr}
  NVMS_LL_Init();
 8027f26:	f7f9 fc25 	bl	8021774 <NVMS_LL_Init>
  reset();
 8027f2a:	f7ff fb35 	bl	8027598 <reset>

  for (uint32_t i = NVMS_CFG_MAX_REPAIR_ATTEMPTS; i > 0UL; i--)
 8027f2e:	2403      	movs	r4, #3
 8027f30:	e000      	b.n	8027f34 <NVMS_Init+0x10>
 8027f32:	3c01      	subs	r4, #1
 8027f34:	2c00      	cmp	r4, #0
 8027f36:	d006      	beq.n	8027f46 <NVMS_Init+0x22>
  {
    nvms_error_t err = try_boot();
 8027f38:	f7ff fdd4 	bl	8027ae4 <try_boot>
    if ((err == NVMS_NOERROR) || (err == NVMS_WARNING))
 8027f3c:	2800      	cmp	r0, #0
 8027f3e:	d003      	beq.n	8027f48 <NVMS_Init+0x24>
 8027f40:	2802      	cmp	r0, #2
 8027f42:	d1f6      	bne.n	8027f32 <NVMS_Init+0xe>
 8027f44:	e000      	b.n	8027f48 <NVMS_Init+0x24>
    {
      return err;
    }
  }
  return NVMS_FLASH_FAILURE;
 8027f46:	2003      	movs	r0, #3
}
 8027f48:	bd10      	pop	{r4, pc}
	...

08027f4c <NVMS_WriteDataWithType>:
  * @retval NVMS_OUT_OF_MEM    if the slot space is exhausted.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
nvms_error_t NVMS_WriteDataWithType(nvms_slot_t slot, size_t size, nvms_data_type_t type,
                                    const uint8_t *slotp)
{
 8027f4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027f4e:	46ce      	mov	lr, r9
 8027f50:	b500      	push	{lr}
 8027f52:	b084      	sub	sp, #16
 8027f54:	0004      	movs	r4, r0
 8027f56:	000e      	movs	r6, r1
 8027f58:	9202      	str	r2, [sp, #8]
 8027f5a:	9303      	str	r3, [sp, #12]
  return nvm.header != NULL;
 8027f5c:	4b29      	ldr	r3, [pc, #164]	; (8028004 <NVMS_WriteDataWithType+0xb8>)
 8027f5e:	681b      	ldr	r3, [r3, #0]
  size_t oldused;
  nvms_error_t err;
  nvms_data_header_t *hdrp;

  /* Check on initialization */
  if (!is_initialized())
 8027f60:	2b00      	cmp	r3, #0
 8027f62:	d049      	beq.n	8027ff8 <NVMS_WriteDataWithType+0xac>
  {
    return NVMS_NOTINIT;
  }

  /* Check on the slot identifier */
  if (slot >= NVMS_CFG_NUM_SLOTS)
 8027f64:	2831      	cmp	r0, #49	; 0x31
 8027f66:	d849      	bhi.n	8027ffc <NVMS_WriteDataWithType+0xb0>
  {
    return NVMS_SLOT_INVALID;
  }

  /* Checking for immediately available space */
  free = NVMS_LL_GetBlockSize() - (nvm.free_next->hdr8 -
 8027f68:	4926      	ldr	r1, [pc, #152]	; (8028004 <NVMS_WriteDataWithType+0xb8>)
 8027f6a:	22d0      	movs	r2, #208	; 0xd0
 8027f6c:	588a      	ldr	r2, [r1, r2]
 8027f6e:	1ad3      	subs	r3, r2, r3
 8027f70:	2280      	movs	r2, #128	; 0x80
 8027f72:	0112      	lsls	r2, r2, #4
 8027f74:	1ad3      	subs	r3, r2, r3

  /* If the requested space is out of the compacted block size then an error is returned.
   * NOTE: The space for one header is reserved in order to allow for a
   * data erase operation after the space has been fully allocated.
   */
  if ((sizeof(nvms_data_header_t) + size) > (NVMS_LL_GetBlockSize() -
 8027f76:	0030      	movs	r0, r6
 8027f78:	3020      	adds	r0, #32
                                             nvm.used_size -
 8027f7a:	22d4      	movs	r2, #212	; 0xd4
 8027f7c:	5889      	ldr	r1, [r1, r2]
 8027f7e:	22fc      	movs	r2, #252	; 0xfc
 8027f80:	00d2      	lsls	r2, r2, #3
 8027f82:	1a52      	subs	r2, r2, r1
  if ((sizeof(nvms_data_header_t) + size) > (NVMS_LL_GetBlockSize() -
 8027f84:	4290      	cmp	r0, r2
 8027f86:	d83b      	bhi.n	8028000 <NVMS_WriteDataWithType+0xb4>
    return NVMS_OUT_OF_MEM;
  }

  /* This is the condition where we need to compact the current block in
     order to obtain enough space for the new data instance */
  if ((sizeof(nvms_data_header_t) + size) > free)
 8027f88:	4298      	cmp	r0, r3
 8027f8a:	d829      	bhi.n	8027fe0 <NVMS_WriteDataWithType+0x94>
  bool warning = false;
 8027f8c:	2300      	movs	r3, #0
 8027f8e:	4699      	mov	r9, r3
      return err;
    }
  }

  /* Index for the new data */
  if (nvm.slots[slot] == NULL)
 8027f90:	1ca3      	adds	r3, r4, #2
 8027f92:	009b      	lsls	r3, r3, #2
 8027f94:	4a1b      	ldr	r2, [pc, #108]	; (8028004 <NVMS_WriteDataWithType+0xb8>)
 8027f96:	589f      	ldr	r7, [r3, r2]
 8027f98:	2f00      	cmp	r7, #0
 8027f9a:	d028      	beq.n	8027fee <NVMS_WriteDataWithType+0xa2>
    instance = 1;
    oldused = 0;
  }
  else
  {
    instance = nvm.slots[slot]->fields.instance + 1UL;
 8027f9c:	68fb      	ldr	r3, [r7, #12]
 8027f9e:	3301      	adds	r3, #1
    oldused = (uint32_t)(nvm.slots[slot]->fields.next->hdr8) - (uint32_t)(nvm.slots[slot]->hdr8);
 8027fa0:	693a      	ldr	r2, [r7, #16]
 8027fa2:	1bd7      	subs	r7, r2, r7
  }

  /* Position of the new data instance */
  hdrp = nvm.free_next;
 8027fa4:	4917      	ldr	r1, [pc, #92]	; (8028004 <NVMS_WriteDataWithType+0xb8>)
 8027fa6:	22d0      	movs	r2, #208	; 0xd0
 8027fa8:	588d      	ldr	r5, [r1, r2]

  /* Writing the new instance */
  err = append_slot(slot, size, type, slotp, instance);
 8027faa:	9300      	str	r3, [sp, #0]
 8027fac:	9b03      	ldr	r3, [sp, #12]
 8027fae:	9a02      	ldr	r2, [sp, #8]
 8027fb0:	0031      	movs	r1, r6
 8027fb2:	0020      	movs	r0, r4
 8027fb4:	f7ff fd42 	bl	8027a3c <append_slot>
  if (err != NVMS_NOERROR)
 8027fb8:	2800      	cmp	r0, #0
 8027fba:	d10d      	bne.n	8027fd8 <NVMS_WriteDataWithType+0x8c>
  {
    return err;
  }

  /* Adjusting the counter of the effective used size */
  nvm.slots[slot]  = hdrp;
 8027fbc:	4b11      	ldr	r3, [pc, #68]	; (8028004 <NVMS_WriteDataWithType+0xb8>)
 8027fbe:	3402      	adds	r4, #2
 8027fc0:	00a4      	lsls	r4, r4, #2
 8027fc2:	50e5      	str	r5, [r4, r3]
  nvm.used_size -= oldused;
 8027fc4:	21d4      	movs	r1, #212	; 0xd4
 8027fc6:	585a      	ldr	r2, [r3, r1]
 8027fc8:	1bd7      	subs	r7, r2, r7
  nvm.used_size += nvm.slots[slot]->fields.next->hdr8 - nvm.slots[slot]->hdr8;
 8027fca:	692a      	ldr	r2, [r5, #16]
 8027fcc:	1b52      	subs	r2, r2, r5
 8027fce:	18bf      	adds	r7, r7, r2
 8027fd0:	505f      	str	r7, [r3, r1]

  return warning ? NVMS_WARNING : NVMS_NOERROR;
 8027fd2:	464b      	mov	r3, r9
 8027fd4:	2b00      	cmp	r3, #0
 8027fd6:	d10d      	bne.n	8027ff4 <NVMS_WriteDataWithType+0xa8>
}
 8027fd8:	b004      	add	sp, #16
 8027fda:	bc80      	pop	{r7}
 8027fdc:	46b9      	mov	r9, r7
 8027fde:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = garbage_collect();
 8027fe0:	f7ff ff6a 	bl	8027eb8 <garbage_collect>
    if (err != NVMS_NOERROR)
 8027fe4:	2800      	cmp	r0, #0
 8027fe6:	d1f7      	bne.n	8027fd8 <NVMS_WriteDataWithType+0x8c>
    warning = true;
 8027fe8:	2301      	movs	r3, #1
 8027fea:	4699      	mov	r9, r3
 8027fec:	e7d0      	b.n	8027f90 <NVMS_WriteDataWithType+0x44>
    oldused = 0;
 8027fee:	2700      	movs	r7, #0
    instance = 1;
 8027ff0:	2301      	movs	r3, #1
 8027ff2:	e7d7      	b.n	8027fa4 <NVMS_WriteDataWithType+0x58>
  return warning ? NVMS_WARNING : NVMS_NOERROR;
 8027ff4:	3002      	adds	r0, #2
 8027ff6:	e7ef      	b.n	8027fd8 <NVMS_WriteDataWithType+0x8c>
    return NVMS_NOTINIT;
 8027ff8:	2001      	movs	r0, #1
 8027ffa:	e7ed      	b.n	8027fd8 <NVMS_WriteDataWithType+0x8c>
    return NVMS_SLOT_INVALID;
 8027ffc:	2004      	movs	r0, #4
 8027ffe:	e7eb      	b.n	8027fd8 <NVMS_WriteDataWithType+0x8c>
    return NVMS_OUT_OF_MEM;
 8028000:	2007      	movs	r0, #7
 8028002:	e7e9      	b.n	8027fd8 <NVMS_WriteDataWithType+0x8c>
 8028004:	2000a22c 	.word	0x2000a22c

08028008 <NVMS_EraseData>:
  *                             failures.
  * @retval NVMS_DATA_NOT_FOUND if the data does not exists.
  * @retval NVMS_INTERNAL       if an internal error occurred.
  */
nvms_error_t NVMS_EraseData(nvms_slot_t slot)
{
 8028008:	b5f0      	push	{r4, r5, r6, r7, lr}
 802800a:	b083      	sub	sp, #12
 802800c:	0004      	movs	r4, r0
  return nvm.header != NULL;
 802800e:	4b24      	ldr	r3, [pc, #144]	; (80280a0 <NVMS_EraseData+0x98>)
 8028010:	681a      	ldr	r2, [r3, #0]
  size_t free;
  size_t oldused;
  nvms_error_t err;

  /* Check on initialization */
  if (!is_initialized())
 8028012:	2a00      	cmp	r2, #0
 8028014:	d03b      	beq.n	802808e <NVMS_EraseData+0x86>
  {
    return NVMS_NOTINIT;
  }

  /* Check on the slot identifier */
  if (slot >= NVMS_CFG_NUM_SLOTS)
 8028016:	2831      	cmp	r0, #49	; 0x31
 8028018:	d83c      	bhi.n	8028094 <NVMS_EraseData+0x8c>
  {
    return NVMS_SLOT_INVALID;
  }

  /* Check slot presence */
  if (nvm.slots[slot] == NULL)
 802801a:	1c83      	adds	r3, r0, #2
 802801c:	009b      	lsls	r3, r3, #2
 802801e:	4920      	ldr	r1, [pc, #128]	; (80280a0 <NVMS_EraseData+0x98>)
 8028020:	585b      	ldr	r3, [r3, r1]
 8028022:	2b00      	cmp	r3, #0
 8028024:	d038      	beq.n	8028098 <NVMS_EraseData+0x90>
  {
    return NVMS_DATA_NOT_FOUND;
  }

  /* Checking for immediately available space */
  free = NVMS_LL_GetBlockSize() - (nvm.free_next->hdr8 -
 8028026:	23d0      	movs	r3, #208	; 0xd0
 8028028:	58cb      	ldr	r3, [r1, r3]
 802802a:	1a9b      	subs	r3, r3, r2
 802802c:	2280      	movs	r2, #128	; 0x80
 802802e:	0112      	lsls	r2, r2, #4
 8028030:	1ad3      	subs	r3, r2, r3

  /* If the requested space is out of the compacted block size then an
     error is returned.
     NOTE: This condition SHOULD NEVER HAPPEN because the slot write operation
     makes sure to leave to leave enough space for an erase operation */
  if (sizeof(nvms_data_header_t) > (NVMS_LL_GetBlockSize() - nvm.used_size))
 8028032:	20d4      	movs	r0, #212	; 0xd4
 8028034:	5809      	ldr	r1, [r1, r0]
 8028036:	1a52      	subs	r2, r2, r1
 8028038:	2a1f      	cmp	r2, #31
 802803a:	d92f      	bls.n	802809c <NVMS_EraseData+0x94>
    return NVMS_INTERNAL;
  }

  /* This is the condition where we need to compact the current block in
     order to obtain enough space for the new slot instance */
  if (sizeof(nvms_data_header_t) > free)
 802803c:	2b1f      	cmp	r3, #31
 802803e:	d805      	bhi.n	802804c <NVMS_EraseData+0x44>
  {
    warning = true;
    err = garbage_collect();
 8028040:	f7ff ff3a 	bl	8027eb8 <garbage_collect>
    if (err != NVMS_NOERROR)
 8028044:	2800      	cmp	r0, #0
 8028046:	d123      	bne.n	8028090 <NVMS_EraseData+0x88>
    warning = true;
 8028048:	2601      	movs	r6, #1
 802804a:	e000      	b.n	802804e <NVMS_EraseData+0x46>
  bool warning = false;
 802804c:	2600      	movs	r6, #0
      return err;
    }
  }

  /* Index for the new slot */
  instance = nvm.slots[slot]->fields.instance + 1UL;
 802804e:	1ca3      	adds	r3, r4, #2
 8028050:	009b      	lsls	r3, r3, #2
 8028052:	4a13      	ldr	r2, [pc, #76]	; (80280a0 <NVMS_EraseData+0x98>)
 8028054:	589d      	ldr	r5, [r3, r2]
 8028056:	68eb      	ldr	r3, [r5, #12]
 8028058:	3301      	adds	r3, #1
  oldused = (uint32_t)(nvm.slots[slot]->fields.next->hdr8) - (uint32_t)(nvm.slots[slot]->hdr8);
 802805a:	692f      	ldr	r7, [r5, #16]

  /* Writing the new instance */
  err = append_slot(slot, 0, NVMS_DATA_TYPE_DEFAULT, NULL, instance);
 802805c:	2201      	movs	r2, #1
 802805e:	9300      	str	r3, [sp, #0]
 8028060:	2300      	movs	r3, #0
 8028062:	4252      	negs	r2, r2
 8028064:	2100      	movs	r1, #0
 8028066:	0020      	movs	r0, r4
 8028068:	f7ff fce8 	bl	8027a3c <append_slot>
  if (err != NVMS_NOERROR)
 802806c:	2800      	cmp	r0, #0
 802806e:	d10f      	bne.n	8028090 <NVMS_EraseData+0x88>
  {
    return err;
  }

  /* Adjusting the counter of the effective used size */
  nvm.slots[slot]  = NULL;
 8028070:	4b0b      	ldr	r3, [pc, #44]	; (80280a0 <NVMS_EraseData+0x98>)
 8028072:	3402      	adds	r4, #2
 8028074:	00a4      	lsls	r4, r4, #2
 8028076:	2200      	movs	r2, #0
 8028078:	50e2      	str	r2, [r4, r3]
  nvm.used_size -= oldused;
 802807a:	32d4      	adds	r2, #212	; 0xd4
 802807c:	1bed      	subs	r5, r5, r7
 802807e:	5899      	ldr	r1, [r3, r2]
 8028080:	468c      	mov	ip, r1
 8028082:	4465      	add	r5, ip
 8028084:	509d      	str	r5, [r3, r2]

  return warning ? NVMS_WARNING : NVMS_NOERROR;
 8028086:	2e00      	cmp	r6, #0
 8028088:	d002      	beq.n	8028090 <NVMS_EraseData+0x88>
 802808a:	3002      	adds	r0, #2
 802808c:	e000      	b.n	8028090 <NVMS_EraseData+0x88>
    return NVMS_NOTINIT;
 802808e:	2001      	movs	r0, #1
}
 8028090:	b003      	add	sp, #12
 8028092:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NVMS_SLOT_INVALID;
 8028094:	2004      	movs	r0, #4
 8028096:	e7fb      	b.n	8028090 <NVMS_EraseData+0x88>
    return NVMS_DATA_NOT_FOUND;
 8028098:	2005      	movs	r0, #5
 802809a:	e7f9      	b.n	8028090 <NVMS_EraseData+0x88>
    return NVMS_INTERNAL;
 802809c:	2008      	movs	r0, #8
 802809e:	e7f7      	b.n	8028090 <NVMS_EraseData+0x88>
 80280a0:	2000a22c 	.word	0x2000a22c

080280a4 <NVMS_GetDataWithType>:
  * @retval NVMS_SLOT_INVALID   if the slot number is out of range.
  * @retval NVMS_DATA_NOT_FOUND if the data does not exists.
  */
nvms_error_t NVMS_GetDataWithType(nvms_slot_t slot, size_t *size_p, nvms_data_type_t *type_p,
                                  uint8_t **data_pp)
{
 80280a4:	b530      	push	{r4, r5, lr}
  return nvm.header != NULL;
 80280a6:	4c15      	ldr	r4, [pc, #84]	; (80280fc <NVMS_GetDataWithType+0x58>)
 80280a8:	6824      	ldr	r4, [r4, #0]
  /* Check on initialization */
  if (!is_initialized())
 80280aa:	2c00      	cmp	r4, #0
 80280ac:	d01d      	beq.n	80280ea <NVMS_GetDataWithType+0x46>
  {
    return NVMS_NOTINIT;
  }

  /* Check on the slot identifier */
  if (slot >= NVMS_CFG_NUM_SLOTS)
 80280ae:	2831      	cmp	r0, #49	; 0x31
 80280b0:	d81d      	bhi.n	80280ee <NVMS_GetDataWithType+0x4a>
  {
    return NVMS_SLOT_INVALID;
  }

  /* Check slot presence */
  if (nvm.slots[slot] == NULL)
 80280b2:	1c84      	adds	r4, r0, #2
 80280b4:	00a4      	lsls	r4, r4, #2
 80280b6:	4d11      	ldr	r5, [pc, #68]	; (80280fc <NVMS_GetDataWithType+0x58>)
 80280b8:	5964      	ldr	r4, [r4, r5]
 80280ba:	2c00      	cmp	r4, #0
 80280bc:	d019      	beq.n	80280f2 <NVMS_GetDataWithType+0x4e>
  {
    return NVMS_DATA_NOT_FOUND;
  }

  if (size_p != NULL)
 80280be:	2900      	cmp	r1, #0
 80280c0:	d001      	beq.n	80280c6 <NVMS_GetDataWithType+0x22>
  {
    *size_p = nvm.slots[slot]->fields.data_size;
 80280c2:	69a4      	ldr	r4, [r4, #24]
 80280c4:	600c      	str	r4, [r1, #0]
  }

  if (type_p != NULL)
 80280c6:	2a00      	cmp	r2, #0
 80280c8:	d005      	beq.n	80280d6 <NVMS_GetDataWithType+0x32>
  {
    *type_p = nvm.slots[slot]->fields.data_type;
 80280ca:	1c81      	adds	r1, r0, #2
 80280cc:	0089      	lsls	r1, r1, #2
 80280ce:	4c0b      	ldr	r4, [pc, #44]	; (80280fc <NVMS_GetDataWithType+0x58>)
 80280d0:	5909      	ldr	r1, [r1, r4]
 80280d2:	6949      	ldr	r1, [r1, #20]
 80280d4:	6011      	str	r1, [r2, #0]
  }

  if (data_pp != NULL)
 80280d6:	2b00      	cmp	r3, #0
 80280d8:	d00d      	beq.n	80280f6 <NVMS_GetDataWithType+0x52>
  {
    *data_pp = nvm.slots[slot]->hdr8 + sizeof(nvms_data_header_t);
 80280da:	3002      	adds	r0, #2
 80280dc:	0080      	lsls	r0, r0, #2
 80280de:	4a07      	ldr	r2, [pc, #28]	; (80280fc <NVMS_GetDataWithType+0x58>)
 80280e0:	5882      	ldr	r2, [r0, r2]
 80280e2:	3220      	adds	r2, #32
 80280e4:	601a      	str	r2, [r3, #0]
  }

  return NVMS_NOERROR;
 80280e6:	2000      	movs	r0, #0
}
 80280e8:	bd30      	pop	{r4, r5, pc}
    return NVMS_NOTINIT;
 80280ea:	2001      	movs	r0, #1
 80280ec:	e7fc      	b.n	80280e8 <NVMS_GetDataWithType+0x44>
    return NVMS_SLOT_INVALID;
 80280ee:	2004      	movs	r0, #4
 80280f0:	e7fa      	b.n	80280e8 <NVMS_GetDataWithType+0x44>
    return NVMS_DATA_NOT_FOUND;
 80280f2:	2005      	movs	r0, #5
 80280f4:	e7f8      	b.n	80280e8 <NVMS_GetDataWithType+0x44>
  return NVMS_NOERROR;
 80280f6:	2000      	movs	r0, #0
 80280f8:	e7f6      	b.n	80280e8 <NVMS_GetDataWithType+0x44>
 80280fa:	46c0      	nop			; (mov r8, r8)
 80280fc:	2000a22c 	.word	0x2000a22c

08028100 <KMS_Objects_GetRange>:
  * @brief  This function returns object range identification from key handle
  * @param  hKey key handle
  * @retval Value within @ref kms_obj_range_t
  */
kms_obj_range_t  KMS_Objects_GetRange(CK_OBJECT_HANDLE hKey)
{
 8028100:	b510      	push	{r4, lr}
 8028102:	b082      	sub	sp, #8
 8028104:	0004      	movs	r4, r0
  uint32_t MinSlot;
  uint32_t MaxSlot;

  /* Read the available static slots from the platform */
  KMS_PlatfObjects_EmbeddedRange(&MinSlot, &MaxSlot);
 8028106:	4669      	mov	r1, sp
 8028108:	a801      	add	r0, sp, #4
 802810a:	f000 fb2f 	bl	802876c <KMS_PlatfObjects_EmbeddedRange>
  /* If hKey is in the range of the embedded keys */
  if ((hKey <= MaxSlot) && (hKey >= MinSlot))
 802810e:	9b00      	ldr	r3, [sp, #0]
 8028110:	42a3      	cmp	r3, r4
 8028112:	d302      	bcc.n	802811a <KMS_Objects_GetRange+0x1a>
 8028114:	9b01      	ldr	r3, [sp, #4]
 8028116:	42a3      	cmp	r3, r4
 8028118:	d916      	bls.n	8028148 <KMS_Objects_GetRange+0x48>
    return (KMS_OBJECT_RANGE_EMBEDDED);
  }

#ifdef KMS_NVM_ENABLED
  /* Read the available nvm slots from the platform */
  KMS_PlatfObjects_NvmStaticRange(&MinSlot, &MaxSlot);
 802811a:	4669      	mov	r1, sp
 802811c:	a801      	add	r0, sp, #4
 802811e:	f000 fb33 	bl	8028788 <KMS_PlatfObjects_NvmStaticRange>
  /* If hKey is in the range of nvm keys */
  if ((hKey <= MaxSlot) && (hKey >= MinSlot))
 8028122:	9b00      	ldr	r3, [sp, #0]
 8028124:	42a3      	cmp	r3, r4
 8028126:	d302      	bcc.n	802812e <KMS_Objects_GetRange+0x2e>
 8028128:	9b01      	ldr	r3, [sp, #4]
 802812a:	42a3      	cmp	r3, r4
 802812c:	d90e      	bls.n	802814c <KMS_Objects_GetRange+0x4c>
    return (KMS_OBJECT_RANGE_NVM_STATIC_ID);
  }

#ifdef KMS_NVM_DYNAMIC_ENABLED
  /* Read the available nvm slots from the platform */
  KMS_PlatfObjects_NvmDynamicRange(&MinSlot, &MaxSlot);
 802812e:	4669      	mov	r1, sp
 8028130:	a801      	add	r0, sp, #4
 8028132:	f000 fb37 	bl	80287a4 <KMS_PlatfObjects_NvmDynamicRange>
  /* If hKey is in the range of nvm keys */
  if ((hKey <= MaxSlot) && (hKey >= MinSlot))
 8028136:	9b00      	ldr	r3, [sp, #0]
 8028138:	42a3      	cmp	r3, r4
 802813a:	d309      	bcc.n	8028150 <KMS_Objects_GetRange+0x50>
 802813c:	9b01      	ldr	r3, [sp, #4]
 802813e:	42a3      	cmp	r3, r4
 8028140:	d908      	bls.n	8028154 <KMS_Objects_GetRange+0x54>
    return (KMS_OBJECT_RANGE_EXT_TOKEN_DYNAMIC_ID);
  }
#endif  /* KMS_EXT_TOKEN_ENABLED */

  /* hKey not in known ranges */
  return KMS_OBJECT_RANGE_UNKNOWN;
 8028142:	2006      	movs	r0, #6
}
 8028144:	b002      	add	sp, #8
 8028146:	bd10      	pop	{r4, pc}
    return (KMS_OBJECT_RANGE_EMBEDDED);
 8028148:	2000      	movs	r0, #0
 802814a:	e7fb      	b.n	8028144 <KMS_Objects_GetRange+0x44>
    return (KMS_OBJECT_RANGE_NVM_STATIC_ID);
 802814c:	2001      	movs	r0, #1
 802814e:	e7f9      	b.n	8028144 <KMS_Objects_GetRange+0x44>
  return KMS_OBJECT_RANGE_UNKNOWN;
 8028150:	2006      	movs	r0, #6
 8028152:	e7f7      	b.n	8028144 <KMS_Objects_GetRange+0x44>
    return (KMS_OBJECT_RANGE_NVM_DYNAMIC_ID);
 8028154:	2002      	movs	r0, #2
 8028156:	e7f5      	b.n	8028144 <KMS_Objects_GetRange+0x44>

08028158 <KMS_CheckKeyIsNotLocked>:
  }
  return e_ret_status;
#else /* KMS_SE_LOCK_KEYS */
  return CKR_OK;
#endif /* KMS_SE_LOCK_KEYS */
}
 8028158:	2000      	movs	r0, #0
 802815a:	4770      	bx	lr

0802815c <KMS_Objects_GetPointer>:
{
 802815c:	b570      	push	{r4, r5, r6, lr}
 802815e:	b082      	sub	sp, #8
 8028160:	0004      	movs	r4, r0
  if (KMS_CheckKeyIsNotLocked(hKey) == CKR_OK)
 8028162:	f7ff fff9 	bl	8028158 <KMS_CheckKeyIsNotLocked>
 8028166:	1e05      	subs	r5, r0, #0
 8028168:	d005      	beq.n	8028176 <KMS_Objects_GetPointer+0x1a>
  kms_obj_keyhead_t *p_object = NULL;
 802816a:	2600      	movs	r6, #0
  if (KMS_CheckKeyIsNotLocked(hKey) == CKR_OK)
 802816c:	2d00      	cmp	r5, #0
 802816e:	d132      	bne.n	80281d6 <KMS_Objects_GetPointer+0x7a>
}
 8028170:	0030      	movs	r0, r6
 8028172:	b002      	add	sp, #8
 8028174:	bd70      	pop	{r4, r5, r6, pc}
    KMS_PlatfObjects_EmbeddedRange(&min_slot, &max_slot);
 8028176:	4669      	mov	r1, sp
 8028178:	a801      	add	r0, sp, #4
 802817a:	f000 faf7 	bl	802876c <KMS_PlatfObjects_EmbeddedRange>
    if ((hKey <= max_slot) && (hKey >= min_slot))
 802817e:	9b00      	ldr	r3, [sp, #0]
 8028180:	42a3      	cmp	r3, r4
 8028182:	d309      	bcc.n	8028198 <KMS_Objects_GetPointer+0x3c>
 8028184:	9b01      	ldr	r3, [sp, #4]
 8028186:	42a3      	cmp	r3, r4
 8028188:	d901      	bls.n	802818e <KMS_Objects_GetPointer+0x32>
  kms_obj_keyhead_t *p_object = NULL;
 802818a:	2600      	movs	r6, #0
 802818c:	e005      	b.n	802819a <KMS_Objects_GetPointer+0x3e>
      p_object = KMS_PlatfObjects_EmbeddedObject(hKey);
 802818e:	0020      	movs	r0, r4
 8028190:	f000 faf2 	bl	8028778 <KMS_PlatfObjects_EmbeddedObject>
 8028194:	0006      	movs	r6, r0
 8028196:	e000      	b.n	802819a <KMS_Objects_GetPointer+0x3e>
  kms_obj_keyhead_t *p_object = NULL;
 8028198:	2600      	movs	r6, #0
    KMS_PlatfObjects_NvmStaticRange(&min_slot, &max_slot);
 802819a:	4669      	mov	r1, sp
 802819c:	a801      	add	r0, sp, #4
 802819e:	f000 faf3 	bl	8028788 <KMS_PlatfObjects_NvmStaticRange>
    if ((hKey <= max_slot) && (hKey >= min_slot))
 80281a2:	9b00      	ldr	r3, [sp, #0]
 80281a4:	42a3      	cmp	r3, r4
 80281a6:	d302      	bcc.n	80281ae <KMS_Objects_GetPointer+0x52>
 80281a8:	9b01      	ldr	r3, [sp, #4]
 80281aa:	42a3      	cmp	r3, r4
 80281ac:	d90e      	bls.n	80281cc <KMS_Objects_GetPointer+0x70>
    KMS_PlatfObjects_NvmDynamicRange(&min_slot, &max_slot);
 80281ae:	4669      	mov	r1, sp
 80281b0:	a801      	add	r0, sp, #4
 80281b2:	f000 faf7 	bl	80287a4 <KMS_PlatfObjects_NvmDynamicRange>
    if ((hKey <= max_slot) && (hKey >= min_slot))
 80281b6:	9b00      	ldr	r3, [sp, #0]
 80281b8:	42a3      	cmp	r3, r4
 80281ba:	d3d7      	bcc.n	802816c <KMS_Objects_GetPointer+0x10>
 80281bc:	9b01      	ldr	r3, [sp, #4]
 80281be:	42a3      	cmp	r3, r4
 80281c0:	d8d4      	bhi.n	802816c <KMS_Objects_GetPointer+0x10>
      p_object = KMS_PlatfObjects_NvmDynamicObject(hKey);
 80281c2:	0020      	movs	r0, r4
 80281c4:	f000 faf4 	bl	80287b0 <KMS_PlatfObjects_NvmDynamicObject>
 80281c8:	0006      	movs	r6, r0
 80281ca:	e7cf      	b.n	802816c <KMS_Objects_GetPointer+0x10>
      p_object = KMS_PlatfObjects_NvmStaticObject(hKey);
 80281cc:	0020      	movs	r0, r4
 80281ce:	f000 fae1 	bl	8028794 <KMS_PlatfObjects_NvmStaticObject>
 80281d2:	0006      	movs	r6, r0
 80281d4:	e7eb      	b.n	80281ae <KMS_Objects_GetPointer+0x52>
    return NULL;
 80281d6:	2600      	movs	r6, #0
 80281d8:	e7ca      	b.n	8028170 <KMS_Objects_GetPointer+0x14>

080281da <KMS_FindAttributeInTemplate>:
  *         CKR_ARGUMENTS_BAD
  *         CKR_GENERAL_ERROR
  */
CK_RV KMS_FindAttributeInTemplate(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount, CK_ATTRIBUTE_TYPE type,
                                  CK_ATTRIBUTE_PTR *ppAttr)
{
 80281da:	b570      	push	{r4, r5, r6, lr}
  CK_RV e_ret_status = CKR_GENERAL_ERROR;
  if ((pTemplate == NULL_PTR) || (ulCount == 0UL) || (ppAttr == NULL_PTR))
 80281dc:	2800      	cmp	r0, #0
 80281de:	d014      	beq.n	802820a <KMS_FindAttributeInTemplate+0x30>
 80281e0:	2900      	cmp	r1, #0
 80281e2:	d014      	beq.n	802820e <KMS_FindAttributeInTemplate+0x34>
 80281e4:	2b00      	cmp	r3, #0
 80281e6:	d014      	beq.n	8028212 <KMS_FindAttributeInTemplate+0x38>
    e_ret_status = CKR_ARGUMENTS_BAD;
  }
  else
  {
    /* Search within template attributes the given attribute type */
    for (uint32_t i = 0; i < ulCount; i++)
 80281e8:	2500      	movs	r5, #0
 80281ea:	428d      	cmp	r5, r1
 80281ec:	d20b      	bcs.n	8028206 <KMS_FindAttributeInTemplate+0x2c>
    {
      if (pTemplate[i].type == type)
 80281ee:	006c      	lsls	r4, r5, #1
 80281f0:	1964      	adds	r4, r4, r5
 80281f2:	00a4      	lsls	r4, r4, #2
 80281f4:	1904      	adds	r4, r0, r4
 80281f6:	6826      	ldr	r6, [r4, #0]
 80281f8:	4296      	cmp	r6, r2
 80281fa:	d001      	beq.n	8028200 <KMS_FindAttributeInTemplate+0x26>
    for (uint32_t i = 0; i < ulCount; i++)
 80281fc:	3501      	adds	r5, #1
 80281fe:	e7f4      	b.n	80281ea <KMS_FindAttributeInTemplate+0x10>
      {
        *ppAttr = &(pTemplate[i]);
 8028200:	601c      	str	r4, [r3, #0]
        e_ret_status = CKR_OK;
 8028202:	2000      	movs	r0, #0
        break;
 8028204:	e004      	b.n	8028210 <KMS_FindAttributeInTemplate+0x36>
  CK_RV e_ret_status = CKR_GENERAL_ERROR;
 8028206:	2005      	movs	r0, #5
 8028208:	e002      	b.n	8028210 <KMS_FindAttributeInTemplate+0x36>
    e_ret_status = CKR_ARGUMENTS_BAD;
 802820a:	2007      	movs	r0, #7
 802820c:	e000      	b.n	8028210 <KMS_FindAttributeInTemplate+0x36>
 802820e:	2007      	movs	r0, #7
      }
    }
  }
  return e_ret_status;
}
 8028210:	bd70      	pop	{r4, r5, r6, pc}
    e_ret_status = CKR_ARGUMENTS_BAD;
 8028212:	2007      	movs	r0, #7
  return e_ret_status;
 8028214:	e7fc      	b.n	8028210 <KMS_FindAttributeInTemplate+0x36>

08028216 <KMS_Objects_SearchAttributes>:
  * @param  pAttribute found attribute
  * @retval CKR_OK if attribute is found
  *         CKR_ATTRIBUTE_TYPE_INVALID otherwise
  */
CK_RV KMS_Objects_SearchAttributes(uint32_t SearchedId, kms_obj_keyhead_t *pKmsKeyHead, kms_attr_t **pAttribute)
{
 8028216:	b570      	push	{r4, r5, r6, lr}
  CK_RV e_ret_status = CKR_ATTRIBUTE_TYPE_INVALID;
  kms_attr_t *pkms_blob_current = (kms_attr_t *)(uint32_t)(pKmsKeyHead->blobs);
 8028218:	000c      	movs	r4, r1
 802821a:	3414      	adds	r4, #20
  uint8_t  *pkms_blob;
  uint32_t blob_index;
  uint32_t current_attribute_size;

  /* The blob containing the attributes is described by the kms_obj_keyhead_t */
  for (blob_index = 0; blob_index < pKmsKeyHead->blobs_count; blob_index++)
 802821c:	2500      	movs	r5, #0
 802821e:	e005      	b.n	802822c <KMS_Objects_SearchAttributes+0x16>
  {
    /* Parse the attributes from the blob to find the id */
    if (pkms_blob_current->id == SearchedId)
    {
      *pAttribute = pkms_blob_current;
 8028220:	6014      	str	r4, [r2, #0]

      /* ID is found */
      e_ret_status = CKR_OK;
 8028222:	2000      	movs	r0, #0
      break;
 8028224:	e010      	b.n	8028248 <KMS_Objects_SearchAttributes+0x32>
    {
      current_attribute_size += 4UL - (current_attribute_size % 4UL);
    }

    /* Point to next attribute */
    pkms_blob = &((uint8_t *)pkms_blob_current)[4UL + 4UL + current_attribute_size];
 8028226:	3308      	adds	r3, #8
 8028228:	18e4      	adds	r4, r4, r3
  for (blob_index = 0; blob_index < pKmsKeyHead->blobs_count; blob_index++)
 802822a:	3501      	adds	r5, #1
 802822c:	68cb      	ldr	r3, [r1, #12]
 802822e:	42ab      	cmp	r3, r5
 8028230:	d909      	bls.n	8028246 <KMS_Objects_SearchAttributes+0x30>
    if (pkms_blob_current->id == SearchedId)
 8028232:	6823      	ldr	r3, [r4, #0]
 8028234:	4283      	cmp	r3, r0
 8028236:	d0f3      	beq.n	8028220 <KMS_Objects_SearchAttributes+0xa>
    current_attribute_size = pkms_blob_current->size ;
 8028238:	6863      	ldr	r3, [r4, #4]
    if ((current_attribute_size % 4UL) != 0UL)
 802823a:	079e      	lsls	r6, r3, #30
 802823c:	d0f3      	beq.n	8028226 <KMS_Objects_SearchAttributes+0x10>
      current_attribute_size += 4UL - (current_attribute_size % 4UL);
 802823e:	2603      	movs	r6, #3
 8028240:	43b3      	bics	r3, r6
 8028242:	3304      	adds	r3, #4
 8028244:	e7ef      	b.n	8028226 <KMS_Objects_SearchAttributes+0x10>
  CK_RV e_ret_status = CKR_ATTRIBUTE_TYPE_INVALID;
 8028246:	2012      	movs	r0, #18

    /* Point to the next Attribute */
    pkms_blob_current = (kms_attr_t *)(uint32_t)pkms_blob;
  }
  return e_ret_status;
}
 8028248:	bd70      	pop	{r4, r5, r6, pc}

0802824a <KMS_FindObjectsFromTemplate>:
{
 802824a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802824c:	46de      	mov	lr, fp
 802824e:	4657      	mov	r7, sl
 8028250:	464e      	mov	r6, r9
 8028252:	4645      	mov	r5, r8
 8028254:	b5e0      	push	{r5, r6, r7, lr}
 8028256:	b08d      	sub	sp, #52	; 0x34
 8028258:	9102      	str	r1, [sp, #8]
 802825a:	4693      	mov	fp, r2
 802825c:	001f      	movs	r7, r3
 802825e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8028260:	469a      	mov	sl, r3
  *p_working_obj_count = 0;
 8028262:	2300      	movs	r3, #0
 8028264:	603b      	str	r3, [r7, #0]
  KMS_PlatfObjects_EmbeddedRange(&h_emb_obj_min, &h_emb_obj_max);
 8028266:	a909      	add	r1, sp, #36	; 0x24
 8028268:	a80a      	add	r0, sp, #40	; 0x28
 802826a:	f000 fa7f 	bl	802876c <KMS_PlatfObjects_EmbeddedRange>
  KMS_PlatfObjects_NvmStaticRange(&h_nvms_obj_min, &h_nvms_obj_max);
 802826e:	a907      	add	r1, sp, #28
 8028270:	a808      	add	r0, sp, #32
 8028272:	f000 fa89 	bl	8028788 <KMS_PlatfObjects_NvmStaticRange>
  KMS_PlatfObjects_NvmDynamicRange(&h_nvmd_obj_min, &h_nvmd_obj_max);
 8028276:	a905      	add	r1, sp, #20
 8028278:	a806      	add	r0, sp, #24
 802827a:	f000 fa93 	bl	80287a4 <KMS_PlatfObjects_NvmDynamicRange>
  h_object = h_emb_obj_min;
 802827e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  state = KMS_OBJECT_RANGE_EMBEDDED;
 8028280:	2300      	movs	r3, #0
 8028282:	4698      	mov	r8, r3
  CK_RV e_ret_status = CKR_OK;
 8028284:	9301      	str	r3, [sp, #4]
  while ((*p_working_obj_count < ulMaxCount)
 8028286:	e03d      	b.n	8028304 <KMS_FindObjectsFromTemplate+0xba>
        for (template_index = 0; template_index < ulCount; template_index++)
 8028288:	3501      	adds	r5, #1
 802828a:	42b5      	cmp	r5, r6
 802828c:	d21b      	bcs.n	80282c6 <KMS_FindObjectsFromTemplate+0x7c>
          if (KMS_Objects_SearchAttributes(pTemplate[template_index].type, p_pkms_object, &p_attribute) == CKR_OK)
 802828e:	006c      	lsls	r4, r5, #1
 8028290:	1964      	adds	r4, r4, r5
 8028292:	00a4      	lsls	r4, r4, #2
 8028294:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8028296:	469c      	mov	ip, r3
 8028298:	4464      	add	r4, ip
 802829a:	aa0b      	add	r2, sp, #44	; 0x2c
 802829c:	0039      	movs	r1, r7
 802829e:	6820      	ldr	r0, [r4, #0]
 80282a0:	f7ff ffb9 	bl	8028216 <KMS_Objects_SearchAttributes>
 80282a4:	2800      	cmp	r0, #0
 80282a6:	d1ef      	bne.n	8028288 <KMS_FindObjectsFromTemplate+0x3e>
            if ((p_attribute->size == pTemplate[template_index].ulValueLen)
 80282a8:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80282aa:	6842      	ldr	r2, [r0, #4]
 80282ac:	68a3      	ldr	r3, [r4, #8]
 80282ae:	429a      	cmp	r2, r3
 80282b0:	d1ea      	bne.n	8028288 <KMS_FindObjectsFromTemplate+0x3e>
                && (memcmp(p_attribute->data, pTemplate[template_index].pValue, p_attribute->size) == 0))
 80282b2:	3008      	adds	r0, #8
 80282b4:	6861      	ldr	r1, [r4, #4]
 80282b6:	f00c fa1f 	bl	80346f8 <memcmp>
 80282ba:	2800      	cmp	r0, #0
 80282bc:	d1e4      	bne.n	8028288 <KMS_FindObjectsFromTemplate+0x3e>
              ul_attributes_found_count++;
 80282be:	9b03      	ldr	r3, [sp, #12]
 80282c0:	3301      	adds	r3, #1
 80282c2:	9303      	str	r3, [sp, #12]
 80282c4:	e7e0      	b.n	8028288 <KMS_FindObjectsFromTemplate+0x3e>
 80282c6:	4657      	mov	r7, sl
 80282c8:	46b2      	mov	sl, r6
 80282ca:	464e      	mov	r6, r9
        if (ul_attributes_found_count == ulCount)
 80282cc:	9b03      	ldr	r3, [sp, #12]
 80282ce:	4553      	cmp	r3, sl
 80282d0:	d10e      	bne.n	80282f0 <KMS_FindObjectsFromTemplate+0xa6>
          phObject[*p_working_obj_count] = h_object;
 80282d2:	683b      	ldr	r3, [r7, #0]
 80282d4:	009b      	lsls	r3, r3, #2
 80282d6:	9a02      	ldr	r2, [sp, #8]
 80282d8:	50d6      	str	r6, [r2, r3]
          *p_working_obj_count = *p_working_obj_count + 1;
 80282da:	683b      	ldr	r3, [r7, #0]
 80282dc:	3301      	adds	r3, #1
 80282de:	603b      	str	r3, [r7, #0]
 80282e0:	e006      	b.n	80282f0 <KMS_FindObjectsFromTemplate+0xa6>
        phObject[*p_working_obj_count] = h_object;
 80282e2:	683b      	ldr	r3, [r7, #0]
 80282e4:	009b      	lsls	r3, r3, #2
 80282e6:	9a02      	ldr	r2, [sp, #8]
 80282e8:	50d6      	str	r6, [r2, r3]
        *p_working_obj_count = *p_working_obj_count + 1;
 80282ea:	683b      	ldr	r3, [r7, #0]
 80282ec:	3301      	adds	r3, #1
 80282ee:	603b      	str	r3, [r7, #0]
    h_object++;
 80282f0:	3601      	adds	r6, #1
    switch (state)
 80282f2:	4643      	mov	r3, r8
 80282f4:	2b01      	cmp	r3, #1
 80282f6:	d026      	beq.n	8028346 <KMS_FindObjectsFromTemplate+0xfc>
 80282f8:	2b02      	cmp	r3, #2
 80282fa:	d02b      	beq.n	8028354 <KMS_FindObjectsFromTemplate+0x10a>
 80282fc:	2b00      	cmp	r3, #0
 80282fe:	d01b      	beq.n	8028338 <KMS_FindObjectsFromTemplate+0xee>
 8028300:	2305      	movs	r3, #5
 8028302:	9301      	str	r3, [sp, #4]
  while ((*p_working_obj_count < ulMaxCount)
 8028304:	683b      	ldr	r3, [r7, #0]
 8028306:	455b      	cmp	r3, fp
 8028308:	d229      	bcs.n	802835e <KMS_FindObjectsFromTemplate+0x114>
         && (h_object != KMS_HANDLE_KEY_NOT_KNOWN)
 802830a:	2e00      	cmp	r6, #0
 802830c:	d027      	beq.n	802835e <KMS_FindObjectsFromTemplate+0x114>
         && (e_ret_status == CKR_OK))
 802830e:	9b01      	ldr	r3, [sp, #4]
 8028310:	2b00      	cmp	r3, #0
 8028312:	d124      	bne.n	802835e <KMS_FindObjectsFromTemplate+0x114>
    p_pkms_object = KMS_Objects_GetPointer(h_object);
 8028314:	0030      	movs	r0, r6
 8028316:	f7ff ff21 	bl	802815c <KMS_Objects_GetPointer>
    if ((p_pkms_object != NULL) && (e_ret_status == CKR_OK))
 802831a:	2800      	cmp	r0, #0
 802831c:	d0e8      	beq.n	80282f0 <KMS_FindObjectsFromTemplate+0xa6>
      if (ulCount > 0UL)
 802831e:	4653      	mov	r3, sl
 8028320:	2b00      	cmp	r3, #0
 8028322:	d0de      	beq.n	80282e2 <KMS_FindObjectsFromTemplate+0x98>
        for (template_index = 0; template_index < ulCount; template_index++)
 8028324:	9b01      	ldr	r3, [sp, #4]
 8028326:	001d      	movs	r5, r3
        ul_attributes_found_count = 0;
 8028328:	9303      	str	r3, [sp, #12]
 802832a:	4653      	mov	r3, sl
 802832c:	9317      	str	r3, [sp, #92]	; 0x5c
 802832e:	46ba      	mov	sl, r7
 8028330:	0007      	movs	r7, r0
 8028332:	46b1      	mov	r9, r6
 8028334:	001e      	movs	r6, r3
 8028336:	e7a8      	b.n	802828a <KMS_FindObjectsFromTemplate+0x40>
        if (h_object > h_emb_obj_max)
 8028338:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802833a:	42b3      	cmp	r3, r6
 802833c:	d2e2      	bcs.n	8028304 <KMS_FindObjectsFromTemplate+0xba>
          h_object = h_nvms_obj_min;
 802833e:	9e08      	ldr	r6, [sp, #32]
          state = KMS_OBJECT_RANGE_NVM_STATIC_ID;
 8028340:	2301      	movs	r3, #1
 8028342:	4698      	mov	r8, r3
 8028344:	e7de      	b.n	8028304 <KMS_FindObjectsFromTemplate+0xba>
        if (h_object > h_nvms_obj_max)
 8028346:	9b07      	ldr	r3, [sp, #28]
 8028348:	42b3      	cmp	r3, r6
 802834a:	d2db      	bcs.n	8028304 <KMS_FindObjectsFromTemplate+0xba>
          h_object = h_nvmd_obj_min;
 802834c:	9e06      	ldr	r6, [sp, #24]
          state = KMS_OBJECT_RANGE_NVM_DYNAMIC_ID;
 802834e:	2302      	movs	r3, #2
 8028350:	4698      	mov	r8, r3
 8028352:	e7d7      	b.n	8028304 <KMS_FindObjectsFromTemplate+0xba>
        if (h_object > h_nvmd_obj_max)
 8028354:	9b05      	ldr	r3, [sp, #20]
 8028356:	42b3      	cmp	r3, r6
 8028358:	d2d4      	bcs.n	8028304 <KMS_FindObjectsFromTemplate+0xba>
          h_object = KMS_HANDLE_KEY_NOT_KNOWN;
 802835a:	9e01      	ldr	r6, [sp, #4]
 802835c:	e7d2      	b.n	8028304 <KMS_FindObjectsFromTemplate+0xba>
}
 802835e:	2000      	movs	r0, #0
 8028360:	b00d      	add	sp, #52	; 0x34
 8028362:	bcf0      	pop	{r4, r5, r6, r7}
 8028364:	46bb      	mov	fp, r7
 8028366:	46b2      	mov	sl, r6
 8028368:	46a9      	mov	r9, r5
 802836a:	46a0      	mov	r8, r4
 802836c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802836e <KMS_Objects_u8ptr_2_BlobU32>:
  * @param  u8Size u8 buffer size (in bytes)
  * @param  pU32 translated buffer
  * @retval None
  */
void KMS_Objects_u8ptr_2_BlobU32(uint8_t *pU8, uint32_t u8Size, uint32_t *pU32)
{
 802836e:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t index;
  uint32_t reste = u8Size & 0x3UL;
 8028370:	2303      	movs	r3, #3
 8028372:	400b      	ands	r3, r1
 8028374:	469c      	mov	ip, r3
  for (index = 0; index < ((u8Size) / 4UL); index++)
 8028376:	2400      	movs	r4, #0
 8028378:	088b      	lsrs	r3, r1, #2
 802837a:	42a3      	cmp	r3, r4
 802837c:	d90e      	bls.n	802839c <KMS_Objects_u8ptr_2_BlobU32+0x2e>
  {
    pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 24) + \
 802837e:	00a5      	lsls	r5, r4, #2
 8028380:	5d43      	ldrb	r3, [r0, r5]
 8028382:	061b      	lsls	r3, r3, #24
                  ((uint32_t)pU8[(index * 4UL) + 1UL] << 16) + \
 8028384:	1946      	adds	r6, r0, r5
 8028386:	7877      	ldrb	r7, [r6, #1]
 8028388:	043f      	lsls	r7, r7, #16
    pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 24) + \
 802838a:	19db      	adds	r3, r3, r7
                  ((uint32_t)pU8[(index * 4UL) + 2UL] << 8) + \
 802838c:	78b7      	ldrb	r7, [r6, #2]
 802838e:	023f      	lsls	r7, r7, #8
                  ((uint32_t)pU8[(index * 4UL) + 1UL] << 16) + \
 8028390:	19db      	adds	r3, r3, r7
                  ((uint32_t)pU8[(index * 4UL) + 3UL]);
 8028392:	78f6      	ldrb	r6, [r6, #3]
                  ((uint32_t)pU8[(index * 4UL) + 2UL] << 8) + \
 8028394:	199b      	adds	r3, r3, r6
    pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 24) + \
 8028396:	5153      	str	r3, [r2, r5]
  for (index = 0; index < ((u8Size) / 4UL); index++)
 8028398:	3401      	adds	r4, #1
 802839a:	e7ed      	b.n	8028378 <KMS_Objects_u8ptr_2_BlobU32+0xa>
  }
  if (reste != 0UL)     /* check that we have a multiple of 4 bytes */
 802839c:	4663      	mov	r3, ip
 802839e:	2b00      	cmp	r3, #0
 80283a0:	d007      	beq.n	80283b2 <KMS_Objects_u8ptr_2_BlobU32+0x44>
  {
    if (reste == 1UL)
 80283a2:	2b01      	cmp	r3, #1
 80283a4:	d006      	beq.n	80283b4 <KMS_Objects_u8ptr_2_BlobU32+0x46>
      /* One byte remains, convention is as follow:
       *         u8[]  = {0x01}
       *         u32[] = {0x00000001} */
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL]);
    }
    if (reste == 2UL)
 80283a6:	4663      	mov	r3, ip
 80283a8:	2b02      	cmp	r3, #2
 80283aa:	d007      	beq.n	80283bc <KMS_Objects_u8ptr_2_BlobU32+0x4e>
       *         u8[]  = {0x01, 0x02}
       *         u32[] = {0x00000102} */
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 8) + \
                    ((uint32_t)pU8[(index * 4UL) + 1UL]);
    }
    if (reste == 3UL)
 80283ac:	4663      	mov	r3, ip
 80283ae:	2b03      	cmp	r3, #3
 80283b0:	d00c      	beq.n	80283cc <KMS_Objects_u8ptr_2_BlobU32+0x5e>
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
                    ((uint32_t)pU8[(index * 4UL) + 1UL] << 8) + \
                    ((uint32_t)pU8[(index * 4UL) + 2UL]);
    }
  }
}
 80283b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL]);
 80283b4:	00a3      	lsls	r3, r4, #2
 80283b6:	5cc1      	ldrb	r1, [r0, r3]
 80283b8:	50d1      	str	r1, [r2, r3]
 80283ba:	e7f4      	b.n	80283a6 <KMS_Objects_u8ptr_2_BlobU32+0x38>
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 8) + \
 80283bc:	00a1      	lsls	r1, r4, #2
 80283be:	5c43      	ldrb	r3, [r0, r1]
 80283c0:	021b      	lsls	r3, r3, #8
                    ((uint32_t)pU8[(index * 4UL) + 1UL]);
 80283c2:	1845      	adds	r5, r0, r1
 80283c4:	786d      	ldrb	r5, [r5, #1]
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 8) + \
 80283c6:	195b      	adds	r3, r3, r5
 80283c8:	5053      	str	r3, [r2, r1]
 80283ca:	e7ef      	b.n	80283ac <KMS_Objects_u8ptr_2_BlobU32+0x3e>
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
 80283cc:	00a4      	lsls	r4, r4, #2
 80283ce:	5d03      	ldrb	r3, [r0, r4]
 80283d0:	041b      	lsls	r3, r3, #16
                    ((uint32_t)pU8[(index * 4UL) + 1UL] << 8) + \
 80283d2:	1900      	adds	r0, r0, r4
 80283d4:	7841      	ldrb	r1, [r0, #1]
 80283d6:	0209      	lsls	r1, r1, #8
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
 80283d8:	185b      	adds	r3, r3, r1
                    ((uint32_t)pU8[(index * 4UL) + 2UL]);
 80283da:	7881      	ldrb	r1, [r0, #2]
                    ((uint32_t)pU8[(index * 4UL) + 1UL] << 8) + \
 80283dc:	185b      	adds	r3, r3, r1
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
 80283de:	5113      	str	r3, [r2, r4]
}
 80283e0:	e7e7      	b.n	80283b2 <KMS_Objects_u8ptr_2_BlobU32+0x44>

080283e2 <KMS_Objects_BlobU32_2_u8ptr>:
  * @param  u32Size u32 buffer size
  * @param  pU8 translated buffer
  * @retval None
  */
void  KMS_Objects_BlobU32_2_u8ptr(uint32_t *pU32, uint32_t u32Size, uint8_t *pU8)
{
 80283e2:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t index_key;
  uint32_t reste = u32Size & 0x3UL;
 80283e4:	2303      	movs	r3, #3
 80283e6:	400b      	ands	r3, r1
 80283e8:	469c      	mov	ip, r3

  for (index_key = 0; index_key < (u32Size / sizeof(uint32_t)); index_key++)
 80283ea:	2500      	movs	r5, #0
 80283ec:	088b      	lsrs	r3, r1, #2
 80283ee:	42ab      	cmp	r3, r5
 80283f0:	d90f      	bls.n	8028412 <KMS_Objects_BlobU32_2_u8ptr+0x30>
  {
    pU8[(index_key * sizeof(uint32_t))]       = (uint8_t)(pU32[index_key] >> 24);
 80283f2:	00ab      	lsls	r3, r5, #2
 80283f4:	18c4      	adds	r4, r0, r3
 80283f6:	78e6      	ldrb	r6, [r4, #3]
 80283f8:	54d6      	strb	r6, [r2, r3]
    pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key] >> 16);
 80283fa:	1c5e      	adds	r6, r3, #1
 80283fc:	78a7      	ldrb	r7, [r4, #2]
 80283fe:	5597      	strb	r7, [r2, r6]
    pU8[(index_key * sizeof(uint32_t)) + 2UL] = (uint8_t)(pU32[index_key] >> 8);
 8028400:	6826      	ldr	r6, [r4, #0]
 8028402:	0a36      	lsrs	r6, r6, #8
 8028404:	1c9f      	adds	r7, r3, #2
 8028406:	55d6      	strb	r6, [r2, r7]
    pU8[(index_key * sizeof(uint32_t)) + 3UL] = (uint8_t)(pU32[index_key]);
 8028408:	3303      	adds	r3, #3
 802840a:	7824      	ldrb	r4, [r4, #0]
 802840c:	54d4      	strb	r4, [r2, r3]
  for (index_key = 0; index_key < (u32Size / sizeof(uint32_t)); index_key++)
 802840e:	3501      	adds	r5, #1
 8028410:	e7ec      	b.n	80283ec <KMS_Objects_BlobU32_2_u8ptr+0xa>
  }

  if (reste != 0UL)     /* check that we have a multiple of 4 bytes */
 8028412:	4663      	mov	r3, ip
 8028414:	2b00      	cmp	r3, #0
 8028416:	d007      	beq.n	8028428 <KMS_Objects_BlobU32_2_u8ptr+0x46>
  {
    if (reste == 1UL)
 8028418:	2b01      	cmp	r3, #1
 802841a:	d006      	beq.n	802842a <KMS_Objects_BlobU32_2_u8ptr+0x48>
       *         u8[]  = {0x01}
       *         u32[] = {0x00000001} */
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key]);
    }

    if (reste == 2UL)
 802841c:	4663      	mov	r3, ip
 802841e:	2b02      	cmp	r3, #2
 8028420:	d007      	beq.n	8028432 <KMS_Objects_BlobU32_2_u8ptr+0x50>
       *         u32[] = {0x00000102} */
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key] >> 8);
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key]);
    }

    if (reste == 3UL)
 8028422:	4663      	mov	r3, ip
 8028424:	2b03      	cmp	r3, #3
 8028426:	d00d      	beq.n	8028444 <KMS_Objects_BlobU32_2_u8ptr+0x62>
      pU8[(index_key * sizeof(uint32_t))]       = (uint8_t)(pU32[index_key] >> 16);
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key] >> 8);
      pU8[(index_key * sizeof(uint32_t)) + 2UL] = (uint8_t)(pU32[index_key]);
    }
  }
}
 8028428:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key]);
 802842a:	00ab      	lsls	r3, r5, #2
 802842c:	5cc1      	ldrb	r1, [r0, r3]
 802842e:	54d1      	strb	r1, [r2, r3]
 8028430:	e7f4      	b.n	802841c <KMS_Objects_BlobU32_2_u8ptr+0x3a>
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key] >> 8);
 8028432:	00ab      	lsls	r3, r5, #2
 8028434:	18c4      	adds	r4, r0, r3
 8028436:	6821      	ldr	r1, [r4, #0]
 8028438:	0a09      	lsrs	r1, r1, #8
 802843a:	54d1      	strb	r1, [r2, r3]
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key]);
 802843c:	3301      	adds	r3, #1
 802843e:	7821      	ldrb	r1, [r4, #0]
 8028440:	54d1      	strb	r1, [r2, r3]
 8028442:	e7ee      	b.n	8028422 <KMS_Objects_BlobU32_2_u8ptr+0x40>
      pU8[(index_key * sizeof(uint32_t))]       = (uint8_t)(pU32[index_key] >> 16);
 8028444:	00ad      	lsls	r5, r5, #2
 8028446:	1940      	adds	r0, r0, r5
 8028448:	7883      	ldrb	r3, [r0, #2]
 802844a:	5553      	strb	r3, [r2, r5]
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key] >> 8);
 802844c:	6803      	ldr	r3, [r0, #0]
 802844e:	0a1b      	lsrs	r3, r3, #8
 8028450:	1c69      	adds	r1, r5, #1
 8028452:	5453      	strb	r3, [r2, r1]
      pU8[(index_key * sizeof(uint32_t)) + 2UL] = (uint8_t)(pU32[index_key]);
 8028454:	3502      	adds	r5, #2
 8028456:	7803      	ldrb	r3, [r0, #0]
 8028458:	5553      	strb	r3, [r2, r5]
}
 802845a:	e7e5      	b.n	8028428 <KMS_Objects_BlobU32_2_u8ptr+0x46>

0802845c <KMS_Objects_CreateNStoreBlobFromTemplates>:
                                                CK_ATTRIBUTE_PTR pTemplate1,
                                                CK_ULONG ulCount1,
                                                CK_ATTRIBUTE_PTR pTemplate2,
                                                CK_ULONG ulCount2,
                                                CK_OBJECT_HANDLE_PTR phObject)
{
 802845c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802845e:	46de      	mov	lr, fp
 8028460:	4657      	mov	r7, sl
 8028462:	464e      	mov	r6, r9
 8028464:	4645      	mov	r5, r8
 8028466:	b5e0      	push	{r5, r6, r7, lr}
 8028468:	b083      	sub	sp, #12
 802846a:	9001      	str	r0, [sp, #4]
 802846c:	4689      	mov	r9, r1
 802846e:	0016      	movs	r6, r2
 8028470:	469a      	mov	sl, r3
  uint32_t offset;
  uint32_t *ptr;
  uint32_t tmp;
  kms_obj_keyhead_no_blob_t *p_blob;

  if ((pTemplate1 == NULL_PTR) || (ulCount1 == 0UL) || (phObject == NULL_PTR)
 8028472:	2900      	cmp	r1, #0
 8028474:	d100      	bne.n	8028478 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1c>
 8028476:	e0ca      	b.n	802860e <KMS_Objects_CreateNStoreBlobFromTemplates+0x1b2>
 8028478:	2a00      	cmp	r2, #0
 802847a:	d100      	bne.n	802847e <KMS_Objects_CreateNStoreBlobFromTemplates+0x22>
 802847c:	e0c9      	b.n	8028612 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1b6>
 802847e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8028480:	2b00      	cmp	r3, #0
 8028482:	d100      	bne.n	8028486 <KMS_Objects_CreateNStoreBlobFromTemplates+0x2a>
 8028484:	e0c7      	b.n	8028616 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1ba>
      || ((pTemplate2 == NULL_PTR) && (ulCount2 != 0UL)) || ((pTemplate2 != NULL_PTR) && (ulCount2 == 0UL)))
 8028486:	4653      	mov	r3, sl
 8028488:	2b00      	cmp	r3, #0
 802848a:	d00a      	beq.n	80284a2 <KMS_Objects_CreateNStoreBlobFromTemplates+0x46>
 802848c:	4653      	mov	r3, sl
 802848e:	2b00      	cmp	r3, #0
 8028490:	d01f      	beq.n	80284d2 <KMS_Objects_CreateNStoreBlobFromTemplates+0x76>
 8028492:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028494:	2b00      	cmp	r3, #0
 8028496:	d100      	bne.n	802849a <KMS_Objects_CreateNStoreBlobFromTemplates+0x3e>
 8028498:	e0bf      	b.n	802861a <KMS_Objects_CreateNStoreBlobFromTemplates+0x1be>
 802849a:	2200      	movs	r2, #0
 802849c:	2100      	movs	r1, #0
 802849e:	464d      	mov	r5, r9
 80284a0:	e007      	b.n	80284b2 <KMS_Objects_CreateNStoreBlobFromTemplates+0x56>
 80284a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80284a4:	2b00      	cmp	r3, #0
 80284a6:	d0f1      	beq.n	802848c <KMS_Objects_CreateNStoreBlobFromTemplates+0x30>
  {
    return CKR_ARGUMENTS_BAD;
 80284a8:	2407      	movs	r4, #7
 80284aa:	e0a8      	b.n	80285fe <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
  blob_size = 0;
  for (uint32_t i = 0; i < ulCount1; i++)
  {
    /* pValue size align on 4 bytes */
    blob_size += (pTemplate1[i].ulValueLen & 0xFFFFFFFCUL)
                 + (((pTemplate1[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 80284ac:	19db      	adds	r3, r3, r7
    blob_size += (pTemplate1[i].ulValueLen & 0xFFFFFFFCUL)
 80284ae:	18c9      	adds	r1, r1, r3
  for (uint32_t i = 0; i < ulCount1; i++)
 80284b0:	3201      	adds	r2, #1
 80284b2:	42b2      	cmp	r2, r6
 80284b4:	d211      	bcs.n	80284da <KMS_Objects_CreateNStoreBlobFromTemplates+0x7e>
    blob_size += (pTemplate1[i].ulValueLen & 0xFFFFFFFCUL)
 80284b6:	0053      	lsls	r3, r2, #1
 80284b8:	189b      	adds	r3, r3, r2
 80284ba:	009b      	lsls	r3, r3, #2
 80284bc:	18eb      	adds	r3, r5, r3
 80284be:	6898      	ldr	r0, [r3, #8]
 80284c0:	2403      	movs	r4, #3
 80284c2:	0003      	movs	r3, r0
 80284c4:	43a3      	bics	r3, r4
                 + (((pTemplate1[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 80284c6:	0027      	movs	r7, r4
 80284c8:	4007      	ands	r7, r0
 80284ca:	4204      	tst	r4, r0
 80284cc:	d0ee      	beq.n	80284ac <KMS_Objects_CreateNStoreBlobFromTemplates+0x50>
 80284ce:	2704      	movs	r7, #4
 80284d0:	e7ec      	b.n	80284ac <KMS_Objects_CreateNStoreBlobFromTemplates+0x50>
 80284d2:	2200      	movs	r2, #0
 80284d4:	2100      	movs	r1, #0
 80284d6:	464d      	mov	r5, r9
 80284d8:	e7eb      	b.n	80284b2 <KMS_Objects_CreateNStoreBlobFromTemplates+0x56>
 80284da:	46a9      	mov	r9, r5
  }

  /* Add for each attribute type & length fields */
  blob_size += ulCount1 * 2UL * sizeof(uint32_t);
 80284dc:	00f4      	lsls	r4, r6, #3
 80284de:	1864      	adds	r4, r4, r1
  if ((ulCount2 != 0UL) && (pTemplate2 != NULL_PTR))
 80284e0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80284e2:	2b00      	cmp	r3, #0
 80284e4:	d01f      	beq.n	8028526 <KMS_Objects_CreateNStoreBlobFromTemplates+0xca>
 80284e6:	4653      	mov	r3, sl
 80284e8:	2b00      	cmp	r3, #0
 80284ea:	d01c      	beq.n	8028526 <KMS_Objects_CreateNStoreBlobFromTemplates+0xca>
  {
    for (uint32_t i = 0; i < ulCount2; i++)
 80284ec:	2200      	movs	r2, #0
 80284ee:	46b4      	mov	ip, r6
 80284f0:	4655      	mov	r5, sl
 80284f2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80284f4:	e002      	b.n	80284fc <KMS_Objects_CreateNStoreBlobFromTemplates+0xa0>
    {
      /* pValue size align on 4 bytes */
      blob_size += (pTemplate2[i].ulValueLen & 0xFFFFFFFCUL)
                   + (((pTemplate2[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 80284f6:	199b      	adds	r3, r3, r6
      blob_size += (pTemplate2[i].ulValueLen & 0xFFFFFFFCUL)
 80284f8:	18e4      	adds	r4, r4, r3
    for (uint32_t i = 0; i < ulCount2; i++)
 80284fa:	3201      	adds	r2, #1
 80284fc:	428a      	cmp	r2, r1
 80284fe:	d20d      	bcs.n	802851c <KMS_Objects_CreateNStoreBlobFromTemplates+0xc0>
      blob_size += (pTemplate2[i].ulValueLen & 0xFFFFFFFCUL)
 8028500:	0053      	lsls	r3, r2, #1
 8028502:	189b      	adds	r3, r3, r2
 8028504:	009b      	lsls	r3, r3, #2
 8028506:	18eb      	adds	r3, r5, r3
 8028508:	6898      	ldr	r0, [r3, #8]
 802850a:	2703      	movs	r7, #3
 802850c:	0003      	movs	r3, r0
 802850e:	43bb      	bics	r3, r7
                   + (((pTemplate2[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 8028510:	003e      	movs	r6, r7
 8028512:	4006      	ands	r6, r0
 8028514:	4207      	tst	r7, r0
 8028516:	d0ee      	beq.n	80284f6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x9a>
 8028518:	2604      	movs	r6, #4
 802851a:	e7ec      	b.n	80284f6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x9a>
 802851c:	4666      	mov	r6, ip
 802851e:	46aa      	mov	sl, r5
    }
    /* Add for each attribute type & length fields */
    blob_size += ulCount2 * 2UL * sizeof(uint32_t);
 8028520:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028522:	00db      	lsls	r3, r3, #3
 8028524:	18e4      	adds	r4, r4, r3
  }

  /* Allocate blob object */
  p_blob = (kms_obj_keyhead_no_blob_t *)KMS_Alloc(hSession, sizeof(kms_obj_keyhead_no_blob_t) + blob_size);
 8028526:	0021      	movs	r1, r4
 8028528:	3114      	adds	r1, #20
 802852a:	9801      	ldr	r0, [sp, #4]
 802852c:	f7fe ffc8 	bl	80274c0 <KMS_Alloc>
 8028530:	4683      	mov	fp, r0
  if (p_blob == NULL_PTR)
 8028532:	2800      	cmp	r0, #0
 8028534:	d100      	bne.n	8028538 <KMS_Objects_CreateNStoreBlobFromTemplates+0xdc>
 8028536:	e072      	b.n	802861e <KMS_Objects_CreateNStoreBlobFromTemplates+0x1c2>
  {
    e_ret_status = CKR_DEVICE_MEMORY;
  }
  else
  {
    p_blob->version = KMS_ABI_VERSION_CK_2_40;
 8028538:	4b3a      	ldr	r3, [pc, #232]	; (8028624 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1c8>)
 802853a:	6003      	str	r3, [r0, #0]
    p_blob->configuration = KMS_ABI_CONFIG_KEYHEAD;
 802853c:	4b3a      	ldr	r3, [pc, #232]	; (8028628 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1cc>)
 802853e:	6043      	str	r3, [r0, #4]
    p_blob->blobs_size = blob_size;
 8028540:	6084      	str	r4, [r0, #8]
    p_blob->blobs_count = ulCount1 + ulCount2;
 8028542:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028544:	18f3      	adds	r3, r6, r3
 8028546:	60c3      	str	r3, [r0, #12]
    p_blob->object_id = KMS_HANDLE_KEY_NOT_KNOWN;    /* Updated when inserting object in NVM / VM */
 8028548:	2300      	movs	r3, #0
 802854a:	6103      	str	r3, [r0, #16]

    offset = 0;
    tmp = (uint32_t)(p_blob);
    ptr = (uint32_t *)(tmp + sizeof(kms_obj_keyhead_no_blob_t));
 802854c:	3314      	adds	r3, #20
 802854e:	445b      	add	r3, fp
 8028550:	4698      	mov	r8, r3

    /* Copy Template in blob, size and pValue are reversed, memcpy is impossible */
    for (uint32_t i = 0; i < ulCount1; i++)
 8028552:	2500      	movs	r5, #0
    offset = 0;
 8028554:	2700      	movs	r7, #0
 8028556:	0033      	movs	r3, r6
 8028558:	4646      	mov	r6, r8
 802855a:	4698      	mov	r8, r3
    for (uint32_t i = 0; i < ulCount1; i++)
 802855c:	e018      	b.n	8028590 <KMS_Objects_CreateNStoreBlobFromTemplates+0x134>
    {
      ptr[(3UL * i) + offset] = pTemplate1[i].type;
 802855e:	0068      	lsls	r0, r5, #1
 8028560:	1944      	adds	r4, r0, r5
 8028562:	00a4      	lsls	r4, r4, #2
 8028564:	444c      	add	r4, r9
 8028566:	1940      	adds	r0, r0, r5
 8028568:	19c0      	adds	r0, r0, r7
 802856a:	0083      	lsls	r3, r0, #2
 802856c:	6822      	ldr	r2, [r4, #0]
 802856e:	50f2      	str	r2, [r6, r3]
      ptr[(3UL * i) + 1UL + offset] = pTemplate1[i].ulValueLen;
 8028570:	1c43      	adds	r3, r0, #1
 8028572:	009b      	lsls	r3, r3, #2
 8028574:	68a2      	ldr	r2, [r4, #8]
 8028576:	50f2      	str	r2, [r6, r3]
      (void)memcpy((uint8_t *) & (ptr[(3UL * i) + 2UL + offset]), (uint8_t *)(pTemplate1[i].pValue),
 8028578:	3002      	adds	r0, #2
 802857a:	0080      	lsls	r0, r0, #2
 802857c:	1830      	adds	r0, r6, r0
 802857e:	68a2      	ldr	r2, [r4, #8]
 8028580:	6861      	ldr	r1, [r4, #4]
 8028582:	f00c f8c7 	bl	8034714 <memcpy>
                   pTemplate1[i].ulValueLen);
      offset += (pTemplate1[i].ulValueLen - 1UL) / 4UL;
 8028586:	68a3      	ldr	r3, [r4, #8]
 8028588:	3b01      	subs	r3, #1
 802858a:	089b      	lsrs	r3, r3, #2
 802858c:	18ff      	adds	r7, r7, r3
    for (uint32_t i = 0; i < ulCount1; i++)
 802858e:	3501      	adds	r5, #1
 8028590:	4545      	cmp	r5, r8
 8028592:	d3e4      	bcc.n	802855e <KMS_Objects_CreateNStoreBlobFromTemplates+0x102>
 8028594:	4643      	mov	r3, r8
 8028596:	46b0      	mov	r8, r6
 8028598:	001e      	movs	r6, r3
    }

    /* Object template #2 management when required by the caller */
    if ((ulCount2 != 0UL) && (pTemplate2 != NULL_PTR))
 802859a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802859c:	2b00      	cmp	r3, #0
 802859e:	d025      	beq.n	80285ec <KMS_Objects_CreateNStoreBlobFromTemplates+0x190>
 80285a0:	4653      	mov	r3, sl
 80285a2:	2b00      	cmp	r3, #0
 80285a4:	d022      	beq.n	80285ec <KMS_Objects_CreateNStoreBlobFromTemplates+0x190>
    {
      for (uint32_t i = 0; i < ulCount2; i++)
 80285a6:	2500      	movs	r5, #0
 80285a8:	46b1      	mov	r9, r6
 80285aa:	4646      	mov	r6, r8
 80285ac:	e01b      	b.n	80285e6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x18a>
      {
        ptr[(3UL * (i + ulCount1)) + offset] = pTemplate2[i].type;
 80285ae:	006c      	lsls	r4, r5, #1
 80285b0:	1964      	adds	r4, r4, r5
 80285b2:	00a4      	lsls	r4, r4, #2
 80285b4:	4454      	add	r4, sl
 80285b6:	464b      	mov	r3, r9
 80285b8:	18eb      	adds	r3, r5, r3
 80285ba:	0058      	lsls	r0, r3, #1
 80285bc:	18c0      	adds	r0, r0, r3
 80285be:	19c0      	adds	r0, r0, r7
 80285c0:	0083      	lsls	r3, r0, #2
 80285c2:	6822      	ldr	r2, [r4, #0]
 80285c4:	50f2      	str	r2, [r6, r3]
        ptr[(3UL * (i + ulCount1)) + 1UL + offset] = pTemplate2[i].ulValueLen;
 80285c6:	1c43      	adds	r3, r0, #1
 80285c8:	009b      	lsls	r3, r3, #2
 80285ca:	68a2      	ldr	r2, [r4, #8]
 80285cc:	50f2      	str	r2, [r6, r3]
        (void)memcpy((uint8_t *) & (ptr[(3UL * (i + ulCount1)) + 2UL + offset]), (uint8_t *)(pTemplate2[i].pValue),
 80285ce:	3002      	adds	r0, #2
 80285d0:	0080      	lsls	r0, r0, #2
 80285d2:	1830      	adds	r0, r6, r0
 80285d4:	68a2      	ldr	r2, [r4, #8]
 80285d6:	6861      	ldr	r1, [r4, #4]
 80285d8:	f00c f89c 	bl	8034714 <memcpy>
                     pTemplate2[i].ulValueLen);
        offset += (pTemplate2[i].ulValueLen - 1UL) / 4UL;
 80285dc:	68a3      	ldr	r3, [r4, #8]
 80285de:	3b01      	subs	r3, #1
 80285e0:	089b      	lsrs	r3, r3, #2
 80285e2:	18ff      	adds	r7, r7, r3
      for (uint32_t i = 0; i < ulCount2; i++)
 80285e4:	3501      	adds	r5, #1
 80285e6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80285e8:	429d      	cmp	r5, r3
 80285ea:	d3e0      	bcc.n	80285ae <KMS_Objects_CreateNStoreBlobFromTemplates+0x152>
      }
    }

    e_ret_status = KMS_PlatfObjects_AllocateAndStore(p_blob, phObject);
 80285ec:	990d      	ldr	r1, [sp, #52]	; 0x34
 80285ee:	4658      	mov	r0, fp
 80285f0:	f000 f8e6 	bl	80287c0 <KMS_PlatfObjects_AllocateAndStore>
 80285f4:	0004      	movs	r4, r0
    KMS_Free(hSession, p_blob);
 80285f6:	4659      	mov	r1, fp
 80285f8:	9801      	ldr	r0, [sp, #4]
 80285fa:	f7fe ff87 	bl	802750c <KMS_Free>
  }

  return e_ret_status;
}
 80285fe:	0020      	movs	r0, r4
 8028600:	b003      	add	sp, #12
 8028602:	bcf0      	pop	{r4, r5, r6, r7}
 8028604:	46bb      	mov	fp, r7
 8028606:	46b2      	mov	sl, r6
 8028608:	46a9      	mov	r9, r5
 802860a:	46a0      	mov	r8, r4
 802860c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_ARGUMENTS_BAD;
 802860e:	2407      	movs	r4, #7
 8028610:	e7f5      	b.n	80285fe <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 8028612:	2407      	movs	r4, #7
 8028614:	e7f3      	b.n	80285fe <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 8028616:	2407      	movs	r4, #7
 8028618:	e7f1      	b.n	80285fe <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 802861a:	2407      	movs	r4, #7
 802861c:	e7ef      	b.n	80285fe <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
    e_ret_status = CKR_DEVICE_MEMORY;
 802861e:	2431      	movs	r4, #49	; 0x31
 8028620:	e7ed      	b.n	80285fe <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 8028622:	46c0      	nop			; (mov r8, r8)
 8028624:	b10b0240 	.word	0xb10b0240
 8028628:	b10b0003 	.word	0xb10b0003

0802862c <KMS_Objects_CreateNStoreBlobForAES>:
                                         uint8_t *pKey,
                                         uint32_t keySize,
                                         CK_ATTRIBUTE_PTR pTemplate,
                                         CK_ULONG ulCount,
                                         CK_OBJECT_HANDLE_PTR phObject)
{
 802862c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802862e:	46c6      	mov	lr, r8
 8028630:	b500      	push	{lr}
 8028632:	b08c      	sub	sp, #48	; 0x30
 8028634:	0006      	movs	r6, r0
 8028636:	000d      	movs	r5, r1
 8028638:	0014      	movs	r4, r2
 802863a:	001f      	movs	r7, r3
   */
  CK_RV e_ret_status;
  CK_ATTRIBUTE template[3];
  uint32_t *trans_key;

  if ((pKey == NULL_PTR) || (keySize == 0UL) || (phObject == NULL_PTR)
 802863c:	2900      	cmp	r1, #0
 802863e:	d03d      	beq.n	80286bc <KMS_Objects_CreateNStoreBlobForAES+0x90>
 8028640:	2a00      	cmp	r2, #0
 8028642:	d03d      	beq.n	80286c0 <KMS_Objects_CreateNStoreBlobForAES+0x94>
 8028644:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8028646:	2b00      	cmp	r3, #0
 8028648:	d040      	beq.n	80286cc <KMS_Objects_CreateNStoreBlobForAES+0xa0>
      || ((pTemplate == NULL_PTR) && (ulCount != 0UL))
 802864a:	2f00      	cmp	r7, #0
 802864c:	d031      	beq.n	80286b2 <KMS_Objects_CreateNStoreBlobForAES+0x86>
      || ((pTemplate != NULL_PTR) && (ulCount == 0UL)))
 802864e:	2f00      	cmp	r7, #0
 8028650:	d002      	beq.n	8028658 <KMS_Objects_CreateNStoreBlobForAES+0x2c>
 8028652:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8028654:	2b00      	cmp	r3, #0
 8028656:	d03b      	beq.n	80286d0 <KMS_Objects_CreateNStoreBlobForAES+0xa4>
  {
    e_ret_status = CKR_ARGUMENTS_BAD;
  }
  else
  {
    trans_key = KMS_Alloc(hSession, keySize); /* AES keys shall be multiple of 4 length */
 8028658:	0021      	movs	r1, r4
 802865a:	0030      	movs	r0, r6
 802865c:	f7fe ff30 	bl	80274c0 <KMS_Alloc>
 8028660:	4680      	mov	r8, r0
    if (trans_key == NULL_PTR)
 8028662:	2800      	cmp	r0, #0
 8028664:	d036      	beq.n	80286d4 <KMS_Objects_CreateNStoreBlobForAES+0xa8>
      e_ret_status = CKR_DEVICE_MEMORY;
    }
    else
    {
      /* Convert key from u8 to u32 */
      KMS_Objects_u8ptr_2_BlobU32(pKey, keySize, trans_key);
 8028666:	0002      	movs	r2, r0
 8028668:	0021      	movs	r1, r4
 802866a:	0028      	movs	r0, r5
 802866c:	f7ff fe7f 	bl	802836e <KMS_Objects_u8ptr_2_BlobU32>
  pTemp->type = Type;
 8028670:	2300      	movs	r3, #0
 8028672:	9303      	str	r3, [sp, #12]
  pTemp->pValue = pValue;
 8028674:	4b18      	ldr	r3, [pc, #96]	; (80286d8 <KMS_Objects_CreateNStoreBlobForAES+0xac>)
 8028676:	9304      	str	r3, [sp, #16]
  pTemp->ulValueLen = ulValueLen;
 8028678:	2304      	movs	r3, #4
 802867a:	9305      	str	r3, [sp, #20]
  pTemp->type = Type;
 802867c:	2280      	movs	r2, #128	; 0x80
 802867e:	0052      	lsls	r2, r2, #1
 8028680:	9206      	str	r2, [sp, #24]
  pTemp->pValue = pValue;
 8028682:	4a16      	ldr	r2, [pc, #88]	; (80286dc <KMS_Objects_CreateNStoreBlobForAES+0xb0>)
 8028684:	9207      	str	r2, [sp, #28]
  pTemp->ulValueLen = ulValueLen;
 8028686:	9308      	str	r3, [sp, #32]
  pTemp->type = Type;
 8028688:	330d      	adds	r3, #13
 802868a:	9309      	str	r3, [sp, #36]	; 0x24
  pTemp->pValue = pValue;
 802868c:	4643      	mov	r3, r8
 802868e:	930a      	str	r3, [sp, #40]	; 0x28
  pTemp->ulValueLen = ulValueLen;
 8028690:	940b      	str	r4, [sp, #44]	; 0x2c
      fill_TLV(&(template[0]), CKA_CLASS, (void *)&vCKO_SECRET_KEY, sizeof(CK_OBJECT_CLASS));
      fill_TLV(&(template[1]), CKA_KEY_TYPE, (void *)&vCKK_AES, sizeof(CK_KEY_TYPE));
      fill_TLV(&(template[2]), CKA_VALUE, trans_key, keySize);

      /* Create and store blob object including additional user template */
      e_ret_status = KMS_Objects_CreateNStoreBlobFromTemplates(hSession,
 8028692:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8028694:	9301      	str	r3, [sp, #4]
 8028696:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8028698:	9300      	str	r3, [sp, #0]
 802869a:	003b      	movs	r3, r7
 802869c:	2203      	movs	r2, #3
 802869e:	a903      	add	r1, sp, #12
 80286a0:	0030      	movs	r0, r6
 80286a2:	f7ff fedb 	bl	802845c <KMS_Objects_CreateNStoreBlobFromTemplates>
 80286a6:	0004      	movs	r4, r0
                                                               3,
                                                               pTemplate,
                                                               ulCount,
                                                               phObject);

      KMS_Free(hSession, trans_key);
 80286a8:	4641      	mov	r1, r8
 80286aa:	0030      	movs	r0, r6
 80286ac:	f7fe ff2e 	bl	802750c <KMS_Free>
 80286b0:	e007      	b.n	80286c2 <KMS_Objects_CreateNStoreBlobForAES+0x96>
      || ((pTemplate == NULL_PTR) && (ulCount != 0UL))
 80286b2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80286b4:	2b00      	cmp	r3, #0
 80286b6:	d0ca      	beq.n	802864e <KMS_Objects_CreateNStoreBlobForAES+0x22>
    e_ret_status = CKR_ARGUMENTS_BAD;
 80286b8:	2407      	movs	r4, #7
 80286ba:	e002      	b.n	80286c2 <KMS_Objects_CreateNStoreBlobForAES+0x96>
 80286bc:	2407      	movs	r4, #7
 80286be:	e000      	b.n	80286c2 <KMS_Objects_CreateNStoreBlobForAES+0x96>
 80286c0:	2407      	movs	r4, #7
    }
  }
  return e_ret_status;
}
 80286c2:	0020      	movs	r0, r4
 80286c4:	b00c      	add	sp, #48	; 0x30
 80286c6:	bc80      	pop	{r7}
 80286c8:	46b8      	mov	r8, r7
 80286ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e_ret_status = CKR_ARGUMENTS_BAD;
 80286cc:	2407      	movs	r4, #7
 80286ce:	e7f8      	b.n	80286c2 <KMS_Objects_CreateNStoreBlobForAES+0x96>
 80286d0:	2407      	movs	r4, #7
 80286d2:	e7f6      	b.n	80286c2 <KMS_Objects_CreateNStoreBlobForAES+0x96>
      e_ret_status = CKR_DEVICE_MEMORY;
 80286d4:	2431      	movs	r4, #49	; 0x31
  return e_ret_status;
 80286d6:	e7f4      	b.n	80286c2 <KMS_Objects_CreateNStoreBlobForAES+0x96>
 80286d8:	2000a03c 	.word	0x2000a03c
 80286dc:	2000a038 	.word	0x2000a038

080286e0 <KMS_PlatfObjects_NvmStaticObjectList>:
/**
  * @brief  Update @ref KMS_PlatfObjects_NvmStaticList with NVM contents
  * @retval None
  */
static void KMS_PlatfObjects_NvmStaticObjectList(void)
{
 80286e0:	b530      	push	{r4, r5, lr}
 80286e2:	b083      	sub	sp, #12
  size_t nvms_data_size;
  kms_obj_keyhead_t *p_nvms_data;

  /* Load the KMS_PlatfObjects_NvmStaticList[], used to store buffer to NVM  */
  /* This should save processing time  */
  for (uint32_t i = KMS_INDEX_MIN_NVM_STATIC_OBJECTS; i < KMS_INDEX_MAX_NVM_STATIC_OBJECTS; i++)
 80286e4:	251e      	movs	r5, #30
 80286e6:	e004      	b.n	80286f2 <KMS_PlatfObjects_NvmStaticObjectList+0x12>
    {
      KMS_PlatfObjects_NvmStaticList[i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS] = p_nvms_data;
    }
    else
    {
      KMS_PlatfObjects_NvmStaticList[i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS] = NULL;
 80286e8:	00a4      	lsls	r4, r4, #2
 80286ea:	4b0d      	ldr	r3, [pc, #52]	; (8028720 <KMS_PlatfObjects_NvmStaticObjectList+0x40>)
 80286ec:	2200      	movs	r2, #0
 80286ee:	50e2      	str	r2, [r4, r3]
  for (uint32_t i = KMS_INDEX_MIN_NVM_STATIC_OBJECTS; i < KMS_INDEX_MAX_NVM_STATIC_OBJECTS; i++)
 80286f0:	3501      	adds	r5, #1
 80286f2:	2d30      	cmp	r5, #48	; 0x30
 80286f4:	d811      	bhi.n	802871a <KMS_PlatfObjects_NvmStaticObjectList+0x3a>
    nvms_rv = NVMS_GET_DATA(i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, &nvms_data_size, (uint8_t **)(uint32_t)&p_nvms_data);
 80286f6:	002c      	movs	r4, r5
 80286f8:	3c1e      	subs	r4, #30
 80286fa:	466b      	mov	r3, sp
 80286fc:	2200      	movs	r2, #0
 80286fe:	a901      	add	r1, sp, #4
 8028700:	0020      	movs	r0, r4
 8028702:	f7ff fccf 	bl	80280a4 <NVMS_GetDataWithType>
    if ((nvms_data_size != 0UL) && (nvms_rv == NVMS_NOERROR))
 8028706:	9b01      	ldr	r3, [sp, #4]
 8028708:	2b00      	cmp	r3, #0
 802870a:	d0ed      	beq.n	80286e8 <KMS_PlatfObjects_NvmStaticObjectList+0x8>
 802870c:	2800      	cmp	r0, #0
 802870e:	d1eb      	bne.n	80286e8 <KMS_PlatfObjects_NvmStaticObjectList+0x8>
      KMS_PlatfObjects_NvmStaticList[i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS] = p_nvms_data;
 8028710:	00a4      	lsls	r4, r4, #2
 8028712:	4b03      	ldr	r3, [pc, #12]	; (8028720 <KMS_PlatfObjects_NvmStaticObjectList+0x40>)
 8028714:	9a00      	ldr	r2, [sp, #0]
 8028716:	50e2      	str	r2, [r4, r3]
 8028718:	e7ea      	b.n	80286f0 <KMS_PlatfObjects_NvmStaticObjectList+0x10>
    }
  }
}
 802871a:	b003      	add	sp, #12
 802871c:	bd30      	pop	{r4, r5, pc}
 802871e:	46c0      	nop			; (mov r8, r8)
 8028720:	2000a354 	.word	0x2000a354

08028724 <KMS_PlatfObjects_NvmDynamicObjectList>:
/**
  * @brief  Update @ref KMS_PlatfObjects_NvmDynamicList with NVM contents
  * @retval None
  */
static void KMS_PlatfObjects_NvmDynamicObjectList(void)
{
 8028724:	b510      	push	{r4, lr}
 8028726:	b082      	sub	sp, #8
  size_t nvms_data_size;
  kms_obj_keyhead_t *p_nvms_data;

  /* Load the KMS_PlatfObjects_NvmDynamicList[], used to store buffer to NVM  */
  /* This should save processing time  */
  for (uint32_t i = KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS; i <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS; i++)
 8028728:	2432      	movs	r4, #50	; 0x32
 802872a:	e006      	b.n	802873a <KMS_PlatfObjects_NvmDynamicObjectList+0x16>
    {
      KMS_PlatfObjects_NvmDynamicList[i - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS] = p_nvms_data;
    }
    else
    {
      KMS_PlatfObjects_NvmDynamicList[i - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS] = NULL;
 802872c:	0023      	movs	r3, r4
 802872e:	3b32      	subs	r3, #50	; 0x32
 8028730:	009b      	lsls	r3, r3, #2
 8028732:	4a0d      	ldr	r2, [pc, #52]	; (8028768 <KMS_PlatfObjects_NvmDynamicObjectList+0x44>)
 8028734:	2100      	movs	r1, #0
 8028736:	5099      	str	r1, [r3, r2]
  for (uint32_t i = KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS; i <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS; i++)
 8028738:	3401      	adds	r4, #1
 802873a:	2c45      	cmp	r4, #69	; 0x45
 802873c:	d812      	bhi.n	8028764 <KMS_PlatfObjects_NvmDynamicObjectList+0x40>
    nvms_rv = NVMS_GET_DATA(i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, &nvms_data_size, (uint8_t **)(uint32_t)&p_nvms_data);
 802873e:	466b      	mov	r3, sp
 8028740:	2200      	movs	r2, #0
 8028742:	a901      	add	r1, sp, #4
 8028744:	0020      	movs	r0, r4
 8028746:	381e      	subs	r0, #30
 8028748:	f7ff fcac 	bl	80280a4 <NVMS_GetDataWithType>
    if ((nvms_data_size != 0UL) && (nvms_rv == NVMS_NOERROR))
 802874c:	9b01      	ldr	r3, [sp, #4]
 802874e:	2b00      	cmp	r3, #0
 8028750:	d0ec      	beq.n	802872c <KMS_PlatfObjects_NvmDynamicObjectList+0x8>
 8028752:	2800      	cmp	r0, #0
 8028754:	d1ea      	bne.n	802872c <KMS_PlatfObjects_NvmDynamicObjectList+0x8>
      KMS_PlatfObjects_NvmDynamicList[i - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS] = p_nvms_data;
 8028756:	0023      	movs	r3, r4
 8028758:	3b32      	subs	r3, #50	; 0x32
 802875a:	009b      	lsls	r3, r3, #2
 802875c:	4a02      	ldr	r2, [pc, #8]	; (8028768 <KMS_PlatfObjects_NvmDynamicObjectList+0x44>)
 802875e:	9900      	ldr	r1, [sp, #0]
 8028760:	5099      	str	r1, [r3, r2]
 8028762:	e7e9      	b.n	8028738 <KMS_PlatfObjects_NvmDynamicObjectList+0x14>
    }

  }
}
 8028764:	b002      	add	sp, #8
 8028766:	bd10      	pop	{r4, pc}
 8028768:	2000a304 	.word	0x2000a304

0802876c <KMS_PlatfObjects_EmbeddedRange>:
  * @param  pMax Embedded objects max ID
  * @retval None
  */
void KMS_PlatfObjects_EmbeddedRange(uint32_t *pMin, uint32_t *pMax)
{
  *pMin = KMS_INDEX_MIN_EMBEDDED_OBJECTS;
 802876c:	2301      	movs	r3, #1
 802876e:	6003      	str	r3, [r0, #0]
  *pMax = KMS_INDEX_MAX_EMBEDDED_OBJECTS;
 8028770:	331c      	adds	r3, #28
 8028772:	600b      	str	r3, [r1, #0]
}
 8028774:	4770      	bx	lr
	...

08028778 <KMS_PlatfObjects_EmbeddedObject>:
  * @param  hKey key handle
  * @retval Corresponding object
  */
kms_obj_keyhead_t *KMS_PlatfObjects_EmbeddedObject(uint32_t hKey)
{
  return (kms_obj_keyhead_t *)(uint32_t)KMS_PlatfObjects_EmbeddedList[hKey - KMS_INDEX_MIN_EMBEDDED_OBJECTS];
 8028778:	3801      	subs	r0, #1
 802877a:	0080      	lsls	r0, r0, #2
 802877c:	4b01      	ldr	r3, [pc, #4]	; (8028784 <KMS_PlatfObjects_EmbeddedObject+0xc>)
 802877e:	58c0      	ldr	r0, [r0, r3]
}
 8028780:	4770      	bx	lr
 8028782:	46c0      	nop			; (mov r8, r8)
 8028784:	08034c84 	.word	0x08034c84

08028788 <KMS_PlatfObjects_NvmStaticRange>:
  * @param  pMax NVM static objects max ID
  * @retval None
  */
void KMS_PlatfObjects_NvmStaticRange(uint32_t *pMin, uint32_t *pMax)
{
  *pMin = KMS_INDEX_MIN_NVM_STATIC_OBJECTS;
 8028788:	231e      	movs	r3, #30
 802878a:	6003      	str	r3, [r0, #0]
  *pMax = KMS_INDEX_MAX_NVM_STATIC_OBJECTS;
 802878c:	3313      	adds	r3, #19
 802878e:	600b      	str	r3, [r1, #0]
}
 8028790:	4770      	bx	lr
	...

08028794 <KMS_PlatfObjects_NvmStaticObject>:
  * @param  hKey key handle
  * @retval Corresponding object
  */
kms_obj_keyhead_t *KMS_PlatfObjects_NvmStaticObject(uint32_t hKey)
{
  return KMS_PlatfObjects_NvmStaticList[hKey - KMS_INDEX_MIN_NVM_STATIC_OBJECTS];
 8028794:	381e      	subs	r0, #30
 8028796:	0080      	lsls	r0, r0, #2
 8028798:	4b01      	ldr	r3, [pc, #4]	; (80287a0 <KMS_PlatfObjects_NvmStaticObject+0xc>)
 802879a:	58c0      	ldr	r0, [r0, r3]
}
 802879c:	4770      	bx	lr
 802879e:	46c0      	nop			; (mov r8, r8)
 80287a0:	2000a354 	.word	0x2000a354

080287a4 <KMS_PlatfObjects_NvmDynamicRange>:
  * @param  pMax NVM dynamic objects max ID
  * @retval None
  */
void KMS_PlatfObjects_NvmDynamicRange(uint32_t *pMin, uint32_t *pMax)
{
  *pMin = KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS;
 80287a4:	2332      	movs	r3, #50	; 0x32
 80287a6:	6003      	str	r3, [r0, #0]
  *pMax = KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS;
 80287a8:	3313      	adds	r3, #19
 80287aa:	600b      	str	r3, [r1, #0]
}
 80287ac:	4770      	bx	lr
	...

080287b0 <KMS_PlatfObjects_NvmDynamicObject>:
  * @param  hKey key handle
  * @retval Corresponding object
  */
kms_obj_keyhead_t *KMS_PlatfObjects_NvmDynamicObject(uint32_t hKey)
{
  return KMS_PlatfObjects_NvmDynamicList[hKey - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS];
 80287b0:	3832      	subs	r0, #50	; 0x32
 80287b2:	0080      	lsls	r0, r0, #2
 80287b4:	4b01      	ldr	r3, [pc, #4]	; (80287bc <KMS_PlatfObjects_NvmDynamicObject+0xc>)
 80287b6:	58c0      	ldr	r0, [r0, r3]
}
 80287b8:	4770      	bx	lr
 80287ba:	46c0      	nop			; (mov r8, r8)
 80287bc:	2000a304 	.word	0x2000a304

080287c0 <KMS_PlatfObjects_AllocateAndStore>:
  *         CKR_DEVICE_MEMORY
  *         @ref KMS_PlatfObjects_NvmStoreObject returned values
  *         @ref KMS_PlatfObjects_VmStoreObject returned values
  */
CK_RV KMS_PlatfObjects_AllocateAndStore(kms_obj_keyhead_no_blob_t *pBlob, CK_OBJECT_HANDLE_PTR pObjId)
{
 80287c0:	b570      	push	{r4, r5, r6, lr}
 80287c2:	0006      	movs	r6, r0
 80287c4:	1e0d      	subs	r5, r1, #0
  CK_OBJECT_HANDLE Index;
  CK_RV e_ret_status;

  if ((pObjId == NULL_PTR) || (pBlob == NULL_PTR))
 80287c6:	d01e      	beq.n	8028806 <KMS_PlatfObjects_AllocateAndStore+0x46>
 80287c8:	2800      	cmp	r0, #0
 80287ca:	d01e      	beq.n	802880a <KMS_PlatfObjects_AllocateAndStore+0x4a>
  {
    e_ret_status = CKR_ARGUMENTS_BAD;
  }
  else
  {
    *pObjId = KMS_HANDLE_KEY_NOT_KNOWN;
 80287cc:	2300      	movs	r3, #0
 80287ce:	600b      	str	r3, [r1, #0]
#ifdef KMS_NVM_DYNAMIC_ENABLED
    /* Find a Free place in nvm dynamic table */
    for (Index = 0; Index <= (KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS); Index++)
 80287d0:	e000      	b.n	80287d4 <KMS_PlatfObjects_AllocateAndStore+0x14>
 80287d2:	3301      	adds	r3, #1
 80287d4:	2b13      	cmp	r3, #19
 80287d6:	d806      	bhi.n	80287e6 <KMS_PlatfObjects_AllocateAndStore+0x26>
    {
      if (KMS_PlatfObjects_NvmDynamicList[Index] == NULL)
 80287d8:	009a      	lsls	r2, r3, #2
 80287da:	4c0d      	ldr	r4, [pc, #52]	; (8028810 <KMS_PlatfObjects_AllocateAndStore+0x50>)
 80287dc:	5912      	ldr	r2, [r2, r4]
 80287de:	2a00      	cmp	r2, #0
 80287e0:	d1f7      	bne.n	80287d2 <KMS_PlatfObjects_AllocateAndStore+0x12>
      {
        *pObjId = Index + KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS;
 80287e2:	3332      	adds	r3, #50	; 0x32
 80287e4:	602b      	str	r3, [r5, #0]
        *pObjId = Index + KMS_INDEX_MIN_VM_DYNAMIC_OBJECTS;
        break;
      }
    }
#endif /* KMS_VM_DYNAMIC_ENABLED */
    if (*pObjId == KMS_HANDLE_KEY_NOT_KNOWN)
 80287e6:	6828      	ldr	r0, [r5, #0]
 80287e8:	2800      	cmp	r0, #0
 80287ea:	d101      	bne.n	80287f0 <KMS_PlatfObjects_AllocateAndStore+0x30>
    {
      /* No place found in Dynamic List */
      e_ret_status = CKR_DEVICE_MEMORY;
 80287ec:	2031      	movs	r0, #49	; 0x31
        *pObjId = KMS_HANDLE_KEY_NOT_KNOWN;
      }
    }
  }
  return e_ret_status;
}
 80287ee:	bd70      	pop	{r4, r5, r6, pc}
      pBlob->object_id = *pObjId;
 80287f0:	6130      	str	r0, [r6, #16]
      e_ret_status = KMS_PlatfObjects_NvmStoreObject(*pObjId,
 80287f2:	68b2      	ldr	r2, [r6, #8]
 80287f4:	3214      	adds	r2, #20
 80287f6:	0031      	movs	r1, r6
 80287f8:	f000 f81e 	bl	8028838 <KMS_PlatfObjects_NvmStoreObject>
      if (e_ret_status != CKR_OK)
 80287fc:	2800      	cmp	r0, #0
 80287fe:	d0f6      	beq.n	80287ee <KMS_PlatfObjects_AllocateAndStore+0x2e>
        *pObjId = KMS_HANDLE_KEY_NOT_KNOWN;
 8028800:	2300      	movs	r3, #0
 8028802:	602b      	str	r3, [r5, #0]
 8028804:	e7f3      	b.n	80287ee <KMS_PlatfObjects_AllocateAndStore+0x2e>
    e_ret_status = CKR_ARGUMENTS_BAD;
 8028806:	2007      	movs	r0, #7
 8028808:	e7f1      	b.n	80287ee <KMS_PlatfObjects_AllocateAndStore+0x2e>
 802880a:	2007      	movs	r0, #7
 802880c:	e7ef      	b.n	80287ee <KMS_PlatfObjects_AllocateAndStore+0x2e>
 802880e:	46c0      	nop			; (mov r8, r8)
 8028810:	2000a304 	.word	0x2000a304

08028814 <KMS_PlatfObjects_Init>:
  * @brief  Initialize platform objects
  * @note   Initialize NVM / VM storage and fill "cache" buffers
  * @retval None
  */
void KMS_PlatfObjects_Init(void)
{
 8028814:	b510      	push	{r4, lr}
#ifdef KMS_NVM_ENABLED
  /* The NVMS_Init should be done only once */
  if (kms_platf_nvm_initialisation_done == 0UL)
 8028816:	4b07      	ldr	r3, [pc, #28]	; (8028834 <KMS_PlatfObjects_Init+0x20>)
 8028818:	681b      	ldr	r3, [r3, #0]
 802881a:	2b00      	cmp	r3, #0
 802881c:	d004      	beq.n	8028828 <KMS_PlatfObjects_Init+0x14>
    /* Initialize the NVMS */
    (void)NVMS_Init();
    kms_platf_nvm_initialisation_done = 1UL;
  }

  KMS_PlatfObjects_NvmStaticObjectList();
 802881e:	f7ff ff5f 	bl	80286e0 <KMS_PlatfObjects_NvmStaticObjectList>
#ifdef KMS_NVM_DYNAMIC_ENABLED
  KMS_PlatfObjects_NvmDynamicObjectList();
 8028822:	f7ff ff7f 	bl	8028724 <KMS_PlatfObjects_NvmDynamicObjectList>
    kms_platf_vm_initialisation_done = 1UL;
  }

  KMS_PlatfObjects_VmDynamicObjectList();
#endif /* KMS_VM_DYNAMIC_ENABLED */
}
 8028826:	bd10      	pop	{r4, pc}
    (void)NVMS_Init();
 8028828:	f7ff fb7c 	bl	8027f24 <NVMS_Init>
    kms_platf_nvm_initialisation_done = 1UL;
 802882c:	4b01      	ldr	r3, [pc, #4]	; (8028834 <KMS_PlatfObjects_Init+0x20>)
 802882e:	2201      	movs	r2, #1
 8028830:	601a      	str	r2, [r3, #0]
 8028832:	e7f4      	b.n	802881e <KMS_PlatfObjects_Init+0xa>
 8028834:	2000a3a4 	.word	0x2000a3a4

08028838 <KMS_PlatfObjects_NvmStoreObject>:
  * @param  ObjectSize Object size
  * @retval CKR_OK if storage is successful
  *         CKR_DEVICE_MEMORY otherwise
  */
CK_RV KMS_PlatfObjects_NvmStoreObject(uint32_t ObjectId, uint8_t *pObjectToAdd,  uint32_t ObjectSize)
{
 8028838:	b510      	push	{r4, lr}
 802883a:	0004      	movs	r4, r0
 802883c:	000b      	movs	r3, r1
 802883e:	0011      	movs	r1, r2
  nvms_error_t  rv;
  CK_RV e_ret_status;

  /* It's a NVM STATIC object */
  if ((ObjectId >= KMS_INDEX_MIN_NVM_STATIC_OBJECTS) && (ObjectId <= KMS_INDEX_MAX_NVM_STATIC_OBJECTS))
 8028840:	381e      	subs	r0, #30
 8028842:	2813      	cmp	r0, #19
 8028844:	d90c      	bls.n	8028860 <KMS_PlatfObjects_NvmStoreObject+0x28>
  }
  else
  {
#ifdef KMS_NVM_DYNAMIC_ENABLED
    /* It's a NVM DYNAMIC object */
    if ((ObjectId >= KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS) && (ObjectId <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS))
 8028846:	3c32      	subs	r4, #50	; 0x32
 8028848:	2c13      	cmp	r4, #19
 802884a:	d911      	bls.n	8028870 <KMS_PlatfObjects_NvmStoreObject+0x38>
    {
      rv = NVMS_WRITE_DATA(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, ObjectSize, (const uint8_t *)pObjectToAdd);
    }
    else
    {
      rv = NVMS_SLOT_INVALID;
 802884c:	2004      	movs	r0, #4
#else /* KMS_NVM_DYNAMIC_ENABLED */
    rv = NVMS_SLOT_INVALID;
#endif /* KMS_NVM_DYNAMIC_ENABLED */
  }
  /* A Garbage collection generate a WARNING ==> Not an error */
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 802884e:	2802      	cmp	r0, #2
 8028850:	d013      	beq.n	802887a <KMS_PlatfObjects_NvmStoreObject+0x42>
  {
    e_ret_status = CKR_OK;
  }
  else
  {
    e_ret_status = CKR_DEVICE_MEMORY;
 8028852:	2431      	movs	r4, #49	; 0x31
  }

  /* Refresh NVM lists */
  KMS_PlatfObjects_NvmStaticObjectList();
 8028854:	f7ff ff44 	bl	80286e0 <KMS_PlatfObjects_NvmStaticObjectList>
#ifdef KMS_NVM_DYNAMIC_ENABLED
  KMS_PlatfObjects_NvmDynamicObjectList();
 8028858:	f7ff ff64 	bl	8028724 <KMS_PlatfObjects_NvmDynamicObjectList>
#endif /* KMS_NVM_DYNAMIC_ENABLED */

  return e_ret_status;
}
 802885c:	0020      	movs	r0, r4
 802885e:	bd10      	pop	{r4, pc}
    rv = NVMS_WRITE_DATA(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, ObjectSize, (const uint8_t *)pObjectToAdd);
 8028860:	2201      	movs	r2, #1
 8028862:	4252      	negs	r2, r2
 8028864:	f7ff fb72 	bl	8027f4c <NVMS_WriteDataWithType>
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 8028868:	2800      	cmp	r0, #0
 802886a:	d1f0      	bne.n	802884e <KMS_PlatfObjects_NvmStoreObject+0x16>
    e_ret_status = CKR_OK;
 802886c:	2400      	movs	r4, #0
 802886e:	e7f1      	b.n	8028854 <KMS_PlatfObjects_NvmStoreObject+0x1c>
      rv = NVMS_WRITE_DATA(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, ObjectSize, (const uint8_t *)pObjectToAdd);
 8028870:	2201      	movs	r2, #1
 8028872:	4252      	negs	r2, r2
 8028874:	f7ff fb6a 	bl	8027f4c <NVMS_WriteDataWithType>
 8028878:	e7f6      	b.n	8028868 <KMS_PlatfObjects_NvmStoreObject+0x30>
    e_ret_status = CKR_OK;
 802887a:	2400      	movs	r4, #0
 802887c:	e7ea      	b.n	8028854 <KMS_PlatfObjects_NvmStoreObject+0x1c>

0802887e <KMS_PlatfObjects_NvmRemoveObject>:
  * @param  ObjectId Object ID
  * @retval CKR_OK if removal is successful
  *         CKR_DEVICE_MEMORY otherwise
  */
CK_RV KMS_PlatfObjects_NvmRemoveObject(uint32_t ObjectId)
{
 802887e:	b510      	push	{r4, lr}
  nvms_error_t rv = NVMS_DATA_NOT_FOUND;
  CK_RV e_ret_status;

  /* Check that the ObjectID is in dynamic range */
  if ((ObjectId >= KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS) && (ObjectId <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS))
 8028880:	0003      	movs	r3, r0
 8028882:	3b32      	subs	r3, #50	; 0x32
 8028884:	2b13      	cmp	r3, #19
 8028886:	d909      	bls.n	802889c <KMS_PlatfObjects_NvmRemoveObject+0x1e>
  nvms_error_t rv = NVMS_DATA_NOT_FOUND;
 8028888:	2005      	movs	r0, #5
  {
    rv = NVMS_EraseData(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS);
  }
  /* A Garbage collection generate a WARNING ==> Not an error */
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 802888a:	2802      	cmp	r0, #2
 802888c:	d00d      	beq.n	80288aa <KMS_PlatfObjects_NvmRemoveObject+0x2c>
  {
    e_ret_status = CKR_OK;
  }
  else
  {
    e_ret_status = CKR_DEVICE_MEMORY;
 802888e:	2431      	movs	r4, #49	; 0x31
  }

  /* Refresh NVM lists */
  KMS_PlatfObjects_NvmStaticObjectList();
 8028890:	f7ff ff26 	bl	80286e0 <KMS_PlatfObjects_NvmStaticObjectList>
#ifdef KMS_NVM_DYNAMIC_ENABLED
  KMS_PlatfObjects_NvmDynamicObjectList();
 8028894:	f7ff ff46 	bl	8028724 <KMS_PlatfObjects_NvmDynamicObjectList>
#endif /* KMS_NVM_DYNAMIC_ENABLED */

  return e_ret_status;
}
 8028898:	0020      	movs	r0, r4
 802889a:	bd10      	pop	{r4, pc}
    rv = NVMS_EraseData(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS);
 802889c:	381e      	subs	r0, #30
 802889e:	f7ff fbb3 	bl	8028008 <NVMS_EraseData>
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 80288a2:	2800      	cmp	r0, #0
 80288a4:	d1f1      	bne.n	802888a <KMS_PlatfObjects_NvmRemoveObject+0xc>
    e_ret_status = CKR_OK;
 80288a6:	2400      	movs	r4, #0
 80288a8:	e7f2      	b.n	8028890 <KMS_PlatfObjects_NvmRemoveObject+0x12>
 80288aa:	2400      	movs	r4, #0
 80288ac:	e7f0      	b.n	8028890 <KMS_PlatfObjects_NvmRemoveObject+0x12>
	...

080288b0 <sign_verify_init>:
  */
CK_RV     sign_verify_init(CK_SESSION_HANDLE hSession,
                           CK_MECHANISM_PTR  pMechanism,
                           CK_OBJECT_HANDLE  hKey,
                           uint32_t sigver_flag)
{
 80288b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80288b2:	46d6      	mov	lr, sl
 80288b4:	b500      	push	{lr}
 80288b6:	b084      	sub	sp, #16
 80288b8:	0004      	movs	r4, r0
 80288ba:	000d      	movs	r5, r1
 80288bc:	9200      	str	r2, [sp, #0]
 80288be:	9301      	str	r3, [sp, #4]
  CK_RV e_ret_status = CKR_MECHANISM_INVALID;

  if (!KMS_IS_INITIALIZED())
 80288c0:	4b62      	ldr	r3, [pc, #392]	; (8028a4c <sign_verify_init+0x19c>)
 80288c2:	781b      	ldrb	r3, [r3, #0]
 80288c4:	2b00      	cmp	r3, #0
 80288c6:	d100      	bne.n	80288ca <sign_verify_init+0x1a>
 80288c8:	e0b3      	b.n	8028a32 <sign_verify_init+0x182>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80288ca:	f7fe fca3 	bl	8027214 <KMS_CheckSessionHdle>
 80288ce:	2800      	cmp	r0, #0
 80288d0:	d000      	beq.n	80288d4 <sign_verify_init+0x24>
 80288d2:	e0b5      	b.n	8028a40 <sign_verify_init+0x190>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 80288d4:	1e66      	subs	r6, r4, #1
 80288d6:	00f3      	lsls	r3, r6, #3
 80288d8:	199b      	adds	r3, r3, r6
 80288da:	009b      	lsls	r3, r3, #2
 80288dc:	4a5b      	ldr	r2, [pc, #364]	; (8028a4c <sign_verify_init+0x19c>)
 80288de:	18d3      	adds	r3, r2, r3
 80288e0:	68db      	ldr	r3, [r3, #12]
 80288e2:	2b00      	cmp	r3, #0
 80288e4:	d000      	beq.n	80288e8 <sign_verify_init+0x38>
 80288e6:	e0ad      	b.n	8028a44 <sign_verify_init+0x194>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Check that we support the expected mechanism  */
  if (pMechanism == NULL_PTR)
 80288e8:	2d00      	cmp	r5, #0
 80288ea:	d100      	bne.n	80288ee <sign_verify_init+0x3e>
 80288ec:	e0ac      	b.n	8028a48 <sign_verify_init+0x198>
  {
    return CKR_ARGUMENTS_BAD;
  }
  switch (pMechanism->mechanism)
 80288ee:	682b      	ldr	r3, [r5, #0]
 80288f0:	4a57      	ldr	r2, [pc, #348]	; (8028a50 <sign_verify_init+0x1a0>)
 80288f2:	4694      	mov	ip, r2
 80288f4:	4463      	add	r3, ip
 80288f6:	2b01      	cmp	r3, #1
 80288f8:	d901      	bls.n	80288fe <sign_verify_init+0x4e>
  CK_RV e_ret_status = CKR_MECHANISM_INVALID;
 80288fa:	2770      	movs	r7, #112	; 0x70
 80288fc:	e09b      	b.n	8028a36 <sign_verify_init+0x186>
      kms_attr_t *P_pKeyAttribute;
      kms_aes_cmac_sv_ctx_t *p_ctx;

      /* Read the key value from the Key Handle                 */
      /* Key Handle is the index to one of static or nvm        */
      pkms_object = KMS_Objects_GetPointer(hKey);
 80288fe:	9800      	ldr	r0, [sp, #0]
 8028900:	f7ff fc2c 	bl	802815c <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL) &&
 8028904:	2800      	cmp	r0, #0
 8028906:	d100      	bne.n	802890a <sign_verify_init+0x5a>
 8028908:	e08f      	b.n	8028a2a <sign_verify_init+0x17a>
 802890a:	4b52      	ldr	r3, [pc, #328]	; (8028a54 <sign_verify_init+0x1a4>)
 802890c:	6802      	ldr	r2, [r0, #0]
 802890e:	429a      	cmp	r2, r3
 8028910:	d001      	beq.n	8028916 <sign_verify_init+0x66>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028912:	2782      	movs	r7, #130	; 0x82
 8028914:	e08f      	b.n	8028a36 <sign_verify_init+0x186>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8028916:	4b50      	ldr	r3, [pc, #320]	; (8028a58 <sign_verify_init+0x1a8>)
 8028918:	6842      	ldr	r2, [r0, #4]
 802891a:	429a      	cmp	r2, r3
 802891c:	d001      	beq.n	8028922 <sign_verify_init+0x72>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 802891e:	2782      	movs	r7, #130	; 0x82
 8028920:	e089      	b.n	8028a36 <sign_verify_init+0x186>
        e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8028922:	aa03      	add	r2, sp, #12
 8028924:	0001      	movs	r1, r0
 8028926:	2011      	movs	r0, #17
 8028928:	f7ff fc75 	bl	8028216 <KMS_Objects_SearchAttributes>
 802892c:	1e07      	subs	r7, r0, #0
        if (e_ret_status == CKR_OK)
 802892e:	d000      	beq.n	8028932 <sign_verify_init+0x82>
 8028930:	e081      	b.n	8028a36 <sign_verify_init+0x186>
          if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8028932:	9b03      	ldr	r3, [sp, #12]
 8028934:	685b      	ldr	r3, [r3, #4]
 8028936:	2b10      	cmp	r3, #16
 8028938:	d005      	beq.n	8028946 <sign_verify_init+0x96>
 802893a:	2b18      	cmp	r3, #24
 802893c:	d003      	beq.n	8028946 <sign_verify_init+0x96>
              (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 802893e:	2b20      	cmp	r3, #32
 8028940:	d001      	beq.n	8028946 <sign_verify_init+0x96>
            e_ret_status = CKR_ARGUMENTS_BAD;
 8028942:	2707      	movs	r7, #7
 8028944:	e077      	b.n	8028a36 <sign_verify_init+0x186>
            p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_cmac_sv_ctx_t));
 8028946:	2178      	movs	r1, #120	; 0x78
 8028948:	0020      	movs	r0, r4
 802894a:	f7fe fdb9 	bl	80274c0 <KMS_Alloc>
 802894e:	4682      	mov	sl, r0
            if (p_ctx == NULL_PTR)
 8028950:	2800      	cmp	r0, #0
 8028952:	d06c      	beq.n	8028a2e <sign_verify_init+0x17e>
            KMS_GETSESSION(hSession).hKey = hKey;
 8028954:	00f3      	lsls	r3, r6, #3
 8028956:	199b      	adds	r3, r3, r6
 8028958:	009a      	lsls	r2, r3, #2
 802895a:	4b3c      	ldr	r3, [pc, #240]	; (8028a4c <sign_verify_init+0x19c>)
 802895c:	189b      	adds	r3, r3, r2
 802895e:	9a00      	ldr	r2, [sp, #0]
 8028960:	625a      	str	r2, [r3, #36]	; 0x24
            KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8028962:	682a      	ldr	r2, [r5, #0]
 8028964:	621a      	str	r2, [r3, #32]
            KMS_GETSESSION(hSession).pCtx = p_ctx;
 8028966:	6298      	str	r0, [r3, #40]	; 0x28
            if ((pMechanism->mechanism == CKM_AES_CMAC_GENERAL)
 8028968:	682b      	ldr	r3, [r5, #0]
 802896a:	4a3c      	ldr	r2, [pc, #240]	; (8028a5c <sign_verify_init+0x1ac>)
 802896c:	4293      	cmp	r3, r2
 802896e:	d021      	beq.n	80289b4 <sign_verify_init+0x104>
            else if ((pMechanism->mechanism == CKM_AES_CMAC_GENERAL)
 8028970:	4a3a      	ldr	r2, [pc, #232]	; (8028a5c <sign_verify_init+0x1ac>)
 8028972:	4293      	cmp	r3, r2
 8028974:	d024      	beq.n	80289c0 <sign_verify_init+0x110>
              p_ctx->tagLength = CA_CRL_AES_BLOCK;
 8028976:	2310      	movs	r3, #16
 8028978:	4652      	mov	r2, sl
 802897a:	6313      	str	r3, [r2, #48]	; 0x30
            p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 802897c:	2338      	movs	r3, #56	; 0x38
 802897e:	2200      	movs	r2, #0
 8028980:	4651      	mov	r1, sl
 8028982:	54ca      	strb	r2, [r1, r3]
            p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 8028984:	9803      	ldr	r0, [sp, #12]
 8028986:	6842      	ldr	r2, [r0, #4]
 8028988:	658a      	str	r2, [r1, #88]	; 0x58
            KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 802898a:	6841      	ldr	r1, [r0, #4]
 802898c:	3008      	adds	r0, #8
 802898e:	4652      	mov	r2, sl
 8028990:	f7ff fd27 	bl	80283e2 <KMS_Objects_BlobU32_2_u8ptr>
            p_ctx->ca_ctx.pmKey = p_ctx->key;
 8028994:	4653      	mov	r3, sl
 8028996:	63db      	str	r3, [r3, #60]	; 0x3c
            p_ctx->ca_ctx.mTagSize = (int32_t)p_ctx->tagLength;
 8028998:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802899a:	665a      	str	r2, [r3, #100]	; 0x64
            p_ctx->ca_ctx.pmTag = p_ctx->tag;
 802899c:	3320      	adds	r3, #32
 802899e:	4652      	mov	r2, sl
 80289a0:	6613      	str	r3, [r2, #96]	; 0x60
            if (sigver_flag == KMS_FLAG_SIGN)
 80289a2:	9b01      	ldr	r3, [sp, #4]
 80289a4:	2b00      	cmp	r3, #0
 80289a6:	d01a      	beq.n	80289de <sign_verify_init+0x12e>
        e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 80289a8:	003b      	movs	r3, r7
            if (sigver_flag == KMS_FLAG_VERIFY)
 80289aa:	9a01      	ldr	r2, [sp, #4]
 80289ac:	2a01      	cmp	r2, #1
 80289ae:	d02a      	beq.n	8028a06 <sign_verify_init+0x156>
 80289b0:	001f      	movs	r7, r3
 80289b2:	e040      	b.n	8028a36 <sign_verify_init+0x186>
                && (pMechanism->pParameter != NULL_PTR))
 80289b4:	686a      	ldr	r2, [r5, #4]
 80289b6:	2a00      	cmp	r2, #0
 80289b8:	d0da      	beq.n	8028970 <sign_verify_init+0xc0>
              p_ctx->tagLength = *(CK_ULONG_PTR)pMechanism->pParameter;
 80289ba:	6812      	ldr	r2, [r2, #0]
 80289bc:	6302      	str	r2, [r0, #48]	; 0x30
 80289be:	e7dd      	b.n	802897c <sign_verify_init+0xcc>
                     && (pMechanism->pParameter == NULL_PTR))
 80289c0:	686b      	ldr	r3, [r5, #4]
 80289c2:	2b00      	cmp	r3, #0
 80289c4:	d1d7      	bne.n	8028976 <sign_verify_init+0xc6>
              KMS_Free(hSession, p_ctx);
 80289c6:	4651      	mov	r1, sl
 80289c8:	0020      	movs	r0, r4
 80289ca:	f7fe fd9f 	bl	802750c <KMS_Free>
              KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 80289ce:	2324      	movs	r3, #36	; 0x24
 80289d0:	435e      	muls	r6, r3
 80289d2:	4b1e      	ldr	r3, [pc, #120]	; (8028a4c <sign_verify_init+0x19c>)
 80289d4:	199b      	adds	r3, r3, r6
 80289d6:	2200      	movs	r2, #0
 80289d8:	629a      	str	r2, [r3, #40]	; 0x28
              e_ret_status = CKR_ARGUMENTS_BAD;
 80289da:	2707      	movs	r7, #7
              break;
 80289dc:	e02b      	b.n	8028a36 <sign_verify_init+0x186>
              if (CA_AES_CMAC_Encrypt_Init(&p_ctx->ca_ctx) == CA_AES_SUCCESS)
 80289de:	4650      	mov	r0, sl
 80289e0:	3034      	adds	r0, #52	; 0x34
 80289e2:	f7fd fa1b 	bl	8025e1c <CA_AES_CMAC_Encrypt_Init>
 80289e6:	2800      	cmp	r0, #0
 80289e8:	d101      	bne.n	80289ee <sign_verify_init+0x13e>
                e_ret_status = CKR_OK;
 80289ea:	9b01      	ldr	r3, [sp, #4]
 80289ec:	e7dd      	b.n	80289aa <sign_verify_init+0xfa>
                KMS_Free(hSession, p_ctx);
 80289ee:	4651      	mov	r1, sl
 80289f0:	0020      	movs	r0, r4
 80289f2:	f7fe fd8b 	bl	802750c <KMS_Free>
                KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 80289f6:	2224      	movs	r2, #36	; 0x24
 80289f8:	4372      	muls	r2, r6
 80289fa:	4b14      	ldr	r3, [pc, #80]	; (8028a4c <sign_verify_init+0x19c>)
 80289fc:	189b      	adds	r3, r3, r2
 80289fe:	2200      	movs	r2, #0
 8028a00:	629a      	str	r2, [r3, #40]	; 0x28
                e_ret_status = CKR_FUNCTION_FAILED;
 8028a02:	2306      	movs	r3, #6
 8028a04:	e7d1      	b.n	80289aa <sign_verify_init+0xfa>
              if (CA_AES_CMAC_Decrypt_Init(&p_ctx->ca_ctx) == CA_AES_SUCCESS)
 8028a06:	4650      	mov	r0, sl
 8028a08:	3034      	adds	r0, #52	; 0x34
 8028a0a:	f7fd fa65 	bl	8025ed8 <CA_AES_CMAC_Decrypt_Init>
 8028a0e:	2800      	cmp	r0, #0
 8028a10:	d011      	beq.n	8028a36 <sign_verify_init+0x186>
                KMS_Free(hSession, p_ctx);
 8028a12:	4651      	mov	r1, sl
 8028a14:	0020      	movs	r0, r4
 8028a16:	f7fe fd79 	bl	802750c <KMS_Free>
                KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028a1a:	2224      	movs	r2, #36	; 0x24
 8028a1c:	4372      	muls	r2, r6
 8028a1e:	4b0b      	ldr	r3, [pc, #44]	; (8028a4c <sign_verify_init+0x19c>)
 8028a20:	189b      	adds	r3, r3, r2
 8028a22:	2200      	movs	r2, #0
 8028a24:	629a      	str	r2, [r3, #40]	; 0x28
                e_ret_status = CKR_FUNCTION_FAILED;
 8028a26:	2706      	movs	r7, #6
 8028a28:	e005      	b.n	8028a36 <sign_verify_init+0x186>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028a2a:	2782      	movs	r7, #130	; 0x82
 8028a2c:	e003      	b.n	8028a36 <sign_verify_init+0x186>
              e_ret_status = CKR_DEVICE_MEMORY;
 8028a2e:	2731      	movs	r7, #49	; 0x31
 8028a30:	e001      	b.n	8028a36 <sign_verify_init+0x186>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8028a32:	27c8      	movs	r7, #200	; 0xc8
 8028a34:	007f      	lsls	r7, r7, #1
    default:
      break;
  }

  return e_ret_status;
}
 8028a36:	0038      	movs	r0, r7
 8028a38:	b004      	add	sp, #16
 8028a3a:	bc80      	pop	{r7}
 8028a3c:	46ba      	mov	sl, r7
 8028a3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8028a40:	27b3      	movs	r7, #179	; 0xb3
 8028a42:	e7f8      	b.n	8028a36 <sign_verify_init+0x186>
    return CKR_SESSION_HANDLE_INVALID;
 8028a44:	27b3      	movs	r7, #179	; 0xb3
 8028a46:	e7f6      	b.n	8028a36 <sign_verify_init+0x186>
    return CKR_ARGUMENTS_BAD;
 8028a48:	2707      	movs	r7, #7
 8028a4a:	e7f4      	b.n	8028a36 <sign_verify_init+0x186>
 8028a4c:	2000a200 	.word	0x2000a200
 8028a50:	ffffef76 	.word	0xffffef76
 8028a54:	b10b0240 	.word	0xb10b0240
 8028a58:	b10b0003 	.word	0xb10b0003
 8028a5c:	0000108b 	.word	0x0000108b

08028a60 <KMS_SignInit>:
  *         @ref sign_verify_init returned values
  */
CK_RV     KMS_SignInit(CK_SESSION_HANDLE hSession,
                       CK_MECHANISM_PTR  pMechanism,
                       CK_OBJECT_HANDLE  hKey)
{
 8028a60:	b510      	push	{r4, lr}
 8028a62:	0004      	movs	r4, r0
#if defined(KMS_SIGN)
  CK_RV e_ret_status = sign_verify_init(hSession, pMechanism, hKey, KMS_FLAG_SIGN);
 8028a64:	2300      	movs	r3, #0
 8028a66:	f7ff ff23 	bl	80288b0 <sign_verify_init>

  if (e_ret_status == CKR_OK)
 8028a6a:	2800      	cmp	r0, #0
 8028a6c:	d107      	bne.n	8028a7e <KMS_SignInit+0x1e>
  {
    /* If successful, set processing state of the session */
    KMS_GETSESSION(hSession).state = KMS_SESSION_SIGN;
 8028a6e:	3c01      	subs	r4, #1
 8028a70:	00e3      	lsls	r3, r4, #3
 8028a72:	191c      	adds	r4, r3, r4
 8028a74:	00a4      	lsls	r4, r4, #2
 8028a76:	4b02      	ldr	r3, [pc, #8]	; (8028a80 <KMS_SignInit+0x20>)
 8028a78:	191c      	adds	r4, r3, r4
 8028a7a:	2304      	movs	r3, #4
 8028a7c:	60e3      	str	r3, [r4, #12]

  return e_ret_status;
#else /* KMS_SIGN */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SIGN */
}
 8028a7e:	bd10      	pop	{r4, pc}
 8028a80:	2000a200 	.word	0x2000a200

08028a84 <KMS_Sign>:
CK_RV     KMS_Sign(CK_SESSION_HANDLE hSession,         /* the session's handle */
                   CK_BYTE_PTR       pData,           /* the data to sign */
                   CK_ULONG          ulDataLen,       /* count of bytes to sign */
                   CK_BYTE_PTR       pSignature,      /* gets the signature */
                   CK_ULONG_PTR      pulSignatureLen)  /* gets signature length */
{
 8028a84:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028a86:	46d6      	mov	lr, sl
 8028a88:	b500      	push	{lr}
 8028a8a:	b082      	sub	sp, #8
 8028a8c:	0004      	movs	r4, r0
 8028a8e:	9100      	str	r1, [sp, #0]
 8028a90:	0017      	movs	r7, r2
 8028a92:	9301      	str	r3, [sp, #4]
#if defined(KMS_SIGN)
  CK_RV e_ret_status = CKR_OK;
  kms_obj_keyhead_t *pkms_object;

  if (!KMS_IS_INITIALIZED())
 8028a94:	4b42      	ldr	r3, [pc, #264]	; (8028ba0 <KMS_Sign+0x11c>)
 8028a96:	781b      	ldrb	r3, [r3, #0]
 8028a98:	2b00      	cmp	r3, #0
 8028a9a:	d076      	beq.n	8028b8a <KMS_Sign+0x106>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8028a9c:	f7fe fbba 	bl	8027214 <KMS_CheckSessionHdle>
 8028aa0:	1e05      	subs	r5, r0, #0
 8028aa2:	d000      	beq.n	8028aa6 <KMS_Sign+0x22>
 8028aa4:	e078      	b.n	8028b98 <KMS_Sign+0x114>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_SIGN)
 8028aa6:	1e66      	subs	r6, r4, #1
 8028aa8:	00f3      	lsls	r3, r6, #3
 8028aaa:	199b      	adds	r3, r3, r6
 8028aac:	009b      	lsls	r3, r3, #2
 8028aae:	4a3c      	ldr	r2, [pc, #240]	; (8028ba0 <KMS_Sign+0x11c>)
 8028ab0:	18d3      	adds	r3, r2, r3
 8028ab2:	68db      	ldr	r3, [r3, #12]
 8028ab4:	2b04      	cmp	r3, #4
 8028ab6:	d000      	beq.n	8028aba <KMS_Sign+0x36>
 8028ab8:	e070      	b.n	8028b9c <KMS_Sign+0x118>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  /* If a digest has to be computed */
  switch (KMS_GETSESSION(hSession).Mechanism)
 8028aba:	00f3      	lsls	r3, r6, #3
 8028abc:	199b      	adds	r3, r3, r6
 8028abe:	009b      	lsls	r3, r3, #2
 8028ac0:	18d3      	adds	r3, r2, r3
 8028ac2:	6a1b      	ldr	r3, [r3, #32]
 8028ac4:	4a37      	ldr	r2, [pc, #220]	; (8028ba4 <KMS_Sign+0x120>)
 8028ac6:	4694      	mov	ip, r2
 8028ac8:	4463      	add	r3, ip
 8028aca:	2b01      	cmp	r3, #1
 8028acc:	d918      	bls.n	8028b00 <KMS_Sign+0x7c>
    }
#endif /* KMS_AES_CMAC & KMS_FCT_SIGN */

    default:
    {
      e_ret_status = CKR_MECHANISM_INVALID;
 8028ace:	2570      	movs	r5, #112	; 0x70

  /* Upon completion error or not:
   * - free the allocated context
   * - release the session
   */
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8028ad0:	00f3      	lsls	r3, r6, #3
 8028ad2:	199b      	adds	r3, r3, r6
 8028ad4:	009b      	lsls	r3, r3, #2
 8028ad6:	4a32      	ldr	r2, [pc, #200]	; (8028ba0 <KMS_Sign+0x11c>)
 8028ad8:	18d3      	adds	r3, r2, r3
 8028ada:	2200      	movs	r2, #0
 8028adc:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8028ade:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8028ae0:	2900      	cmp	r1, #0
 8028ae2:	d009      	beq.n	8028af8 <KMS_Sign+0x74>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8028ae4:	0020      	movs	r0, r4
 8028ae6:	f7fe fd11 	bl	802750c <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028aea:	00f3      	lsls	r3, r6, #3
 8028aec:	199b      	adds	r3, r3, r6
 8028aee:	009b      	lsls	r3, r3, #2
 8028af0:	4a2b      	ldr	r2, [pc, #172]	; (8028ba0 <KMS_Sign+0x11c>)
 8028af2:	18d3      	adds	r3, r2, r3
 8028af4:	2200      	movs	r2, #0
 8028af6:	629a      	str	r2, [r3, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 8028af8:	0020      	movs	r0, r4
 8028afa:	f7fe fbd3 	bl	80272a4 <KMS_SetStateIdle>

  return e_ret_status;
 8028afe:	e046      	b.n	8028b8e <KMS_Sign+0x10a>
    pkms_object = KMS_Objects_GetPointer(KMS_GETSESSION(hSession).hKey);
 8028b00:	00f3      	lsls	r3, r6, #3
 8028b02:	199b      	adds	r3, r3, r6
 8028b04:	009b      	lsls	r3, r3, #2
 8028b06:	4a26      	ldr	r2, [pc, #152]	; (8028ba0 <KMS_Sign+0x11c>)
 8028b08:	18d3      	adds	r3, r2, r3
 8028b0a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8028b0c:	f7ff fb26 	bl	802815c <KMS_Objects_GetPointer>
    if ((pkms_object != NULL) &&
 8028b10:	2800      	cmp	r0, #0
 8028b12:	d038      	beq.n	8028b86 <KMS_Sign+0x102>
 8028b14:	4b24      	ldr	r3, [pc, #144]	; (8028ba8 <KMS_Sign+0x124>)
 8028b16:	6802      	ldr	r2, [r0, #0]
 8028b18:	429a      	cmp	r2, r3
 8028b1a:	d001      	beq.n	8028b20 <KMS_Sign+0x9c>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028b1c:	2582      	movs	r5, #130	; 0x82
 8028b1e:	e7d7      	b.n	8028ad0 <KMS_Sign+0x4c>
        (pkms_object->configuration == KMS_ABI_CONFIG_KEYHEAD))
 8028b20:	6842      	ldr	r2, [r0, #4]
        (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8028b22:	4b22      	ldr	r3, [pc, #136]	; (8028bac <KMS_Sign+0x128>)
 8028b24:	429a      	cmp	r2, r3
 8028b26:	d001      	beq.n	8028b2c <KMS_Sign+0xa8>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028b28:	2582      	movs	r5, #130	; 0x82
 8028b2a:	e7d1      	b.n	8028ad0 <KMS_Sign+0x4c>
      switch (KMS_GETSESSION(hSession).Mechanism)
 8028b2c:	00f3      	lsls	r3, r6, #3
 8028b2e:	199b      	adds	r3, r3, r6
 8028b30:	009b      	lsls	r3, r3, #2
 8028b32:	4a1b      	ldr	r2, [pc, #108]	; (8028ba0 <KMS_Sign+0x11c>)
 8028b34:	18d3      	adds	r3, r2, r3
 8028b36:	6a1b      	ldr	r3, [r3, #32]
 8028b38:	4a1a      	ldr	r2, [pc, #104]	; (8028ba4 <KMS_Sign+0x120>)
 8028b3a:	4694      	mov	ip, r2
 8028b3c:	4463      	add	r3, ip
 8028b3e:	2b01      	cmp	r3, #1
 8028b40:	d901      	bls.n	8028b46 <KMS_Sign+0xc2>
          e_ret_status = CKR_MECHANISM_INVALID;
 8028b42:	2570      	movs	r5, #112	; 0x70
 8028b44:	e7c4      	b.n	8028ad0 <KMS_Sign+0x4c>
          kms_aes_cmac_sv_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8028b46:	00f3      	lsls	r3, r6, #3
 8028b48:	199b      	adds	r3, r3, r6
 8028b4a:	009b      	lsls	r3, r3, #2
 8028b4c:	4a14      	ldr	r2, [pc, #80]	; (8028ba0 <KMS_Sign+0x11c>)
 8028b4e:	18d3      	adds	r3, r2, r3
 8028b50:	6a98      	ldr	r0, [r3, #40]	; 0x28
          p_ctx->ca_ctx.mFlags |= CA_E_SK_FINAL_APPEND;
 8028b52:	2238      	movs	r2, #56	; 0x38
 8028b54:	5c83      	ldrb	r3, [r0, r2]
 8028b56:	2120      	movs	r1, #32
 8028b58:	430b      	orrs	r3, r1
 8028b5a:	5483      	strb	r3, [r0, r2]
          if (CA_AES_CMAC_Encrypt_Append(&(p_ctx->ca_ctx),
 8028b5c:	2334      	movs	r3, #52	; 0x34
 8028b5e:	469a      	mov	sl, r3
 8028b60:	4482      	add	sl, r0
 8028b62:	003a      	movs	r2, r7
 8028b64:	9900      	ldr	r1, [sp, #0]
 8028b66:	4650      	mov	r0, sl
 8028b68:	f7fd f974 	bl	8025e54 <CA_AES_CMAC_Encrypt_Append>
 8028b6c:	2800      	cmp	r0, #0
 8028b6e:	d001      	beq.n	8028b74 <KMS_Sign+0xf0>
            e_ret_status = CKR_FUNCTION_FAILED;
 8028b70:	2506      	movs	r5, #6
 8028b72:	e7ad      	b.n	8028ad0 <KMS_Sign+0x4c>
            if (CA_AES_CMAC_Encrypt_Finish(&(p_ctx->ca_ctx),
 8028b74:	aa08      	add	r2, sp, #32
 8028b76:	9901      	ldr	r1, [sp, #4]
 8028b78:	4650      	mov	r0, sl
 8028b7a:	f7fd f991 	bl	8025ea0 <CA_AES_CMAC_Encrypt_Finish>
 8028b7e:	2800      	cmp	r0, #0
 8028b80:	d0a6      	beq.n	8028ad0 <KMS_Sign+0x4c>
              e_ret_status = CKR_FUNCTION_FAILED;
 8028b82:	2506      	movs	r5, #6
 8028b84:	e7a4      	b.n	8028ad0 <KMS_Sign+0x4c>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028b86:	2582      	movs	r5, #130	; 0x82
 8028b88:	e7a2      	b.n	8028ad0 <KMS_Sign+0x4c>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8028b8a:	25c8      	movs	r5, #200	; 0xc8
 8028b8c:	006d      	lsls	r5, r5, #1
#else /* KMS_SIGN */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SIGN */
}
 8028b8e:	0028      	movs	r0, r5
 8028b90:	b002      	add	sp, #8
 8028b92:	bc80      	pop	{r7}
 8028b94:	46ba      	mov	sl, r7
 8028b96:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8028b98:	25b3      	movs	r5, #179	; 0xb3
 8028b9a:	e7f8      	b.n	8028b8e <KMS_Sign+0x10a>
    return CKR_OPERATION_NOT_INITIALIZED;
 8028b9c:	2591      	movs	r5, #145	; 0x91
 8028b9e:	e7f6      	b.n	8028b8e <KMS_Sign+0x10a>
 8028ba0:	2000a200 	.word	0x2000a200
 8028ba4:	ffffef76 	.word	0xffffef76
 8028ba8:	b10b0240 	.word	0xb10b0240
 8028bac:	b10b0003 	.word	0xb10b0003

08028bb0 <KMS_VerifyInit>:
  *         @ref sign_verify_init returned values
  */
CK_RV        KMS_VerifyInit(CK_SESSION_HANDLE hSession,
                            CK_MECHANISM_PTR  pMechanism,
                            CK_OBJECT_HANDLE  hKey)
{
 8028bb0:	b510      	push	{r4, lr}
 8028bb2:	0004      	movs	r4, r0
#if defined(KMS_VERIFY)
  CK_RV e_ret_status = sign_verify_init(hSession, pMechanism, hKey, KMS_FLAG_VERIFY);
 8028bb4:	2301      	movs	r3, #1
 8028bb6:	f7ff fe7b 	bl	80288b0 <sign_verify_init>

  if (e_ret_status == CKR_OK)
 8028bba:	2800      	cmp	r0, #0
 8028bbc:	d107      	bne.n	8028bce <KMS_VerifyInit+0x1e>
  {
    /* If successful, set processing state of the session */
    KMS_GETSESSION(hSession).state = KMS_SESSION_VERIFY;
 8028bbe:	3c01      	subs	r4, #1
 8028bc0:	00e3      	lsls	r3, r4, #3
 8028bc2:	191c      	adds	r4, r3, r4
 8028bc4:	00a4      	lsls	r4, r4, #2
 8028bc6:	4b02      	ldr	r3, [pc, #8]	; (8028bd0 <KMS_VerifyInit+0x20>)
 8028bc8:	191c      	adds	r4, r3, r4
 8028bca:	2305      	movs	r3, #5
 8028bcc:	60e3      	str	r3, [r4, #12]

  return e_ret_status;
#else /* KMS_VERIFY */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_VERIFY */
}
 8028bce:	bd10      	pop	{r4, pc}
 8028bd0:	2000a200 	.word	0x2000a200

08028bd4 <KMS_Verify>:
                  CK_BYTE_PTR       pData,           /* signed data */
                  CK_ULONG          ulDataLen,       /* length of signed data */
                  CK_BYTE_PTR       pSignature,      /* signature */
                  CK_ULONG          ulSignatureLen)  /* signature length */

{
 8028bd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028bd6:	46de      	mov	lr, fp
 8028bd8:	4657      	mov	r7, sl
 8028bda:	b580      	push	{r7, lr}
 8028bdc:	b083      	sub	sp, #12
 8028bde:	0004      	movs	r4, r0
 8028be0:	9100      	str	r1, [sp, #0]
 8028be2:	9201      	str	r2, [sp, #4]
 8028be4:	001d      	movs	r5, r3
#if defined(KMS_VERIFY)
  CK_RV    e_ret_status ;
  kms_obj_keyhead_t *pkms_object;

  if (!KMS_IS_INITIALIZED())
 8028be6:	4b47      	ldr	r3, [pc, #284]	; (8028d04 <KMS_Verify+0x130>)
 8028be8:	781b      	ldrb	r3, [r3, #0]
 8028bea:	2b00      	cmp	r3, #0
 8028bec:	d07d      	beq.n	8028cea <KMS_Verify+0x116>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8028bee:	f7fe fb11 	bl	8027214 <KMS_CheckSessionHdle>
 8028bf2:	1e06      	subs	r6, r0, #0
 8028bf4:	d000      	beq.n	8028bf8 <KMS_Verify+0x24>
 8028bf6:	e080      	b.n	8028cfa <KMS_Verify+0x126>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_VERIFY)
 8028bf8:	1e67      	subs	r7, r4, #1
 8028bfa:	00fb      	lsls	r3, r7, #3
 8028bfc:	19db      	adds	r3, r3, r7
 8028bfe:	009b      	lsls	r3, r3, #2
 8028c00:	4a40      	ldr	r2, [pc, #256]	; (8028d04 <KMS_Verify+0x130>)
 8028c02:	18d3      	adds	r3, r2, r3
 8028c04:	68db      	ldr	r3, [r3, #12]
 8028c06:	2b05      	cmp	r3, #5
 8028c08:	d000      	beq.n	8028c0c <KMS_Verify+0x38>
 8028c0a:	e078      	b.n	8028cfe <KMS_Verify+0x12a>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  /* If a digest has to be computed */
  switch (KMS_GETSESSION(hSession).Mechanism)
 8028c0c:	00fb      	lsls	r3, r7, #3
 8028c0e:	19db      	adds	r3, r3, r7
 8028c10:	009b      	lsls	r3, r3, #2
 8028c12:	18d3      	adds	r3, r2, r3
 8028c14:	6a1b      	ldr	r3, [r3, #32]
 8028c16:	4a3c      	ldr	r2, [pc, #240]	; (8028d08 <KMS_Verify+0x134>)
 8028c18:	4694      	mov	ip, r2
 8028c1a:	4463      	add	r3, ip
 8028c1c:	2b01      	cmp	r3, #1
 8028c1e:	d918      	bls.n	8028c52 <KMS_Verify+0x7e>
    }
#endif /* KMS_AES_CMAC & KMS_FCT_VERIFY */

    default:
    {
      e_ret_status = CKR_FUNCTION_FAILED;
 8028c20:	2606      	movs	r6, #6

  /* Upon completion error or not:
   * - free the allocated context
   * - release the session
   */
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8028c22:	00fb      	lsls	r3, r7, #3
 8028c24:	19db      	adds	r3, r3, r7
 8028c26:	009b      	lsls	r3, r3, #2
 8028c28:	4a36      	ldr	r2, [pc, #216]	; (8028d04 <KMS_Verify+0x130>)
 8028c2a:	18d3      	adds	r3, r2, r3
 8028c2c:	2200      	movs	r2, #0
 8028c2e:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8028c30:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8028c32:	2900      	cmp	r1, #0
 8028c34:	d009      	beq.n	8028c4a <KMS_Verify+0x76>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8028c36:	0020      	movs	r0, r4
 8028c38:	f7fe fc68 	bl	802750c <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028c3c:	00fb      	lsls	r3, r7, #3
 8028c3e:	19db      	adds	r3, r3, r7
 8028c40:	009b      	lsls	r3, r3, #2
 8028c42:	4a30      	ldr	r2, [pc, #192]	; (8028d04 <KMS_Verify+0x130>)
 8028c44:	18d3      	adds	r3, r2, r3
 8028c46:	2200      	movs	r2, #0
 8028c48:	629a      	str	r2, [r3, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 8028c4a:	0020      	movs	r0, r4
 8028c4c:	f7fe fb2a 	bl	80272a4 <KMS_SetStateIdle>

  return e_ret_status;
 8028c50:	e04d      	b.n	8028cee <KMS_Verify+0x11a>
    pkms_object = KMS_Objects_GetPointer(KMS_GETSESSION(hSession).hKey);
 8028c52:	00fb      	lsls	r3, r7, #3
 8028c54:	19db      	adds	r3, r3, r7
 8028c56:	009b      	lsls	r3, r3, #2
 8028c58:	4a2a      	ldr	r2, [pc, #168]	; (8028d04 <KMS_Verify+0x130>)
 8028c5a:	18d3      	adds	r3, r2, r3
 8028c5c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8028c5e:	f7ff fa7d 	bl	802815c <KMS_Objects_GetPointer>
    if ((pkms_object != NULL) &&
 8028c62:	2800      	cmp	r0, #0
 8028c64:	d03f      	beq.n	8028ce6 <KMS_Verify+0x112>
 8028c66:	4b29      	ldr	r3, [pc, #164]	; (8028d0c <KMS_Verify+0x138>)
 8028c68:	6802      	ldr	r2, [r0, #0]
 8028c6a:	429a      	cmp	r2, r3
 8028c6c:	d001      	beq.n	8028c72 <KMS_Verify+0x9e>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028c6e:	2682      	movs	r6, #130	; 0x82
 8028c70:	e7d7      	b.n	8028c22 <KMS_Verify+0x4e>
        (pkms_object->configuration == KMS_ABI_CONFIG_KEYHEAD))
 8028c72:	6842      	ldr	r2, [r0, #4]
        (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8028c74:	4b26      	ldr	r3, [pc, #152]	; (8028d10 <KMS_Verify+0x13c>)
 8028c76:	429a      	cmp	r2, r3
 8028c78:	d001      	beq.n	8028c7e <KMS_Verify+0xaa>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028c7a:	2682      	movs	r6, #130	; 0x82
 8028c7c:	e7d1      	b.n	8028c22 <KMS_Verify+0x4e>
      switch (KMS_GETSESSION(hSession).Mechanism)
 8028c7e:	00fb      	lsls	r3, r7, #3
 8028c80:	19db      	adds	r3, r3, r7
 8028c82:	009b      	lsls	r3, r3, #2
 8028c84:	4a1f      	ldr	r2, [pc, #124]	; (8028d04 <KMS_Verify+0x130>)
 8028c86:	18d3      	adds	r3, r2, r3
 8028c88:	6a1b      	ldr	r3, [r3, #32]
 8028c8a:	4a1f      	ldr	r2, [pc, #124]	; (8028d08 <KMS_Verify+0x134>)
 8028c8c:	4694      	mov	ip, r2
 8028c8e:	4463      	add	r3, ip
 8028c90:	2b01      	cmp	r3, #1
 8028c92:	d901      	bls.n	8028c98 <KMS_Verify+0xc4>
          e_ret_status = CKR_FUNCTION_FAILED;
 8028c94:	2606      	movs	r6, #6
 8028c96:	e7c4      	b.n	8028c22 <KMS_Verify+0x4e>
          kms_aes_cmac_sv_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8028c98:	00fb      	lsls	r3, r7, #3
 8028c9a:	19db      	adds	r3, r3, r7
 8028c9c:	009b      	lsls	r3, r3, #2
 8028c9e:	4a19      	ldr	r2, [pc, #100]	; (8028d04 <KMS_Verify+0x130>)
 8028ca0:	18d3      	adds	r3, r2, r3
 8028ca2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8028ca4:	469a      	mov	sl, r3
          p_ctx->ca_ctx.mFlags |= CA_E_SK_FINAL_APPEND;
 8028ca6:	2238      	movs	r2, #56	; 0x38
 8028ca8:	5c9b      	ldrb	r3, [r3, r2]
 8028caa:	2120      	movs	r1, #32
 8028cac:	430b      	orrs	r3, r1
 8028cae:	4651      	mov	r1, sl
 8028cb0:	548b      	strb	r3, [r1, r2]
          if (CA_AES_CMAC_Decrypt_Append(&(p_ctx->ca_ctx),
 8028cb2:	2334      	movs	r3, #52	; 0x34
 8028cb4:	4453      	add	r3, sl
 8028cb6:	469b      	mov	fp, r3
 8028cb8:	9a01      	ldr	r2, [sp, #4]
 8028cba:	9900      	ldr	r1, [sp, #0]
 8028cbc:	0018      	movs	r0, r3
 8028cbe:	f7fd f92b 	bl	8025f18 <CA_AES_CMAC_Decrypt_Append>
 8028cc2:	2800      	cmp	r0, #0
 8028cc4:	d001      	beq.n	8028cca <KMS_Verify+0xf6>
            e_ret_status = CKR_FUNCTION_FAILED;
 8028cc6:	2606      	movs	r6, #6
 8028cc8:	e7ab      	b.n	8028c22 <KMS_Verify+0x4e>
          p_ctx->ca_ctx.mTagSize = (int32_t)ulSignatureLen;
 8028cca:	4653      	mov	r3, sl
 8028ccc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8028cce:	665a      	str	r2, [r3, #100]	; 0x64
          p_ctx->ca_ctx.pmTag = pSignature;
 8028cd0:	661d      	str	r5, [r3, #96]	; 0x60
          if (CA_AES_CMAC_Decrypt_Finish(&(p_ctx->ca_ctx),
 8028cd2:	aa0a      	add	r2, sp, #40	; 0x28
 8028cd4:	0029      	movs	r1, r5
 8028cd6:	4658      	mov	r0, fp
 8028cd8:	f7fd f944 	bl	8025f64 <CA_AES_CMAC_Decrypt_Finish>
 8028cdc:	4b0d      	ldr	r3, [pc, #52]	; (8028d14 <KMS_Verify+0x140>)
 8028cde:	4298      	cmp	r0, r3
 8028ce0:	d09f      	beq.n	8028c22 <KMS_Verify+0x4e>
            e_ret_status = CKR_SIGNATURE_INVALID;
 8028ce2:	26c0      	movs	r6, #192	; 0xc0
 8028ce4:	e79d      	b.n	8028c22 <KMS_Verify+0x4e>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028ce6:	2682      	movs	r6, #130	; 0x82
 8028ce8:	e79b      	b.n	8028c22 <KMS_Verify+0x4e>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8028cea:	26c8      	movs	r6, #200	; 0xc8
 8028cec:	0076      	lsls	r6, r6, #1

#else /* KMS_VERIFY */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_VERIFY */
}
 8028cee:	0030      	movs	r0, r6
 8028cf0:	b003      	add	sp, #12
 8028cf2:	bcc0      	pop	{r6, r7}
 8028cf4:	46bb      	mov	fp, r7
 8028cf6:	46b2      	mov	sl, r6
 8028cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8028cfa:	26b3      	movs	r6, #179	; 0xb3
 8028cfc:	e7f7      	b.n	8028cee <KMS_Verify+0x11a>
    return CKR_OPERATION_NOT_INITIALIZED;
 8028cfe:	2691      	movs	r6, #145	; 0x91
 8028d00:	e7f5      	b.n	8028cee <KMS_Verify+0x11a>
 8028d02:	46c0      	nop			; (mov r8, r8)
 8028d04:	2000a200 	.word	0x2000a200
 8028d08:	ffffef76 	.word	0xffffef76
 8028d0c:	b10b0240 	.word	0xb10b0240
 8028d10:	b10b0003 	.word	0xb10b0003
 8028d14:	000003eb 	.word	0x000003eb

08028d18 <LmHandlerPackageIsInitialized>:
        return LORAMAC_HANDLER_ERROR;
    }
}

static bool LmHandlerPackageIsInitialized( uint8_t id )
{
 8028d18:	b510      	push	{r4, lr}
    if (( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ))
 8028d1a:	2804      	cmp	r0, #4
 8028d1c:	d807      	bhi.n	8028d2e <LmHandlerPackageIsInitialized+0x16>
 8028d1e:	0080      	lsls	r0, r0, #2
 8028d20:	4b05      	ldr	r3, [pc, #20]	; (8028d38 <LmHandlerPackageIsInitialized+0x20>)
 8028d22:	58c3      	ldr	r3, [r0, r3]
 8028d24:	689b      	ldr	r3, [r3, #8]
 8028d26:	2b00      	cmp	r3, #0
 8028d28:	d003      	beq.n	8028d32 <LmHandlerPackageIsInitialized+0x1a>
    {
        return LmHandlerPackages[id]->IsInitialized( );
 8028d2a:	4798      	blx	r3
    }
    else
    {
        return false;
    }
}
 8028d2c:	bd10      	pop	{r4, pc}
        return false;
 8028d2e:	2000      	movs	r0, #0
 8028d30:	e7fc      	b.n	8028d2c <LmHandlerPackageIsInitialized+0x14>
 8028d32:	2000      	movs	r0, #0
 8028d34:	e7fa      	b.n	8028d2c <LmHandlerPackageIsInitialized+0x14>
 8028d36:	46c0      	nop			; (mov r8, r8)
 8028d38:	2000a4a0 	.word	0x2000a4a0

08028d3c <LmHandlerPackagesNotify>:

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
 8028d3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028d3e:	0006      	movs	r6, r0
 8028d40:	000f      	movs	r7, r1
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8028d42:	2400      	movs	r4, #0
 8028d44:	e01c      	b.n	8028d80 <LmHandlerPackagesNotify+0x44>
                    }
                    break;
                }
                case PACKAGE_MCPS_INDICATION:
                {
                    if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 8028d46:	69da      	ldr	r2, [r3, #28]
 8028d48:	2a00      	cmp	r2, #0
 8028d4a:	d017      	beq.n	8028d7c <LmHandlerPackagesNotify+0x40>
                        ( ( LmHandlerPackages[i]->Port == ((McpsIndication_t* )params)->Port ) ||
 8028d4c:	781a      	ldrb	r2, [r3, #0]
 8028d4e:	78fb      	ldrb	r3, [r7, #3]
                    if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 8028d50:	429a      	cmp	r2, r3
 8028d52:	d007      	beq.n	8028d64 <LmHandlerPackagesNotify+0x28>
                        ( ( LmHandlerPackages[i]->Port == ((McpsIndication_t* )params)->Port ) ||
 8028d54:	2c00      	cmp	r4, #0
 8028d56:	d111      	bne.n	8028d7c <LmHandlerPackagesNotify+0x40>
                          ( ( i == PACKAGE_ID_COMPLIANCE ) && ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning() ))))
 8028d58:	4b14      	ldr	r3, [pc, #80]	; (8028dac <LmHandlerPackagesNotify+0x70>)
 8028d5a:	681b      	ldr	r3, [r3, #0]
 8028d5c:	68db      	ldr	r3, [r3, #12]
 8028d5e:	4798      	blx	r3
 8028d60:	2800      	cmp	r0, #0
 8028d62:	d00b      	beq.n	8028d7c <LmHandlerPackagesNotify+0x40>
                    {
                        LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t* )params );
 8028d64:	00ad      	lsls	r5, r5, #2
 8028d66:	4b11      	ldr	r3, [pc, #68]	; (8028dac <LmHandlerPackagesNotify+0x70>)
 8028d68:	58eb      	ldr	r3, [r5, r3]
 8028d6a:	69db      	ldr	r3, [r3, #28]
 8028d6c:	0038      	movs	r0, r7
 8028d6e:	4798      	blx	r3
 8028d70:	e004      	b.n	8028d7c <LmHandlerPackagesNotify+0x40>
                    }
                    break;
                }
                case PACKAGE_MLME_CONFIRM:
                {
                    if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 8028d72:	6a1b      	ldr	r3, [r3, #32]
 8028d74:	2b00      	cmp	r3, #0
 8028d76:	d001      	beq.n	8028d7c <LmHandlerPackagesNotify+0x40>
                    {
                        LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t* )params );
 8028d78:	0038      	movs	r0, r7
 8028d7a:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8028d7c:	3401      	adds	r4, #1
 8028d7e:	b264      	sxtb	r4, r4
 8028d80:	2c04      	cmp	r4, #4
 8028d82:	dc11      	bgt.n	8028da8 <LmHandlerPackagesNotify+0x6c>
        if( LmHandlerPackages[i] != NULL )
 8028d84:	0025      	movs	r5, r4
 8028d86:	00a3      	lsls	r3, r4, #2
 8028d88:	4a08      	ldr	r2, [pc, #32]	; (8028dac <LmHandlerPackagesNotify+0x70>)
 8028d8a:	589b      	ldr	r3, [r3, r2]
 8028d8c:	2b00      	cmp	r3, #0
 8028d8e:	d0f5      	beq.n	8028d7c <LmHandlerPackagesNotify+0x40>
            switch( notifyType )
 8028d90:	2e01      	cmp	r6, #1
 8028d92:	d0d8      	beq.n	8028d46 <LmHandlerPackagesNotify+0xa>
 8028d94:	2e02      	cmp	r6, #2
 8028d96:	d0ec      	beq.n	8028d72 <LmHandlerPackagesNotify+0x36>
 8028d98:	2e00      	cmp	r6, #0
 8028d9a:	d1ef      	bne.n	8028d7c <LmHandlerPackagesNotify+0x40>
                    if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 8028d9c:	699b      	ldr	r3, [r3, #24]
 8028d9e:	2b00      	cmp	r3, #0
 8028da0:	d0ec      	beq.n	8028d7c <LmHandlerPackagesNotify+0x40>
                        LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t* ) params );
 8028da2:	0038      	movs	r0, r7
 8028da4:	4798      	blx	r3
 8028da6:	e7e9      	b.n	8028d7c <LmHandlerPackagesNotify+0x40>
                    break;
                }
            }
        }
    }
}
 8028da8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8028daa:	46c0      	nop			; (mov r8, r8)
 8028dac:	2000a4a0 	.word	0x2000a4a0

08028db0 <McpsConfirm>:
{
 8028db0:	b510      	push	{r4, lr}
 8028db2:	0004      	movs	r4, r0
    TxParams.IsMcpsConfirm = 1;
 8028db4:	480c      	ldr	r0, [pc, #48]	; (8028de8 <McpsConfirm+0x38>)
 8028db6:	2301      	movs	r3, #1
 8028db8:	7003      	strb	r3, [r0, #0]
    TxParams.Status = mcpsConfirm->Status;
 8028dba:	7863      	ldrb	r3, [r4, #1]
 8028dbc:	7043      	strb	r3, [r0, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 8028dbe:	2302      	movs	r3, #2
 8028dc0:	56e3      	ldrsb	r3, [r4, r3]
 8028dc2:	7103      	strb	r3, [r0, #4]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 8028dc4:	68e3      	ldr	r3, [r4, #12]
 8028dc6:	6083      	str	r3, [r0, #8]
    TxParams.TxPower = mcpsConfirm->TxPower;
 8028dc8:	2303      	movs	r3, #3
 8028dca:	56e3      	ldrsb	r3, [r4, r3]
 8028dcc:	7503      	strb	r3, [r0, #20]
    TxParams.Channel = mcpsConfirm->Channel;
 8028dce:	6923      	ldr	r3, [r4, #16]
 8028dd0:	7543      	strb	r3, [r0, #21]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 8028dd2:	7923      	ldrb	r3, [r4, #4]
 8028dd4:	70c3      	strb	r3, [r0, #3]
    LmHandlerCallbacks->OnTxData( &TxParams );
 8028dd6:	4b05      	ldr	r3, [pc, #20]	; (8028dec <McpsConfirm+0x3c>)
 8028dd8:	681b      	ldr	r3, [r3, #0]
 8028dda:	6a1b      	ldr	r3, [r3, #32]
 8028ddc:	4798      	blx	r3
    LmHandlerPackagesNotify( PACKAGE_MCPS_CONFIRM, mcpsConfirm );
 8028dde:	0021      	movs	r1, r4
 8028de0:	2000      	movs	r0, #0
 8028de2:	f7ff ffab 	bl	8028d3c <LmHandlerPackagesNotify>
}
 8028de6:	bd10      	pop	{r4, pc}
 8028de8:	2000a4e8 	.word	0x2000a4e8
 8028dec:	2000a49c 	.word	0x2000a49c

08028df0 <LmHandlerPackagesProcess>:

static void LmHandlerPackagesProcess( void )
{
 8028df0:	b570      	push	{r4, r5, r6, lr}
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8028df2:	2400      	movs	r4, #0
 8028df4:	e001      	b.n	8028dfa <LmHandlerPackagesProcess+0xa>
 8028df6:	3401      	adds	r4, #1
 8028df8:	b264      	sxtb	r4, r4
 8028dfa:	2c04      	cmp	r4, #4
 8028dfc:	dc12      	bgt.n	8028e24 <LmHandlerPackagesProcess+0x34>
    {
        if( ( LmHandlerPackages[i] != NULL ) &&
 8028dfe:	00a3      	lsls	r3, r4, #2
 8028e00:	4a09      	ldr	r2, [pc, #36]	; (8028e28 <LmHandlerPackagesProcess+0x38>)
 8028e02:	589b      	ldr	r3, [r3, r2]
 8028e04:	2b00      	cmp	r3, #0
 8028e06:	d0f6      	beq.n	8028df6 <LmHandlerPackagesProcess+0x6>
            ( LmHandlerPackages[i]->Process != NULL ) &&
 8028e08:	691b      	ldr	r3, [r3, #16]
        if( ( LmHandlerPackages[i] != NULL ) &&
 8028e0a:	2b00      	cmp	r3, #0
 8028e0c:	d0f3      	beq.n	8028df6 <LmHandlerPackagesProcess+0x6>
            ( LmHandlerPackageIsInitialized( i ) != false ) )
 8028e0e:	b2e0      	uxtb	r0, r4
 8028e10:	f7ff ff82 	bl	8028d18 <LmHandlerPackageIsInitialized>
            ( LmHandlerPackages[i]->Process != NULL ) &&
 8028e14:	2800      	cmp	r0, #0
 8028e16:	d0ee      	beq.n	8028df6 <LmHandlerPackagesProcess+0x6>
        {
            LmHandlerPackages[i]->Process( );
 8028e18:	00a5      	lsls	r5, r4, #2
 8028e1a:	4b03      	ldr	r3, [pc, #12]	; (8028e28 <LmHandlerPackagesProcess+0x38>)
 8028e1c:	58eb      	ldr	r3, [r5, r3]
 8028e1e:	691b      	ldr	r3, [r3, #16]
 8028e20:	4798      	blx	r3
 8028e22:	e7e8      	b.n	8028df6 <LmHandlerPackagesProcess+0x6>
        }
    }
}
 8028e24:	bd70      	pop	{r4, r5, r6, pc}
 8028e26:	46c0      	nop			; (mov r8, r8)
 8028e28:	2000a4a0 	.word	0x2000a4a0

08028e2c <DisplayClassUpdate>:
        return LORAMAC_HANDLER_ERROR;
    }
}

static void DisplayClassUpdate(DeviceClass_t deviceClass)
{
 8028e2c:	b500      	push	{lr}
 8028e2e:	b083      	sub	sp, #12
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8028e30:	4b05      	ldr	r3, [pc, #20]	; (8028e48 <DisplayClassUpdate+0x1c>)
 8028e32:	5c1b      	ldrb	r3, [r3, r0]
 8028e34:	9300      	str	r3, [sp, #0]
 8028e36:	4b05      	ldr	r3, [pc, #20]	; (8028e4c <DisplayClassUpdate+0x20>)
 8028e38:	2200      	movs	r2, #0
 8028e3a:	2100      	movs	r1, #0
 8028e3c:	2002      	movs	r0, #2
 8028e3e:	f00a fe3b 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 8028e42:	b003      	add	sp, #12
 8028e44:	bd00      	pop	{pc}
 8028e46:	46c0      	nop			; (mov r8, r8)
 8028e48:	08034d14 	.word	0x08034d14
 8028e4c:	08034cf8 	.word	0x08034cf8

08028e50 <LmHandlerSetSystemMaxRxError>:
{
 8028e50:	b500      	push	{lr}
 8028e52:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 8028e54:	ab01      	add	r3, sp, #4
 8028e56:	2222      	movs	r2, #34	; 0x22
 8028e58:	701a      	strb	r2, [r3, #0]
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 8028e5a:	9002      	str	r0, [sp, #8]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8028e5c:	0018      	movs	r0, r3
 8028e5e:	f003 ff75 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8028e62:	2800      	cmp	r0, #0
 8028e64:	d101      	bne.n	8028e6a <LmHandlerSetSystemMaxRxError+0x1a>
}
 8028e66:	b00b      	add	sp, #44	; 0x2c
 8028e68:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8028e6a:	2001      	movs	r0, #1
 8028e6c:	4240      	negs	r0, r0
 8028e6e:	e7fa      	b.n	8028e66 <LmHandlerSetSystemMaxRxError+0x16>

08028e70 <LmHandlerDeviceTimeReq>:
{
 8028e70:	b500      	push	{lr}
 8028e72:	b087      	sub	sp, #28
    mlmeReq.Type = MLME_DEVICE_TIME;
 8028e74:	a801      	add	r0, sp, #4
 8028e76:	230a      	movs	r3, #10
 8028e78:	7003      	strb	r3, [r0, #0]
    status = LoRaMacMlmeRequest( &mlmeReq );
 8028e7a:	f004 f9ad 	bl	802d1d8 <LoRaMacMlmeRequest>
    if( status == LORAMAC_STATUS_OK )
 8028e7e:	2800      	cmp	r0, #0
 8028e80:	d101      	bne.n	8028e86 <LmHandlerDeviceTimeReq+0x16>
}
 8028e82:	b007      	add	sp, #28
 8028e84:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8028e86:	2001      	movs	r0, #1
 8028e88:	4240      	negs	r0, r0
 8028e8a:	e7fa      	b.n	8028e82 <LmHandlerDeviceTimeReq+0x12>

08028e8c <LmHandlerConfigure>:
{
 8028e8c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028e8e:	46ce      	mov	lr, r9
 8028e90:	4647      	mov	r7, r8
 8028e92:	b580      	push	{r7, lr}
 8028e94:	b095      	sub	sp, #84	; 0x54
 8028e96:	0001      	movs	r1, r0
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 8028e98:	4c62      	ldr	r4, [pc, #392]	; (8029024 <LmHandlerConfigure+0x198>)
 8028e9a:	2210      	movs	r2, #16
 8028e9c:	0020      	movs	r0, r4
 8028e9e:	f00a ff23 	bl	8033ce8 <UTIL_MEM_cpy_8>
    loraInfo = LoraInfo_GetPtr();
 8028ea2:	f7f9 fab9 	bl	8022418 <LoraInfo_GetPtr>
    if (0U != ((1 << (LmHandlerParams.ActiveRegion)) & (loraInfo->Region)))
 8028ea6:	7822      	ldrb	r2, [r4, #0]
 8028ea8:	2301      	movs	r3, #1
 8028eaa:	4093      	lsls	r3, r2
 8028eac:	6841      	ldr	r1, [r0, #4]
 8028eae:	4219      	tst	r1, r3
 8028eb0:	d100      	bne.n	8028eb4 <LmHandlerConfigure+0x28>
 8028eb2:	e0a8      	b.n	8029006 <LmHandlerConfigure+0x17a>
        if (LoRaMacInitialization(&LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion) != LORAMAC_STATUS_OK)
 8028eb4:	495c      	ldr	r1, [pc, #368]	; (8029028 <LmHandlerConfigure+0x19c>)
 8028eb6:	485d      	ldr	r0, [pc, #372]	; (802902c <LmHandlerConfigure+0x1a0>)
 8028eb8:	f003 fbf6 	bl	802c6a8 <LoRaMacInitialization>
 8028ebc:	2800      	cmp	r0, #0
 8028ebe:	d000      	beq.n	8028ec2 <LmHandlerConfigure+0x36>
 8028ec0:	e0ac      	b.n	802901c <LmHandlerConfigure+0x190>
    nbNvmData = NvmDataMgmtRestore( );
 8028ec2:	f005 fc0b 	bl	802e6dc <NvmDataMgmtRestore>
    if( nbNvmData > 0 )
 8028ec6:	2800      	cmp	r0, #0
 8028ec8:	d100      	bne.n	8028ecc <LmHandlerConfigure+0x40>
 8028eca:	e0a3      	b.n	8029014 <LmHandlerConfigure+0x188>
        CtxRestoreDone = true;
 8028ecc:	4b58      	ldr	r3, [pc, #352]	; (8029030 <LmHandlerConfigure+0x1a4>)
 8028ece:	2201      	movs	r2, #1
 8028ed0:	701a      	strb	r2, [r3, #0]
    mibReq.Type = MIB_DEV_EUI;
 8028ed2:	ad0b      	add	r5, sp, #44	; 0x2c
 8028ed4:	2302      	movs	r3, #2
 8028ed6:	702b      	strb	r3, [r5, #0]
    LoRaMacMibGetRequestConfirm( &mibReq );
 8028ed8:	0028      	movs	r0, r5
 8028eda:	f003 fe51 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 8028ede:	4c55      	ldr	r4, [pc, #340]	; (8029034 <LmHandlerConfigure+0x1a8>)
 8028ee0:	2208      	movs	r2, #8
 8028ee2:	6869      	ldr	r1, [r5, #4]
 8028ee4:	0020      	movs	r0, r4
 8028ee6:	f008 fc58 	bl	803179a <memcpy1>
    mibReq.Type = MIB_JOIN_EUI;
 8028eea:	2303      	movs	r3, #3
 8028eec:	702b      	strb	r3, [r5, #0]
    LoRaMacMibGetRequestConfirm( &mibReq );
 8028eee:	0028      	movs	r0, r5
 8028ef0:	f003 fe46 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.JoinEui, mibReq.Param.JoinEui, 8 );
 8028ef4:	0020      	movs	r0, r4
 8028ef6:	3008      	adds	r0, #8
 8028ef8:	2208      	movs	r2, #8
 8028efa:	6869      	ldr	r1, [r5, #4]
 8028efc:	f008 fc4d 	bl	803179a <memcpy1>
    CommissioningParams.DevAddr = LmHandlerCallbacks->GetDevAddr();
 8028f00:	4b4d      	ldr	r3, [pc, #308]	; (8029038 <LmHandlerConfigure+0x1ac>)
 8028f02:	681b      	ldr	r3, [r3, #0]
 8028f04:	68db      	ldr	r3, [r3, #12]
 8028f06:	4798      	blx	r3
 8028f08:	6160      	str	r0, [r4, #20]
    mibReq.Type = MIB_DEV_ADDR;
 8028f0a:	2306      	movs	r3, #6
 8028f0c:	702b      	strb	r3, [r5, #0]
    mibReq.Param.DevAddr = CommissioningParams.DevAddr;
 8028f0e:	6068      	str	r0, [r5, #4]
    LoRaMacMibSetRequestConfirm(&mibReq);
 8028f10:	0028      	movs	r0, r5
 8028f12:	f003 ff1b 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 8028f16:	7823      	ldrb	r3, [r4, #0]
 8028f18:	4699      	mov	r9, r3
 8028f1a:	7862      	ldrb	r2, [r4, #1]
 8028f1c:	78a1      	ldrb	r1, [r4, #2]
 8028f1e:	78e0      	ldrb	r0, [r4, #3]
 8028f20:	7926      	ldrb	r6, [r4, #4]
 8028f22:	7967      	ldrb	r7, [r4, #5]
 8028f24:	79a3      	ldrb	r3, [r4, #6]
 8028f26:	469c      	mov	ip, r3
 8028f28:	79e3      	ldrb	r3, [r4, #7]
 8028f2a:	9307      	str	r3, [sp, #28]
 8028f2c:	4663      	mov	r3, ip
 8028f2e:	9306      	str	r3, [sp, #24]
 8028f30:	9705      	str	r7, [sp, #20]
 8028f32:	9604      	str	r6, [sp, #16]
 8028f34:	9003      	str	r0, [sp, #12]
 8028f36:	9102      	str	r1, [sp, #8]
 8028f38:	9201      	str	r2, [sp, #4]
 8028f3a:	464b      	mov	r3, r9
 8028f3c:	9300      	str	r3, [sp, #0]
 8028f3e:	4b3f      	ldr	r3, [pc, #252]	; (802903c <LmHandlerConfigure+0x1b0>)
 8028f40:	2200      	movs	r2, #0
 8028f42:	2100      	movs	r1, #0
 8028f44:	2002      	movs	r0, #2
 8028f46:	f00a fdb7 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### AppEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 8028f4a:	7a23      	ldrb	r3, [r4, #8]
 8028f4c:	4699      	mov	r9, r3
 8028f4e:	7a62      	ldrb	r2, [r4, #9]
 8028f50:	7aa1      	ldrb	r1, [r4, #10]
 8028f52:	7ae0      	ldrb	r0, [r4, #11]
 8028f54:	7b26      	ldrb	r6, [r4, #12]
 8028f56:	7b67      	ldrb	r7, [r4, #13]
 8028f58:	7ba3      	ldrb	r3, [r4, #14]
 8028f5a:	469c      	mov	ip, r3
 8028f5c:	7be3      	ldrb	r3, [r4, #15]
 8028f5e:	9307      	str	r3, [sp, #28]
 8028f60:	4663      	mov	r3, ip
 8028f62:	9306      	str	r3, [sp, #24]
 8028f64:	9705      	str	r7, [sp, #20]
 8028f66:	9604      	str	r6, [sp, #16]
 8028f68:	9003      	str	r0, [sp, #12]
 8028f6a:	9102      	str	r1, [sp, #8]
 8028f6c:	9201      	str	r2, [sp, #4]
 8028f6e:	464b      	mov	r3, r9
 8028f70:	9300      	str	r3, [sp, #0]
 8028f72:	4b33      	ldr	r3, [pc, #204]	; (8029040 <LmHandlerConfigure+0x1b4>)
 8028f74:	2200      	movs	r2, #0
 8028f76:	2100      	movs	r1, #0
 8028f78:	2002      	movs	r0, #2
 8028f7a:	f00a fd9d 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevAddr: %02X:%02X:%02X:%02X\r\n",
 8028f7e:	7de3      	ldrb	r3, [r4, #23]
 8028f80:	7da2      	ldrb	r2, [r4, #22]
 8028f82:	7d61      	ldrb	r1, [r4, #21]
 8028f84:	7d20      	ldrb	r0, [r4, #20]
 8028f86:	9003      	str	r0, [sp, #12]
 8028f88:	9102      	str	r1, [sp, #8]
 8028f8a:	9201      	str	r2, [sp, #4]
 8028f8c:	9300      	str	r3, [sp, #0]
 8028f8e:	4b2d      	ldr	r3, [pc, #180]	; (8029044 <LmHandlerConfigure+0x1b8>)
 8028f90:	2200      	movs	r2, #0
 8028f92:	2100      	movs	r1, #0
 8028f94:	2002      	movs	r0, #2
 8028f96:	f00a fd8f 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_L, "###### KMS ENABLED \r\n");
 8028f9a:	4b2b      	ldr	r3, [pc, #172]	; (8029048 <LmHandlerConfigure+0x1bc>)
 8028f9c:	2200      	movs	r2, #0
 8028f9e:	2100      	movs	r1, #0
 8028fa0:	2001      	movs	r0, #1
 8028fa2:	f00a fd89 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 8028fa6:	260f      	movs	r6, #15
 8028fa8:	702e      	strb	r6, [r5, #0]
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 8028faa:	2301      	movs	r3, #1
 8028fac:	712b      	strb	r3, [r5, #4]
    LoRaMacMibSetRequestConfirm(&mibReq);
 8028fae:	0028      	movs	r0, r5
 8028fb0:	f003 fecc 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_NET_ID;
 8028fb4:	2305      	movs	r3, #5
 8028fb6:	702b      	strb	r3, [r5, #0]
    mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 8028fb8:	2400      	movs	r4, #0
 8028fba:	606c      	str	r4, [r5, #4]
    LoRaMacMibSetRequestConfirm(&mibReq);
 8028fbc:	0028      	movs	r0, r5
 8028fbe:	f003 fec5 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 8028fc2:	2310      	movs	r3, #16
 8028fc4:	702b      	strb	r3, [r5, #0]
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 8028fc6:	712c      	strb	r4, [r5, #4]
    LoRaMacMibSetRequestConfirm( &mibReq );
 8028fc8:	0028      	movs	r0, r5
 8028fca:	f003 febf 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 8028fce:	2304      	movs	r3, #4
 8028fd0:	702b      	strb	r3, [r5, #0]
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 8028fd2:	4c14      	ldr	r4, [pc, #80]	; (8029024 <LmHandlerConfigure+0x198>)
 8028fd4:	78a3      	ldrb	r3, [r4, #2]
 8028fd6:	712b      	strb	r3, [r5, #4]
    LoRaMacMibSetRequestConfirm( &mibReq );
 8028fd8:	0028      	movs	r0, r5
 8028fda:	f003 feb7 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8028fde:	a909      	add	r1, sp, #36	; 0x24
 8028fe0:	700e      	strb	r6, [r1, #0]
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 8028fe2:	7820      	ldrb	r0, [r4, #0]
 8028fe4:	f005 fb86 	bl	802e6f4 <RegionGetPhyParam>
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 8028fe8:	1e43      	subs	r3, r0, #1
 8028fea:	4198      	sbcs	r0, r3
 8028fec:	7160      	strb	r0, [r4, #5]
    LmHandlerSetSystemMaxRxError( 20 );
 8028fee:	2014      	movs	r0, #20
 8028ff0:	f7ff ff2e 	bl	8028e50 <LmHandlerSetSystemMaxRxError>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 8028ff4:	7960      	ldrb	r0, [r4, #5]
 8028ff6:	f004 fa9f 	bl	802d538 <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 8028ffa:	2000      	movs	r0, #0
}
 8028ffc:	b015      	add	sp, #84	; 0x54
 8028ffe:	bcc0      	pop	{r6, r7}
 8029000:	46b9      	mov	r9, r7
 8029002:	46b0      	mov	r8, r6
 8029004:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MW_LOG(TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n");
 8029006:	4b11      	ldr	r3, [pc, #68]	; (802904c <LmHandlerConfigure+0x1c0>)
 8029008:	2201      	movs	r2, #1
 802900a:	2100      	movs	r1, #0
 802900c:	2000      	movs	r0, #0
 802900e:	f00a fd53 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
        while (1) {}  /* error: Region is not defined in the MW */
 8029012:	e7fe      	b.n	8029012 <LmHandlerConfigure+0x186>
        CtxRestoreDone = false;
 8029014:	4b06      	ldr	r3, [pc, #24]	; (8029030 <LmHandlerConfigure+0x1a4>)
 8029016:	2200      	movs	r2, #0
 8029018:	701a      	strb	r2, [r3, #0]
 802901a:	e75a      	b.n	8028ed2 <LmHandlerConfigure+0x46>
            return LORAMAC_HANDLER_ERROR;
 802901c:	2001      	movs	r0, #1
 802901e:	4240      	negs	r0, r0
 8029020:	e7ec      	b.n	8028ffc <LmHandlerConfigure+0x170>
 8029022:	46c0      	nop			; (mov r8, r8)
 8029024:	2000a4b4 	.word	0x2000a4b4
 8029028:	2000a4c4 	.word	0x2000a4c4
 802902c:	2000a4d8 	.word	0x2000a4d8
 8029030:	2000a49a 	.word	0x2000a49a
 8029034:	2000a040 	.word	0x2000a040
 8029038:	2000a49c 	.word	0x2000a49c
 802903c:	08034d64 	.word	0x08034d64
 8029040:	08034da0 	.word	0x08034da0
 8029044:	08034ddc 	.word	0x08034ddc
 8029048:	08034e04 	.word	0x08034e04
 802904c:	08034d18 	.word	0x08034d18

08029050 <LmHandlerProcess>:
{
 8029050:	b510      	push	{r4, lr}
    LoRaMacProcess( );
 8029052:	f003 faf1 	bl	802c638 <LoRaMacProcess>
    LmHandlerPackagesProcess( );
 8029056:	f7ff fecb 	bl	8028df0 <LmHandlerPackagesProcess>
    NvmDataMgmtStore( );
 802905a:	f005 fb3d 	bl	802e6d8 <NvmDataMgmtStore>
}
 802905e:	bd10      	pop	{r4, pc}

08029060 <LmHandlerJoinStatus>:
{
 8029060:	b500      	push	{lr}
 8029062:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 8029064:	a801      	add	r0, sp, #4
 8029066:	2301      	movs	r3, #1
 8029068:	7003      	strb	r3, [r0, #0]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 802906a:	f003 fd89 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 802906e:	2800      	cmp	r0, #0
 8029070:	d105      	bne.n	802907e <LmHandlerJoinStatus+0x1e>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 8029072:	ab01      	add	r3, sp, #4
 8029074:	7918      	ldrb	r0, [r3, #4]
 8029076:	2800      	cmp	r0, #0
 8029078:	d002      	beq.n	8029080 <LmHandlerJoinStatus+0x20>
            return LORAMAC_HANDLER_SET;
 802907a:	2001      	movs	r0, #1
 802907c:	e000      	b.n	8029080 <LmHandlerJoinStatus+0x20>
        return LORAMAC_HANDLER_RESET;
 802907e:	2000      	movs	r0, #0
}
 8029080:	b00b      	add	sp, #44	; 0x2c
 8029082:	bd00      	pop	{pc}

08029084 <LmHandlerStop>:
{
 8029084:	b510      	push	{r4, lr}
    if (LoRaMacDeInitialization() == LORAMAC_STATUS_OK)
 8029086:	f004 fa6d 	bl	802d564 <LoRaMacDeInitialization>
 802908a:	2800      	cmp	r0, #0
 802908c:	d100      	bne.n	8029090 <LmHandlerStop+0xc>
}
 802908e:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_BUSY_ERROR;
 8029090:	2002      	movs	r0, #2
 8029092:	4240      	negs	r0, r0
 8029094:	e7fb      	b.n	802908e <LmHandlerStop+0xa>

08029096 <LmHandlerLinkCheckReq>:
{
 8029096:	b500      	push	{lr}
 8029098:	b087      	sub	sp, #28
    mlmeReq.Type = MLME_LINK_CHECK;
 802909a:	a801      	add	r0, sp, #4
 802909c:	2304      	movs	r3, #4
 802909e:	7003      	strb	r3, [r0, #0]
    status = LoRaMacMlmeRequest( &mlmeReq );
 80290a0:	f004 f89a 	bl	802d1d8 <LoRaMacMlmeRequest>
    if( status == LORAMAC_STATUS_OK )
 80290a4:	2800      	cmp	r0, #0
 80290a6:	d101      	bne.n	80290ac <LmHandlerLinkCheckReq+0x16>
}
 80290a8:	b007      	add	sp, #28
 80290aa:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 80290ac:	2001      	movs	r0, #1
 80290ae:	4240      	negs	r0, r0
 80290b0:	e7fa      	b.n	80290a8 <LmHandlerLinkCheckReq+0x12>
	...

080290b4 <LmHandlerRequestClass>:
{
 80290b4:	b510      	push	{r4, lr}
 80290b6:	b08a      	sub	sp, #40	; 0x28
 80290b8:	0004      	movs	r4, r0
    if (LoRaMacIsBusy() == true)
 80290ba:	f003 faa9 	bl	802c610 <LoRaMacIsBusy>
 80290be:	2800      	cmp	r0, #0
 80290c0:	d141      	bne.n	8029146 <LmHandlerRequestClass+0x92>
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 80290c2:	f7ff ffcd 	bl	8029060 <LmHandlerJoinStatus>
 80290c6:	2801      	cmp	r0, #1
 80290c8:	d140      	bne.n	802914c <LmHandlerRequestClass+0x98>
    mibReq.Type = MIB_DEVICE_CLASS;
 80290ca:	a801      	add	r0, sp, #4
 80290cc:	2300      	movs	r3, #0
 80290ce:	7003      	strb	r3, [r0, #0]
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80290d0:	f003 fd56 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 80290d4:	2800      	cmp	r0, #0
 80290d6:	d13c      	bne.n	8029152 <LmHandlerRequestClass+0x9e>
    currentClass = mibReq.Param.Class;
 80290d8:	ab01      	add	r3, sp, #4
 80290da:	791b      	ldrb	r3, [r3, #4]
    if( currentClass != newClass )
 80290dc:	42a3      	cmp	r3, r4
 80290de:	d03b      	beq.n	8029158 <LmHandlerRequestClass+0xa4>
        switch( newClass )
 80290e0:	2c01      	cmp	r4, #1
 80290e2:	d03b      	beq.n	802915c <LmHandlerRequestClass+0xa8>
 80290e4:	2c02      	cmp	r4, #2
 80290e6:	d01a      	beq.n	802911e <LmHandlerRequestClass+0x6a>
 80290e8:	2c00      	cmp	r4, #0
 80290ea:	d002      	beq.n	80290f2 <LmHandlerRequestClass+0x3e>
 80290ec:	2000      	movs	r0, #0
}
 80290ee:	b00a      	add	sp, #40	; 0x28
 80290f0:	bd10      	pop	{r4, pc}
                if( currentClass != CLASS_A )
 80290f2:	2b00      	cmp	r3, #0
 80290f4:	d101      	bne.n	80290fa <LmHandlerRequestClass+0x46>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 80290f6:	2000      	movs	r0, #0
 80290f8:	e7f9      	b.n	80290ee <LmHandlerRequestClass+0x3a>
                    mibReq.Param.Class = newClass;
 80290fa:	a801      	add	r0, sp, #4
 80290fc:	7104      	strb	r4, [r0, #4]
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80290fe:	f003 fe25 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029102:	2800      	cmp	r0, #0
 8029104:	d12d      	bne.n	8029162 <LmHandlerRequestClass+0xae>
                        DisplayClassUpdate(newClass);
 8029106:	0020      	movs	r0, r4
 8029108:	f7ff fe90 	bl	8028e2c <DisplayClassUpdate>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 802910c:	4b1b      	ldr	r3, [pc, #108]	; (802917c <LmHandlerRequestClass+0xc8>)
 802910e:	681b      	ldr	r3, [r3, #0]
 8029110:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8029112:	2b00      	cmp	r3, #0
 8029114:	d028      	beq.n	8029168 <LmHandlerRequestClass+0xb4>
                            LmHandlerCallbacks->OnClassChange( newClass );
 8029116:	0020      	movs	r0, r4
 8029118:	4798      	blx	r3
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 802911a:	2000      	movs	r0, #0
 802911c:	e7e7      	b.n	80290ee <LmHandlerRequestClass+0x3a>
                if( currentClass != CLASS_A )
 802911e:	2b00      	cmp	r3, #0
 8029120:	d124      	bne.n	802916c <LmHandlerRequestClass+0xb8>
                    mibReq.Param.Class = newClass;
 8029122:	a801      	add	r0, sp, #4
 8029124:	7104      	strb	r4, [r0, #4]
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 8029126:	f003 fe11 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 802912a:	2800      	cmp	r0, #0
 802912c:	d121      	bne.n	8029172 <LmHandlerRequestClass+0xbe>
                        DisplayClassUpdate(newClass);
 802912e:	0020      	movs	r0, r4
 8029130:	f7ff fe7c 	bl	8028e2c <DisplayClassUpdate>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 8029134:	4b11      	ldr	r3, [pc, #68]	; (802917c <LmHandlerRequestClass+0xc8>)
 8029136:	681b      	ldr	r3, [r3, #0]
 8029138:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802913a:	2b00      	cmp	r3, #0
 802913c:	d01c      	beq.n	8029178 <LmHandlerRequestClass+0xc4>
                            LmHandlerCallbacks->OnClassChange( newClass );
 802913e:	0020      	movs	r0, r4
 8029140:	4798      	blx	r3
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 8029142:	2000      	movs	r0, #0
 8029144:	e7d3      	b.n	80290ee <LmHandlerRequestClass+0x3a>
        return LORAMAC_HANDLER_BUSY_ERROR;
 8029146:	2002      	movs	r0, #2
 8029148:	4240      	negs	r0, r0
 802914a:	e7d0      	b.n	80290ee <LmHandlerRequestClass+0x3a>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 802914c:	2003      	movs	r0, #3
 802914e:	4240      	negs	r0, r0
 8029150:	e7cd      	b.n	80290ee <LmHandlerRequestClass+0x3a>
        return LORAMAC_HANDLER_ERROR;
 8029152:	2001      	movs	r0, #1
 8029154:	4240      	negs	r0, r0
 8029156:	e7ca      	b.n	80290ee <LmHandlerRequestClass+0x3a>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 8029158:	2000      	movs	r0, #0
 802915a:	e7c8      	b.n	80290ee <LmHandlerRequestClass+0x3a>
                errorStatus = LORAMAC_HANDLER_ERROR;
 802915c:	2001      	movs	r0, #1
 802915e:	4240      	negs	r0, r0
 8029160:	e7c5      	b.n	80290ee <LmHandlerRequestClass+0x3a>
                        errorStatus = LORAMAC_HANDLER_ERROR;
 8029162:	2001      	movs	r0, #1
 8029164:	4240      	negs	r0, r0
 8029166:	e7c2      	b.n	80290ee <LmHandlerRequestClass+0x3a>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 8029168:	2000      	movs	r0, #0
 802916a:	e7c0      	b.n	80290ee <LmHandlerRequestClass+0x3a>
                    errorStatus = LORAMAC_HANDLER_ERROR;
 802916c:	2001      	movs	r0, #1
 802916e:	4240      	negs	r0, r0
 8029170:	e7bd      	b.n	80290ee <LmHandlerRequestClass+0x3a>
                        errorStatus = LORAMAC_HANDLER_ERROR;
 8029172:	2001      	movs	r0, #1
 8029174:	4240      	negs	r0, r0
 8029176:	e7ba      	b.n	80290ee <LmHandlerRequestClass+0x3a>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 8029178:	2000      	movs	r0, #0
 802917a:	e7b8      	b.n	80290ee <LmHandlerRequestClass+0x3a>
 802917c:	2000a49c 	.word	0x2000a49c

08029180 <LmHandlerJoin>:
{
 8029180:	b500      	push	{lr}
 8029182:	b08f      	sub	sp, #60	; 0x3c
    if ( mode == ACTIVATION_TYPE_OTAA )
 8029184:	2802      	cmp	r0, #2
 8029186:	d020      	beq.n	80291ca <LmHandlerJoin+0x4a>
        JoinParams.Mode = ACTIVATION_TYPE_ABP;
 8029188:	4b1f      	ldr	r3, [pc, #124]	; (8029208 <LmHandlerJoin+0x88>)
 802918a:	2201      	movs	r2, #1
 802918c:	709a      	strb	r2, [r3, #2]
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 802918e:	4a1f      	ldr	r2, [pc, #124]	; (802920c <LmHandlerJoin+0x8c>)
 8029190:	78d2      	ldrb	r2, [r2, #3]
 8029192:	b252      	sxtb	r2, r2
 8029194:	701a      	strb	r2, [r3, #0]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 8029196:	2200      	movs	r2, #0
 8029198:	705a      	strb	r2, [r3, #1]
        if (CtxRestoreDone == false)
 802919a:	4b1d      	ldr	r3, [pc, #116]	; (8029210 <LmHandlerJoin+0x90>)
 802919c:	781b      	ldrb	r3, [r3, #0]
 802919e:	2b00      	cmp	r3, #0
 80291a0:	d022      	beq.n	80291e8 <LmHandlerJoin+0x68>
        LoRaMacStart();
 80291a2:	f003 fc67 	bl	802ca74 <LoRaMacStart>
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80291a6:	2301      	movs	r3, #1
 80291a8:	466a      	mov	r2, sp
 80291aa:	7513      	strb	r3, [r2, #20]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 80291ac:	7613      	strb	r3, [r2, #24]
        LoRaMacMibSetRequestConfirm( &mibReq );
 80291ae:	a805      	add	r0, sp, #20
 80291b0:	f003 fdcc 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
        LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 80291b4:	4b17      	ldr	r3, [pc, #92]	; (8029214 <LmHandlerJoin+0x94>)
 80291b6:	681b      	ldr	r3, [r3, #0]
 80291b8:	69db      	ldr	r3, [r3, #28]
 80291ba:	4813      	ldr	r0, [pc, #76]	; (8029208 <LmHandlerJoin+0x88>)
 80291bc:	4798      	blx	r3
        LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80291be:	4b13      	ldr	r3, [pc, #76]	; (802920c <LmHandlerJoin+0x8c>)
 80291c0:	7858      	ldrb	r0, [r3, #1]
 80291c2:	f7ff ff77 	bl	80290b4 <LmHandlerRequestClass>
}
 80291c6:	b00f      	add	sp, #60	; 0x3c
 80291c8:	bd00      	pop	{pc}
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 80291ca:	4b0f      	ldr	r3, [pc, #60]	; (8029208 <LmHandlerJoin+0x88>)
 80291cc:	2202      	movs	r2, #2
 80291ce:	709a      	strb	r2, [r3, #2]
        LoRaMacStart();
 80291d0:	f003 fc50 	bl	802ca74 <LoRaMacStart>
        mlmeReq.Type = MLME_JOIN;
 80291d4:	2301      	movs	r3, #1
 80291d6:	466a      	mov	r2, sp
 80291d8:	7013      	strb	r3, [r2, #0]
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 80291da:	4b0c      	ldr	r3, [pc, #48]	; (802920c <LmHandlerJoin+0x8c>)
 80291dc:	78db      	ldrb	r3, [r3, #3]
 80291de:	7113      	strb	r3, [r2, #4]
        LoRaMacMlmeRequest( &mlmeReq );
 80291e0:	4668      	mov	r0, sp
 80291e2:	f003 fff9 	bl	802d1d8 <LoRaMacMlmeRequest>
 80291e6:	e7ee      	b.n	80291c6 <LmHandlerJoin+0x46>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 80291e8:	a805      	add	r0, sp, #20
 80291ea:	3327      	adds	r3, #39	; 0x27
 80291ec:	7003      	strb	r3, [r0, #0]
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 80291ee:	4b0a      	ldr	r3, [pc, #40]	; (8029218 <LmHandlerJoin+0x98>)
 80291f0:	6043      	str	r3, [r0, #4]
            LoRaMacMibSetRequestConfirm(&mibReq);
 80291f2:	f003 fdab 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
            SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 80291f6:	2104      	movs	r1, #4
 80291f8:	2002      	movs	r0, #2
 80291fa:	f007 ff95 	bl	8031128 <SecureElementSetObjHandler>
            SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 80291fe:	2105      	movs	r1, #5
 8029200:	2003      	movs	r0, #3
 8029202:	f007 ff91 	bl	8031128 <SecureElementSetObjHandler>
 8029206:	e7cc      	b.n	80291a2 <LmHandlerJoin+0x22>
 8029208:	2000a058 	.word	0x2000a058
 802920c:	2000a4b4 	.word	0x2000a4b4
 8029210:	2000a49a 	.word	0x2000a49a
 8029214:	2000a49c 	.word	0x2000a49c
 8029218:	01000300 	.word	0x01000300

0802921c <LmHandlerSend>:
{
 802921c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802921e:	b087      	sub	sp, #28
 8029220:	0004      	movs	r4, r0
 8029222:	000f      	movs	r7, r1
 8029224:	0015      	movs	r5, r2
 8029226:	001e      	movs	r6, r3
    if (LoRaMacIsBusy() == true)
 8029228:	f003 f9f2 	bl	802c610 <LoRaMacIsBusy>
 802922c:	2800      	cmp	r0, #0
 802922e:	d164      	bne.n	80292fa <LmHandlerSend+0xde>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8029230:	f7ff ff16 	bl	8029060 <LmHandlerJoinStatus>
 8029234:	2801      	cmp	r0, #1
 8029236:	d137      	bne.n	80292a8 <LmHandlerSend+0x8c>
    if( ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true ) && ( appData->Port != LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->Port ) && ( appData->Port != 0 ) )
 8029238:	4b35      	ldr	r3, [pc, #212]	; (8029310 <LmHandlerSend+0xf4>)
 802923a:	681b      	ldr	r3, [r3, #0]
 802923c:	68db      	ldr	r3, [r3, #12]
 802923e:	4798      	blx	r3
 8029240:	2800      	cmp	r0, #0
 8029242:	d007      	beq.n	8029254 <LmHandlerSend+0x38>
 8029244:	7823      	ldrb	r3, [r4, #0]
 8029246:	4a32      	ldr	r2, [pc, #200]	; (8029310 <LmHandlerSend+0xf4>)
 8029248:	6812      	ldr	r2, [r2, #0]
 802924a:	7812      	ldrb	r2, [r2, #0]
 802924c:	4293      	cmp	r3, r2
 802924e:	d001      	beq.n	8029254 <LmHandlerSend+0x38>
 8029250:	2b00      	cmp	r3, #0
 8029252:	d155      	bne.n	8029300 <LmHandlerSend+0xe4>
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 8029254:	4b2f      	ldr	r3, [pc, #188]	; (8029314 <LmHandlerSend+0xf8>)
 8029256:	2203      	movs	r2, #3
 8029258:	569a      	ldrsb	r2, [r3, r2]
 802925a:	ab01      	add	r3, sp, #4
 802925c:	739a      	strb	r2, [r3, #14]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 802925e:	7860      	ldrb	r0, [r4, #1]
 8029260:	4669      	mov	r1, sp
 8029262:	f003 fc29 	bl	802cab8 <LoRaMacQueryTxPossible>
 8029266:	2800      	cmp	r0, #0
 8029268:	d025      	beq.n	80292b6 <LmHandlerSend+0x9a>
        TxParams.MsgType = LORAMAC_HANDLER_UNCONFIRMED_MSG;
 802926a:	2200      	movs	r2, #0
 802926c:	4b2a      	ldr	r3, [pc, #168]	; (8029318 <LmHandlerSend+0xfc>)
 802926e:	709a      	strb	r2, [r3, #2]
        mcpsReq.Type = MCPS_UNCONFIRMED;
 8029270:	ab01      	add	r3, sp, #4
 8029272:	701a      	strb	r2, [r3, #0]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 8029274:	9203      	str	r2, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 8029276:	819a      	strh	r2, [r3, #12]
    TxParams.AppData = *appData;
 8029278:	4a27      	ldr	r2, [pc, #156]	; (8029318 <LmHandlerSend+0xfc>)
 802927a:	0011      	movs	r1, r2
 802927c:	310c      	adds	r1, #12
 802927e:	cc09      	ldmia	r4!, {r0, r3}
 8029280:	c109      	stmia	r1!, {r0, r3}
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 8029282:	4b24      	ldr	r3, [pc, #144]	; (8029314 <LmHandlerSend+0xf8>)
 8029284:	78db      	ldrb	r3, [r3, #3]
 8029286:	b25b      	sxtb	r3, r3
 8029288:	7113      	strb	r3, [r2, #4]
    status = LoRaMacMcpsRequest(&mcpsReq, allowDelayedTx);
 802928a:	0031      	movs	r1, r6
 802928c:	a801      	add	r0, sp, #4
 802928e:	f004 f87b 	bl	802d388 <LoRaMacMcpsRequest>
 8029292:	0003      	movs	r3, r0
    if (nextTxIn != NULL)
 8029294:	2d00      	cmp	r5, #0
 8029296:	d001      	beq.n	802929c <LmHandlerSend+0x80>
        *nextTxIn = mcpsReq.ReqReturn.DutyCycleWaitTime;
 8029298:	9a05      	ldr	r2, [sp, #20]
 802929a:	602a      	str	r2, [r5, #0]
    switch (status)
 802929c:	2b11      	cmp	r3, #17
 802929e:	d829      	bhi.n	80292f4 <LmHandlerSend+0xd8>
 80292a0:	0080      	lsls	r0, r0, #2
 80292a2:	4b1e      	ldr	r3, [pc, #120]	; (802931c <LmHandlerSend+0x100>)
 80292a4:	581b      	ldr	r3, [r3, r0]
 80292a6:	469f      	mov	pc, r3
        LmHandlerJoin(JoinParams.Mode);
 80292a8:	4b1d      	ldr	r3, [pc, #116]	; (8029320 <LmHandlerSend+0x104>)
 80292aa:	7898      	ldrb	r0, [r3, #2]
 80292ac:	f7ff ff68 	bl	8029180 <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 80292b0:	2003      	movs	r0, #3
 80292b2:	4240      	negs	r0, r0
 80292b4:	e029      	b.n	802930a <LmHandlerSend+0xee>
        TxParams.MsgType = isTxConfirmed;
 80292b6:	4b18      	ldr	r3, [pc, #96]	; (8029318 <LmHandlerSend+0xfc>)
 80292b8:	709f      	strb	r7, [r3, #2]
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 80292ba:	7822      	ldrb	r2, [r4, #0]
 80292bc:	ab01      	add	r3, sp, #4
 80292be:	711a      	strb	r2, [r3, #4]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 80292c0:	7862      	ldrb	r2, [r4, #1]
 80292c2:	819a      	strh	r2, [r3, #12]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 80292c4:	6862      	ldr	r2, [r4, #4]
 80292c6:	9203      	str	r2, [sp, #12]
        if( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG )
 80292c8:	2f00      	cmp	r7, #0
 80292ca:	d102      	bne.n	80292d2 <LmHandlerSend+0xb6>
            mcpsReq.Type = MCPS_UNCONFIRMED;
 80292cc:	2200      	movs	r2, #0
 80292ce:	701a      	strb	r2, [r3, #0]
 80292d0:	e7d2      	b.n	8029278 <LmHandlerSend+0x5c>
            mcpsReq.Type = MCPS_CONFIRMED;
 80292d2:	ab01      	add	r3, sp, #4
 80292d4:	2201      	movs	r2, #1
 80292d6:	701a      	strb	r2, [r3, #0]
            mcpsReq.Req.Confirmed.NbTrials = 8;
 80292d8:	3207      	adds	r2, #7
 80292da:	73da      	strb	r2, [r3, #15]
 80292dc:	e7cc      	b.n	8029278 <LmHandlerSend+0x5c>
            lmhStatus = LORAMAC_HANDLER_CRYPTO_ERROR;
 80292de:	2000      	movs	r0, #0
 80292e0:	e013      	b.n	802930a <LmHandlerSend+0xee>
            lmhStatus = LORAMAC_HANDLER_NO_NETWORK_JOINED;
 80292e2:	2003      	movs	r0, #3
 80292e4:	4240      	negs	r0, r0
            break;
 80292e6:	e010      	b.n	802930a <LmHandlerSend+0xee>
            lmhStatus = LORAMAC_HANDLER_CRYPTO_ERROR;
 80292e8:	2005      	movs	r0, #5
 80292ea:	4240      	negs	r0, r0
            break;
 80292ec:	e00d      	b.n	802930a <LmHandlerSend+0xee>
            lmhStatus = LORAMAC_HANDLER_DUTYCYCLE_RESTRICTED;
 80292ee:	2006      	movs	r0, #6
 80292f0:	4240      	negs	r0, r0
            break;
 80292f2:	e00a      	b.n	802930a <LmHandlerSend+0xee>
            lmhStatus = LORAMAC_HANDLER_ERROR;
 80292f4:	2001      	movs	r0, #1
 80292f6:	4240      	negs	r0, r0
            break;
 80292f8:	e007      	b.n	802930a <LmHandlerSend+0xee>
        return LORAMAC_HANDLER_BUSY_ERROR;
 80292fa:	2002      	movs	r0, #2
 80292fc:	4240      	negs	r0, r0
 80292fe:	e004      	b.n	802930a <LmHandlerSend+0xee>
        return LORAMAC_HANDLER_COMPLIANCE_RUNNING;
 8029300:	2004      	movs	r0, #4
 8029302:	4240      	negs	r0, r0
 8029304:	e001      	b.n	802930a <LmHandlerSend+0xee>
            lmhStatus = LORAMAC_HANDLER_BUSY_ERROR;
 8029306:	2002      	movs	r0, #2
 8029308:	4240      	negs	r0, r0
}
 802930a:	b007      	add	sp, #28
 802930c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802930e:	46c0      	nop			; (mov r8, r8)
 8029310:	2000a4a0 	.word	0x2000a4a0
 8029314:	2000a4b4 	.word	0x2000a4b4
 8029318:	2000a4e8 	.word	0x2000a4e8
 802931c:	08034e1c 	.word	0x08034e1c
 8029320:	2000a058 	.word	0x2000a058

08029324 <MlmeIndication>:
{
 8029324:	b530      	push	{r4, r5, lr}
 8029326:	b083      	sub	sp, #12
 8029328:	0004      	movs	r4, r0
    RxParams.IsMcpsIndication = 0;
 802932a:	4b16      	ldr	r3, [pc, #88]	; (8029384 <MlmeIndication+0x60>)
 802932c:	2200      	movs	r2, #0
 802932e:	701a      	strb	r2, [r3, #0]
    RxParams.Status = mlmeIndication->Status;
 8029330:	7842      	ldrb	r2, [r0, #1]
 8029332:	705a      	strb	r2, [r3, #1]
    RxParams.Rssi = RxStatus->Rssi;
 8029334:	2500      	movs	r5, #0
 8029336:	5f48      	ldrsh	r0, [r1, r5]
 8029338:	70d8      	strb	r0, [r3, #3]
    RxParams.Snr = RxStatus->Snr;
 802933a:	2002      	movs	r0, #2
 802933c:	5608      	ldrsb	r0, [r1, r0]
 802933e:	7118      	strb	r0, [r3, #4]
    RxParams.RxSlot = RxStatus->RxSlot;
 8029340:	78c9      	ldrb	r1, [r1, #3]
 8029342:	b249      	sxtb	r1, r1
 8029344:	7319      	strb	r1, [r3, #12]
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_BEACON_LOCKED )
 8029346:	2a0e      	cmp	r2, #14
 8029348:	d005      	beq.n	8029356 <MlmeIndication+0x32>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 802934a:	4b0f      	ldr	r3, [pc, #60]	; (8029388 <MlmeIndication+0x64>)
 802934c:	681b      	ldr	r3, [r3, #0]
 802934e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029350:	490c      	ldr	r1, [pc, #48]	; (8029384 <MlmeIndication+0x60>)
 8029352:	2000      	movs	r0, #0
 8029354:	4798      	blx	r3
    switch( mlmeIndication->MlmeIndication )
 8029356:	7823      	ldrb	r3, [r4, #0]
 8029358:	2b07      	cmp	r3, #7
 802935a:	d001      	beq.n	8029360 <MlmeIndication+0x3c>
}
 802935c:	b003      	add	sp, #12
 802935e:	bd30      	pop	{r4, r5, pc}
            LmHandlerAppData_t appData =
 8029360:	2300      	movs	r3, #0
 8029362:	466a      	mov	r2, sp
 8029364:	7013      	strb	r3, [r2, #0]
 8029366:	7053      	strb	r3, [r2, #1]
 8029368:	9301      	str	r3, [sp, #4]
            if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == false )
 802936a:	4b08      	ldr	r3, [pc, #32]	; (802938c <MlmeIndication+0x68>)
 802936c:	681b      	ldr	r3, [r3, #0]
 802936e:	68db      	ldr	r3, [r3, #12]
 8029370:	4798      	blx	r3
 8029372:	2800      	cmp	r0, #0
 8029374:	d1f2      	bne.n	802935c <MlmeIndication+0x38>
                LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8029376:	2301      	movs	r3, #1
 8029378:	2200      	movs	r2, #0
 802937a:	2100      	movs	r1, #0
 802937c:	4668      	mov	r0, sp
 802937e:	f7ff ff4d 	bl	802921c <LmHandlerSend>
}
 8029382:	e7eb      	b.n	802935c <MlmeIndication+0x38>
 8029384:	2000a068 	.word	0x2000a068
 8029388:	2000a49c 	.word	0x2000a49c
 802938c:	2000a4a0 	.word	0x2000a4a0

08029390 <LmHandlerGetCurrentClass>:
{
 8029390:	b510      	push	{r4, lr}
 8029392:	b08a      	sub	sp, #40	; 0x28
 8029394:	1e04      	subs	r4, r0, #0
    if (deviceClass == NULL)
 8029396:	d00b      	beq.n	80293b0 <LmHandlerGetCurrentClass+0x20>
    mibReq.Type = MIB_DEVICE_CLASS;
 8029398:	a801      	add	r0, sp, #4
 802939a:	2300      	movs	r3, #0
 802939c:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 802939e:	f003 fbef 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 80293a2:	2800      	cmp	r0, #0
 80293a4:	d107      	bne.n	80293b6 <LmHandlerGetCurrentClass+0x26>
    *deviceClass = mibReq.Param.Class;
 80293a6:	ab01      	add	r3, sp, #4
 80293a8:	791b      	ldrb	r3, [r3, #4]
 80293aa:	7023      	strb	r3, [r4, #0]
}
 80293ac:	b00a      	add	sp, #40	; 0x28
 80293ae:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 80293b0:	2001      	movs	r0, #1
 80293b2:	4240      	negs	r0, r0
 80293b4:	e7fa      	b.n	80293ac <LmHandlerGetCurrentClass+0x1c>
        return LORAMAC_HANDLER_ERROR;
 80293b6:	2001      	movs	r0, #1
 80293b8:	4240      	negs	r0, r0
 80293ba:	e7f7      	b.n	80293ac <LmHandlerGetCurrentClass+0x1c>

080293bc <McpsIndication>:
{
 80293bc:	b530      	push	{r4, r5, lr}
 80293be:	b087      	sub	sp, #28
 80293c0:	0004      	movs	r4, r0
 80293c2:	000b      	movs	r3, r1
    DeviceClass_t deviceClass = CLASS_A;
 80293c4:	220f      	movs	r2, #15
 80293c6:	446a      	add	r2, sp
 80293c8:	2100      	movs	r1, #0
 80293ca:	7011      	strb	r1, [r2, #0]
    RxParams.IsMcpsIndication = 1;
 80293cc:	4922      	ldr	r1, [pc, #136]	; (8029458 <McpsIndication+0x9c>)
 80293ce:	2201      	movs	r2, #1
 80293d0:	700a      	strb	r2, [r1, #0]
    RxParams.Status = mcpsIndication->Status;
 80293d2:	7842      	ldrb	r2, [r0, #1]
 80293d4:	704a      	strb	r2, [r1, #1]
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 80293d6:	2a00      	cmp	r2, #0
 80293d8:	d12c      	bne.n	8029434 <McpsIndication+0x78>
    RxParams.Datarate = mcpsIndication->RxDatarate;
 80293da:	2204      	movs	r2, #4
 80293dc:	5682      	ldrsb	r2, [r0, r2]
 80293de:	708a      	strb	r2, [r1, #2]
    RxParams.Rssi = RxStatus->Rssi;
 80293e0:	2000      	movs	r0, #0
 80293e2:	5e1a      	ldrsh	r2, [r3, r0]
 80293e4:	70ca      	strb	r2, [r1, #3]
    RxParams.Snr = RxStatus->Snr;
 80293e6:	2202      	movs	r2, #2
 80293e8:	569a      	ldrsb	r2, [r3, r2]
 80293ea:	710a      	strb	r2, [r1, #4]
    RxParams.RxSlot = RxStatus->RxSlot;
 80293ec:	78db      	ldrb	r3, [r3, #3]
 80293ee:	b25b      	sxtb	r3, r3
 80293f0:	730b      	strb	r3, [r1, #12]
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 80293f2:	6923      	ldr	r3, [r4, #16]
 80293f4:	608b      	str	r3, [r1, #8]
    appData.Port = mcpsIndication->Port;
 80293f6:	78e3      	ldrb	r3, [r4, #3]
 80293f8:	466a      	mov	r2, sp
 80293fa:	7413      	strb	r3, [r2, #16]
    appData.BufferSize = mcpsIndication->BufferSize;
 80293fc:	7b23      	ldrb	r3, [r4, #12]
 80293fe:	7453      	strb	r3, [r2, #17]
    appData.Buffer = mcpsIndication->Buffer;
 8029400:	68a3      	ldr	r3, [r4, #8]
 8029402:	9305      	str	r3, [sp, #20]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 8029404:	4d15      	ldr	r5, [pc, #84]	; (802945c <McpsIndication+0xa0>)
 8029406:	682b      	ldr	r3, [r5, #0]
 8029408:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802940a:	a804      	add	r0, sp, #16
 802940c:	4798      	blx	r3
    if ((LmHandlerCallbacks->OnSysTimeUpdate != NULL) && (mcpsIndication->DeviceTimeAnsReceived == true))
 802940e:	682b      	ldr	r3, [r5, #0]
 8029410:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029412:	2b00      	cmp	r3, #0
 8029414:	d003      	beq.n	802941e <McpsIndication+0x62>
 8029416:	7e22      	ldrb	r2, [r4, #24]
 8029418:	2a00      	cmp	r2, #0
 802941a:	d000      	beq.n	802941e <McpsIndication+0x62>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 802941c:	4798      	blx	r3
    LmHandlerPackagesNotify( PACKAGE_MCPS_INDICATION, mcpsIndication );
 802941e:	0021      	movs	r1, r4
 8029420:	2001      	movs	r0, #1
 8029422:	f7ff fc8b 	bl	8028d3c <LmHandlerPackagesNotify>
    LmHandlerGetCurrentClass(&deviceClass);
 8029426:	200f      	movs	r0, #15
 8029428:	4468      	add	r0, sp
 802942a:	f7ff ffb1 	bl	8029390 <LmHandlerGetCurrentClass>
    if ((mcpsIndication->FramePending == true) && (deviceClass == CLASS_A))
 802942e:	7963      	ldrb	r3, [r4, #5]
 8029430:	2b01      	cmp	r3, #1
 8029432:	d001      	beq.n	8029438 <McpsIndication+0x7c>
}
 8029434:	b007      	add	sp, #28
 8029436:	bd30      	pop	{r4, r5, pc}
    if ((mcpsIndication->FramePending == true) && (deviceClass == CLASS_A))
 8029438:	330e      	adds	r3, #14
 802943a:	446b      	add	r3, sp
 802943c:	781b      	ldrb	r3, [r3, #0]
 802943e:	2b00      	cmp	r3, #0
 8029440:	d1f8      	bne.n	8029434 <McpsIndication+0x78>
        LmHandlerAppData_t appData =
 8029442:	466a      	mov	r2, sp
 8029444:	7113      	strb	r3, [r2, #4]
 8029446:	7153      	strb	r3, [r2, #5]
 8029448:	9302      	str	r3, [sp, #8]
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 802944a:	3301      	adds	r3, #1
 802944c:	2200      	movs	r2, #0
 802944e:	2100      	movs	r1, #0
 8029450:	a801      	add	r0, sp, #4
 8029452:	f7ff fee3 	bl	802921c <LmHandlerSend>
 8029456:	e7ed      	b.n	8029434 <McpsIndication+0x78>
 8029458:	2000a068 	.word	0x2000a068
 802945c:	2000a49c 	.word	0x2000a49c

08029460 <LmHandlerGetTxDatarate>:
{
 8029460:	b510      	push	{r4, lr}
 8029462:	b08a      	sub	sp, #40	; 0x28
 8029464:	1e04      	subs	r4, r0, #0
    if (txDatarate == NULL)
 8029466:	d00e      	beq.n	8029486 <LmHandlerGetTxDatarate+0x26>
    mibGet.Type = MIB_CHANNELS_DATARATE;
 8029468:	a801      	add	r0, sp, #4
 802946a:	231f      	movs	r3, #31
 802946c:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 802946e:	f003 fb87 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 8029472:	2800      	cmp	r0, #0
 8029474:	d10a      	bne.n	802948c <LmHandlerGetTxDatarate+0x2c>
    *txDatarate = mibGet.Param.ChannelsDatarate;
 8029476:	ab01      	add	r3, sp, #4
 8029478:	791b      	ldrb	r3, [r3, #4]
 802947a:	b25b      	sxtb	r3, r3
 802947c:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxDatarate = *txDatarate;
 802947e:	4a05      	ldr	r2, [pc, #20]	; (8029494 <LmHandlerGetTxDatarate+0x34>)
 8029480:	70d3      	strb	r3, [r2, #3]
}
 8029482:	b00a      	add	sp, #40	; 0x28
 8029484:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029486:	2001      	movs	r0, #1
 8029488:	4240      	negs	r0, r0
 802948a:	e7fa      	b.n	8029482 <LmHandlerGetTxDatarate+0x22>
        return LORAMAC_HANDLER_ERROR;
 802948c:	2001      	movs	r0, #1
 802948e:	4240      	negs	r0, r0
 8029490:	e7f7      	b.n	8029482 <LmHandlerGetTxDatarate+0x22>
 8029492:	46c0      	nop			; (mov r8, r8)
 8029494:	2000a4b4 	.word	0x2000a4b4

08029498 <MlmeConfirm>:
{
 8029498:	b530      	push	{r4, r5, lr}
 802949a:	b08b      	sub	sp, #44	; 0x2c
 802949c:	0004      	movs	r4, r0
    TxParams.IsMcpsConfirm = 0;
 802949e:	481e      	ldr	r0, [pc, #120]	; (8029518 <MlmeConfirm+0x80>)
 80294a0:	2300      	movs	r3, #0
 80294a2:	7003      	strb	r3, [r0, #0]
    TxParams.Status = mlmeConfirm->Status;
 80294a4:	7863      	ldrb	r3, [r4, #1]
 80294a6:	7043      	strb	r3, [r0, #1]
    LmHandlerCallbacks->OnTxData( &TxParams );
 80294a8:	4b1c      	ldr	r3, [pc, #112]	; (802951c <MlmeConfirm+0x84>)
 80294aa:	681b      	ldr	r3, [r3, #0]
 80294ac:	6a1b      	ldr	r3, [r3, #32]
 80294ae:	4798      	blx	r3
    LmHandlerPackagesNotify( PACKAGE_MLME_CONFIRM, mlmeConfirm );
 80294b0:	0021      	movs	r1, r4
 80294b2:	2002      	movs	r0, #2
 80294b4:	f7ff fc42 	bl	8028d3c <LmHandlerPackagesNotify>
    switch( mlmeConfirm->MlmeRequest )
 80294b8:	7823      	ldrb	r3, [r4, #0]
 80294ba:	2b01      	cmp	r3, #1
 80294bc:	d003      	beq.n	80294c6 <MlmeConfirm+0x2e>
 80294be:	2b04      	cmp	r3, #4
 80294c0:	d021      	beq.n	8029506 <MlmeConfirm+0x6e>
}
 80294c2:	b00b      	add	sp, #44	; 0x2c
 80294c4:	bd30      	pop	{r4, r5, pc}
            mibReq.Type = MIB_DEV_ADDR;
 80294c6:	ad01      	add	r5, sp, #4
 80294c8:	2306      	movs	r3, #6
 80294ca:	702b      	strb	r3, [r5, #0]
            LoRaMacMibGetRequestConfirm( &mibReq );
 80294cc:	0028      	movs	r0, r5
 80294ce:	f003 fb57 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 80294d2:	686a      	ldr	r2, [r5, #4]
 80294d4:	4b12      	ldr	r3, [pc, #72]	; (8029520 <MlmeConfirm+0x88>)
 80294d6:	615a      	str	r2, [r3, #20]
            LmHandlerGetTxDatarate( &JoinParams.Datarate );
 80294d8:	4812      	ldr	r0, [pc, #72]	; (8029524 <MlmeConfirm+0x8c>)
 80294da:	f7ff ffc1 	bl	8029460 <LmHandlerGetTxDatarate>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 80294de:	7863      	ldrb	r3, [r4, #1]
 80294e0:	2b00      	cmp	r3, #0
 80294e2:	d008      	beq.n	80294f6 <MlmeConfirm+0x5e>
                JoinParams.Status = LORAMAC_HANDLER_ERROR;
 80294e4:	4b0f      	ldr	r3, [pc, #60]	; (8029524 <MlmeConfirm+0x8c>)
 80294e6:	22ff      	movs	r2, #255	; 0xff
 80294e8:	705a      	strb	r2, [r3, #1]
            LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 80294ea:	4b0c      	ldr	r3, [pc, #48]	; (802951c <MlmeConfirm+0x84>)
 80294ec:	681b      	ldr	r3, [r3, #0]
 80294ee:	69db      	ldr	r3, [r3, #28]
 80294f0:	480c      	ldr	r0, [pc, #48]	; (8029524 <MlmeConfirm+0x8c>)
 80294f2:	4798      	blx	r3
        break;
 80294f4:	e7e5      	b.n	80294c2 <MlmeConfirm+0x2a>
                JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80294f6:	4b0b      	ldr	r3, [pc, #44]	; (8029524 <MlmeConfirm+0x8c>)
 80294f8:	2200      	movs	r2, #0
 80294fa:	705a      	strb	r2, [r3, #1]
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 80294fc:	4b0a      	ldr	r3, [pc, #40]	; (8029528 <MlmeConfirm+0x90>)
 80294fe:	7858      	ldrb	r0, [r3, #1]
 8029500:	f7ff fdd8 	bl	80290b4 <LmHandlerRequestClass>
 8029504:	e7f1      	b.n	80294ea <MlmeConfirm+0x52>
            RxParams.LinkCheck = true;
 8029506:	4b09      	ldr	r3, [pc, #36]	; (802952c <MlmeConfirm+0x94>)
 8029508:	2201      	movs	r2, #1
 802950a:	735a      	strb	r2, [r3, #13]
            RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 802950c:	7a22      	ldrb	r2, [r4, #8]
 802950e:	739a      	strb	r2, [r3, #14]
            RxParams.NbGateways = mlmeConfirm->NbGateways;
 8029510:	7a62      	ldrb	r2, [r4, #9]
 8029512:	73da      	strb	r2, [r3, #15]
}
 8029514:	e7d5      	b.n	80294c2 <MlmeConfirm+0x2a>
 8029516:	46c0      	nop			; (mov r8, r8)
 8029518:	2000a4e8 	.word	0x2000a4e8
 802951c:	2000a49c 	.word	0x2000a49c
 8029520:	2000a040 	.word	0x2000a040
 8029524:	2000a058 	.word	0x2000a058
 8029528:	2000a4b4 	.word	0x2000a4b4
 802952c:	2000a068 	.word	0x2000a068

08029530 <LmHandlerGetActiveRegion>:
    if (region == NULL)
 8029530:	2800      	cmp	r0, #0
 8029532:	d004      	beq.n	802953e <LmHandlerGetActiveRegion+0xe>
    *region = LmHandlerParams.ActiveRegion;
 8029534:	4b03      	ldr	r3, [pc, #12]	; (8029544 <LmHandlerGetActiveRegion+0x14>)
 8029536:	781b      	ldrb	r3, [r3, #0]
 8029538:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 802953a:	2000      	movs	r0, #0
}
 802953c:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 802953e:	2001      	movs	r0, #1
 8029540:	4240      	negs	r0, r0
 8029542:	e7fb      	b.n	802953c <LmHandlerGetActiveRegion+0xc>
 8029544:	2000a4b4 	.word	0x2000a4b4

08029548 <LmHandlerPackageRegister>:
{
 8029548:	b570      	push	{r4, r5, r6, lr}
 802954a:	0004      	movs	r4, r0
 802954c:	000d      	movs	r5, r1
    switch( id )
 802954e:	2800      	cmp	r0, #0
 8029550:	d117      	bne.n	8029582 <LmHandlerPackageRegister+0x3a>
            package = LmhpCompliancePackageFactory( );
 8029552:	f000 fcef 	bl	8029f34 <LmhpCompliancePackageFactory>
    if( package != NULL )
 8029556:	2800      	cmp	r0, #0
 8029558:	d013      	beq.n	8029582 <LmHandlerPackageRegister+0x3a>
        LmHandlerPackages[id] = package;
 802955a:	00a4      	lsls	r4, r4, #2
 802955c:	4b0a      	ldr	r3, [pc, #40]	; (8029588 <LmHandlerPackageRegister+0x40>)
 802955e:	50e0      	str	r0, [r4, r3]
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8029560:	4b0a      	ldr	r3, [pc, #40]	; (802958c <LmHandlerPackageRegister+0x44>)
 8029562:	6243      	str	r3, [r0, #36]	; 0x24
        LmHandlerPackages[id]->OnSendRequest = LmHandlerSend;
 8029564:	4b0a      	ldr	r3, [pc, #40]	; (8029590 <LmHandlerPackageRegister+0x48>)
 8029566:	6283      	str	r3, [r0, #40]	; 0x28
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 8029568:	4b0a      	ldr	r3, [pc, #40]	; (8029594 <LmHandlerPackageRegister+0x4c>)
 802956a:	62c3      	str	r3, [r0, #44]	; 0x2c
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 802956c:	4b0a      	ldr	r3, [pc, #40]	; (8029598 <LmHandlerPackageRegister+0x50>)
 802956e:	681b      	ldr	r3, [r3, #0]
 8029570:	691b      	ldr	r3, [r3, #16]
 8029572:	6143      	str	r3, [r0, #20]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 8029574:	6843      	ldr	r3, [r0, #4]
 8029576:	22f2      	movs	r2, #242	; 0xf2
 8029578:	4908      	ldr	r1, [pc, #32]	; (802959c <LmHandlerPackageRegister+0x54>)
 802957a:	0028      	movs	r0, r5
 802957c:	4798      	blx	r3
        return LORAMAC_HANDLER_SUCCESS;
 802957e:	2000      	movs	r0, #0
}
 8029580:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_HANDLER_ERROR;
 8029582:	2001      	movs	r0, #1
 8029584:	4240      	negs	r0, r0
 8029586:	e7fb      	b.n	8029580 <LmHandlerPackageRegister+0x38>
 8029588:	2000a4a0 	.word	0x2000a4a0
 802958c:	08029181 	.word	0x08029181
 8029590:	0802921d 	.word	0x0802921d
 8029594:	08028e71 	.word	0x08028e71
 8029598:	2000a49c 	.word	0x2000a49c
 802959c:	2000a3a8 	.word	0x2000a3a8

080295a0 <LmHandlerInit>:
{
 80295a0:	b510      	push	{r4, lr}
    LmHandlerCallbacks = handlerCallbacks;
 80295a2:	4b10      	ldr	r3, [pc, #64]	; (80295e4 <LmHandlerInit+0x44>)
 80295a4:	6018      	str	r0, [r3, #0]
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 80295a6:	4b10      	ldr	r3, [pc, #64]	; (80295e8 <LmHandlerInit+0x48>)
 80295a8:	4a10      	ldr	r2, [pc, #64]	; (80295ec <LmHandlerInit+0x4c>)
 80295aa:	601a      	str	r2, [r3, #0]
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 80295ac:	4a10      	ldr	r2, [pc, #64]	; (80295f0 <LmHandlerInit+0x50>)
 80295ae:	605a      	str	r2, [r3, #4]
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 80295b0:	4a10      	ldr	r2, [pc, #64]	; (80295f4 <LmHandlerInit+0x54>)
 80295b2:	609a      	str	r2, [r3, #8]
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 80295b4:	4a10      	ldr	r2, [pc, #64]	; (80295f8 <LmHandlerInit+0x58>)
 80295b6:	60da      	str	r2, [r3, #12]
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 80295b8:	4b10      	ldr	r3, [pc, #64]	; (80295fc <LmHandlerInit+0x5c>)
 80295ba:	6802      	ldr	r2, [r0, #0]
 80295bc:	601a      	str	r2, [r3, #0]
    LoRaMacCallbacks.GetTemperatureLevel = LmHandlerCallbacks->GetTemperature;
 80295be:	6842      	ldr	r2, [r0, #4]
 80295c0:	605a      	str	r2, [r3, #4]
    LoRaMacCallbacks.GetUniqueId = LmHandlerCallbacks->GetUniqueId;
 80295c2:	6882      	ldr	r2, [r0, #8]
 80295c4:	609a      	str	r2, [r3, #8]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 80295c6:	4a0e      	ldr	r2, [pc, #56]	; (8029600 <LmHandlerInit+0x60>)
 80295c8:	60da      	str	r2, [r3, #12]
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 80295ca:	6902      	ldr	r2, [r0, #16]
 80295cc:	611a      	str	r2, [r3, #16]
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 80295ce:	490d      	ldr	r1, [pc, #52]	; (8029604 <LmHandlerInit+0x64>)
 80295d0:	2000      	movs	r0, #0
 80295d2:	f7ff ffb9 	bl	8029548 <LmHandlerPackageRegister>
 80295d6:	2800      	cmp	r0, #0
 80295d8:	d100      	bne.n	80295dc <LmHandlerInit+0x3c>
}
 80295da:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 80295dc:	2001      	movs	r0, #1
 80295de:	4240      	negs	r0, r0
 80295e0:	e7fb      	b.n	80295da <LmHandlerInit+0x3a>
 80295e2:	46c0      	nop			; (mov r8, r8)
 80295e4:	2000a49c 	.word	0x2000a49c
 80295e8:	2000a4d8 	.word	0x2000a4d8
 80295ec:	08028db1 	.word	0x08028db1
 80295f0:	080293bd 	.word	0x080293bd
 80295f4:	08029499 	.word	0x08029499
 80295f8:	08029325 	.word	0x08029325
 80295fc:	2000a4c4 	.word	0x2000a4c4
 8029600:	0802e6d7 	.word	0x0802e6d7
 8029604:	2000a05c 	.word	0x2000a05c

08029608 <LmHandlerGetDevEUI>:
{
 8029608:	b510      	push	{r4, lr}
 802960a:	b08a      	sub	sp, #40	; 0x28
 802960c:	1e04      	subs	r4, r0, #0
    if (devEUI == NULL)
 802960e:	d00e      	beq.n	802962e <LmHandlerGetDevEUI+0x26>
    mibReq.Type = MIB_DEV_EUI;
 8029610:	a801      	add	r0, sp, #4
 8029612:	2302      	movs	r3, #2
 8029614:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029616:	f003 fab3 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 802961a:	2800      	cmp	r0, #0
 802961c:	d10a      	bne.n	8029634 <LmHandlerGetDevEUI+0x2c>
    UTIL_MEM_cpy_8(devEUI, mibReq.Param.DevEui, SE_EUI_SIZE);
 802961e:	2208      	movs	r2, #8
 8029620:	9902      	ldr	r1, [sp, #8]
 8029622:	0020      	movs	r0, r4
 8029624:	f00a fb60 	bl	8033ce8 <UTIL_MEM_cpy_8>
    return LORAMAC_HANDLER_SUCCESS;
 8029628:	2000      	movs	r0, #0
}
 802962a:	b00a      	add	sp, #40	; 0x28
 802962c:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 802962e:	2001      	movs	r0, #1
 8029630:	4240      	negs	r0, r0
 8029632:	e7fa      	b.n	802962a <LmHandlerGetDevEUI+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029634:	2001      	movs	r0, #1
 8029636:	4240      	negs	r0, r0
 8029638:	e7f7      	b.n	802962a <LmHandlerGetDevEUI+0x22>

0802963a <LmHandlerSetDevEUI>:
{
 802963a:	b510      	push	{r4, lr}
 802963c:	b08a      	sub	sp, #40	; 0x28
 802963e:	0004      	movs	r4, r0
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 8029640:	f7ff fd0e 	bl	8029060 <LmHandlerJoinStatus>
 8029644:	2801      	cmp	r0, #1
 8029646:	d00d      	beq.n	8029664 <LmHandlerSetDevEUI+0x2a>
        mibReq.Type = MIB_DEV_EUI;
 8029648:	a801      	add	r0, sp, #4
 802964a:	2302      	movs	r3, #2
 802964c:	7003      	strb	r3, [r0, #0]
        mibReq.Param.DevEui = devEUI;
 802964e:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029650:	f003 fb7c 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029654:	2800      	cmp	r0, #0
 8029656:	d102      	bne.n	802965e <LmHandlerSetDevEUI+0x24>
        return LORAMAC_HANDLER_SUCCESS;
 8029658:	2000      	movs	r0, #0
}
 802965a:	b00a      	add	sp, #40	; 0x28
 802965c:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 802965e:	2001      	movs	r0, #1
 8029660:	4240      	negs	r0, r0
 8029662:	e7fa      	b.n	802965a <LmHandlerSetDevEUI+0x20>
        return LORAMAC_HANDLER_ERROR;
 8029664:	2001      	movs	r0, #1
 8029666:	4240      	negs	r0, r0
 8029668:	e7f7      	b.n	802965a <LmHandlerSetDevEUI+0x20>

0802966a <LmHandlerGetAppEUI>:
{
 802966a:	b510      	push	{r4, lr}
 802966c:	b08a      	sub	sp, #40	; 0x28
 802966e:	1e04      	subs	r4, r0, #0
    if (appEUI == NULL)
 8029670:	d00e      	beq.n	8029690 <LmHandlerGetAppEUI+0x26>
    mibReq.Type = MIB_JOIN_EUI;
 8029672:	a801      	add	r0, sp, #4
 8029674:	2303      	movs	r3, #3
 8029676:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029678:	f003 fa82 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 802967c:	2800      	cmp	r0, #0
 802967e:	d10a      	bne.n	8029696 <LmHandlerGetAppEUI+0x2c>
    UTIL_MEM_cpy_8(appEUI, mibReq.Param.JoinEui, SE_EUI_SIZE);
 8029680:	2208      	movs	r2, #8
 8029682:	9902      	ldr	r1, [sp, #8]
 8029684:	0020      	movs	r0, r4
 8029686:	f00a fb2f 	bl	8033ce8 <UTIL_MEM_cpy_8>
    return LORAMAC_HANDLER_SUCCESS;
 802968a:	2000      	movs	r0, #0
}
 802968c:	b00a      	add	sp, #40	; 0x28
 802968e:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029690:	2001      	movs	r0, #1
 8029692:	4240      	negs	r0, r0
 8029694:	e7fa      	b.n	802968c <LmHandlerGetAppEUI+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029696:	2001      	movs	r0, #1
 8029698:	4240      	negs	r0, r0
 802969a:	e7f7      	b.n	802968c <LmHandlerGetAppEUI+0x22>

0802969c <LmHandlerSetAppEUI>:
{
 802969c:	b510      	push	{r4, lr}
 802969e:	b08a      	sub	sp, #40	; 0x28
 80296a0:	0004      	movs	r4, r0
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 80296a2:	f7ff fcdd 	bl	8029060 <LmHandlerJoinStatus>
 80296a6:	2801      	cmp	r0, #1
 80296a8:	d00d      	beq.n	80296c6 <LmHandlerSetAppEUI+0x2a>
        mibReq.Type = MIB_JOIN_EUI;
 80296aa:	a801      	add	r0, sp, #4
 80296ac:	2303      	movs	r3, #3
 80296ae:	7003      	strb	r3, [r0, #0]
        mibReq.Param.JoinEui = appEUI;
 80296b0:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80296b2:	f003 fb4b 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 80296b6:	2800      	cmp	r0, #0
 80296b8:	d102      	bne.n	80296c0 <LmHandlerSetAppEUI+0x24>
        return LORAMAC_HANDLER_SUCCESS;
 80296ba:	2000      	movs	r0, #0
}
 80296bc:	b00a      	add	sp, #40	; 0x28
 80296be:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 80296c0:	2001      	movs	r0, #1
 80296c2:	4240      	negs	r0, r0
 80296c4:	e7fa      	b.n	80296bc <LmHandlerSetAppEUI+0x20>
        return LORAMAC_HANDLER_ERROR;
 80296c6:	2001      	movs	r0, #1
 80296c8:	4240      	negs	r0, r0
 80296ca:	e7f7      	b.n	80296bc <LmHandlerSetAppEUI+0x20>

080296cc <LmHandlerGetNetworkID>:
{
 80296cc:	b510      	push	{r4, lr}
 80296ce:	b08a      	sub	sp, #40	; 0x28
 80296d0:	1e04      	subs	r4, r0, #0
    if (networkId == NULL)
 80296d2:	d00a      	beq.n	80296ea <LmHandlerGetNetworkID+0x1e>
    mibReq.Type = MIB_NET_ID;
 80296d4:	a801      	add	r0, sp, #4
 80296d6:	2305      	movs	r3, #5
 80296d8:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80296da:	f003 fa51 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 80296de:	2800      	cmp	r0, #0
 80296e0:	d106      	bne.n	80296f0 <LmHandlerGetNetworkID+0x24>
    *networkId = mibReq.Param.NetID;
 80296e2:	9b02      	ldr	r3, [sp, #8]
 80296e4:	6023      	str	r3, [r4, #0]
}
 80296e6:	b00a      	add	sp, #40	; 0x28
 80296e8:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 80296ea:	2001      	movs	r0, #1
 80296ec:	4240      	negs	r0, r0
 80296ee:	e7fa      	b.n	80296e6 <LmHandlerGetNetworkID+0x1a>
        return LORAMAC_HANDLER_ERROR;
 80296f0:	2001      	movs	r0, #1
 80296f2:	4240      	negs	r0, r0
 80296f4:	e7f7      	b.n	80296e6 <LmHandlerGetNetworkID+0x1a>

080296f6 <LmHandlerSetNetworkID>:
{
 80296f6:	b510      	push	{r4, lr}
 80296f8:	b08a      	sub	sp, #40	; 0x28
 80296fa:	0004      	movs	r4, r0
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 80296fc:	f7ff fcb0 	bl	8029060 <LmHandlerJoinStatus>
 8029700:	2801      	cmp	r0, #1
 8029702:	d00d      	beq.n	8029720 <LmHandlerSetNetworkID+0x2a>
        mibReq.Type = MIB_NET_ID;
 8029704:	a801      	add	r0, sp, #4
 8029706:	2305      	movs	r3, #5
 8029708:	7003      	strb	r3, [r0, #0]
        mibReq.Param.NetID = networkId;
 802970a:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 802970c:	f003 fb1e 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029710:	2800      	cmp	r0, #0
 8029712:	d102      	bne.n	802971a <LmHandlerSetNetworkID+0x24>
        return LORAMAC_HANDLER_SUCCESS;
 8029714:	2000      	movs	r0, #0
}
 8029716:	b00a      	add	sp, #40	; 0x28
 8029718:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 802971a:	2001      	movs	r0, #1
 802971c:	4240      	negs	r0, r0
 802971e:	e7fa      	b.n	8029716 <LmHandlerSetNetworkID+0x20>
        return LORAMAC_HANDLER_ERROR;
 8029720:	2001      	movs	r0, #1
 8029722:	4240      	negs	r0, r0
 8029724:	e7f7      	b.n	8029716 <LmHandlerSetNetworkID+0x20>

08029726 <LmHandlerGetDevAddr>:
{
 8029726:	b510      	push	{r4, lr}
 8029728:	b08a      	sub	sp, #40	; 0x28
 802972a:	1e04      	subs	r4, r0, #0
    if (devAddr == NULL)
 802972c:	d00a      	beq.n	8029744 <LmHandlerGetDevAddr+0x1e>
    mibReq.Type = MIB_DEV_ADDR;
 802972e:	a801      	add	r0, sp, #4
 8029730:	2306      	movs	r3, #6
 8029732:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029734:	f003 fa24 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 8029738:	2800      	cmp	r0, #0
 802973a:	d106      	bne.n	802974a <LmHandlerGetDevAddr+0x24>
    *devAddr = mibReq.Param.DevAddr;
 802973c:	9b02      	ldr	r3, [sp, #8]
 802973e:	6023      	str	r3, [r4, #0]
}
 8029740:	b00a      	add	sp, #40	; 0x28
 8029742:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029744:	2001      	movs	r0, #1
 8029746:	4240      	negs	r0, r0
 8029748:	e7fa      	b.n	8029740 <LmHandlerGetDevAddr+0x1a>
        return LORAMAC_HANDLER_ERROR;
 802974a:	2001      	movs	r0, #1
 802974c:	4240      	negs	r0, r0
 802974e:	e7f7      	b.n	8029740 <LmHandlerGetDevAddr+0x1a>

08029750 <LmHandlerSetDevAddr>:
{
 8029750:	b510      	push	{r4, lr}
 8029752:	b08a      	sub	sp, #40	; 0x28
 8029754:	0004      	movs	r4, r0
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 8029756:	f7ff fc83 	bl	8029060 <LmHandlerJoinStatus>
 802975a:	2801      	cmp	r0, #1
 802975c:	d00d      	beq.n	802977a <LmHandlerSetDevAddr+0x2a>
        mibReq.Type = MIB_DEV_ADDR;
 802975e:	a801      	add	r0, sp, #4
 8029760:	2306      	movs	r3, #6
 8029762:	7003      	strb	r3, [r0, #0]
        mibReq.Param.DevAddr = devAddr;
 8029764:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029766:	f003 faf1 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 802976a:	2800      	cmp	r0, #0
 802976c:	d102      	bne.n	8029774 <LmHandlerSetDevAddr+0x24>
        return LORAMAC_HANDLER_SUCCESS;
 802976e:	2000      	movs	r0, #0
}
 8029770:	b00a      	add	sp, #40	; 0x28
 8029772:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 8029774:	2001      	movs	r0, #1
 8029776:	4240      	negs	r0, r0
 8029778:	e7fa      	b.n	8029770 <LmHandlerSetDevAddr+0x20>
        return LORAMAC_HANDLER_ERROR;
 802977a:	2001      	movs	r0, #1
 802977c:	4240      	negs	r0, r0
 802977e:	e7f7      	b.n	8029770 <LmHandlerSetDevAddr+0x20>

08029780 <LmHandlerSetActiveRegion>:
{
 8029780:	b510      	push	{r4, lr}
 8029782:	0004      	movs	r4, r0
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 8029784:	f7ff fc6c 	bl	8029060 <LmHandlerJoinStatus>
 8029788:	2801      	cmp	r0, #1
 802978a:	d004      	beq.n	8029796 <LmHandlerSetActiveRegion+0x16>
        LmHandlerParams.ActiveRegion = region;
 802978c:	4803      	ldr	r0, [pc, #12]	; (802979c <LmHandlerSetActiveRegion+0x1c>)
 802978e:	7004      	strb	r4, [r0, #0]
        return LmHandlerConfigure( &LmHandlerParams );
 8029790:	f7ff fb7c 	bl	8028e8c <LmHandlerConfigure>
}
 8029794:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029796:	2001      	movs	r0, #1
 8029798:	4240      	negs	r0, r0
 802979a:	e7fb      	b.n	8029794 <LmHandlerSetActiveRegion+0x14>
 802979c:	2000a4b4 	.word	0x2000a4b4

080297a0 <LmHandlerGetAdrEnable>:
    if (adrEnable == NULL)
 80297a0:	2800      	cmp	r0, #0
 80297a2:	d004      	beq.n	80297ae <LmHandlerGetAdrEnable+0xe>
    *adrEnable = LmHandlerParams.AdrEnable;
 80297a4:	4b03      	ldr	r3, [pc, #12]	; (80297b4 <LmHandlerGetAdrEnable+0x14>)
 80297a6:	789b      	ldrb	r3, [r3, #2]
 80297a8:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 80297aa:	2000      	movs	r0, #0
}
 80297ac:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 80297ae:	2001      	movs	r0, #1
 80297b0:	4240      	negs	r0, r0
 80297b2:	e7fb      	b.n	80297ac <LmHandlerGetAdrEnable+0xc>
 80297b4:	2000a4b4 	.word	0x2000a4b4

080297b8 <LmHandlerSetAdrEnable>:
{
 80297b8:	b510      	push	{r4, lr}
 80297ba:	b08a      	sub	sp, #40	; 0x28
 80297bc:	0004      	movs	r4, r0
    mibReq.Type = MIB_ADR;
 80297be:	2304      	movs	r3, #4
 80297c0:	466a      	mov	r2, sp
 80297c2:	7113      	strb	r3, [r2, #4]
    mibReq.Param.AdrEnable = adrEnable;
 80297c4:	7210      	strb	r0, [r2, #8]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80297c6:	a801      	add	r0, sp, #4
 80297c8:	f003 fac0 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 80297cc:	2800      	cmp	r0, #0
 80297ce:	d103      	bne.n	80297d8 <LmHandlerSetAdrEnable+0x20>
    LmHandlerParams.AdrEnable = adrEnable;
 80297d0:	4b03      	ldr	r3, [pc, #12]	; (80297e0 <LmHandlerSetAdrEnable+0x28>)
 80297d2:	709c      	strb	r4, [r3, #2]
}
 80297d4:	b00a      	add	sp, #40	; 0x28
 80297d6:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 80297d8:	2001      	movs	r0, #1
 80297da:	4240      	negs	r0, r0
 80297dc:	e7fa      	b.n	80297d4 <LmHandlerSetAdrEnable+0x1c>
 80297de:	46c0      	nop			; (mov r8, r8)
 80297e0:	2000a4b4 	.word	0x2000a4b4

080297e4 <LmHandlerSetTxDatarate>:
{
 80297e4:	b510      	push	{r4, lr}
 80297e6:	b08a      	sub	sp, #40	; 0x28
 80297e8:	0004      	movs	r4, r0
    if (LmHandlerParams.AdrEnable == true)
 80297ea:	4b0b      	ldr	r3, [pc, #44]	; (8029818 <LmHandlerSetTxDatarate+0x34>)
 80297ec:	789b      	ldrb	r3, [r3, #2]
 80297ee:	2b00      	cmp	r3, #0
 80297f0:	d10c      	bne.n	802980c <LmHandlerSetTxDatarate+0x28>
    mibReq.Type = MIB_CHANNELS_DATARATE;
 80297f2:	331f      	adds	r3, #31
 80297f4:	466a      	mov	r2, sp
 80297f6:	7113      	strb	r3, [r2, #4]
    mibReq.Param.ChannelsDatarate = txDatarate;
 80297f8:	7210      	strb	r0, [r2, #8]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80297fa:	a801      	add	r0, sp, #4
 80297fc:	f003 faa6 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029800:	2800      	cmp	r0, #0
 8029802:	d106      	bne.n	8029812 <LmHandlerSetTxDatarate+0x2e>
    LmHandlerParams.TxDatarate = txDatarate;
 8029804:	4b04      	ldr	r3, [pc, #16]	; (8029818 <LmHandlerSetTxDatarate+0x34>)
 8029806:	70dc      	strb	r4, [r3, #3]
}
 8029808:	b00a      	add	sp, #40	; 0x28
 802980a:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 802980c:	2001      	movs	r0, #1
 802980e:	4240      	negs	r0, r0
 8029810:	e7fa      	b.n	8029808 <LmHandlerSetTxDatarate+0x24>
        return LORAMAC_HANDLER_ERROR;
 8029812:	2001      	movs	r0, #1
 8029814:	4240      	negs	r0, r0
 8029816:	e7f7      	b.n	8029808 <LmHandlerSetTxDatarate+0x24>
 8029818:	2000a4b4 	.word	0x2000a4b4

0802981c <LmHandlerGetDutyCycleEnable>:
    if (dutyCycleEnable == NULL)
 802981c:	2800      	cmp	r0, #0
 802981e:	d004      	beq.n	802982a <LmHandlerGetDutyCycleEnable+0xe>
    *dutyCycleEnable = LmHandlerParams.DutyCycleEnabled;
 8029820:	4b03      	ldr	r3, [pc, #12]	; (8029830 <LmHandlerGetDutyCycleEnable+0x14>)
 8029822:	795b      	ldrb	r3, [r3, #5]
 8029824:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8029826:	2000      	movs	r0, #0
}
 8029828:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 802982a:	2001      	movs	r0, #1
 802982c:	4240      	negs	r0, r0
 802982e:	e7fb      	b.n	8029828 <LmHandlerGetDutyCycleEnable+0xc>
 8029830:	2000a4b4 	.word	0x2000a4b4

08029834 <LmHandlerSetDutyCycleEnable>:
{
 8029834:	b510      	push	{r4, lr}
    LmHandlerParams.DutyCycleEnabled = dutyCycleEnable;
 8029836:	4b03      	ldr	r3, [pc, #12]	; (8029844 <LmHandlerSetDutyCycleEnable+0x10>)
 8029838:	7158      	strb	r0, [r3, #5]
    LoRaMacTestSetDutyCycleOn(dutyCycleEnable);
 802983a:	f003 fe7d 	bl	802d538 <LoRaMacTestSetDutyCycleOn>
}
 802983e:	2000      	movs	r0, #0
 8029840:	bd10      	pop	{r4, pc}
 8029842:	46c0      	nop			; (mov r8, r8)
 8029844:	2000a4b4 	.word	0x2000a4b4

08029848 <LmHandlerGetRX2Params>:
{
 8029848:	b510      	push	{r4, lr}
 802984a:	b08a      	sub	sp, #40	; 0x28
 802984c:	1e04      	subs	r4, r0, #0
    if (rxParams == NULL)
 802984e:	d00d      	beq.n	802986c <LmHandlerGetRX2Params+0x24>
    mibReq.Type = MIB_RX2_CHANNEL;
 8029850:	a801      	add	r0, sp, #4
 8029852:	2312      	movs	r3, #18
 8029854:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029856:	f003 f993 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 802985a:	2800      	cmp	r0, #0
 802985c:	d109      	bne.n	8029872 <LmHandlerGetRX2Params+0x2a>
    rxParams->Frequency = mibReq.Param.Rx2Channel.Frequency;
 802985e:	ab01      	add	r3, sp, #4
 8029860:	9a02      	ldr	r2, [sp, #8]
 8029862:	6022      	str	r2, [r4, #0]
    rxParams->Datarate = mibReq.Param.Rx2Channel.Datarate;
 8029864:	7a1b      	ldrb	r3, [r3, #8]
 8029866:	7123      	strb	r3, [r4, #4]
}
 8029868:	b00a      	add	sp, #40	; 0x28
 802986a:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 802986c:	2001      	movs	r0, #1
 802986e:	4240      	negs	r0, r0
 8029870:	e7fa      	b.n	8029868 <LmHandlerGetRX2Params+0x20>
        return LORAMAC_HANDLER_ERROR;
 8029872:	2001      	movs	r0, #1
 8029874:	4240      	negs	r0, r0
 8029876:	e7f7      	b.n	8029868 <LmHandlerGetRX2Params+0x20>

08029878 <LmHandlerGetTxPower>:
{
 8029878:	b510      	push	{r4, lr}
 802987a:	b08a      	sub	sp, #40	; 0x28
 802987c:	1e04      	subs	r4, r0, #0
    if (txPower == NULL)
 802987e:	d00c      	beq.n	802989a <LmHandlerGetTxPower+0x22>
    mibReq.Type = MIB_CHANNELS_TX_POWER;
 8029880:	a801      	add	r0, sp, #4
 8029882:	2320      	movs	r3, #32
 8029884:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029886:	f003 f97b 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 802988a:	2800      	cmp	r0, #0
 802988c:	d108      	bne.n	80298a0 <LmHandlerGetTxPower+0x28>
    *txPower = mibReq.Param.ChannelsTxPower;
 802988e:	ab01      	add	r3, sp, #4
 8029890:	791b      	ldrb	r3, [r3, #4]
 8029892:	b25b      	sxtb	r3, r3
 8029894:	7023      	strb	r3, [r4, #0]
}
 8029896:	b00a      	add	sp, #40	; 0x28
 8029898:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 802989a:	2001      	movs	r0, #1
 802989c:	4240      	negs	r0, r0
 802989e:	e7fa      	b.n	8029896 <LmHandlerGetTxPower+0x1e>
        return LORAMAC_HANDLER_ERROR;
 80298a0:	2001      	movs	r0, #1
 80298a2:	4240      	negs	r0, r0
 80298a4:	e7f7      	b.n	8029896 <LmHandlerGetTxPower+0x1e>

080298a6 <LmHandlerGetRx1Delay>:
{
 80298a6:	b510      	push	{r4, lr}
 80298a8:	b08a      	sub	sp, #40	; 0x28
 80298aa:	1e04      	subs	r4, r0, #0
    if (rxDelay == NULL)
 80298ac:	d00a      	beq.n	80298c4 <LmHandlerGetRx1Delay+0x1e>
    mibReq.Type = MIB_RECEIVE_DELAY_1;
 80298ae:	a801      	add	r0, sp, #4
 80298b0:	231a      	movs	r3, #26
 80298b2:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80298b4:	f003 f964 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 80298b8:	2800      	cmp	r0, #0
 80298ba:	d106      	bne.n	80298ca <LmHandlerGetRx1Delay+0x24>
    *rxDelay = mibReq.Param.ReceiveDelay1;
 80298bc:	9b02      	ldr	r3, [sp, #8]
 80298be:	6023      	str	r3, [r4, #0]
}
 80298c0:	b00a      	add	sp, #40	; 0x28
 80298c2:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 80298c4:	2001      	movs	r0, #1
 80298c6:	4240      	negs	r0, r0
 80298c8:	e7fa      	b.n	80298c0 <LmHandlerGetRx1Delay+0x1a>
        return LORAMAC_HANDLER_ERROR;
 80298ca:	2001      	movs	r0, #1
 80298cc:	4240      	negs	r0, r0
 80298ce:	e7f7      	b.n	80298c0 <LmHandlerGetRx1Delay+0x1a>

080298d0 <LmHandlerGetRx2Delay>:
{
 80298d0:	b510      	push	{r4, lr}
 80298d2:	b08a      	sub	sp, #40	; 0x28
 80298d4:	1e04      	subs	r4, r0, #0
    if (rxDelay == NULL)
 80298d6:	d00a      	beq.n	80298ee <LmHandlerGetRx2Delay+0x1e>
    mibReq.Type = MIB_RECEIVE_DELAY_2;
 80298d8:	a801      	add	r0, sp, #4
 80298da:	231b      	movs	r3, #27
 80298dc:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80298de:	f003 f94f 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 80298e2:	2800      	cmp	r0, #0
 80298e4:	d106      	bne.n	80298f4 <LmHandlerGetRx2Delay+0x24>
    *rxDelay = mibReq.Param.ReceiveDelay2;
 80298e6:	9b02      	ldr	r3, [sp, #8]
 80298e8:	6023      	str	r3, [r4, #0]
}
 80298ea:	b00a      	add	sp, #40	; 0x28
 80298ec:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 80298ee:	2001      	movs	r0, #1
 80298f0:	4240      	negs	r0, r0
 80298f2:	e7fa      	b.n	80298ea <LmHandlerGetRx2Delay+0x1a>
        return LORAMAC_HANDLER_ERROR;
 80298f4:	2001      	movs	r0, #1
 80298f6:	4240      	negs	r0, r0
 80298f8:	e7f7      	b.n	80298ea <LmHandlerGetRx2Delay+0x1a>

080298fa <LmHandlerGetJoinRx1Delay>:
{
 80298fa:	b510      	push	{r4, lr}
 80298fc:	b08a      	sub	sp, #40	; 0x28
 80298fe:	1e04      	subs	r4, r0, #0
    if (rxDelay == NULL)
 8029900:	d00a      	beq.n	8029918 <LmHandlerGetJoinRx1Delay+0x1e>
    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_1;
 8029902:	a801      	add	r0, sp, #4
 8029904:	231c      	movs	r3, #28
 8029906:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029908:	f003 f93a 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 802990c:	2800      	cmp	r0, #0
 802990e:	d106      	bne.n	802991e <LmHandlerGetJoinRx1Delay+0x24>
    *rxDelay = mibReq.Param.JoinAcceptDelay1;
 8029910:	9b02      	ldr	r3, [sp, #8]
 8029912:	6023      	str	r3, [r4, #0]
}
 8029914:	b00a      	add	sp, #40	; 0x28
 8029916:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029918:	2001      	movs	r0, #1
 802991a:	4240      	negs	r0, r0
 802991c:	e7fa      	b.n	8029914 <LmHandlerGetJoinRx1Delay+0x1a>
        return LORAMAC_HANDLER_ERROR;
 802991e:	2001      	movs	r0, #1
 8029920:	4240      	negs	r0, r0
 8029922:	e7f7      	b.n	8029914 <LmHandlerGetJoinRx1Delay+0x1a>

08029924 <LmHandlerGetJoinRx2Delay>:
{
 8029924:	b510      	push	{r4, lr}
 8029926:	b08a      	sub	sp, #40	; 0x28
 8029928:	1e04      	subs	r4, r0, #0
    if (rxDelay == NULL)
 802992a:	d00a      	beq.n	8029942 <LmHandlerGetJoinRx2Delay+0x1e>
    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_2;
 802992c:	a801      	add	r0, sp, #4
 802992e:	231d      	movs	r3, #29
 8029930:	7003      	strb	r3, [r0, #0]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029932:	f003 f925 	bl	802cb80 <LoRaMacMibGetRequestConfirm>
 8029936:	2800      	cmp	r0, #0
 8029938:	d106      	bne.n	8029948 <LmHandlerGetJoinRx2Delay+0x24>
    *rxDelay = mibReq.Param.JoinAcceptDelay2;
 802993a:	9b02      	ldr	r3, [sp, #8]
 802993c:	6023      	str	r3, [r4, #0]
}
 802993e:	b00a      	add	sp, #40	; 0x28
 8029940:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029942:	2001      	movs	r0, #1
 8029944:	4240      	negs	r0, r0
 8029946:	e7fa      	b.n	802993e <LmHandlerGetJoinRx2Delay+0x1a>
        return LORAMAC_HANDLER_ERROR;
 8029948:	2001      	movs	r0, #1
 802994a:	4240      	negs	r0, r0
 802994c:	e7f7      	b.n	802993e <LmHandlerGetJoinRx2Delay+0x1a>

0802994e <LmHandlerSetTxPower>:
{
 802994e:	b500      	push	{lr}
 8029950:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_CHANNELS_TX_POWER;
 8029952:	2320      	movs	r3, #32
 8029954:	466a      	mov	r2, sp
 8029956:	7113      	strb	r3, [r2, #4]
    mibReq.Param.ChannelsTxPower = txPower;
 8029958:	7210      	strb	r0, [r2, #8]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 802995a:	a801      	add	r0, sp, #4
 802995c:	f003 f9f6 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029960:	2800      	cmp	r0, #0
 8029962:	d101      	bne.n	8029968 <LmHandlerSetTxPower+0x1a>
}
 8029964:	b00b      	add	sp, #44	; 0x2c
 8029966:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029968:	2001      	movs	r0, #1
 802996a:	4240      	negs	r0, r0
 802996c:	e7fa      	b.n	8029964 <LmHandlerSetTxPower+0x16>

0802996e <LmHandlerSetRX2Params>:
{
 802996e:	b500      	push	{lr}
 8029970:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_RX2_CHANNEL;
 8029972:	2312      	movs	r3, #18
 8029974:	466a      	mov	r2, sp
 8029976:	7113      	strb	r3, [r2, #4]
    mibReq.Param.Rx2Channel.Frequency = rxParams->Frequency;
 8029978:	6803      	ldr	r3, [r0, #0]
 802997a:	9302      	str	r3, [sp, #8]
    mibReq.Param.Rx2Channel.Datarate = rxParams->Datarate;
 802997c:	7903      	ldrb	r3, [r0, #4]
 802997e:	7313      	strb	r3, [r2, #12]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029980:	a801      	add	r0, sp, #4
 8029982:	f003 f9e3 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029986:	2800      	cmp	r0, #0
 8029988:	d101      	bne.n	802998e <LmHandlerSetRX2Params+0x20>
}
 802998a:	b00b      	add	sp, #44	; 0x2c
 802998c:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 802998e:	2001      	movs	r0, #1
 8029990:	4240      	negs	r0, r0
 8029992:	e7fa      	b.n	802998a <LmHandlerSetRX2Params+0x1c>

08029994 <LmHandlerSetRx1Delay>:
{
 8029994:	b500      	push	{lr}
 8029996:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_RECEIVE_DELAY_1;
 8029998:	ab01      	add	r3, sp, #4
 802999a:	221a      	movs	r2, #26
 802999c:	701a      	strb	r2, [r3, #0]
    mibReq.Param.ReceiveDelay1 = rxDelay;
 802999e:	9002      	str	r0, [sp, #8]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80299a0:	0018      	movs	r0, r3
 80299a2:	f003 f9d3 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 80299a6:	2800      	cmp	r0, #0
 80299a8:	d101      	bne.n	80299ae <LmHandlerSetRx1Delay+0x1a>
}
 80299aa:	b00b      	add	sp, #44	; 0x2c
 80299ac:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 80299ae:	2001      	movs	r0, #1
 80299b0:	4240      	negs	r0, r0
 80299b2:	e7fa      	b.n	80299aa <LmHandlerSetRx1Delay+0x16>

080299b4 <LmHandlerSetRx2Delay>:
{
 80299b4:	b500      	push	{lr}
 80299b6:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_RECEIVE_DELAY_2;
 80299b8:	ab01      	add	r3, sp, #4
 80299ba:	221b      	movs	r2, #27
 80299bc:	701a      	strb	r2, [r3, #0]
    mibReq.Param.ReceiveDelay2 = rxDelay;
 80299be:	9002      	str	r0, [sp, #8]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80299c0:	0018      	movs	r0, r3
 80299c2:	f003 f9c3 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 80299c6:	2800      	cmp	r0, #0
 80299c8:	d101      	bne.n	80299ce <LmHandlerSetRx2Delay+0x1a>
}
 80299ca:	b00b      	add	sp, #44	; 0x2c
 80299cc:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 80299ce:	2001      	movs	r0, #1
 80299d0:	4240      	negs	r0, r0
 80299d2:	e7fa      	b.n	80299ca <LmHandlerSetRx2Delay+0x16>

080299d4 <LmHandlerSetJoinRx1Delay>:
{
 80299d4:	b500      	push	{lr}
 80299d6:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_1;
 80299d8:	ab01      	add	r3, sp, #4
 80299da:	221c      	movs	r2, #28
 80299dc:	701a      	strb	r2, [r3, #0]
    mibReq.Param.JoinAcceptDelay1 = rxDelay;
 80299de:	9002      	str	r0, [sp, #8]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 80299e0:	0018      	movs	r0, r3
 80299e2:	f003 f9b3 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 80299e6:	2800      	cmp	r0, #0
 80299e8:	d101      	bne.n	80299ee <LmHandlerSetJoinRx1Delay+0x1a>
}
 80299ea:	b00b      	add	sp, #44	; 0x2c
 80299ec:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 80299ee:	2001      	movs	r0, #1
 80299f0:	4240      	negs	r0, r0
 80299f2:	e7fa      	b.n	80299ea <LmHandlerSetJoinRx1Delay+0x16>

080299f4 <LmHandlerSetJoinRx2Delay>:
{
 80299f4:	b500      	push	{lr}
 80299f6:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_2;
 80299f8:	ab01      	add	r3, sp, #4
 80299fa:	221d      	movs	r2, #29
 80299fc:	701a      	strb	r2, [r3, #0]
    mibReq.Param.JoinAcceptDelay2 = rxDelay;
 80299fe:	9002      	str	r0, [sp, #8]
    if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029a00:	0018      	movs	r0, r3
 8029a02:	f003 f9a3 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029a06:	2800      	cmp	r0, #0
 8029a08:	d101      	bne.n	8029a0e <LmHandlerSetJoinRx2Delay+0x1a>
}
 8029a0a:	b00b      	add	sp, #44	; 0x2c
 8029a0c:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029a0e:	2001      	movs	r0, #1
 8029a10:	4240      	negs	r0, r0
 8029a12:	e7fa      	b.n	8029a0a <LmHandlerSetJoinRx2Delay+0x16>

08029a14 <LmHandlerGetPingPeriodicity>:
    return LORAMAC_HANDLER_ERROR;
 8029a14:	2001      	movs	r0, #1
}
 8029a16:	4240      	negs	r0, r0
 8029a18:	4770      	bx	lr

08029a1a <LmHandlerSetPingPeriodicity>:
    return LORAMAC_HANDLER_ERROR;
 8029a1a:	2001      	movs	r0, #1
}
 8029a1c:	4240      	negs	r0, r0
 8029a1e:	4770      	bx	lr

08029a20 <LmHandlerGetBeaconState>:
    return LORAMAC_HANDLER_ERROR;
 8029a20:	2001      	movs	r0, #1
}
 8029a22:	4240      	negs	r0, r0
 8029a24:	4770      	bx	lr

08029a26 <LmHandlerGetNwkKey>:
{
 8029a26:	b510      	push	{r4, lr}
 8029a28:	b082      	sub	sp, #8
 8029a2a:	1e04      	subs	r4, r0, #0
    if (nwkKey == NULL)
 8029a2c:	d00e      	beq.n	8029a4c <LmHandlerGetNwkKey+0x26>
    if (SECURE_ELEMENT_SUCCESS != SecureElementGetKeyByID(NWK_KEY, &keyItem))
 8029a2e:	a901      	add	r1, sp, #4
 8029a30:	2001      	movs	r0, #1
 8029a32:	f007 fa01 	bl	8030e38 <SecureElementGetKeyByID>
 8029a36:	2800      	cmp	r0, #0
 8029a38:	d10b      	bne.n	8029a52 <LmHandlerGetNwkKey+0x2c>
    UTIL_MEM_cpy_8( nwkKey, keyItem->KeyValue, 16 );
 8029a3a:	9b01      	ldr	r3, [sp, #4]
 8029a3c:	1c59      	adds	r1, r3, #1
 8029a3e:	2210      	movs	r2, #16
 8029a40:	0020      	movs	r0, r4
 8029a42:	f00a f951 	bl	8033ce8 <UTIL_MEM_cpy_8>
    return LORAMAC_HANDLER_SUCCESS;
 8029a46:	2000      	movs	r0, #0
}
 8029a48:	b002      	add	sp, #8
 8029a4a:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029a4c:	2001      	movs	r0, #1
 8029a4e:	4240      	negs	r0, r0
 8029a50:	e7fa      	b.n	8029a48 <LmHandlerGetNwkKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029a52:	2001      	movs	r0, #1
 8029a54:	4240      	negs	r0, r0
 8029a56:	e7f7      	b.n	8029a48 <LmHandlerGetNwkKey+0x22>

08029a58 <LmHandlerSetNwkKey>:
{
 8029a58:	b510      	push	{r4, lr}
 8029a5a:	b08a      	sub	sp, #40	; 0x28
 8029a5c:	0004      	movs	r4, r0
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8029a5e:	f7ff faff 	bl	8029060 <LmHandlerJoinStatus>
 8029a62:	2801      	cmp	r0, #1
 8029a64:	d00d      	beq.n	8029a82 <LmHandlerSetNwkKey+0x2a>
        mibReq.Type = MIB_NWK_KEY;
 8029a66:	a801      	add	r0, sp, #4
 8029a68:	2308      	movs	r3, #8
 8029a6a:	7003      	strb	r3, [r0, #0]
        mibReq.Param.NwkKey = nwkKey;
 8029a6c:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029a6e:	f003 f96d 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029a72:	2800      	cmp	r0, #0
 8029a74:	d003      	beq.n	8029a7e <LmHandlerSetNwkKey+0x26>
            return LORAMAC_HANDLER_ERROR;
 8029a76:	2001      	movs	r0, #1
 8029a78:	4240      	negs	r0, r0
}
 8029a7a:	b00a      	add	sp, #40	; 0x28
 8029a7c:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_SUCCESS;
 8029a7e:	2000      	movs	r0, #0
 8029a80:	e7fb      	b.n	8029a7a <LmHandlerSetNwkKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029a82:	2001      	movs	r0, #1
 8029a84:	4240      	negs	r0, r0
 8029a86:	e7f8      	b.n	8029a7a <LmHandlerSetNwkKey+0x22>

08029a88 <LmHandlerGetAppKey>:
{
 8029a88:	b510      	push	{r4, lr}
 8029a8a:	b082      	sub	sp, #8
 8029a8c:	1e04      	subs	r4, r0, #0
    if (appKey == NULL)
 8029a8e:	d00e      	beq.n	8029aae <LmHandlerGetAppKey+0x26>
    if (SECURE_ELEMENT_SUCCESS != SecureElementGetKeyByID(APP_KEY, &keyItem))
 8029a90:	a901      	add	r1, sp, #4
 8029a92:	2000      	movs	r0, #0
 8029a94:	f007 f9d0 	bl	8030e38 <SecureElementGetKeyByID>
 8029a98:	2800      	cmp	r0, #0
 8029a9a:	d10b      	bne.n	8029ab4 <LmHandlerGetAppKey+0x2c>
    UTIL_MEM_cpy_8( appKey, keyItem->KeyValue, 16 );
 8029a9c:	9b01      	ldr	r3, [sp, #4]
 8029a9e:	1c59      	adds	r1, r3, #1
 8029aa0:	2210      	movs	r2, #16
 8029aa2:	0020      	movs	r0, r4
 8029aa4:	f00a f920 	bl	8033ce8 <UTIL_MEM_cpy_8>
    return LORAMAC_HANDLER_SUCCESS;
 8029aa8:	2000      	movs	r0, #0
}
 8029aaa:	b002      	add	sp, #8
 8029aac:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029aae:	2001      	movs	r0, #1
 8029ab0:	4240      	negs	r0, r0
 8029ab2:	e7fa      	b.n	8029aaa <LmHandlerGetAppKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029ab4:	2001      	movs	r0, #1
 8029ab6:	4240      	negs	r0, r0
 8029ab8:	e7f7      	b.n	8029aaa <LmHandlerGetAppKey+0x22>

08029aba <LmHandlerSetAppKey>:
{
 8029aba:	b510      	push	{r4, lr}
 8029abc:	b08a      	sub	sp, #40	; 0x28
 8029abe:	0004      	movs	r4, r0
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8029ac0:	f7ff face 	bl	8029060 <LmHandlerJoinStatus>
 8029ac4:	2801      	cmp	r0, #1
 8029ac6:	d00d      	beq.n	8029ae4 <LmHandlerSetAppKey+0x2a>
        mibReq.Type = MIB_APP_KEY;
 8029ac8:	a801      	add	r0, sp, #4
 8029aca:	2307      	movs	r3, #7
 8029acc:	7003      	strb	r3, [r0, #0]
        mibReq.Param.AppKey = appKey;
 8029ace:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029ad0:	f003 f93c 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029ad4:	2800      	cmp	r0, #0
 8029ad6:	d003      	beq.n	8029ae0 <LmHandlerSetAppKey+0x26>
            return LORAMAC_HANDLER_ERROR;
 8029ad8:	2001      	movs	r0, #1
 8029ada:	4240      	negs	r0, r0
}
 8029adc:	b00a      	add	sp, #40	; 0x28
 8029ade:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_SUCCESS;
 8029ae0:	2000      	movs	r0, #0
 8029ae2:	e7fb      	b.n	8029adc <LmHandlerSetAppKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029ae4:	2001      	movs	r0, #1
 8029ae6:	4240      	negs	r0, r0
 8029ae8:	e7f8      	b.n	8029adc <LmHandlerSetAppKey+0x22>

08029aea <LmHandlerGetNwkSKey>:
{
 8029aea:	b510      	push	{r4, lr}
 8029aec:	b082      	sub	sp, #8
 8029aee:	1e04      	subs	r4, r0, #0
    if (nwkSKey == NULL)
 8029af0:	d00e      	beq.n	8029b10 <LmHandlerGetNwkSKey+0x26>
    if (SECURE_ELEMENT_SUCCESS != SecureElementGetKeyByID(NWK_S_KEY, &keyItem))
 8029af2:	a901      	add	r1, sp, #4
 8029af4:	2002      	movs	r0, #2
 8029af6:	f007 f99f 	bl	8030e38 <SecureElementGetKeyByID>
 8029afa:	2800      	cmp	r0, #0
 8029afc:	d10b      	bne.n	8029b16 <LmHandlerGetNwkSKey+0x2c>
    UTIL_MEM_cpy_8( nwkSKey, keyItem->KeyValue, 16 );
 8029afe:	9b01      	ldr	r3, [sp, #4]
 8029b00:	1c59      	adds	r1, r3, #1
 8029b02:	2210      	movs	r2, #16
 8029b04:	0020      	movs	r0, r4
 8029b06:	f00a f8ef 	bl	8033ce8 <UTIL_MEM_cpy_8>
    return LORAMAC_HANDLER_SUCCESS;
 8029b0a:	2000      	movs	r0, #0
}
 8029b0c:	b002      	add	sp, #8
 8029b0e:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029b10:	2001      	movs	r0, #1
 8029b12:	4240      	negs	r0, r0
 8029b14:	e7fa      	b.n	8029b0c <LmHandlerGetNwkSKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029b16:	2001      	movs	r0, #1
 8029b18:	4240      	negs	r0, r0
 8029b1a:	e7f7      	b.n	8029b0c <LmHandlerGetNwkSKey+0x22>

08029b1c <LmHandlerSetNwkSKey>:
{
 8029b1c:	b510      	push	{r4, lr}
 8029b1e:	b08a      	sub	sp, #40	; 0x28
 8029b20:	0004      	movs	r4, r0
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8029b22:	f7ff fa9d 	bl	8029060 <LmHandlerJoinStatus>
 8029b26:	2801      	cmp	r0, #1
 8029b28:	d00d      	beq.n	8029b46 <LmHandlerSetNwkSKey+0x2a>
        mibReq.Type = MIB_NWK_S_KEY;
 8029b2a:	a801      	add	r0, sp, #4
 8029b2c:	2309      	movs	r3, #9
 8029b2e:	7003      	strb	r3, [r0, #0]
        mibReq.Param.NwkSKey = nwkSKey;
 8029b30:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029b32:	f003 f90b 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029b36:	2800      	cmp	r0, #0
 8029b38:	d003      	beq.n	8029b42 <LmHandlerSetNwkSKey+0x26>
            return LORAMAC_HANDLER_ERROR;
 8029b3a:	2001      	movs	r0, #1
 8029b3c:	4240      	negs	r0, r0
}
 8029b3e:	b00a      	add	sp, #40	; 0x28
 8029b40:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_SUCCESS;
 8029b42:	2000      	movs	r0, #0
 8029b44:	e7fb      	b.n	8029b3e <LmHandlerSetNwkSKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029b46:	2001      	movs	r0, #1
 8029b48:	4240      	negs	r0, r0
 8029b4a:	e7f8      	b.n	8029b3e <LmHandlerSetNwkSKey+0x22>

08029b4c <LmHandlerGetAppSKey>:
{
 8029b4c:	b510      	push	{r4, lr}
 8029b4e:	b082      	sub	sp, #8
 8029b50:	1e04      	subs	r4, r0, #0
    if (appSKey == NULL)
 8029b52:	d00e      	beq.n	8029b72 <LmHandlerGetAppSKey+0x26>
    if (SECURE_ELEMENT_SUCCESS != SecureElementGetKeyByID(APP_S_KEY, &keyItem))
 8029b54:	a901      	add	r1, sp, #4
 8029b56:	2003      	movs	r0, #3
 8029b58:	f007 f96e 	bl	8030e38 <SecureElementGetKeyByID>
 8029b5c:	2800      	cmp	r0, #0
 8029b5e:	d10b      	bne.n	8029b78 <LmHandlerGetAppSKey+0x2c>
    UTIL_MEM_cpy_8( appSKey, keyItem->KeyValue, 16 );
 8029b60:	9b01      	ldr	r3, [sp, #4]
 8029b62:	1c59      	adds	r1, r3, #1
 8029b64:	2210      	movs	r2, #16
 8029b66:	0020      	movs	r0, r4
 8029b68:	f00a f8be 	bl	8033ce8 <UTIL_MEM_cpy_8>
    return LORAMAC_HANDLER_SUCCESS;
 8029b6c:	2000      	movs	r0, #0
}
 8029b6e:	b002      	add	sp, #8
 8029b70:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029b72:	2001      	movs	r0, #1
 8029b74:	4240      	negs	r0, r0
 8029b76:	e7fa      	b.n	8029b6e <LmHandlerGetAppSKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029b78:	2001      	movs	r0, #1
 8029b7a:	4240      	negs	r0, r0
 8029b7c:	e7f7      	b.n	8029b6e <LmHandlerGetAppSKey+0x22>

08029b7e <LmHandlerSetAppSKey>:
{
 8029b7e:	b510      	push	{r4, lr}
 8029b80:	b08a      	sub	sp, #40	; 0x28
 8029b82:	0004      	movs	r4, r0
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8029b84:	f7ff fa6c 	bl	8029060 <LmHandlerJoinStatus>
 8029b88:	2801      	cmp	r0, #1
 8029b8a:	d00d      	beq.n	8029ba8 <LmHandlerSetAppSKey+0x2a>
        mibReq.Type = MIB_APP_S_KEY;
 8029b8c:	a801      	add	r0, sp, #4
 8029b8e:	230a      	movs	r3, #10
 8029b90:	7003      	strb	r3, [r0, #0]
        mibReq.Param.AppSKey = appSKey;
 8029b92:	6044      	str	r4, [r0, #4]
        if (LoRaMacMibSetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8029b94:	f003 f8da 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
 8029b98:	2800      	cmp	r0, #0
 8029b9a:	d003      	beq.n	8029ba4 <LmHandlerSetAppSKey+0x26>
            return LORAMAC_HANDLER_ERROR;
 8029b9c:	2001      	movs	r0, #1
 8029b9e:	4240      	negs	r0, r0
}
 8029ba0:	b00a      	add	sp, #40	; 0x28
 8029ba2:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_SUCCESS;
 8029ba4:	2000      	movs	r0, #0
 8029ba6:	e7fb      	b.n	8029ba0 <LmHandlerSetAppSKey+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029ba8:	2001      	movs	r0, #1
 8029baa:	4240      	negs	r0, r0
 8029bac:	e7f8      	b.n	8029ba0 <LmHandlerSetAppSKey+0x22>
	...

08029bb0 <LmhpComplianceInit>:
    return &LmhpCompliancePackage;
}

static void LmhpComplianceInit( void *params, uint8_t *dataBuffer, uint8_t dataBufferMaxSize )
{
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 8029bb0:	2800      	cmp	r0, #0
 8029bb2:	d009      	beq.n	8029bc8 <LmhpComplianceInit+0x18>
 8029bb4:	2900      	cmp	r1, #0
 8029bb6:	d007      	beq.n	8029bc8 <LmhpComplianceInit+0x18>
    {
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
 8029bb8:	4b06      	ldr	r3, [pc, #24]	; (8029bd4 <LmhpComplianceInit+0x24>)
 8029bba:	6018      	str	r0, [r3, #0]
        ComplianceTestState.DataBuffer = dataBuffer;
 8029bbc:	4b06      	ldr	r3, [pc, #24]	; (8029bd8 <LmhpComplianceInit+0x28>)
 8029bbe:	6099      	str	r1, [r3, #8]
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 8029bc0:	715a      	strb	r2, [r3, #5]
        ComplianceTestState.Initialized = true;
 8029bc2:	2201      	movs	r2, #1
 8029bc4:	701a      	strb	r2, [r3, #0]
 8029bc6:	e004      	b.n	8029bd2 <LmhpComplianceInit+0x22>
    }
    else
    {
        LmhpComplianceParams = NULL;
 8029bc8:	2300      	movs	r3, #0
 8029bca:	4a02      	ldr	r2, [pc, #8]	; (8029bd4 <LmhpComplianceInit+0x24>)
 8029bcc:	6013      	str	r3, [r2, #0]
        ComplianceTestState.Initialized = false;
 8029bce:	4a02      	ldr	r2, [pc, #8]	; (8029bd8 <LmhpComplianceInit+0x28>)
 8029bd0:	7013      	strb	r3, [r2, #0]
    }
}
 8029bd2:	4770      	bx	lr
 8029bd4:	2000a52c 	.word	0x2000a52c
 8029bd8:	2000a500 	.word	0x2000a500

08029bdc <LmhpComplianceIsInitialized>:

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
 8029bdc:	4b01      	ldr	r3, [pc, #4]	; (8029be4 <LmhpComplianceIsInitialized+0x8>)
 8029bde:	7818      	ldrb	r0, [r3, #0]
}
 8029be0:	4770      	bx	lr
 8029be2:	46c0      	nop			; (mov r8, r8)
 8029be4:	2000a500 	.word	0x2000a500

08029be8 <LmhpComplianceIsRunning>:

static bool LmhpComplianceIsRunning( void )
{
    if( ComplianceTestState.Initialized == false )
 8029be8:	4b02      	ldr	r3, [pc, #8]	; (8029bf4 <LmhpComplianceIsRunning+0xc>)
 8029bea:	7818      	ldrb	r0, [r3, #0]
 8029bec:	2800      	cmp	r0, #0
 8029bee:	d000      	beq.n	8029bf2 <LmhpComplianceIsRunning+0xa>
    {
        return false;
    }

    return ComplianceTestState.IsRunning;
 8029bf0:	7858      	ldrb	r0, [r3, #1]
}
 8029bf2:	4770      	bx	lr
 8029bf4:	2000a500 	.word	0x2000a500

08029bf8 <LmhpComplianceOnMcpsConfirm>:

static void LmhpComplianceOnMcpsConfirm(McpsConfirm_t *mcpsConfirm)
{
    if (ComplianceTestState.Initialized == false)
 8029bf8:	4b09      	ldr	r3, [pc, #36]	; (8029c20 <LmhpComplianceOnMcpsConfirm+0x28>)
 8029bfa:	781b      	ldrb	r3, [r3, #0]
 8029bfc:	2b00      	cmp	r3, #0
 8029bfe:	d006      	beq.n	8029c0e <LmhpComplianceOnMcpsConfirm+0x16>
    {
        return;
    }

    if ((ComplianceTestState.IsRunning == true) &&
 8029c00:	4b07      	ldr	r3, [pc, #28]	; (8029c20 <LmhpComplianceOnMcpsConfirm+0x28>)
 8029c02:	785b      	ldrb	r3, [r3, #1]
 8029c04:	2b00      	cmp	r3, #0
 8029c06:	d002      	beq.n	8029c0e <LmhpComplianceOnMcpsConfirm+0x16>
        (mcpsConfirm->McpsRequest == MCPS_CONFIRMED) &&
 8029c08:	7803      	ldrb	r3, [r0, #0]
    if ((ComplianceTestState.IsRunning == true) &&
 8029c0a:	2b01      	cmp	r3, #1
 8029c0c:	d000      	beq.n	8029c10 <LmhpComplianceOnMcpsConfirm+0x18>
        (mcpsConfirm->AckReceived != 0))
    {
        /* Increment the compliance certification protocol downlink counter */
        ComplianceTestState.DownLinkCounter++;
    }
}
 8029c0e:	4770      	bx	lr
        (mcpsConfirm->AckReceived != 0))
 8029c10:	7903      	ldrb	r3, [r0, #4]
        (mcpsConfirm->McpsRequest == MCPS_CONFIRMED) &&
 8029c12:	2b00      	cmp	r3, #0
 8029c14:	d0fb      	beq.n	8029c0e <LmhpComplianceOnMcpsConfirm+0x16>
        ComplianceTestState.DownLinkCounter++;
 8029c16:	4a02      	ldr	r2, [pc, #8]	; (8029c20 <LmhpComplianceOnMcpsConfirm+0x28>)
 8029c18:	8993      	ldrh	r3, [r2, #12]
 8029c1a:	3301      	adds	r3, #1
 8029c1c:	8193      	strh	r3, [r2, #12]
 8029c1e:	e7f6      	b.n	8029c0e <LmhpComplianceOnMcpsConfirm+0x16>
 8029c20:	2000a500 	.word	0x2000a500

08029c24 <LmhpComplianceOnMlmeConfirm>:

static void LmhpComplianceOnMlmeConfirm( MlmeConfirm_t *mlmeConfirm )
{
    if( ComplianceTestState.Initialized == false )
 8029c24:	4b09      	ldr	r3, [pc, #36]	; (8029c4c <LmhpComplianceOnMlmeConfirm+0x28>)
 8029c26:	781b      	ldrb	r3, [r3, #0]
 8029c28:	2b00      	cmp	r3, #0
 8029c2a:	d006      	beq.n	8029c3a <LmhpComplianceOnMlmeConfirm+0x16>
    {
        return;
    }

    if( ComplianceTestState.IsRunning == false )
 8029c2c:	4b07      	ldr	r3, [pc, #28]	; (8029c4c <LmhpComplianceOnMlmeConfirm+0x28>)
 8029c2e:	785b      	ldrb	r3, [r3, #1]
 8029c30:	2b00      	cmp	r3, #0
 8029c32:	d002      	beq.n	8029c3a <LmhpComplianceOnMlmeConfirm+0x16>
    {
        return;
    }

    if( mlmeConfirm->MlmeRequest == MLME_LINK_CHECK )
 8029c34:	7803      	ldrb	r3, [r0, #0]
 8029c36:	2b04      	cmp	r3, #4
 8029c38:	d000      	beq.n	8029c3c <LmhpComplianceOnMlmeConfirm+0x18>
    {
        ComplianceTestState.LinkCheck = true;
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
        ComplianceTestState.NbGateways = mlmeConfirm->NbGateways;
    }
}
 8029c3a:	4770      	bx	lr
        ComplianceTestState.LinkCheck = true;
 8029c3c:	4b03      	ldr	r3, [pc, #12]	; (8029c4c <LmhpComplianceOnMlmeConfirm+0x28>)
 8029c3e:	2201      	movs	r2, #1
 8029c40:	739a      	strb	r2, [r3, #14]
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
 8029c42:	7a02      	ldrb	r2, [r0, #8]
 8029c44:	73da      	strb	r2, [r3, #15]
        ComplianceTestState.NbGateways = mlmeConfirm->NbGateways;
 8029c46:	7a42      	ldrb	r2, [r0, #9]
 8029c48:	741a      	strb	r2, [r3, #16]
 8029c4a:	e7f6      	b.n	8029c3a <LmhpComplianceOnMlmeConfirm+0x16>
 8029c4c:	2000a500 	.word	0x2000a500

08029c50 <LmhpComplianceProcess>:
}

static void LmhpComplianceProcess( void )
{
    /* Nothing to process */
}
 8029c50:	4770      	bx	lr
	...

08029c54 <LmhpComplianceTxProcess>:
{
 8029c54:	b530      	push	{r4, r5, lr}
 8029c56:	b083      	sub	sp, #12
    if( ComplianceTestState.Initialized == false )
 8029c58:	4b22      	ldr	r3, [pc, #136]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029c5a:	781b      	ldrb	r3, [r3, #0]
 8029c5c:	2b00      	cmp	r3, #0
 8029c5e:	d03c      	beq.n	8029cda <LmhpComplianceTxProcess+0x86>
    if( ComplianceTestState.IsRunning == false )
 8029c60:	4b20      	ldr	r3, [pc, #128]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029c62:	785b      	ldrb	r3, [r3, #1]
 8029c64:	2b00      	cmp	r3, #0
 8029c66:	d03b      	beq.n	8029ce0 <LmhpComplianceTxProcess+0x8c>
    if( ComplianceTestState.LinkCheck == true )
 8029c68:	4b1e      	ldr	r3, [pc, #120]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029c6a:	7b9b      	ldrb	r3, [r3, #14]
 8029c6c:	2b00      	cmp	r3, #0
 8029c6e:	d021      	beq.n	8029cb4 <LmhpComplianceTxProcess+0x60>
        ComplianceTestState.LinkCheck = false;
 8029c70:	4b1c      	ldr	r3, [pc, #112]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029c72:	2200      	movs	r2, #0
 8029c74:	739a      	strb	r2, [r3, #14]
        ComplianceTestState.DataBufferSize = 3;
 8029c76:	3203      	adds	r2, #3
 8029c78:	719a      	strb	r2, [r3, #6]
        ComplianceTestState.DataBuffer[0] = 5;
 8029c7a:	689a      	ldr	r2, [r3, #8]
 8029c7c:	2105      	movs	r1, #5
 8029c7e:	7011      	strb	r1, [r2, #0]
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 8029c80:	7bd9      	ldrb	r1, [r3, #15]
 8029c82:	7051      	strb	r1, [r2, #1]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 8029c84:	7c19      	ldrb	r1, [r3, #16]
 8029c86:	7091      	strb	r1, [r2, #2]
        ComplianceTestState.State = 1;
 8029c88:	2201      	movs	r2, #1
 8029c8a:	709a      	strb	r2, [r3, #2]
    LmHandlerAppData_t appData =
 8029c8c:	23e0      	movs	r3, #224	; 0xe0
 8029c8e:	466a      	mov	r2, sp
 8029c90:	7013      	strb	r3, [r2, #0]
        .BufferSize = ComplianceTestState.DataBufferSize,
 8029c92:	4c14      	ldr	r4, [pc, #80]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029c94:	79a3      	ldrb	r3, [r4, #6]
    LmHandlerAppData_t appData =
 8029c96:	7053      	strb	r3, [r2, #1]
 8029c98:	68a3      	ldr	r3, [r4, #8]
 8029c9a:	9301      	str	r3, [sp, #4]
    TimerStart( &ComplianceTxNextPacketTimer );
 8029c9c:	4812      	ldr	r0, [pc, #72]	; (8029ce8 <LmhpComplianceTxProcess+0x94>)
 8029c9e:	f00a fad5 	bl	803424c <UTIL_TIMER_Start>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, NULL, true );
 8029ca2:	4b12      	ldr	r3, [pc, #72]	; (8029cec <LmhpComplianceTxProcess+0x98>)
 8029ca4:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8029ca6:	78e1      	ldrb	r1, [r4, #3]
 8029ca8:	2301      	movs	r3, #1
 8029caa:	2200      	movs	r2, #0
 8029cac:	4668      	mov	r0, sp
 8029cae:	47a8      	blx	r5
}
 8029cb0:	b003      	add	sp, #12
 8029cb2:	bd30      	pop	{r4, r5, pc}
        switch( ComplianceTestState.State )
 8029cb4:	4b0b      	ldr	r3, [pc, #44]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029cb6:	789b      	ldrb	r3, [r3, #2]
 8029cb8:	2b01      	cmp	r3, #1
 8029cba:	d005      	beq.n	8029cc8 <LmhpComplianceTxProcess+0x74>
 8029cbc:	2b04      	cmp	r3, #4
 8029cbe:	d1e5      	bne.n	8029c8c <LmhpComplianceTxProcess+0x38>
            ComplianceTestState.State = 1;
 8029cc0:	4b08      	ldr	r3, [pc, #32]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029cc2:	2201      	movs	r2, #1
 8029cc4:	709a      	strb	r2, [r3, #2]
            break;
 8029cc6:	e7e1      	b.n	8029c8c <LmhpComplianceTxProcess+0x38>
            ComplianceTestState.DataBufferSize = 2;
 8029cc8:	4b06      	ldr	r3, [pc, #24]	; (8029ce4 <LmhpComplianceTxProcess+0x90>)
 8029cca:	2202      	movs	r2, #2
 8029ccc:	719a      	strb	r2, [r3, #6]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8029cce:	899a      	ldrh	r2, [r3, #12]
 8029cd0:	689b      	ldr	r3, [r3, #8]
 8029cd2:	0a11      	lsrs	r1, r2, #8
 8029cd4:	7019      	strb	r1, [r3, #0]
            ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 8029cd6:	705a      	strb	r2, [r3, #1]
            break;
 8029cd8:	e7d8      	b.n	8029c8c <LmhpComplianceTxProcess+0x38>
        return LORAMAC_HANDLER_ERROR;
 8029cda:	2001      	movs	r0, #1
 8029cdc:	4240      	negs	r0, r0
 8029cde:	e7e7      	b.n	8029cb0 <LmhpComplianceTxProcess+0x5c>
        return LORAMAC_HANDLER_SUCCESS;
 8029ce0:	2000      	movs	r0, #0
 8029ce2:	e7e5      	b.n	8029cb0 <LmhpComplianceTxProcess+0x5c>
 8029ce4:	2000a500 	.word	0x2000a500
 8029ce8:	2000a514 	.word	0x2000a514
 8029cec:	2000a078 	.word	0x2000a078

08029cf0 <LmhpComplianceOnMcpsIndication>:
{
 8029cf0:	b530      	push	{r4, r5, lr}
 8029cf2:	b08d      	sub	sp, #52	; 0x34
    if( ComplianceTestState.Initialized == false )
 8029cf4:	4b86      	ldr	r3, [pc, #536]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029cf6:	781b      	ldrb	r3, [r3, #0]
 8029cf8:	2b00      	cmp	r3, #0
 8029cfa:	d015      	beq.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
    if( mcpsIndication->RxData == false )
 8029cfc:	7b43      	ldrb	r3, [r0, #13]
 8029cfe:	2b00      	cmp	r3, #0
 8029d00:	d012      	beq.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
    if ((ComplianceTestState.IsRunning == true) &&
 8029d02:	4b83      	ldr	r3, [pc, #524]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029d04:	785b      	ldrb	r3, [r3, #1]
 8029d06:	2b00      	cmp	r3, #0
 8029d08:	d006      	beq.n	8029d18 <LmhpComplianceOnMcpsIndication+0x28>
        (mcpsIndication->AckReceived == 0))
 8029d0a:	7b82      	ldrb	r2, [r0, #14]
    if ((ComplianceTestState.IsRunning == true) &&
 8029d0c:	2a00      	cmp	r2, #0
 8029d0e:	d103      	bne.n	8029d18 <LmhpComplianceOnMcpsIndication+0x28>
        ComplianceTestState.DownLinkCounter++;
 8029d10:	497f      	ldr	r1, [pc, #508]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029d12:	898a      	ldrh	r2, [r1, #12]
 8029d14:	3201      	adds	r2, #1
 8029d16:	818a      	strh	r2, [r1, #12]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 8029d18:	78c2      	ldrb	r2, [r0, #3]
 8029d1a:	2ae0      	cmp	r2, #224	; 0xe0
 8029d1c:	d104      	bne.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
    if( ComplianceTestState.IsRunning == false )
 8029d1e:	2b00      	cmp	r3, #0
 8029d20:	d13f      	bne.n	8029da2 <LmhpComplianceOnMcpsIndication+0xb2>
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8029d22:	7b03      	ldrb	r3, [r0, #12]
 8029d24:	2b04      	cmp	r3, #4
 8029d26:	d001      	beq.n	8029d2c <LmhpComplianceOnMcpsIndication+0x3c>
}
 8029d28:	b00d      	add	sp, #52	; 0x34
 8029d2a:	bd30      	pop	{r4, r5, pc}
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8029d2c:	6883      	ldr	r3, [r0, #8]
 8029d2e:	781a      	ldrb	r2, [r3, #0]
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8029d30:	2a01      	cmp	r2, #1
 8029d32:	d1f9      	bne.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8029d34:	785a      	ldrb	r2, [r3, #1]
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8029d36:	2a01      	cmp	r2, #1
 8029d38:	d1f6      	bne.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8029d3a:	789a      	ldrb	r2, [r3, #2]
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8029d3c:	2a01      	cmp	r2, #1
 8029d3e:	d1f3      	bne.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ( mcpsIndication->Buffer[3] == 0x01 ) )
 8029d40:	78db      	ldrb	r3, [r3, #3]
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8029d42:	2b01      	cmp	r3, #1
 8029d44:	d1f0      	bne.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ComplianceTestState.IsTxConfirmed = false;
 8029d46:	4b72      	ldr	r3, [pc, #456]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029d48:	2400      	movs	r4, #0
 8029d4a:	70dc      	strb	r4, [r3, #3]
            ComplianceTestState.Port = 224;
 8029d4c:	32df      	adds	r2, #223	; 0xdf
 8029d4e:	711a      	strb	r2, [r3, #4]
            ComplianceTestState.DataBufferSize = 2;
 8029d50:	3ade      	subs	r2, #222	; 0xde
 8029d52:	719a      	strb	r2, [r3, #6]
            ComplianceTestState.DownLinkCounter = 0;
 8029d54:	819c      	strh	r4, [r3, #12]
            ComplianceTestState.LinkCheck = false;
 8029d56:	739c      	strb	r4, [r3, #14]
            ComplianceTestState.DemodMargin = 0;
 8029d58:	73dc      	strb	r4, [r3, #15]
            ComplianceTestState.NbGateways = 0;
 8029d5a:	741c      	strb	r4, [r3, #16]
            ComplianceTestState.IsRunning = true;
 8029d5c:	3a01      	subs	r2, #1
 8029d5e:	705a      	strb	r2, [r3, #1]
            ComplianceTestState.State = 1;
 8029d60:	709a      	strb	r2, [r3, #2]
            mibReq.Type = MIB_ADR;
 8029d62:	2304      	movs	r3, #4
 8029d64:	4669      	mov	r1, sp
 8029d66:	730b      	strb	r3, [r1, #12]
            mibReq.Param.AdrEnable = true;
 8029d68:	740a      	strb	r2, [r1, #16]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8029d6a:	a803      	add	r0, sp, #12
 8029d6c:	f002 ffee 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
            LoRaMacTestSetDutyCycleOn( false );
 8029d70:	0020      	movs	r0, r4
 8029d72:	f003 fbe1 	bl	802d538 <LoRaMacTestSetDutyCycleOn>
            if( LmhpComplianceParams->StopPeripherals != NULL )
 8029d76:	4b67      	ldr	r3, [pc, #412]	; (8029f14 <LmhpComplianceOnMcpsIndication+0x224>)
 8029d78:	681b      	ldr	r3, [r3, #0]
 8029d7a:	685b      	ldr	r3, [r3, #4]
 8029d7c:	42a3      	cmp	r3, r4
 8029d7e:	d000      	beq.n	8029d82 <LmhpComplianceOnMcpsIndication+0x92>
                LmhpComplianceParams->StopPeripherals( );
 8029d80:	4798      	blx	r3
            TimerInit( &ComplianceTxNextPacketTimer, OnComplianceTxNextPacketTimerEvent );
 8029d82:	2101      	movs	r1, #1
 8029d84:	4c64      	ldr	r4, [pc, #400]	; (8029f18 <LmhpComplianceOnMcpsIndication+0x228>)
 8029d86:	2200      	movs	r2, #0
 8029d88:	9200      	str	r2, [sp, #0]
 8029d8a:	4b64      	ldr	r3, [pc, #400]	; (8029f1c <LmhpComplianceOnMcpsIndication+0x22c>)
 8029d8c:	4249      	negs	r1, r1
 8029d8e:	0020      	movs	r0, r4
 8029d90:	f00a f99a 	bl	80340c8 <UTIL_TIMER_Create>
            TimerSetValue( &ComplianceTxNextPacketTimer, COMPLIANCE_TX_DUTYCYCLE );
 8029d94:	4962      	ldr	r1, [pc, #392]	; (8029f20 <LmhpComplianceOnMcpsIndication+0x230>)
 8029d96:	0020      	movs	r0, r4
 8029d98:	f00a fa9e 	bl	80342d8 <UTIL_TIMER_SetPeriod>
            LmhpComplianceTxProcess( );
 8029d9c:	f7ff ff5a 	bl	8029c54 <LmhpComplianceTxProcess>
 8029da0:	e7c2      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
        ComplianceTestState.State = mcpsIndication->Buffer[0];
 8029da2:	6882      	ldr	r2, [r0, #8]
 8029da4:	7813      	ldrb	r3, [r2, #0]
 8029da6:	495a      	ldr	r1, [pc, #360]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029da8:	708b      	strb	r3, [r1, #2]
        switch( ComplianceTestState.State )
 8029daa:	2b0a      	cmp	r3, #10
 8029dac:	d8bc      	bhi.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
 8029dae:	009b      	lsls	r3, r3, #2
 8029db0:	495c      	ldr	r1, [pc, #368]	; (8029f24 <LmhpComplianceOnMcpsIndication+0x234>)
 8029db2:	58cb      	ldr	r3, [r1, r3]
 8029db4:	469f      	mov	pc, r3
                TimerStop( &ComplianceTxNextPacketTimer );
 8029db6:	4858      	ldr	r0, [pc, #352]	; (8029f18 <LmhpComplianceOnMcpsIndication+0x228>)
 8029db8:	f00a f9e6 	bl	8034188 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 8029dbc:	4b54      	ldr	r3, [pc, #336]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029dbe:	2200      	movs	r2, #0
 8029dc0:	819a      	strh	r2, [r3, #12]
                ComplianceTestState.IsRunning = false;
 8029dc2:	705a      	strb	r2, [r3, #1]
                mibReq.Type = MIB_ADR;
 8029dc4:	2304      	movs	r3, #4
 8029dc6:	466a      	mov	r2, sp
 8029dc8:	7313      	strb	r3, [r2, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8029dca:	4c52      	ldr	r4, [pc, #328]	; (8029f14 <LmhpComplianceOnMcpsIndication+0x224>)
 8029dcc:	6823      	ldr	r3, [r4, #0]
 8029dce:	781b      	ldrb	r3, [r3, #0]
 8029dd0:	7413      	strb	r3, [r2, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8029dd2:	a803      	add	r0, sp, #12
 8029dd4:	f002 ffba 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8029dd8:	6823      	ldr	r3, [r4, #0]
 8029dda:	7858      	ldrb	r0, [r3, #1]
 8029ddc:	f003 fbac 	bl	802d538 <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8029de0:	6823      	ldr	r3, [r4, #0]
 8029de2:	689b      	ldr	r3, [r3, #8]
 8029de4:	2b00      	cmp	r3, #0
 8029de6:	d09f      	beq.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
                    LmhpComplianceParams->StartPeripherals( );
 8029de8:	4798      	blx	r3
            break;
 8029dea:	e79d      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ComplianceTestState.DataBufferSize = 2;
 8029dec:	4b48      	ldr	r3, [pc, #288]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029dee:	2202      	movs	r2, #2
 8029df0:	719a      	strb	r2, [r3, #6]
            break;
 8029df2:	e799      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ComplianceTestState.IsTxConfirmed = true;
 8029df4:	4b46      	ldr	r3, [pc, #280]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029df6:	2201      	movs	r2, #1
 8029df8:	70da      	strb	r2, [r3, #3]
            ComplianceTestState.State = 1;
 8029dfa:	709a      	strb	r2, [r3, #2]
            break;
 8029dfc:	e794      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ComplianceTestState.IsTxConfirmed = false;
 8029dfe:	4b44      	ldr	r3, [pc, #272]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029e00:	2200      	movs	r2, #0
 8029e02:	70da      	strb	r2, [r3, #3]
            ComplianceTestState.State = 1;
 8029e04:	3201      	adds	r2, #1
 8029e06:	709a      	strb	r2, [r3, #2]
            break;
 8029e08:	e78e      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
            ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 8029e0a:	7b04      	ldrb	r4, [r0, #12]
 8029e0c:	4b40      	ldr	r3, [pc, #256]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029e0e:	719c      	strb	r4, [r3, #6]
            ComplianceTestState.DataBuffer[0] = 4;
 8029e10:	689d      	ldr	r5, [r3, #8]
 8029e12:	2304      	movs	r3, #4
 8029e14:	702b      	strb	r3, [r5, #0]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 8029e16:	3b03      	subs	r3, #3
 8029e18:	e009      	b.n	8029e2e <LmhpComplianceOnMcpsIndication+0x13e>
 8029e1a:	b2d2      	uxtb	r2, r2
 8029e1c:	429a      	cmp	r2, r3
 8029e1e:	d800      	bhi.n	8029e22 <LmhpComplianceOnMcpsIndication+0x132>
 8029e20:	e782      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
                ComplianceTestState.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 8029e22:	6882      	ldr	r2, [r0, #8]
 8029e24:	5cd2      	ldrb	r2, [r2, r3]
 8029e26:	3201      	adds	r2, #1
 8029e28:	54ea      	strb	r2, [r5, r3]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 8029e2a:	3301      	adds	r3, #1
 8029e2c:	b2db      	uxtb	r3, r3
 8029e2e:	4a38      	ldr	r2, [pc, #224]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029e30:	7951      	ldrb	r1, [r2, #5]
 8029e32:	1c22      	adds	r2, r4, #0
 8029e34:	428c      	cmp	r4, r1
 8029e36:	d9f0      	bls.n	8029e1a <LmhpComplianceOnMcpsIndication+0x12a>
 8029e38:	1c0a      	adds	r2, r1, #0
 8029e3a:	e7ee      	b.n	8029e1a <LmhpComplianceOnMcpsIndication+0x12a>
                mlmeReq.Type = MLME_LINK_CHECK;
 8029e3c:	a803      	add	r0, sp, #12
 8029e3e:	2304      	movs	r3, #4
 8029e40:	7003      	strb	r3, [r0, #0]
                LoRaMacMlmeRequest( &mlmeReq );
 8029e42:	f003 f9c9 	bl	802d1d8 <LoRaMacMlmeRequest>
            break;
 8029e46:	e76f      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
                TimerStop(&ComplianceTxNextPacketTimer);
 8029e48:	4833      	ldr	r0, [pc, #204]	; (8029f18 <LmhpComplianceOnMcpsIndication+0x228>)
 8029e4a:	f00a f99d 	bl	8034188 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 8029e4e:	4b30      	ldr	r3, [pc, #192]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029e50:	2200      	movs	r2, #0
 8029e52:	819a      	strh	r2, [r3, #12]
                ComplianceTestState.IsRunning = false;
 8029e54:	705a      	strb	r2, [r3, #1]
                mibReq.Type = MIB_ADR;
 8029e56:	2304      	movs	r3, #4
 8029e58:	466a      	mov	r2, sp
 8029e5a:	7313      	strb	r3, [r2, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8029e5c:	4c2d      	ldr	r4, [pc, #180]	; (8029f14 <LmhpComplianceOnMcpsIndication+0x224>)
 8029e5e:	6823      	ldr	r3, [r4, #0]
 8029e60:	781b      	ldrb	r3, [r3, #0]
 8029e62:	7413      	strb	r3, [r2, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8029e64:	a803      	add	r0, sp, #12
 8029e66:	f002 ff71 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8029e6a:	6823      	ldr	r3, [r4, #0]
 8029e6c:	7858      	ldrb	r0, [r3, #1]
 8029e6e:	f003 fb63 	bl	802d538 <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8029e72:	6823      	ldr	r3, [r4, #0]
 8029e74:	689b      	ldr	r3, [r3, #8]
 8029e76:	2b00      	cmp	r3, #0
 8029e78:	d000      	beq.n	8029e7c <LmhpComplianceOnMcpsIndication+0x18c>
                    LmhpComplianceParams->StartPeripherals( );
 8029e7a:	4798      	blx	r3
                LmhpCompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA );
 8029e7c:	4b2a      	ldr	r3, [pc, #168]	; (8029f28 <LmhpComplianceOnMcpsIndication+0x238>)
 8029e7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029e80:	2002      	movs	r0, #2
 8029e82:	4798      	blx	r3
            break;
 8029e84:	e750      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
                if( mcpsIndication->BufferSize == 3 )
 8029e86:	7b03      	ldrb	r3, [r0, #12]
 8029e88:	2b03      	cmp	r3, #3
 8029e8a:	d008      	beq.n	8029e9e <LmhpComplianceOnMcpsIndication+0x1ae>
                else if( mcpsIndication->BufferSize == 7 )
 8029e8c:	2b07      	cmp	r3, #7
 8029e8e:	d00f      	beq.n	8029eb0 <LmhpComplianceOnMcpsIndication+0x1c0>
                LoRaMacMlmeRequest( &mlmeReq );
 8029e90:	a803      	add	r0, sp, #12
 8029e92:	f003 f9a1 	bl	802d1d8 <LoRaMacMlmeRequest>
                ComplianceTestState.State = 1;
 8029e96:	4b1e      	ldr	r3, [pc, #120]	; (8029f10 <LmhpComplianceOnMcpsIndication+0x220>)
 8029e98:	2201      	movs	r2, #1
 8029e9a:	709a      	strb	r2, [r3, #2]
            break;
 8029e9c:	e744      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
                    mlmeReq.Type = MLME_TXCW;
 8029e9e:	a803      	add	r0, sp, #12
 8029ea0:	3302      	adds	r3, #2
 8029ea2:	7003      	strb	r3, [r0, #0]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8029ea4:	7851      	ldrb	r1, [r2, #1]
 8029ea6:	0209      	lsls	r1, r1, #8
 8029ea8:	7893      	ldrb	r3, [r2, #2]
 8029eaa:	430b      	orrs	r3, r1
 8029eac:	8083      	strh	r3, [r0, #4]
 8029eae:	e7ef      	b.n	8029e90 <LmhpComplianceOnMcpsIndication+0x1a0>
                    mlmeReq.Type = MLME_TXCW_1;
 8029eb0:	a903      	add	r1, sp, #12
 8029eb2:	3b01      	subs	r3, #1
 8029eb4:	700b      	strb	r3, [r1, #0]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8029eb6:	7854      	ldrb	r4, [r2, #1]
 8029eb8:	0224      	lsls	r4, r4, #8
 8029eba:	7893      	ldrb	r3, [r2, #2]
 8029ebc:	4323      	orrs	r3, r4
 8029ebe:	808b      	strh	r3, [r1, #4]
                    mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 8029ec0:	78d3      	ldrb	r3, [r2, #3]
 8029ec2:	041b      	lsls	r3, r3, #16
 8029ec4:	7914      	ldrb	r4, [r2, #4]
 8029ec6:	0224      	lsls	r4, r4, #8
 8029ec8:	4323      	orrs	r3, r4
 8029eca:	7952      	ldrb	r2, [r2, #5]
 8029ecc:	4313      	orrs	r3, r2
 8029ece:	2264      	movs	r2, #100	; 0x64
 8029ed0:	4353      	muls	r3, r2
 8029ed2:	9305      	str	r3, [sp, #20]
                    mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 8029ed4:	6883      	ldr	r3, [r0, #8]
 8029ed6:	799b      	ldrb	r3, [r3, #6]
 8029ed8:	b25b      	sxtb	r3, r3
 8029eda:	730b      	strb	r3, [r1, #12]
 8029edc:	e7d8      	b.n	8029e90 <LmhpComplianceOnMcpsIndication+0x1a0>
                mlmeReq.Type = MLME_DEVICE_TIME;
 8029ede:	a803      	add	r0, sp, #12
 8029ee0:	230a      	movs	r3, #10
 8029ee2:	7003      	strb	r3, [r0, #0]
                LoRaMacMlmeRequest( &mlmeReq );
 8029ee4:	f003 f978 	bl	802d1d8 <LoRaMacMlmeRequest>
            break;
 8029ee8:	e71e      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
                mibReq.Type = MIB_DEVICE_CLASS;
 8029eea:	2300      	movs	r3, #0
 8029eec:	4669      	mov	r1, sp
 8029eee:	730b      	strb	r3, [r1, #12]
                mibReq.Param.Class = ( DeviceClass_t )mcpsIndication->Buffer[1];;
 8029ef0:	7853      	ldrb	r3, [r2, #1]
 8029ef2:	740b      	strb	r3, [r1, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8029ef4:	a803      	add	r0, sp, #12
 8029ef6:	f002 ff29 	bl	802cd4c <LoRaMacMibSetRequestConfirm>
            break;
 8029efa:	e715      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
                mlmeReq.Type = MLME_PING_SLOT_INFO;
 8029efc:	230d      	movs	r3, #13
 8029efe:	4669      	mov	r1, sp
 8029f00:	730b      	strb	r3, [r1, #12]
                mlmeReq.Req.PingSlotInfo.PingSlot.Value = mcpsIndication->Buffer[1];
 8029f02:	7853      	ldrb	r3, [r2, #1]
 8029f04:	740b      	strb	r3, [r1, #16]
                LoRaMacMlmeRequest( &mlmeReq );
 8029f06:	a803      	add	r0, sp, #12
 8029f08:	f003 f966 	bl	802d1d8 <LoRaMacMlmeRequest>
            break;
 8029f0c:	e70c      	b.n	8029d28 <LmhpComplianceOnMcpsIndication+0x38>
 8029f0e:	46c0      	nop			; (mov r8, r8)
 8029f10:	2000a500 	.word	0x2000a500
 8029f14:	2000a52c 	.word	0x2000a52c
 8029f18:	2000a514 	.word	0x2000a514
 8029f1c:	08029f2d 	.word	0x08029f2d
 8029f20:	00001388 	.word	0x00001388
 8029f24:	08034e64 	.word	0x08034e64
 8029f28:	2000a078 	.word	0x2000a078

08029f2c <OnComplianceTxNextPacketTimerEvent>:

static void OnComplianceTxNextPacketTimerEvent( void* context )
{
 8029f2c:	b510      	push	{r4, lr}
    LmhpComplianceTxProcess( );
 8029f2e:	f7ff fe91 	bl	8029c54 <LmhpComplianceTxProcess>
}
 8029f32:	bd10      	pop	{r4, pc}

08029f34 <LmhpCompliancePackageFactory>:
}
 8029f34:	4800      	ldr	r0, [pc, #0]	; (8029f38 <LmhpCompliancePackageFactory+0x4>)
 8029f36:	4770      	bx	lr
 8029f38:	2000a078 	.word	0x2000a078

08029f3c <OnRadioRxError>:
    }
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
}

static void OnRadioRxError( void )
{
 8029f3c:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxError = 1;
 8029f3e:	4a08      	ldr	r2, [pc, #32]	; (8029f60 <OnRadioRxError+0x24>)
 8029f40:	7813      	ldrb	r3, [r2, #0]
 8029f42:	2102      	movs	r1, #2
 8029f44:	430b      	orrs	r3, r1
 8029f46:	7013      	strb	r3, [r2, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8029f48:	4a06      	ldr	r2, [pc, #24]	; (8029f64 <OnRadioRxError+0x28>)
 8029f4a:	23d2      	movs	r3, #210	; 0xd2
 8029f4c:	009b      	lsls	r3, r3, #2
 8029f4e:	58d3      	ldr	r3, [r2, r3]
 8029f50:	2b00      	cmp	r3, #0
 8029f52:	d003      	beq.n	8029f5c <OnRadioRxError+0x20>
 8029f54:	691b      	ldr	r3, [r3, #16]
 8029f56:	2b00      	cmp	r3, #0
 8029f58:	d000      	beq.n	8029f5c <OnRadioRxError+0x20>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 8029f5a:	4798      	blx	r3
    }
}
 8029f5c:	bd10      	pop	{r4, pc}
 8029f5e:	46c0      	nop			; (mov r8, r8)
 8029f60:	2000a530 	.word	0x2000a530
 8029f64:	2000a534 	.word	0x2000a534

08029f68 <UpdateRxSlotIdleState>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
}

static void UpdateRxSlotIdleState( void )
{
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8029f68:	4a08      	ldr	r2, [pc, #32]	; (8029f8c <UpdateRxSlotIdleState+0x24>)
 8029f6a:	23fc      	movs	r3, #252	; 0xfc
 8029f6c:	5cd3      	ldrb	r3, [r2, r3]
 8029f6e:	2b02      	cmp	r3, #2
 8029f70:	d005      	beq.n	8029f7e <UpdateRxSlotIdleState+0x16>
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 8029f72:	4a07      	ldr	r2, [pc, #28]	; (8029f90 <UpdateRxSlotIdleState+0x28>)
 8029f74:	2390      	movs	r3, #144	; 0x90
 8029f76:	00db      	lsls	r3, r3, #3
 8029f78:	2106      	movs	r1, #6
 8029f7a:	54d1      	strb	r1, [r2, r3]
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 8029f7c:	4770      	bx	lr
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
 8029f7e:	4a04      	ldr	r2, [pc, #16]	; (8029f90 <UpdateRxSlotIdleState+0x28>)
 8029f80:	2390      	movs	r3, #144	; 0x90
 8029f82:	00db      	lsls	r3, r3, #3
 8029f84:	2102      	movs	r1, #2
 8029f86:	54d1      	strb	r1, [r2, r3]
}
 8029f88:	e7f8      	b.n	8029f7c <UpdateRxSlotIdleState+0x14>
 8029f8a:	46c0      	nop			; (mov r8, r8)
 8029f8c:	2000aa3c 	.word	0x2000aa3c
 8029f90:	2000a534 	.word	0x2000a534

08029f94 <LoRaMacEnableRequests>:
}


static void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState )
{
    MacCtx.AllowRequests = requestState;
 8029f94:	4a01      	ldr	r2, [pc, #4]	; (8029f9c <LoRaMacEnableRequests+0x8>)
 8029f96:	4b02      	ldr	r3, [pc, #8]	; (8029fa0 <LoRaMacEnableRequests+0xc>)
 8029f98:	54d0      	strb	r0, [r2, r3]
}
 8029f9a:	4770      	bx	lr
 8029f9c:	2000a534 	.word	0x2000a534
 8029fa0:	00000482 	.word	0x00000482

08029fa4 <LoRaMacHandleIndicationEvents>:
        }
    }
}

static void LoRaMacHandleIndicationEvents( void )
{
 8029fa4:	b510      	push	{r4, lr}
 8029fa6:	b088      	sub	sp, #32
    // Handle MLME indication
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 8029fa8:	4a21      	ldr	r2, [pc, #132]	; (802a030 <LoRaMacHandleIndicationEvents+0x8c>)
 8029faa:	4b22      	ldr	r3, [pc, #136]	; (802a034 <LoRaMacHandleIndicationEvents+0x90>)
 8029fac:	5cd3      	ldrb	r3, [r2, r3]
 8029fae:	071b      	lsls	r3, r3, #28
 8029fb0:	d50f      	bpl.n	8029fd2 <LoRaMacHandleIndicationEvents+0x2e>
    {
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 8029fb2:	0010      	movs	r0, r2
 8029fb4:	4a1f      	ldr	r2, [pc, #124]	; (802a034 <LoRaMacHandleIndicationEvents+0x90>)
 8029fb6:	5c83      	ldrb	r3, [r0, r2]
 8029fb8:	2108      	movs	r1, #8
 8029fba:	438b      	bics	r3, r1
 8029fbc:	5483      	strb	r3, [r0, r2]
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 8029fbe:	23d1      	movs	r3, #209	; 0xd1
 8029fc0:	009b      	lsls	r3, r3, #2
 8029fc2:	58c3      	ldr	r3, [r0, r3]
 8029fc4:	68db      	ldr	r3, [r3, #12]
 8029fc6:	4a1c      	ldr	r2, [pc, #112]	; (802a038 <LoRaMacHandleIndicationEvents+0x94>)
 8029fc8:	1881      	adds	r1, r0, r2
 8029fca:	3a1c      	subs	r2, #28
 8029fcc:	4694      	mov	ip, r2
 8029fce:	4460      	add	r0, ip
 8029fd0:	4798      	blx	r3
    }

    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )
 8029fd2:	4a17      	ldr	r2, [pc, #92]	; (802a030 <LoRaMacHandleIndicationEvents+0x8c>)
 8029fd4:	4b17      	ldr	r3, [pc, #92]	; (802a034 <LoRaMacHandleIndicationEvents+0x90>)
 8029fd6:	5cd3      	ldrb	r3, [r2, r3]
 8029fd8:	06db      	lsls	r3, r3, #27
 8029fda:	d512      	bpl.n	802a002 <LoRaMacHandleIndicationEvents+0x5e>
    {
        MlmeIndication_t schduleUplinkIndication;
        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;
 8029fdc:	2307      	movs	r3, #7
 8029fde:	466a      	mov	r2, sp
 8029fe0:	7113      	strb	r3, [r2, #4]
        schduleUplinkIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 8029fe2:	2300      	movs	r3, #0
 8029fe4:	7153      	strb	r3, [r2, #5]

        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication, &MacCtx.RxStatus );
 8029fe6:	4c12      	ldr	r4, [pc, #72]	; (802a030 <LoRaMacHandleIndicationEvents+0x8c>)
 8029fe8:	23d1      	movs	r3, #209	; 0xd1
 8029fea:	009b      	lsls	r3, r3, #2
 8029fec:	58e3      	ldr	r3, [r4, r3]
 8029fee:	68db      	ldr	r3, [r3, #12]
 8029ff0:	4a11      	ldr	r2, [pc, #68]	; (802a038 <LoRaMacHandleIndicationEvents+0x94>)
 8029ff2:	18a1      	adds	r1, r4, r2
 8029ff4:	a801      	add	r0, sp, #4
 8029ff6:	4798      	blx	r3
        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;
 8029ff8:	4a0e      	ldr	r2, [pc, #56]	; (802a034 <LoRaMacHandleIndicationEvents+0x90>)
 8029ffa:	5ca3      	ldrb	r3, [r4, r2]
 8029ffc:	2110      	movs	r1, #16
 8029ffe:	438b      	bics	r3, r1
 802a000:	54a3      	strb	r3, [r4, r2]
    }

    // Handle MCPS indication
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 802a002:	4a0b      	ldr	r2, [pc, #44]	; (802a030 <LoRaMacHandleIndicationEvents+0x8c>)
 802a004:	4b0b      	ldr	r3, [pc, #44]	; (802a034 <LoRaMacHandleIndicationEvents+0x90>)
 802a006:	5cd3      	ldrb	r3, [r2, r3]
 802a008:	079b      	lsls	r3, r3, #30
 802a00a:	d50f      	bpl.n	802a02c <LoRaMacHandleIndicationEvents+0x88>
    {
        MacCtx.MacFlags.Bits.McpsInd = 0;
 802a00c:	0010      	movs	r0, r2
 802a00e:	4a09      	ldr	r2, [pc, #36]	; (802a034 <LoRaMacHandleIndicationEvents+0x90>)
 802a010:	5c83      	ldrb	r3, [r0, r2]
 802a012:	2102      	movs	r1, #2
 802a014:	438b      	bics	r3, r1
 802a016:	5483      	strb	r3, [r0, r2]
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 802a018:	23d1      	movs	r3, #209	; 0xd1
 802a01a:	009b      	lsls	r3, r3, #2
 802a01c:	58c3      	ldr	r3, [r0, r3]
 802a01e:	685b      	ldr	r3, [r3, #4]
 802a020:	4a05      	ldr	r2, [pc, #20]	; (802a038 <LoRaMacHandleIndicationEvents+0x94>)
 802a022:	1881      	adds	r1, r0, r2
 802a024:	4a05      	ldr	r2, [pc, #20]	; (802a03c <LoRaMacHandleIndicationEvents+0x98>)
 802a026:	4694      	mov	ip, r2
 802a028:	4460      	add	r0, ip
 802a02a:	4798      	blx	r3
    }
}
 802a02c:	b008      	add	sp, #32
 802a02e:	bd10      	pop	{r4, pc}
 802a030:	2000a534 	.word	0x2000a534
 802a034:	00000481 	.word	0x00000481
 802a038:	0000047c 	.word	0x0000047c
 802a03c:	0000041c 	.word	0x0000041c

0802a040 <LoRaMacCheckForRxAbort>:
}

static void LoRaMacCheckForRxAbort( void )
{
    // A error occurs during receiving
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 802a040:	4a07      	ldr	r2, [pc, #28]	; (802a060 <LoRaMacCheckForRxAbort+0x20>)
 802a042:	23d0      	movs	r3, #208	; 0xd0
 802a044:	009b      	lsls	r3, r3, #2
 802a046:	58d3      	ldr	r3, [r2, r3]
 802a048:	061a      	lsls	r2, r3, #24
 802a04a:	d507      	bpl.n	802a05c <LoRaMacCheckForRxAbort+0x1c>
    {
        MacCtx.MacState &= ~LORAMAC_RX_ABORT;
 802a04c:	2280      	movs	r2, #128	; 0x80
 802a04e:	4393      	bics	r3, r2
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802a050:	3a7e      	subs	r2, #126	; 0x7e
 802a052:	4393      	bics	r3, r2
 802a054:	4902      	ldr	r1, [pc, #8]	; (802a060 <LoRaMacCheckForRxAbort+0x20>)
 802a056:	22d0      	movs	r2, #208	; 0xd0
 802a058:	0092      	lsls	r2, r2, #2
 802a05a:	508b      	str	r3, [r1, r2]
    }
}
 802a05c:	4770      	bx	lr
 802a05e:	46c0      	nop			; (mov r8, r8)
 802a060:	2000a534 	.word	0x2000a534

0802a064 <SetMlmeScheduleUplinkIndication>:
    return false;
}

static void SetMlmeScheduleUplinkIndication( void )
{
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 802a064:	4903      	ldr	r1, [pc, #12]	; (802a074 <SetMlmeScheduleUplinkIndication+0x10>)
 802a066:	4a04      	ldr	r2, [pc, #16]	; (802a078 <SetMlmeScheduleUplinkIndication+0x14>)
 802a068:	5c8b      	ldrb	r3, [r1, r2]
 802a06a:	2010      	movs	r0, #16
 802a06c:	4303      	orrs	r3, r0
 802a06e:	548b      	strb	r3, [r1, r2]
}
 802a070:	4770      	bx	lr
 802a072:	46c0      	nop			; (mov r8, r8)
 802a074:	2000a534 	.word	0x2000a534
 802a078:	00000481 	.word	0x00000481

0802a07c <CalculateBackOff>:

static void CalculateBackOff( void )
{
    // Make sure that the calculation of the backoff time for the aggregated time off will only be done in
    // case the value is zero. It will be set to zero in the function RegionNextChannel.
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 802a07c:	4b07      	ldr	r3, [pc, #28]	; (802a09c <CalculateBackOff+0x20>)
 802a07e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a080:	2b00      	cmp	r3, #0
 802a082:	d10a      	bne.n	802a09a <CalculateBackOff+0x1e>
    {
        // Update aggregated time-off. This must be an assignment and no incremental
        // update as we do only calculate the time-off based on the last transmission
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 802a084:	4905      	ldr	r1, [pc, #20]	; (802a09c <CalculateBackOff+0x20>)
 802a086:	3303      	adds	r3, #3
 802a088:	33ff      	adds	r3, #255	; 0xff
 802a08a:	5aca      	ldrh	r2, [r1, r3]
 802a08c:	4804      	ldr	r0, [pc, #16]	; (802a0a0 <CalculateBackOff+0x24>)
 802a08e:	2383      	movs	r3, #131	; 0x83
 802a090:	00db      	lsls	r3, r3, #3
 802a092:	58c3      	ldr	r3, [r0, r3]
 802a094:	3a01      	subs	r2, #1
 802a096:	4353      	muls	r3, r2
 802a098:	630b      	str	r3, [r1, #48]	; 0x30
    }
}
 802a09a:	4770      	bx	lr
 802a09c:	2000aa3c 	.word	0x2000aa3c
 802a0a0:	2000a534 	.word	0x2000a534

0802a0a4 <SetTxContinuousWave1>:

    return LORAMAC_STATUS_OK;
}

static LoRaMacStatus_t SetTxContinuousWave1( uint16_t timeout, uint32_t frequency, uint8_t power )
{
 802a0a4:	b510      	push	{r4, lr}
 802a0a6:	0003      	movs	r3, r0
 802a0a8:	0008      	movs	r0, r1
    Radio.SetTxContinuousWave( frequency, power, timeout );
 802a0aa:	4907      	ldr	r1, [pc, #28]	; (802a0c8 <SetTxContinuousWave1+0x24>)
 802a0ac:	6bcc      	ldr	r4, [r1, #60]	; 0x3c
 802a0ae:	b251      	sxtb	r1, r2
 802a0b0:	001a      	movs	r2, r3
 802a0b2:	47a0      	blx	r4

    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 802a0b4:	4905      	ldr	r1, [pc, #20]	; (802a0cc <SetTxContinuousWave1+0x28>)
 802a0b6:	22d0      	movs	r2, #208	; 0xd0
 802a0b8:	0092      	lsls	r2, r2, #2
 802a0ba:	2302      	movs	r3, #2
 802a0bc:	5888      	ldr	r0, [r1, r2]
 802a0be:	4303      	orrs	r3, r0
 802a0c0:	508b      	str	r3, [r1, r2]

    return LORAMAC_STATUS_OK;
}
 802a0c2:	2000      	movs	r0, #0
 802a0c4:	bd10      	pop	{r4, pc}
 802a0c6:	46c0      	nop			; (mov r8, r8)
 802a0c8:	080356b4 	.word	0x080356b4
 802a0cc:	2000a534 	.word	0x2000a534

0802a0d0 <GetNvmData>:

LoRaMacNvmData_t* GetNvmData( void )
{
    return &Nvm;
}
 802a0d0:	4800      	ldr	r0, [pc, #0]	; (802a0d4 <GetNvmData+0x4>)
 802a0d2:	4770      	bx	lr
 802a0d4:	2000aa3c 	.word	0x2000aa3c

0802a0d8 <DetermineFrameType>:

    return LORAMAC_STATUS_OK;
}

static LoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType )
{
 802a0d8:	b510      	push	{r4, lr}
 802a0da:	1e03      	subs	r3, r0, #0
    if( ( macMsg == NULL ) || ( fType == NULL ) )
 802a0dc:	d029      	beq.n	802a132 <DetermineFrameType+0x5a>
 802a0de:	2900      	cmp	r1, #0
 802a0e0:	d029      	beq.n	802a136 <DetermineFrameType+0x5e>
     * +-------+  +----------+------+-------+--------------+
     * |   D   |  |    = 0   |   -  |  > 0  |       X      |
     * +-------+  +----------+------+-------+--------------+
     */

    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 802a0e2:	7b02      	ldrb	r2, [r0, #12]
 802a0e4:	200f      	movs	r0, #15
 802a0e6:	0004      	movs	r4, r0
 802a0e8:	4014      	ands	r4, r2
 802a0ea:	4210      	tst	r0, r2
 802a0ec:	d007      	beq.n	802a0fe <DetermineFrameType+0x26>
 802a0ee:	2220      	movs	r2, #32
 802a0f0:	5c9a      	ldrb	r2, [r3, r2]
 802a0f2:	2a00      	cmp	r2, #0
 802a0f4:	d003      	beq.n	802a0fe <DetermineFrameType+0x26>
    {
        *fType = FRAME_TYPE_A;
 802a0f6:	2300      	movs	r3, #0
 802a0f8:	700b      	strb	r3, [r1, #0]
    {
        // Should never happen.
        return LORAMAC_STATUS_ERROR;
    }

    return LORAMAC_STATUS_OK;
 802a0fa:	2000      	movs	r0, #0
        *fType = FRAME_TYPE_A;
 802a0fc:	e005      	b.n	802a10a <DetermineFrameType+0x32>
    else if( macMsg->FRMPayloadSize == 0 )
 802a0fe:	2228      	movs	r2, #40	; 0x28
 802a100:	5c98      	ldrb	r0, [r3, r2]
 802a102:	2800      	cmp	r0, #0
 802a104:	d102      	bne.n	802a10c <DetermineFrameType+0x34>
        *fType = FRAME_TYPE_B;
 802a106:	2301      	movs	r3, #1
 802a108:	700b      	strb	r3, [r1, #0]
}
 802a10a:	bd10      	pop	{r4, pc}
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 802a10c:	2c00      	cmp	r4, #0
 802a10e:	d106      	bne.n	802a11e <DetermineFrameType+0x46>
 802a110:	2220      	movs	r2, #32
 802a112:	5c98      	ldrb	r0, [r3, r2]
 802a114:	2800      	cmp	r0, #0
 802a116:	d102      	bne.n	802a11e <DetermineFrameType+0x46>
        *fType = FRAME_TYPE_C;
 802a118:	2302      	movs	r3, #2
 802a11a:	700b      	strb	r3, [r1, #0]
 802a11c:	e7f5      	b.n	802a10a <DetermineFrameType+0x32>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort > 0 ) )
 802a11e:	2c00      	cmp	r4, #0
 802a120:	d10b      	bne.n	802a13a <DetermineFrameType+0x62>
 802a122:	2220      	movs	r2, #32
 802a124:	5c9b      	ldrb	r3, [r3, r2]
 802a126:	2b00      	cmp	r3, #0
 802a128:	d009      	beq.n	802a13e <DetermineFrameType+0x66>
        *fType = FRAME_TYPE_D;
 802a12a:	2303      	movs	r3, #3
 802a12c:	700b      	strb	r3, [r1, #0]
    return LORAMAC_STATUS_OK;
 802a12e:	0020      	movs	r0, r4
        *fType = FRAME_TYPE_D;
 802a130:	e7eb      	b.n	802a10a <DetermineFrameType+0x32>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802a132:	2003      	movs	r0, #3
 802a134:	e7e9      	b.n	802a10a <DetermineFrameType+0x32>
 802a136:	2003      	movs	r0, #3
 802a138:	e7e7      	b.n	802a10a <DetermineFrameType+0x32>
        return LORAMAC_STATUS_ERROR;
 802a13a:	2017      	movs	r0, #23
 802a13c:	e7e5      	b.n	802a10a <DetermineFrameType+0x32>
 802a13e:	2017      	movs	r0, #23
 802a140:	e7e3      	b.n	802a10a <DetermineFrameType+0x32>
	...

0802a144 <CheckRetransUnconfirmedUplink>:

static bool CheckRetransUnconfirmedUplink( void )
{
    // Unconfirmed uplink, when all retransmissions are done.
    if( MacCtx.ChannelsNbTransCounter >=
 802a144:	4a10      	ldr	r2, [pc, #64]	; (802a188 <CheckRetransUnconfirmedUplink+0x44>)
 802a146:	2382      	movs	r3, #130	; 0x82
 802a148:	00db      	lsls	r3, r3, #3
 802a14a:	5cd2      	ldrb	r2, [r2, r3]
        Nvm.MacGroup2.MacParams.ChannelsNbTrans )
 802a14c:	490f      	ldr	r1, [pc, #60]	; (802a18c <CheckRetransUnconfirmedUplink+0x48>)
 802a14e:	2360      	movs	r3, #96	; 0x60
 802a150:	5ccb      	ldrb	r3, [r1, r3]
    if( MacCtx.ChannelsNbTransCounter >=
 802a152:	429a      	cmp	r2, r3
 802a154:	d20f      	bcs.n	802a176 <CheckRetransUnconfirmedUplink+0x32>
    {
        return true;
    }
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 802a156:	4a0c      	ldr	r2, [pc, #48]	; (802a188 <CheckRetransUnconfirmedUplink+0x44>)
 802a158:	4b0d      	ldr	r3, [pc, #52]	; (802a190 <CheckRetransUnconfirmedUplink+0x4c>)
 802a15a:	5cd3      	ldrb	r3, [r2, r3]
 802a15c:	079b      	lsls	r3, r3, #30
 802a15e:	d50c      	bpl.n	802a17a <CheckRetransUnconfirmedUplink+0x36>
    {
        // For Class A stop in each case
        if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 802a160:	23fc      	movs	r3, #252	; 0xfc
 802a162:	5ccb      	ldrb	r3, [r1, r3]
 802a164:	2b00      	cmp	r3, #0
 802a166:	d00a      	beq.n	802a17e <CheckRetransUnconfirmedUplink+0x3a>
        {
            return true;
        }
        else
        {// For Class B & C stop only if the frame was received in RX1 window
            if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 802a168:	4a07      	ldr	r2, [pc, #28]	; (802a188 <CheckRetransUnconfirmedUplink+0x44>)
 802a16a:	4b0a      	ldr	r3, [pc, #40]	; (802a194 <CheckRetransUnconfirmedUplink+0x50>)
 802a16c:	5cd3      	ldrb	r3, [r2, r3]
 802a16e:	2b00      	cmp	r3, #0
 802a170:	d007      	beq.n	802a182 <CheckRetransUnconfirmedUplink+0x3e>
            {
                return true;
            }
        }
    }
    return false;
 802a172:	2000      	movs	r0, #0
 802a174:	e000      	b.n	802a178 <CheckRetransUnconfirmedUplink+0x34>
        return true;
 802a176:	2001      	movs	r0, #1
}
 802a178:	4770      	bx	lr
    return false;
 802a17a:	2000      	movs	r0, #0
 802a17c:	e7fc      	b.n	802a178 <CheckRetransUnconfirmedUplink+0x34>
            return true;
 802a17e:	2001      	movs	r0, #1
 802a180:	e7fa      	b.n	802a178 <CheckRetransUnconfirmedUplink+0x34>
                return true;
 802a182:	2001      	movs	r0, #1
 802a184:	e7f8      	b.n	802a178 <CheckRetransUnconfirmedUplink+0x34>
 802a186:	46c0      	nop			; (mov r8, r8)
 802a188:	2000a534 	.word	0x2000a534
 802a18c:	2000aa3c 	.word	0x2000aa3c
 802a190:	00000481 	.word	0x00000481
 802a194:	0000047f 	.word	0x0000047f

0802a198 <CheckRetransConfirmedUplink>:

static bool CheckRetransConfirmedUplink( void )
{
    // Confirmed uplink, when all retransmissions ( tries to get a ack ) are done.
    if( MacCtx.AckTimeoutRetriesCounter >=
 802a198:	4b09      	ldr	r3, [pc, #36]	; (802a1c0 <CheckRetransConfirmedUplink+0x28>)
 802a19a:	4a0a      	ldr	r2, [pc, #40]	; (802a1c4 <CheckRetransConfirmedUplink+0x2c>)
 802a19c:	5c9a      	ldrb	r2, [r3, r2]
        MacCtx.AckTimeoutRetries )
 802a19e:	490a      	ldr	r1, [pc, #40]	; (802a1c8 <CheckRetransConfirmedUplink+0x30>)
 802a1a0:	5c5b      	ldrb	r3, [r3, r1]
    if( MacCtx.AckTimeoutRetriesCounter >=
 802a1a2:	429a      	cmp	r2, r3
 802a1a4:	d207      	bcs.n	802a1b6 <CheckRetransConfirmedUplink+0x1e>
    {
        return true;
    }
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 802a1a6:	4a06      	ldr	r2, [pc, #24]	; (802a1c0 <CheckRetransConfirmedUplink+0x28>)
 802a1a8:	4b08      	ldr	r3, [pc, #32]	; (802a1cc <CheckRetransConfirmedUplink+0x34>)
 802a1aa:	5cd3      	ldrb	r3, [r2, r3]
 802a1ac:	079b      	lsls	r3, r3, #30
 802a1ae:	d504      	bpl.n	802a1ba <CheckRetransConfirmedUplink+0x22>
    {
        if( MacCtx.McpsConfirm.AckReceived == true )
 802a1b0:	4b07      	ldr	r3, [pc, #28]	; (802a1d0 <CheckRetransConfirmedUplink+0x38>)
 802a1b2:	5cd0      	ldrb	r0, [r2, r3]
 802a1b4:	e000      	b.n	802a1b8 <CheckRetransConfirmedUplink+0x20>
        return true;
 802a1b6:	2001      	movs	r0, #1
        {
            return true;
        }
    }
    return false;
}
 802a1b8:	4770      	bx	lr
    return false;
 802a1ba:	2000      	movs	r0, #0
 802a1bc:	e7fc      	b.n	802a1b8 <CheckRetransConfirmedUplink+0x20>
 802a1be:	46c0      	nop			; (mov r8, r8)
 802a1c0:	2000a534 	.word	0x2000a534
 802a1c4:	00000412 	.word	0x00000412
 802a1c8:	00000411 	.word	0x00000411
 802a1cc:	00000481 	.word	0x00000481
 802a1d0:	0000043c 	.word	0x0000043c

0802a1d4 <StopRetransmission>:

static bool StopRetransmission( void )
{
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 802a1d4:	4a10      	ldr	r2, [pc, #64]	; (802a218 <StopRetransmission+0x44>)
 802a1d6:	4b11      	ldr	r3, [pc, #68]	; (802a21c <StopRetransmission+0x48>)
 802a1d8:	5cd3      	ldrb	r3, [r2, r3]
 802a1da:	079b      	lsls	r3, r3, #30
 802a1dc:	d503      	bpl.n	802a1e6 <StopRetransmission+0x12>
        ( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
 802a1de:	4b10      	ldr	r3, [pc, #64]	; (802a220 <StopRetransmission+0x4c>)
 802a1e0:	5cd3      	ldrb	r3, [r2, r3]
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 802a1e2:	2b01      	cmp	r3, #1
 802a1e4:	d907      	bls.n	802a1f6 <StopRetransmission+0x22>
          ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_2 ) ) )
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 802a1e6:	4a0f      	ldr	r2, [pc, #60]	; (802a224 <StopRetransmission+0x50>)
 802a1e8:	23fe      	movs	r3, #254	; 0xfe
 802a1ea:	5cd3      	ldrb	r3, [r2, r3]
 802a1ec:	2b00      	cmp	r3, #0
 802a1ee:	d002      	beq.n	802a1f6 <StopRetransmission+0x22>
        {
            Nvm.MacGroup1.AdrAckCounter++;
 802a1f0:	6a93      	ldr	r3, [r2, #40]	; 0x28
 802a1f2:	3301      	adds	r3, #1
 802a1f4:	6293      	str	r3, [r2, #40]	; 0x28
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 802a1f6:	4b08      	ldr	r3, [pc, #32]	; (802a218 <StopRetransmission+0x44>)
 802a1f8:	2200      	movs	r2, #0
 802a1fa:	2182      	movs	r1, #130	; 0x82
 802a1fc:	00c9      	lsls	r1, r1, #3
 802a1fe:	545a      	strb	r2, [r3, r1]
    MacCtx.NodeAckRequested = false;
 802a200:	4909      	ldr	r1, [pc, #36]	; (802a228 <StopRetransmission+0x54>)
 802a202:	545a      	strb	r2, [r3, r1]
    MacCtx.AckTimeoutRetry = false;
 802a204:	4909      	ldr	r1, [pc, #36]	; (802a22c <StopRetransmission+0x58>)
 802a206:	545a      	strb	r2, [r3, r1]
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802a208:	39d3      	subs	r1, #211	; 0xd3
 802a20a:	3202      	adds	r2, #2
 802a20c:	5858      	ldr	r0, [r3, r1]
 802a20e:	4390      	bics	r0, r2
 802a210:	5058      	str	r0, [r3, r1]

    return true;
}
 802a212:	2001      	movs	r0, #1
 802a214:	4770      	bx	lr
 802a216:	46c0      	nop			; (mov r8, r8)
 802a218:	2000a534 	.word	0x2000a534
 802a21c:	00000481 	.word	0x00000481
 802a220:	0000047f 	.word	0x0000047f
 802a224:	2000aa3c 	.word	0x2000aa3c
 802a228:	00000414 	.word	0x00000414
 802a22c:	00000413 	.word	0x00000413

0802a230 <CallNvmDataChangeCallback>:

static void CallNvmDataChangeCallback( uint16_t notifyFlags )
{
 802a230:	b510      	push	{r4, lr}
    if( ( MacCtx.MacCallbacks != NULL ) &&
 802a232:	4a05      	ldr	r2, [pc, #20]	; (802a248 <CallNvmDataChangeCallback+0x18>)
 802a234:	23d2      	movs	r3, #210	; 0xd2
 802a236:	009b      	lsls	r3, r3, #2
 802a238:	58d3      	ldr	r3, [r2, r3]
 802a23a:	2b00      	cmp	r3, #0
 802a23c:	d003      	beq.n	802a246 <CallNvmDataChangeCallback+0x16>
        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 802a23e:	68db      	ldr	r3, [r3, #12]
    if( ( MacCtx.MacCallbacks != NULL ) &&
 802a240:	2b00      	cmp	r3, #0
 802a242:	d000      	beq.n	802a246 <CallNvmDataChangeCallback+0x16>
    {
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 802a244:	4798      	blx	r3
    }
}
 802a246:	bd10      	pop	{r4, pc}
 802a248:	2000a534 	.word	0x2000a534

0802a24c <IsRequestPending>:
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
}

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 802a24c:	4a05      	ldr	r2, [pc, #20]	; (802a264 <IsRequestPending+0x18>)
 802a24e:	4b06      	ldr	r3, [pc, #24]	; (802a268 <IsRequestPending+0x1c>)
 802a250:	5cd3      	ldrb	r3, [r2, r3]
 802a252:	2205      	movs	r2, #5
 802a254:	0010      	movs	r0, r2
 802a256:	4018      	ands	r0, r3
 802a258:	421a      	tst	r2, r3
 802a25a:	d100      	bne.n	802a25e <IsRequestPending+0x12>
        ( MacCtx.MacFlags.Bits.McpsReq == 1 ) )
    {
        return 1;
    }
    return 0;
}
 802a25c:	4770      	bx	lr
        return 1;
 802a25e:	2001      	movs	r0, #1
 802a260:	e7fc      	b.n	802a25c <IsRequestPending+0x10>
 802a262:	46c0      	nop			; (mov r8, r8)
 802a264:	2000a534 	.word	0x2000a534
 802a268:	00000481 	.word	0x00000481

0802a26c <AckTimeoutRetriesProcess>:
{
 802a26c:	b530      	push	{r4, r5, lr}
 802a26e:	b085      	sub	sp, #20
    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )
 802a270:	4a0f      	ldr	r2, [pc, #60]	; (802a2b0 <AckTimeoutRetriesProcess+0x44>)
 802a272:	4b10      	ldr	r3, [pc, #64]	; (802a2b4 <AckTimeoutRetriesProcess+0x48>)
 802a274:	5cd3      	ldrb	r3, [r2, r3]
 802a276:	4910      	ldr	r1, [pc, #64]	; (802a2b8 <AckTimeoutRetriesProcess+0x4c>)
 802a278:	5c52      	ldrb	r2, [r2, r1]
 802a27a:	4293      	cmp	r3, r2
 802a27c:	d206      	bcs.n	802a28c <AckTimeoutRetriesProcess+0x20>
        MacCtx.AckTimeoutRetriesCounter++;
 802a27e:	3301      	adds	r3, #1
 802a280:	b2db      	uxtb	r3, r3
 802a282:	490b      	ldr	r1, [pc, #44]	; (802a2b0 <AckTimeoutRetriesProcess+0x44>)
 802a284:	4a0b      	ldr	r2, [pc, #44]	; (802a2b4 <AckTimeoutRetriesProcess+0x48>)
 802a286:	548b      	strb	r3, [r1, r2]
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 802a288:	07db      	lsls	r3, r3, #31
 802a28a:	d401      	bmi.n	802a290 <AckTimeoutRetriesProcess+0x24>
}
 802a28c:	b005      	add	sp, #20
 802a28e:	bd30      	pop	{r4, r5, pc}
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 802a290:	a902      	add	r1, sp, #8
 802a292:	2322      	movs	r3, #34	; 0x22
 802a294:	700b      	strb	r3, [r1, #0]
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802a296:	4c09      	ldr	r4, [pc, #36]	; (802a2bc <AckTimeoutRetriesProcess+0x50>)
 802a298:	3352      	adds	r3, #82	; 0x52
 802a29a:	5ce3      	ldrb	r3, [r4, r3]
 802a29c:	708b      	strb	r3, [r1, #2]
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802a29e:	2539      	movs	r5, #57	; 0x39
 802a2a0:	5763      	ldrsb	r3, [r4, r5]
 802a2a2:	704b      	strb	r3, [r1, #1]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802a2a4:	2340      	movs	r3, #64	; 0x40
 802a2a6:	5ce0      	ldrb	r0, [r4, r3]
 802a2a8:	f004 fa24 	bl	802e6f4 <RegionGetPhyParam>
            Nvm.MacGroup1.ChannelsDatarate = phyParam.Value;
 802a2ac:	5560      	strb	r0, [r4, r5]
}
 802a2ae:	e7ed      	b.n	802a28c <AckTimeoutRetriesProcess+0x20>
 802a2b0:	2000a534 	.word	0x2000a534
 802a2b4:	00000412 	.word	0x00000412
 802a2b8:	00000411 	.word	0x00000411
 802a2bc:	2000aa3c 	.word	0x2000aa3c

0802a2c0 <GetMaxAppPayloadWithoutFOptsLength>:
{
 802a2c0:	b500      	push	{lr}
 802a2c2:	b085      	sub	sp, #20
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802a2c4:	4a0b      	ldr	r2, [pc, #44]	; (802a2f4 <GetMaxAppPayloadWithoutFOptsLength+0x34>)
 802a2c6:	2374      	movs	r3, #116	; 0x74
 802a2c8:	5cd1      	ldrb	r1, [r2, r3]
 802a2ca:	ab02      	add	r3, sp, #8
 802a2cc:	7099      	strb	r1, [r3, #2]
    getPhy.Datarate = datarate;
 802a2ce:	7058      	strb	r0, [r3, #1]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 802a2d0:	210d      	movs	r1, #13
 802a2d2:	7019      	strb	r1, [r3, #0]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 802a2d4:	2380      	movs	r3, #128	; 0x80
 802a2d6:	5cd3      	ldrb	r3, [r2, r3]
 802a2d8:	2b00      	cmp	r3, #0
 802a2da:	d002      	beq.n	802a2e2 <GetMaxAppPayloadWithoutFOptsLength+0x22>
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 802a2dc:	ab02      	add	r3, sp, #8
 802a2de:	220e      	movs	r2, #14
 802a2e0:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802a2e2:	4a04      	ldr	r2, [pc, #16]	; (802a2f4 <GetMaxAppPayloadWithoutFOptsLength+0x34>)
 802a2e4:	2340      	movs	r3, #64	; 0x40
 802a2e6:	5cd0      	ldrb	r0, [r2, r3]
 802a2e8:	a902      	add	r1, sp, #8
 802a2ea:	f004 fa03 	bl	802e6f4 <RegionGetPhyParam>
    return phyParam.Value;
 802a2ee:	b2c0      	uxtb	r0, r0
}
 802a2f0:	b005      	add	sp, #20
 802a2f2:	bd00      	pop	{pc}
 802a2f4:	2000aa3c 	.word	0x2000aa3c

0802a2f8 <ValidatePayloadLength>:
{
 802a2f8:	b570      	push	{r4, r5, r6, lr}
 802a2fa:	0005      	movs	r5, r0
 802a2fc:	0008      	movs	r0, r1
 802a2fe:	0014      	movs	r4, r2
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 802a300:	f7ff ffde 	bl	802a2c0 <GetMaxAppPayloadWithoutFOptsLength>
 802a304:	b280      	uxth	r0, r0
    payloadSize = ( lenN + fOptsLen );
 802a306:	1964      	adds	r4, r4, r5
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 802a308:	42a0      	cmp	r0, r4
 802a30a:	d303      	bcc.n	802a314 <ValidatePayloadLength+0x1c>
 802a30c:	2cff      	cmp	r4, #255	; 0xff
 802a30e:	d903      	bls.n	802a318 <ValidatePayloadLength+0x20>
    return false;
 802a310:	2000      	movs	r0, #0
 802a312:	e000      	b.n	802a316 <ValidatePayloadLength+0x1e>
 802a314:	2000      	movs	r0, #0
}
 802a316:	bd70      	pop	{r4, r5, r6, pc}
        return true;
 802a318:	2001      	movs	r0, #1
 802a31a:	e7fc      	b.n	802a316 <ValidatePayloadLength+0x1e>

0802a31c <ProcessRadioTxDone>:
{
 802a31c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802a31e:	b08f      	sub	sp, #60	; 0x3c
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802a320:	4a3d      	ldr	r2, [pc, #244]	; (802a418 <ProcessRadioTxDone+0xfc>)
 802a322:	23fc      	movs	r3, #252	; 0xfc
 802a324:	5cd3      	ldrb	r3, [r2, r3]
 802a326:	2b02      	cmp	r3, #2
 802a328:	d002      	beq.n	802a330 <ProcessRadioTxDone+0x14>
        Radio.Sleep( );
 802a32a:	4b3c      	ldr	r3, [pc, #240]	; (802a41c <ProcessRadioTxDone+0x100>)
 802a32c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802a32e:	4798      	blx	r3
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
 802a330:	4c3b      	ldr	r4, [pc, #236]	; (802a420 <ProcessRadioTxDone+0x104>)
 802a332:	23ec      	movs	r3, #236	; 0xec
 802a334:	009b      	lsls	r3, r3, #2
 802a336:	58e1      	ldr	r1, [r4, r3]
 802a338:	3b30      	subs	r3, #48	; 0x30
 802a33a:	18e5      	adds	r5, r4, r3
 802a33c:	0028      	movs	r0, r5
 802a33e:	f009 ffcb 	bl	80342d8 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 802a342:	0028      	movs	r0, r5
 802a344:	f009 ff82 	bl	803424c <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
 802a348:	23ed      	movs	r3, #237	; 0xed
 802a34a:	009b      	lsls	r3, r3, #2
 802a34c:	58e1      	ldr	r1, [r4, r3]
 802a34e:	3b1c      	subs	r3, #28
 802a350:	469c      	mov	ip, r3
 802a352:	4464      	add	r4, ip
 802a354:	0020      	movs	r0, r4
 802a356:	f009 ffbf 	bl	80342d8 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 802a35a:	0020      	movs	r0, r4
 802a35c:	f009 ff76 	bl	803424c <UTIL_TIMER_Start>
    if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 802a360:	4a2d      	ldr	r2, [pc, #180]	; (802a418 <ProcessRadioTxDone+0xfc>)
 802a362:	23fc      	movs	r3, #252	; 0xfc
 802a364:	5cd3      	ldrb	r3, [r2, r3]
 802a366:	2b02      	cmp	r3, #2
 802a368:	d004      	beq.n	802a374 <ProcessRadioTxDone+0x58>
 802a36a:	4a2d      	ldr	r2, [pc, #180]	; (802a420 <ProcessRadioTxDone+0x104>)
 802a36c:	4b2d      	ldr	r3, [pc, #180]	; (802a424 <ProcessRadioTxDone+0x108>)
 802a36e:	5cd3      	ldrb	r3, [r2, r3]
 802a370:	2b00      	cmp	r3, #0
 802a372:	d015      	beq.n	802a3a0 <ProcessRadioTxDone+0x84>
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 802a374:	a90a      	add	r1, sp, #40	; 0x28
 802a376:	2316      	movs	r3, #22
 802a378:	700b      	strb	r3, [r1, #0]
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802a37a:	4a27      	ldr	r2, [pc, #156]	; (802a418 <ProcessRadioTxDone+0xfc>)
 802a37c:	332a      	adds	r3, #42	; 0x2a
 802a37e:	5cd0      	ldrb	r0, [r2, r3]
 802a380:	f004 f9b8 	bl	802e6f4 <RegionGetPhyParam>
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 802a384:	4c26      	ldr	r4, [pc, #152]	; (802a420 <ProcessRadioTxDone+0x104>)
 802a386:	23ed      	movs	r3, #237	; 0xed
 802a388:	009b      	lsls	r3, r3, #2
 802a38a:	58e1      	ldr	r1, [r4, r3]
 802a38c:	1809      	adds	r1, r1, r0
 802a38e:	3344      	adds	r3, #68	; 0x44
 802a390:	469c      	mov	ip, r3
 802a392:	4464      	add	r4, ip
 802a394:	0020      	movs	r0, r4
 802a396:	f009 ff9f 	bl	80342d8 <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.AckTimeoutTimer );
 802a39a:	0020      	movs	r0, r4
 802a39c:	f009 ff56 	bl	803424c <UTIL_TIMER_Start>
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 802a3a0:	4b21      	ldr	r3, [pc, #132]	; (802a428 <ProcessRadioTxDone+0x10c>)
 802a3a2:	681b      	ldr	r3, [r3, #0]
 802a3a4:	4d1c      	ldr	r5, [pc, #112]	; (802a418 <ProcessRadioTxDone+0xfc>)
 802a3a6:	62eb      	str	r3, [r5, #44]	; 0x2c
    txDone.Channel = MacCtx.Channel;
 802a3a8:	4f1d      	ldr	r7, [pc, #116]	; (802a420 <ProcessRadioTxDone+0x104>)
 802a3aa:	4a20      	ldr	r2, [pc, #128]	; (802a42c <ProcessRadioTxDone+0x110>)
 802a3ac:	5cba      	ldrb	r2, [r7, r2]
 802a3ae:	ae04      	add	r6, sp, #16
 802a3b0:	7032      	strb	r2, [r6, #0]
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 802a3b2:	9305      	str	r3, [sp, #20]
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 802a3b4:	a80c      	add	r0, sp, #48	; 0x30
 802a3b6:	f009 fe1f 	bl	8033ff8 <SysTimeGetMcuTime>
 802a3ba:	ac02      	add	r4, sp, #8
 802a3bc:	002b      	movs	r3, r5
 802a3be:	3309      	adds	r3, #9
 802a3c0:	33ff      	adds	r3, #255	; 0xff
 802a3c2:	681b      	ldr	r3, [r3, #0]
 802a3c4:	9300      	str	r3, [sp, #0]
 802a3c6:	2382      	movs	r3, #130	; 0x82
 802a3c8:	005b      	lsls	r3, r3, #1
 802a3ca:	58eb      	ldr	r3, [r5, r3]
 802a3cc:	990c      	ldr	r1, [sp, #48]	; 0x30
 802a3ce:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802a3d0:	0020      	movs	r0, r4
 802a3d2:	f009 fdb5 	bl	8033f40 <SysTimeSub>
 802a3d6:	ab07      	add	r3, sp, #28
 802a3d8:	cc06      	ldmia	r4!, {r1, r2}
 802a3da:	c306      	stmia	r3!, {r1, r2}
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 802a3dc:	2383      	movs	r3, #131	; 0x83
 802a3de:	00db      	lsls	r3, r3, #3
 802a3e0:	58fb      	ldr	r3, [r7, r3]
 802a3e2:	60b3      	str	r3, [r6, #8]
    txDone.Joined  = true;
 802a3e4:	2301      	movs	r3, #1
 802a3e6:	7073      	strb	r3, [r6, #1]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 802a3e8:	3310      	adds	r3, #16
 802a3ea:	33ff      	adds	r3, #255	; 0xff
 802a3ec:	5ceb      	ldrb	r3, [r5, r3]
 802a3ee:	2b00      	cmp	r3, #0
 802a3f0:	d102      	bne.n	802a3f8 <ProcessRadioTxDone+0xdc>
        txDone.Joined  = false;
 802a3f2:	ab04      	add	r3, sp, #16
 802a3f4:	2200      	movs	r2, #0
 802a3f6:	705a      	strb	r2, [r3, #1]
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 802a3f8:	4a07      	ldr	r2, [pc, #28]	; (802a418 <ProcessRadioTxDone+0xfc>)
 802a3fa:	2340      	movs	r3, #64	; 0x40
 802a3fc:	5cd0      	ldrb	r0, [r2, r3]
 802a3fe:	a904      	add	r1, sp, #16
 802a400:	f004 f98f 	bl	802e722 <RegionSetBandTxDone>
    if( MacCtx.NodeAckRequested == false )
 802a404:	4a06      	ldr	r2, [pc, #24]	; (802a420 <ProcessRadioTxDone+0x104>)
 802a406:	4b07      	ldr	r3, [pc, #28]	; (802a424 <ProcessRadioTxDone+0x108>)
 802a408:	5cd3      	ldrb	r3, [r2, r3]
 802a40a:	2b00      	cmp	r3, #0
 802a40c:	d102      	bne.n	802a414 <ProcessRadioTxDone+0xf8>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802a40e:	4b08      	ldr	r3, [pc, #32]	; (802a430 <ProcessRadioTxDone+0x114>)
 802a410:	2100      	movs	r1, #0
 802a412:	54d1      	strb	r1, [r2, r3]
}
 802a414:	b00f      	add	sp, #60	; 0x3c
 802a416:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802a418:	2000aa3c 	.word	0x2000aa3c
 802a41c:	080356b4 	.word	0x080356b4
 802a420:	2000a534 	.word	0x2000a534
 802a424:	00000414 	.word	0x00000414
 802a428:	2000bcf8 	.word	0x2000bcf8
 802a42c:	00000415 	.word	0x00000415
 802a430:	00000439 	.word	0x00000439

0802a434 <OnAckTimeoutTimerEvent>:
{
 802a434:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.AckTimeoutTimer );
 802a436:	4c13      	ldr	r4, [pc, #76]	; (802a484 <OnAckTimeoutTimerEvent+0x50>)
 802a438:	0020      	movs	r0, r4
 802a43a:	f009 fea5 	bl	8034188 <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 802a43e:	4b12      	ldr	r3, [pc, #72]	; (802a488 <OnAckTimeoutTimerEvent+0x54>)
 802a440:	469c      	mov	ip, r3
 802a442:	4464      	add	r4, ip
 802a444:	4b11      	ldr	r3, [pc, #68]	; (802a48c <OnAckTimeoutTimerEvent+0x58>)
 802a446:	5ce3      	ldrb	r3, [r4, r3]
 802a448:	2b00      	cmp	r3, #0
 802a44a:	d003      	beq.n	802a454 <OnAckTimeoutTimerEvent+0x20>
        MacCtx.AckTimeoutRetry = true;
 802a44c:	4a10      	ldr	r2, [pc, #64]	; (802a490 <OnAckTimeoutTimerEvent+0x5c>)
 802a44e:	4b11      	ldr	r3, [pc, #68]	; (802a494 <OnAckTimeoutTimerEvent+0x60>)
 802a450:	2101      	movs	r1, #1
 802a452:	54d1      	strb	r1, [r2, r3]
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 802a454:	4a10      	ldr	r2, [pc, #64]	; (802a498 <OnAckTimeoutTimerEvent+0x64>)
 802a456:	23fc      	movs	r3, #252	; 0xfc
 802a458:	5cd3      	ldrb	r3, [r2, r3]
 802a45a:	2b02      	cmp	r3, #2
 802a45c:	d00a      	beq.n	802a474 <OnAckTimeoutTimerEvent+0x40>
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 802a45e:	4a0c      	ldr	r2, [pc, #48]	; (802a490 <OnAckTimeoutTimerEvent+0x5c>)
 802a460:	23d2      	movs	r3, #210	; 0xd2
 802a462:	009b      	lsls	r3, r3, #2
 802a464:	58d3      	ldr	r3, [r2, r3]
 802a466:	2b00      	cmp	r3, #0
 802a468:	d003      	beq.n	802a472 <OnAckTimeoutTimerEvent+0x3e>
 802a46a:	691b      	ldr	r3, [r3, #16]
 802a46c:	2b00      	cmp	r3, #0
 802a46e:	d000      	beq.n	802a472 <OnAckTimeoutTimerEvent+0x3e>
        MacCtx.MacCallbacks->MacProcessNotify( );
 802a470:	4798      	blx	r3
}
 802a472:	bd10      	pop	{r4, pc}
        MacCtx.MacFlags.Bits.MacDone = 1;
 802a474:	4906      	ldr	r1, [pc, #24]	; (802a490 <OnAckTimeoutTimerEvent+0x5c>)
 802a476:	4a09      	ldr	r2, [pc, #36]	; (802a49c <OnAckTimeoutTimerEvent+0x68>)
 802a478:	5c8b      	ldrb	r3, [r1, r2]
 802a47a:	2020      	movs	r0, #32
 802a47c:	4303      	orrs	r3, r0
 802a47e:	548b      	strb	r3, [r1, r2]
 802a480:	e7ed      	b.n	802a45e <OnAckTimeoutTimerEvent+0x2a>
 802a482:	46c0      	nop			; (mov r8, r8)
 802a484:	2000a92c 	.word	0x2000a92c
 802a488:	fffffc08 	.word	0xfffffc08
 802a48c:	00000414 	.word	0x00000414
 802a490:	2000a534 	.word	0x2000a534
 802a494:	00000413 	.word	0x00000413
 802a498:	2000aa3c 	.word	0x2000aa3c
 802a49c:	00000481 	.word	0x00000481

0802a4a0 <PrepareRxDoneAbort>:
{
 802a4a0:	b510      	push	{r4, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 802a4a2:	4b0d      	ldr	r3, [pc, #52]	; (802a4d8 <PrepareRxDoneAbort+0x38>)
 802a4a4:	21d0      	movs	r1, #208	; 0xd0
 802a4a6:	0089      	lsls	r1, r1, #2
 802a4a8:	2280      	movs	r2, #128	; 0x80
 802a4aa:	5858      	ldr	r0, [r3, r1]
 802a4ac:	4302      	orrs	r2, r0
 802a4ae:	505a      	str	r2, [r3, r1]
    if( MacCtx.NodeAckRequested == true )
 802a4b0:	4a0a      	ldr	r2, [pc, #40]	; (802a4dc <PrepareRxDoneAbort+0x3c>)
 802a4b2:	5c9b      	ldrb	r3, [r3, r2]
 802a4b4:	2b00      	cmp	r3, #0
 802a4b6:	d10b      	bne.n	802a4d0 <PrepareRxDoneAbort+0x30>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 802a4b8:	4907      	ldr	r1, [pc, #28]	; (802a4d8 <PrepareRxDoneAbort+0x38>)
 802a4ba:	4a09      	ldr	r2, [pc, #36]	; (802a4e0 <PrepareRxDoneAbort+0x40>)
 802a4bc:	5c8b      	ldrb	r3, [r1, r2]
 802a4be:	2002      	movs	r0, #2
 802a4c0:	4303      	orrs	r3, r0
    MacCtx.MacFlags.Bits.MacDone = 1;
 802a4c2:	b2db      	uxtb	r3, r3
 802a4c4:	2020      	movs	r0, #32
 802a4c6:	4303      	orrs	r3, r0
 802a4c8:	548b      	strb	r3, [r1, r2]
    UpdateRxSlotIdleState( );
 802a4ca:	f7ff fd4d 	bl	8029f68 <UpdateRxSlotIdleState>
}
 802a4ce:	bd10      	pop	{r4, pc}
        OnAckTimeoutTimerEvent( NULL );
 802a4d0:	2000      	movs	r0, #0
 802a4d2:	f7ff ffaf 	bl	802a434 <OnAckTimeoutTimerEvent>
 802a4d6:	e7ef      	b.n	802a4b8 <PrepareRxDoneAbort+0x18>
 802a4d8:	2000a534 	.word	0x2000a534
 802a4dc:	00000414 	.word	0x00000414
 802a4e0:	00000481 	.word	0x00000481

0802a4e4 <LoRaMacCheckForBeaconAcquisition>:
{
 802a4e4:	b510      	push	{r4, lr}
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 802a4e6:	200c      	movs	r0, #12
 802a4e8:	f003 fb68 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802a4ec:	2800      	cmp	r0, #0
 802a4ee:	d012      	beq.n	802a516 <LoRaMacCheckForBeaconAcquisition+0x32>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 802a4f0:	4a0b      	ldr	r2, [pc, #44]	; (802a520 <LoRaMacCheckForBeaconAcquisition+0x3c>)
 802a4f2:	4b0c      	ldr	r3, [pc, #48]	; (802a524 <LoRaMacCheckForBeaconAcquisition+0x40>)
 802a4f4:	5cd3      	ldrb	r3, [r2, r3]
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 802a4f6:	07da      	lsls	r2, r3, #31
 802a4f8:	d40f      	bmi.n	802a51a <LoRaMacCheckForBeaconAcquisition+0x36>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 802a4fa:	2204      	movs	r2, #4
 802a4fc:	0010      	movs	r0, r2
 802a4fe:	4018      	ands	r0, r3
 802a500:	421a      	tst	r2, r3
 802a502:	d009      	beq.n	802a518 <LoRaMacCheckForBeaconAcquisition+0x34>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802a504:	4906      	ldr	r1, [pc, #24]	; (802a520 <LoRaMacCheckForBeaconAcquisition+0x3c>)
 802a506:	22d0      	movs	r2, #208	; 0xd0
 802a508:	0092      	lsls	r2, r2, #2
 802a50a:	2302      	movs	r3, #2
 802a50c:	5888      	ldr	r0, [r1, r2]
 802a50e:	4398      	bics	r0, r3
 802a510:	5088      	str	r0, [r1, r2]
            return 0x01;
 802a512:	2001      	movs	r0, #1
 802a514:	e000      	b.n	802a518 <LoRaMacCheckForBeaconAcquisition+0x34>
    return 0x00;
 802a516:	2000      	movs	r0, #0
}
 802a518:	bd10      	pop	{r4, pc}
    return 0x00;
 802a51a:	2000      	movs	r0, #0
 802a51c:	e7fc      	b.n	802a518 <LoRaMacCheckForBeaconAcquisition+0x34>
 802a51e:	46c0      	nop			; (mov r8, r8)
 802a520:	2000a534 	.word	0x2000a534
 802a524:	00000481 	.word	0x00000481

0802a528 <GetFCntDown>:
{
 802a528:	b570      	push	{r4, r5, r6, lr}
 802a52a:	000c      	movs	r4, r1
 802a52c:	a904      	add	r1, sp, #16
 802a52e:	8809      	ldrh	r1, [r1, #0]
    if( ( macMsg == NULL ) || ( fCntID == NULL ) ||
 802a530:	2a00      	cmp	r2, #0
 802a532:	d027      	beq.n	802a584 <GetFCntDown+0x5c>
 802a534:	9d05      	ldr	r5, [sp, #20]
 802a536:	2d00      	cmp	r5, #0
 802a538:	d026      	beq.n	802a588 <GetFCntDown+0x60>
 802a53a:	9d06      	ldr	r5, [sp, #24]
 802a53c:	2d00      	cmp	r5, #0
 802a53e:	d025      	beq.n	802a58c <GetFCntDown+0x64>
    switch( addrID )
 802a540:	2800      	cmp	r0, #0
 802a542:	d015      	beq.n	802a570 <GetFCntDown+0x48>
 802a544:	2801      	cmp	r0, #1
 802a546:	d123      	bne.n	802a590 <GetFCntDown+0x68>
            if( lrWanVersion.Fields.Minor == 1 )
 802a548:	021b      	lsls	r3, r3, #8
 802a54a:	0e1b      	lsrs	r3, r3, #24
 802a54c:	2b01      	cmp	r3, #1
 802a54e:	d003      	beq.n	802a558 <GetFCntDown+0x30>
                *fCntID = FCNT_DOWN;
 802a550:	2303      	movs	r3, #3
 802a552:	9805      	ldr	r0, [sp, #20]
 802a554:	7003      	strb	r3, [r0, #0]
 802a556:	e00e      	b.n	802a576 <GetFCntDown+0x4e>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 802a558:	2c00      	cmp	r4, #0
 802a55a:	d005      	beq.n	802a568 <GetFCntDown+0x40>
 802a55c:	2c03      	cmp	r4, #3
 802a55e:	d003      	beq.n	802a568 <GetFCntDown+0x40>
                    *fCntID = N_FCNT_DOWN;
 802a560:	2301      	movs	r3, #1
 802a562:	9805      	ldr	r0, [sp, #20]
 802a564:	7003      	strb	r3, [r0, #0]
 802a566:	e006      	b.n	802a576 <GetFCntDown+0x4e>
                    *fCntID = A_FCNT_DOWN;
 802a568:	2302      	movs	r3, #2
 802a56a:	9805      	ldr	r0, [sp, #20]
 802a56c:	7003      	strb	r3, [r0, #0]
 802a56e:	e002      	b.n	802a576 <GetFCntDown+0x4e>
            *fCntID = MC_FCNT_DOWN_0;
 802a570:	2304      	movs	r3, #4
 802a572:	9805      	ldr	r0, [sp, #20]
 802a574:	7003      	strb	r3, [r0, #0]
    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 802a576:	89d2      	ldrh	r2, [r2, #14]
 802a578:	9b05      	ldr	r3, [sp, #20]
 802a57a:	7818      	ldrb	r0, [r3, #0]
 802a57c:	9b06      	ldr	r3, [sp, #24]
 802a57e:	f003 fd53 	bl	802e028 <LoRaMacCryptoGetFCntDown>
}
 802a582:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802a584:	200a      	movs	r0, #10
 802a586:	e7fc      	b.n	802a582 <GetFCntDown+0x5a>
 802a588:	200a      	movs	r0, #10
 802a58a:	e7fa      	b.n	802a582 <GetFCntDown+0x5a>
 802a58c:	200a      	movs	r0, #10
 802a58e:	e7f8      	b.n	802a582 <GetFCntDown+0x5a>
    switch( addrID )
 802a590:	2005      	movs	r0, #5
 802a592:	e7f6      	b.n	802a582 <GetFCntDown+0x5a>

0802a594 <RemoveMacCommands>:
{
 802a594:	b510      	push	{r4, lr}
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 802a596:	2801      	cmp	r0, #1
 802a598:	d900      	bls.n	802a59c <RemoveMacCommands+0x8>
}
 802a59a:	bd10      	pop	{r4, pc}
        if( request == MCPS_CONFIRMED )
 802a59c:	2a01      	cmp	r2, #1
 802a59e:	d104      	bne.n	802a5aa <RemoveMacCommands+0x16>
            if( fCtrl.Bits.Ack == 1 )
 802a5a0:	068b      	lsls	r3, r1, #26
 802a5a2:	d5fa      	bpl.n	802a59a <RemoveMacCommands+0x6>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 802a5a4:	f003 f99a 	bl	802d8dc <LoRaMacCommandsRemoveStickyAnsCmds>
 802a5a8:	e7f7      	b.n	802a59a <RemoveMacCommands+0x6>
            LoRaMacCommandsRemoveStickyAnsCmds( );
 802a5aa:	f003 f997 	bl	802d8dc <LoRaMacCommandsRemoveStickyAnsCmds>
}
 802a5ae:	e7f4      	b.n	802a59a <RemoveMacCommands+0x6>

0802a5b0 <ProcessMacCommands>:
{
 802a5b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802a5b2:	46d6      	mov	lr, sl
 802a5b4:	464f      	mov	r7, r9
 802a5b6:	4646      	mov	r6, r8
 802a5b8:	b5c0      	push	{r6, r7, lr}
 802a5ba:	b090      	sub	sp, #64	; 0x40
 802a5bc:	0005      	movs	r5, r0
 802a5be:	000c      	movs	r4, r1
 802a5c0:	4690      	mov	r8, r2
 802a5c2:	9303      	str	r3, [sp, #12]
    uint8_t status = 0;
 802a5c4:	2300      	movs	r3, #0
 802a5c6:	222f      	movs	r2, #47	; 0x2f
 802a5c8:	a902      	add	r1, sp, #8
 802a5ca:	468c      	mov	ip, r1
 802a5cc:	4462      	add	r2, ip
 802a5ce:	7013      	strb	r3, [r2, #0]
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 802a5d0:	aa0d      	add	r2, sp, #52	; 0x34
 802a5d2:	8013      	strh	r3, [r2, #0]
    bool adrBlockFound = false;
 802a5d4:	4699      	mov	r9, r3
    while( macIndex < commandsSize )
 802a5d6:	4544      	cmp	r4, r8
 802a5d8:	d300      	bcc.n	802a5dc <ProcessMacCommands+0x2c>
 802a5da:	e2a9      	b.n	802ab30 <ProcessMacCommands+0x580>
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 802a5dc:	192f      	adds	r7, r5, r4
 802a5de:	5d28      	ldrb	r0, [r5, r4]
 802a5e0:	f003 f9f0 	bl	802d9c4 <LoRaMacCommandsGetCmdSize>
 802a5e4:	1820      	adds	r0, r4, r0
 802a5e6:	4540      	cmp	r0, r8
 802a5e8:	dd00      	ble.n	802a5ec <ProcessMacCommands+0x3c>
 802a5ea:	e2a1      	b.n	802ab30 <ProcessMacCommands+0x580>
        switch( payload[macIndex++] )
 802a5ec:	1c66      	adds	r6, r4, #1
 802a5ee:	b2f6      	uxtb	r6, r6
 802a5f0:	783b      	ldrb	r3, [r7, #0]
 802a5f2:	2b13      	cmp	r3, #19
 802a5f4:	d900      	bls.n	802a5f8 <ProcessMacCommands+0x48>
 802a5f6:	e29b      	b.n	802ab30 <ProcessMacCommands+0x580>
 802a5f8:	009b      	lsls	r3, r3, #2
 802a5fa:	4ae4      	ldr	r2, [pc, #912]	; (802a98c <ProcessMacCommands+0x3dc>)
 802a5fc:	58d3      	ldr	r3, [r2, r3]
 802a5fe:	469f      	mov	pc, r3
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 802a600:	2004      	movs	r0, #4
 802a602:	f003 fadb 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802a606:	2800      	cmp	r0, #0
 802a608:	d101      	bne.n	802a60e <ProcessMacCommands+0x5e>
        switch( payload[macIndex++] )
 802a60a:	0034      	movs	r4, r6
 802a60c:	e7e3      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 802a60e:	2104      	movs	r1, #4
 802a610:	2000      	movs	r0, #0
 802a612:	f003 fa83 	bl	802db1c <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 802a616:	1ca3      	adds	r3, r4, #2
 802a618:	b2db      	uxtb	r3, r3
 802a61a:	5da8      	ldrb	r0, [r5, r6]
 802a61c:	4adc      	ldr	r2, [pc, #880]	; (802a990 <ProcessMacCommands+0x3e0>)
 802a61e:	49dd      	ldr	r1, [pc, #884]	; (802a994 <ProcessMacCommands+0x3e4>)
 802a620:	5450      	strb	r0, [r2, r1]
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 802a622:	3403      	adds	r4, #3
 802a624:	b2e4      	uxtb	r4, r4
 802a626:	5ce9      	ldrb	r1, [r5, r3]
 802a628:	4bdb      	ldr	r3, [pc, #876]	; (802a998 <ProcessMacCommands+0x3e8>)
 802a62a:	54d1      	strb	r1, [r2, r3]
 802a62c:	e7d3      	b.n	802a5d6 <ProcessMacCommands+0x26>
                int8_t linkAdrDatarate = DR_0;
 802a62e:	2300      	movs	r3, #0
 802a630:	220a      	movs	r2, #10
 802a632:	a902      	add	r1, sp, #8
 802a634:	468c      	mov	ip, r1
 802a636:	4462      	add	r2, ip
 802a638:	7013      	strb	r3, [r2, #0]
                int8_t linkAdrTxPower = TX_POWER_0;
 802a63a:	220b      	movs	r2, #11
 802a63c:	4462      	add	r2, ip
 802a63e:	7013      	strb	r3, [r2, #0]
                uint8_t linkAdrNbRep = 0;
 802a640:	aa05      	add	r2, sp, #20
 802a642:	7013      	strb	r3, [r2, #0]
                uint8_t linkAdrNbBytesParsed = 0;
 802a644:	aa07      	add	r2, sp, #28
 802a646:	7013      	strb	r3, [r2, #0]
                if( adrBlockFound == false )
 802a648:	464b      	mov	r3, r9
 802a64a:	2b00      	cmp	r3, #0
 802a64c:	d001      	beq.n	802a652 <ProcessMacCommands+0xa2>
                break;
 802a64e:	0034      	movs	r4, r6
 802a650:	e7c1      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    linkAdrReq.Payload = &payload[macIndex - 1];
 802a652:	1e73      	subs	r3, r6, #1
 802a654:	18eb      	adds	r3, r5, r3
 802a656:	a909      	add	r1, sp, #36	; 0x24
 802a658:	604b      	str	r3, [r1, #4]
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 802a65a:	4643      	mov	r3, r8
 802a65c:	1b9b      	subs	r3, r3, r6
 802a65e:	3301      	adds	r3, #1
 802a660:	720b      	strb	r3, [r1, #8]
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 802a662:	4bce      	ldr	r3, [pc, #824]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a664:	22fe      	movs	r2, #254	; 0xfe
 802a666:	5c9a      	ldrb	r2, [r3, r2]
 802a668:	728a      	strb	r2, [r1, #10]
                    linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802a66a:	2274      	movs	r2, #116	; 0x74
 802a66c:	5c9a      	ldrb	r2, [r3, r2]
 802a66e:	724a      	strb	r2, [r1, #9]
                    linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 802a670:	2239      	movs	r2, #57	; 0x39
 802a672:	569a      	ldrsb	r2, [r3, r2]
 802a674:	72ca      	strb	r2, [r1, #11]
                    linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 802a676:	2238      	movs	r2, #56	; 0x38
 802a678:	569a      	ldrsb	r2, [r3, r2]
 802a67a:	730a      	strb	r2, [r1, #12]
                    linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 802a67c:	2260      	movs	r2, #96	; 0x60
 802a67e:	5c9a      	ldrb	r2, [r3, r2]
 802a680:	734a      	strb	r2, [r1, #13]
                    linkAdrReq.Version = Nvm.MacGroup2.Version;
 802a682:	2286      	movs	r2, #134	; 0x86
 802a684:	0052      	lsls	r2, r2, #1
 802a686:	589a      	ldr	r2, [r3, r2]
 802a688:	9209      	str	r2, [sp, #36]	; 0x24
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 802a68a:	2240      	movs	r2, #64	; 0x40
 802a68c:	5c98      	ldrb	r0, [r3, r2]
 802a68e:	ab07      	add	r3, sp, #28
 802a690:	9301      	str	r3, [sp, #4]
 802a692:	ab05      	add	r3, sp, #20
 802a694:	9300      	str	r3, [sp, #0]
 802a696:	230b      	movs	r3, #11
 802a698:	4463      	add	r3, ip
 802a69a:	220a      	movs	r2, #10
 802a69c:	4462      	add	r2, ip
 802a69e:	f004 f8bc 	bl	802e81a <RegionLinkAdrReq>
 802a6a2:	232f      	movs	r3, #47	; 0x2f
 802a6a4:	aa02      	add	r2, sp, #8
 802a6a6:	4694      	mov	ip, r2
 802a6a8:	4463      	add	r3, ip
 802a6aa:	7018      	strb	r0, [r3, #0]
                    if( ( status & 0x07 ) == 0x07 )
 802a6ac:	2307      	movs	r3, #7
 802a6ae:	4018      	ands	r0, r3
 802a6b0:	2807      	cmp	r0, #7
 802a6b2:	d001      	beq.n	802a6b8 <ProcessMacCommands+0x108>
{
 802a6b4:	2400      	movs	r4, #0
 802a6b6:	e019      	b.n	802a6ec <ProcessMacCommands+0x13c>
                        Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 802a6b8:	4bb8      	ldr	r3, [pc, #736]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a6ba:	220a      	movs	r2, #10
 802a6bc:	4462      	add	r2, ip
 802a6be:	7811      	ldrb	r1, [r2, #0]
 802a6c0:	2239      	movs	r2, #57	; 0x39
 802a6c2:	5499      	strb	r1, [r3, r2]
                        Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 802a6c4:	3a2e      	subs	r2, #46	; 0x2e
 802a6c6:	4462      	add	r2, ip
 802a6c8:	7811      	ldrb	r1, [r2, #0]
 802a6ca:	2238      	movs	r2, #56	; 0x38
 802a6cc:	5499      	strb	r1, [r3, r2]
                        Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 802a6ce:	aa05      	add	r2, sp, #20
 802a6d0:	7811      	ldrb	r1, [r2, #0]
 802a6d2:	2260      	movs	r2, #96	; 0x60
 802a6d4:	5499      	strb	r1, [r3, r2]
 802a6d6:	e7ed      	b.n	802a6b4 <ProcessMacCommands+0x104>
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 802a6d8:	2201      	movs	r2, #1
 802a6da:	212f      	movs	r1, #47	; 0x2f
 802a6dc:	ab02      	add	r3, sp, #8
 802a6de:	469c      	mov	ip, r3
 802a6e0:	4461      	add	r1, ip
 802a6e2:	2003      	movs	r0, #3
 802a6e4:	f003 f89c 	bl	802d820 <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 802a6e8:	3401      	adds	r4, #1
 802a6ea:	b2e4      	uxtb	r4, r4
 802a6ec:	ab07      	add	r3, sp, #28
 802a6ee:	781f      	ldrb	r7, [r3, #0]
 802a6f0:	2105      	movs	r1, #5
 802a6f2:	0038      	movs	r0, r7
 802a6f4:	f7f5 fd10 	bl	8020118 <__udivsi3>
 802a6f8:	b2c0      	uxtb	r0, r0
 802a6fa:	42a0      	cmp	r0, r4
 802a6fc:	d8ec      	bhi.n	802a6d8 <ProcessMacCommands+0x128>
                    macIndex += linkAdrNbBytesParsed - 1;
 802a6fe:	19be      	adds	r6, r7, r6
 802a700:	b2f6      	uxtb	r6, r6
 802a702:	3e01      	subs	r6, #1
 802a704:	b2f6      	uxtb	r6, r6
                    adrBlockFound = true;
 802a706:	2301      	movs	r3, #1
 802a708:	4699      	mov	r9, r3
 802a70a:	e7a0      	b.n	802a64e <ProcessMacCommands+0x9e>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 802a70c:	3402      	adds	r4, #2
 802a70e:	b2e4      	uxtb	r4, r4
 802a710:	5daa      	ldrb	r2, [r5, r6]
 802a712:	230f      	movs	r3, #15
 802a714:	4013      	ands	r3, r2
 802a716:	49a1      	ldr	r1, [pc, #644]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a718:	22ff      	movs	r2, #255	; 0xff
 802a71a:	548b      	strb	r3, [r1, r2]
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 802a71c:	3afe      	subs	r2, #254	; 0xfe
 802a71e:	409a      	lsls	r2, r3
 802a720:	0013      	movs	r3, r2
 802a722:	2281      	movs	r2, #129	; 0x81
 802a724:	0052      	lsls	r2, r2, #1
 802a726:	528b      	strh	r3, [r1, r2]
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 802a728:	2200      	movs	r2, #0
 802a72a:	a90d      	add	r1, sp, #52	; 0x34
 802a72c:	2004      	movs	r0, #4
 802a72e:	f003 f877 	bl	802d820 <LoRaMacCommandsAddCmd>
                break;
 802a732:	e750      	b.n	802a5d6 <ProcessMacCommands+0x26>
                status = 0x07;
 802a734:	272f      	movs	r7, #47	; 0x2f
 802a736:	ab02      	add	r3, sp, #8
 802a738:	469c      	mov	ip, r3
 802a73a:	4467      	add	r7, ip
 802a73c:	2307      	movs	r3, #7
 802a73e:	703b      	strb	r3, [r7, #0]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 802a740:	5dab      	ldrb	r3, [r5, r6]
 802a742:	091b      	lsrs	r3, r3, #4
 802a744:	2207      	movs	r2, #7
 802a746:	4692      	mov	sl, r2
 802a748:	4013      	ands	r3, r2
 802a74a:	4662      	mov	r2, ip
 802a74c:	7753      	strb	r3, [r2, #29]
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 802a74e:	57aa      	ldrsb	r2, [r5, r6]
 802a750:	230f      	movs	r3, #15
 802a752:	4013      	ands	r3, r2
 802a754:	4662      	mov	r2, ip
 802a756:	7713      	strb	r3, [r2, #28]
                macIndex++;
 802a758:	1ca3      	adds	r3, r4, #2
 802a75a:	b2db      	uxtb	r3, r3
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 802a75c:	1ce2      	adds	r2, r4, #3
 802a75e:	b2d2      	uxtb	r2, r2
 802a760:	5ceb      	ldrb	r3, [r5, r3]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 802a762:	1d20      	adds	r0, r4, #4
 802a764:	b2c0      	uxtb	r0, r0
 802a766:	5caa      	ldrb	r2, [r5, r2]
 802a768:	0212      	lsls	r2, r2, #8
 802a76a:	4313      	orrs	r3, r2
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 802a76c:	3405      	adds	r4, #5
 802a76e:	b2e4      	uxtb	r4, r4
 802a770:	5c2a      	ldrb	r2, [r5, r0]
 802a772:	0412      	lsls	r2, r2, #16
 802a774:	4313      	orrs	r3, r2
                rxParamSetupReq.Frequency *= 100;
 802a776:	2264      	movs	r2, #100	; 0x64
 802a778:	4353      	muls	r3, r2
 802a77a:	930a      	str	r3, [sp, #40]	; 0x28
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 802a77c:	4a87      	ldr	r2, [pc, #540]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a77e:	2340      	movs	r3, #64	; 0x40
 802a780:	5cd0      	ldrb	r0, [r2, r3]
 802a782:	a909      	add	r1, sp, #36	; 0x24
 802a784:	f004 f862 	bl	802e84c <RegionRxParamSetupReq>
 802a788:	7038      	strb	r0, [r7, #0]
                if( ( status & 0x07 ) == 0x07 )
 802a78a:	4653      	mov	r3, sl
 802a78c:	4003      	ands	r3, r0
 802a78e:	2b07      	cmp	r3, #7
 802a790:	d008      	beq.n	802a7a4 <ProcessMacCommands+0x1f4>
                macCmdPayload[0] = status;
 802a792:	a90d      	add	r1, sp, #52	; 0x34
 802a794:	7008      	strb	r0, [r1, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 802a796:	2201      	movs	r2, #1
 802a798:	2005      	movs	r0, #5
 802a79a:	f003 f841 	bl	802d820 <LoRaMacCommandsAddCmd>
                SetMlmeScheduleUplinkIndication( );
 802a79e:	f7ff fc61 	bl	802a064 <SetMlmeScheduleUplinkIndication>
                break;
 802a7a2:	e718      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 802a7a4:	aa09      	add	r2, sp, #36	; 0x24
 802a7a6:	7811      	ldrb	r1, [r2, #0]
 802a7a8:	4b7c      	ldr	r3, [pc, #496]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a7aa:	2668      	movs	r6, #104	; 0x68
 802a7ac:	5599      	strb	r1, [r3, r6]
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 802a7ae:	3608      	adds	r6, #8
 802a7b0:	5599      	strb	r1, [r3, r6]
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 802a7b2:	990a      	ldr	r1, [sp, #40]	; 0x28
 802a7b4:	6659      	str	r1, [r3, #100]	; 0x64
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 802a7b6:	66d9      	str	r1, [r3, #108]	; 0x6c
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 802a7b8:	7851      	ldrb	r1, [r2, #1]
 802a7ba:	2261      	movs	r2, #97	; 0x61
 802a7bc:	5499      	strb	r1, [r3, r2]
 802a7be:	e7e8      	b.n	802a792 <ProcessMacCommands+0x1e2>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 802a7c0:	4a73      	ldr	r2, [pc, #460]	; (802a990 <ProcessMacCommands+0x3e0>)
 802a7c2:	23d2      	movs	r3, #210	; 0xd2
 802a7c4:	009b      	lsls	r3, r3, #2
 802a7c6:	58d3      	ldr	r3, [r2, r3]
 802a7c8:	2b00      	cmp	r3, #0
 802a7ca:	d015      	beq.n	802a7f8 <ProcessMacCommands+0x248>
 802a7cc:	681b      	ldr	r3, [r3, #0]
 802a7ce:	2b00      	cmp	r3, #0
 802a7d0:	d014      	beq.n	802a7fc <ProcessMacCommands+0x24c>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 802a7d2:	4798      	blx	r3
                macCmdPayload[0] = batteryLevel;
 802a7d4:	ab02      	add	r3, sp, #8
 802a7d6:	222c      	movs	r2, #44	; 0x2c
 802a7d8:	189b      	adds	r3, r3, r2
 802a7da:	7018      	strb	r0, [r3, #0]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 802a7dc:	233f      	movs	r3, #63	; 0x3f
 802a7de:	9a03      	ldr	r2, [sp, #12]
 802a7e0:	4013      	ands	r3, r2
 802a7e2:	aa02      	add	r2, sp, #8
 802a7e4:	212d      	movs	r1, #45	; 0x2d
 802a7e6:	1852      	adds	r2, r2, r1
 802a7e8:	7013      	strb	r3, [r2, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 802a7ea:	2202      	movs	r2, #2
 802a7ec:	a90d      	add	r1, sp, #52	; 0x34
 802a7ee:	2006      	movs	r0, #6
 802a7f0:	f003 f816 	bl	802d820 <LoRaMacCommandsAddCmd>
        switch( payload[macIndex++] )
 802a7f4:	0034      	movs	r4, r6
                break;
 802a7f6:	e6ee      	b.n	802a5d6 <ProcessMacCommands+0x26>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 802a7f8:	20ff      	movs	r0, #255	; 0xff
 802a7fa:	e7eb      	b.n	802a7d4 <ProcessMacCommands+0x224>
 802a7fc:	20ff      	movs	r0, #255	; 0xff
 802a7fe:	e7e9      	b.n	802a7d4 <ProcessMacCommands+0x224>
                status = 0x03;
 802a800:	272f      	movs	r7, #47	; 0x2f
 802a802:	ab02      	add	r3, sp, #8
 802a804:	469c      	mov	ip, r3
 802a806:	4467      	add	r7, ip
 802a808:	2303      	movs	r3, #3
 802a80a:	703b      	strb	r3, [r7, #0]
                newChannelReq.ChannelId = payload[macIndex++];
 802a80c:	1ca3      	adds	r3, r4, #2
 802a80e:	b2db      	uxtb	r3, r3
 802a810:	57aa      	ldrsb	r2, [r5, r6]
 802a812:	a907      	add	r1, sp, #28
 802a814:	710a      	strb	r2, [r1, #4]
                newChannelReq.NewChannel = &chParam;
 802a816:	a809      	add	r0, sp, #36	; 0x24
 802a818:	9007      	str	r0, [sp, #28]
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 802a81a:	1ce6      	adds	r6, r4, #3
 802a81c:	b2f6      	uxtb	r6, r6
 802a81e:	5ceb      	ldrb	r3, [r5, r3]
 802a820:	469c      	mov	ip, r3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 802a822:	1d22      	adds	r2, r4, #4
 802a824:	b2d2      	uxtb	r2, r2
 802a826:	5dab      	ldrb	r3, [r5, r6]
 802a828:	021b      	lsls	r3, r3, #8
 802a82a:	4666      	mov	r6, ip
 802a82c:	4333      	orrs	r3, r6
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 802a82e:	1d66      	adds	r6, r4, #5
 802a830:	b2f6      	uxtb	r6, r6
 802a832:	5caa      	ldrb	r2, [r5, r2]
 802a834:	0412      	lsls	r2, r2, #16
 802a836:	431a      	orrs	r2, r3
                chParam.Frequency *= 100;
 802a838:	2364      	movs	r3, #100	; 0x64
 802a83a:	4353      	muls	r3, r2
 802a83c:	9309      	str	r3, [sp, #36]	; 0x24
                chParam.Rx1Frequency = 0;
 802a83e:	2300      	movs	r3, #0
 802a840:	930a      	str	r3, [sp, #40]	; 0x28
                chParam.DrRange.Value = payload[macIndex++];
 802a842:	3406      	adds	r4, #6
 802a844:	b2e4      	uxtb	r4, r4
 802a846:	57ab      	ldrsb	r3, [r5, r6]
 802a848:	7203      	strb	r3, [r0, #8]
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 802a84a:	4a54      	ldr	r2, [pc, #336]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a84c:	2340      	movs	r3, #64	; 0x40
 802a84e:	5cd0      	ldrb	r0, [r2, r3]
 802a850:	f004 f80b 	bl	802e86a <RegionNewChannelReq>
 802a854:	b2c3      	uxtb	r3, r0
 802a856:	703b      	strb	r3, [r7, #0]
                if( ( int8_t )status >= 0 )
 802a858:	2800      	cmp	r0, #0
 802a85a:	da00      	bge.n	802a85e <ProcessMacCommands+0x2ae>
 802a85c:	e6bb      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    macCmdPayload[0] = status;
 802a85e:	a90d      	add	r1, sp, #52	; 0x34
 802a860:	700b      	strb	r3, [r1, #0]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 802a862:	2201      	movs	r2, #1
 802a864:	2007      	movs	r0, #7
 802a866:	f002 ffdb 	bl	802d820 <LoRaMacCommandsAddCmd>
                break;
 802a86a:	e6b4      	b.n	802a5d6 <ProcessMacCommands+0x26>
                uint8_t delay = payload[macIndex++] & 0x0F;
 802a86c:	3402      	adds	r4, #2
 802a86e:	b2e4      	uxtb	r4, r4
 802a870:	5dab      	ldrb	r3, [r5, r6]
 802a872:	220f      	movs	r2, #15
 802a874:	0011      	movs	r1, r2
 802a876:	4019      	ands	r1, r3
                if( delay == 0 )
 802a878:	421a      	tst	r2, r3
 802a87a:	d100      	bne.n	802a87e <ProcessMacCommands+0x2ce>
                    delay++;
 802a87c:	3101      	adds	r1, #1
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 802a87e:	014b      	lsls	r3, r1, #5
 802a880:	1a5b      	subs	r3, r3, r1
 802a882:	009b      	lsls	r3, r3, #2
 802a884:	185b      	adds	r3, r3, r1
 802a886:	00db      	lsls	r3, r3, #3
 802a888:	4a44      	ldr	r2, [pc, #272]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a88a:	6513      	str	r3, [r2, #80]	; 0x50
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 802a88c:	21fa      	movs	r1, #250	; 0xfa
 802a88e:	0089      	lsls	r1, r1, #2
 802a890:	468c      	mov	ip, r1
 802a892:	4463      	add	r3, ip
 802a894:	6553      	str	r3, [r2, #84]	; 0x54
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 802a896:	2200      	movs	r2, #0
 802a898:	a90d      	add	r1, sp, #52	; 0x34
 802a89a:	2008      	movs	r0, #8
 802a89c:	f002 ffc0 	bl	802d820 <LoRaMacCommandsAddCmd>
                SetMlmeScheduleUplinkIndication( );
 802a8a0:	f7ff fbe0 	bl	802a064 <SetMlmeScheduleUplinkIndication>
                break;
 802a8a4:	e697      	b.n	802a5d6 <ProcessMacCommands+0x26>
                uint8_t eirpDwellTime = payload[macIndex++];
 802a8a6:	3402      	adds	r4, #2
 802a8a8:	b2e4      	uxtb	r4, r4
 802a8aa:	5daa      	ldrb	r2, [r5, r6]
                txParamSetupReq.UplinkDwellTime = 0;
 802a8ac:	ab05      	add	r3, sp, #20
 802a8ae:	2100      	movs	r1, #0
 802a8b0:	7019      	strb	r1, [r3, #0]
                txParamSetupReq.DownlinkDwellTime = 0;
 802a8b2:	7059      	strb	r1, [r3, #1]
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 802a8b4:	0693      	lsls	r3, r2, #26
 802a8b6:	d502      	bpl.n	802a8be <ProcessMacCommands+0x30e>
                    txParamSetupReq.DownlinkDwellTime = 1;
 802a8b8:	ab05      	add	r3, sp, #20
 802a8ba:	3101      	adds	r1, #1
 802a8bc:	7059      	strb	r1, [r3, #1]
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 802a8be:	06d3      	lsls	r3, r2, #27
 802a8c0:	d502      	bpl.n	802a8c8 <ProcessMacCommands+0x318>
                    txParamSetupReq.UplinkDwellTime = 1;
 802a8c2:	ab05      	add	r3, sp, #20
 802a8c4:	2101      	movs	r1, #1
 802a8c6:	7019      	strb	r1, [r3, #0]
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 802a8c8:	230f      	movs	r3, #15
 802a8ca:	4013      	ands	r3, r2
 802a8cc:	a905      	add	r1, sp, #20
 802a8ce:	708b      	strb	r3, [r1, #2]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 802a8d0:	4a32      	ldr	r2, [pc, #200]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a8d2:	2340      	movs	r3, #64	; 0x40
 802a8d4:	5cd0      	ldrb	r0, [r2, r3]
 802a8d6:	f003 ffd7 	bl	802e888 <RegionTxParamSetupReq>
 802a8da:	1c43      	adds	r3, r0, #1
 802a8dc:	d100      	bne.n	802a8e0 <ProcessMacCommands+0x330>
 802a8de:	e67a      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 802a8e0:	ab05      	add	r3, sp, #20
 802a8e2:	781f      	ldrb	r7, [r3, #0]
 802a8e4:	4e2d      	ldr	r6, [pc, #180]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a8e6:	2274      	movs	r2, #116	; 0x74
 802a8e8:	54b7      	strb	r7, [r6, r2]
                    Nvm.MacGroup2.MacParams.DownlinkDwellTime = txParamSetupReq.DownlinkDwellTime;
 802a8ea:	7859      	ldrb	r1, [r3, #1]
 802a8ec:	3201      	adds	r2, #1
 802a8ee:	54b1      	strb	r1, [r6, r2]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 802a8f0:	789b      	ldrb	r3, [r3, #2]
 802a8f2:	4a2b      	ldr	r2, [pc, #172]	; (802a9a0 <ProcessMacCommands+0x3f0>)
 802a8f4:	5cd0      	ldrb	r0, [r2, r3]
 802a8f6:	f7f6 f89f 	bl	8020a38 <__aeabi_ui2f>
 802a8fa:	67b0      	str	r0, [r6, #120]	; 0x78
                    getPhy.Attribute = PHY_MIN_TX_DR;
 802a8fc:	2302      	movs	r3, #2
 802a8fe:	aa02      	add	r2, sp, #8
 802a900:	7713      	strb	r3, [r2, #28]
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802a902:	7797      	strb	r7, [r2, #30]
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802a904:	2340      	movs	r3, #64	; 0x40
 802a906:	5cf0      	ldrb	r0, [r6, r3]
 802a908:	a909      	add	r1, sp, #36	; 0x24
 802a90a:	f003 fef3 	bl	802e6f4 <RegionGetPhyParam>
 802a90e:	9007      	str	r0, [sp, #28]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 802a910:	b240      	sxtb	r0, r0
 802a912:	2339      	movs	r3, #57	; 0x39
 802a914:	56f2      	ldrsb	r2, [r6, r3]
 802a916:	1c03      	adds	r3, r0, #0
 802a918:	4290      	cmp	r0, r2
 802a91a:	da00      	bge.n	802a91e <ProcessMacCommands+0x36e>
 802a91c:	1c13      	adds	r3, r2, #0
 802a91e:	491f      	ldr	r1, [pc, #124]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a920:	2239      	movs	r2, #57	; 0x39
 802a922:	548b      	strb	r3, [r1, r2]
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 802a924:	2200      	movs	r2, #0
 802a926:	a90d      	add	r1, sp, #52	; 0x34
 802a928:	2009      	movs	r0, #9
 802a92a:	f002 ff79 	bl	802d820 <LoRaMacCommandsAddCmd>
                break;
 802a92e:	e652      	b.n	802a5d6 <ProcessMacCommands+0x26>
                status = 0x03;
 802a930:	272f      	movs	r7, #47	; 0x2f
 802a932:	ab02      	add	r3, sp, #8
 802a934:	469c      	mov	ip, r3
 802a936:	4467      	add	r7, ip
 802a938:	2303      	movs	r3, #3
 802a93a:	703b      	strb	r3, [r7, #0]
                dlChannelReq.ChannelId = payload[macIndex++];
 802a93c:	1ca3      	adds	r3, r4, #2
 802a93e:	b2db      	uxtb	r3, r3
 802a940:	5daa      	ldrb	r2, [r5, r6]
 802a942:	a909      	add	r1, sp, #36	; 0x24
 802a944:	700a      	strb	r2, [r1, #0]
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 802a946:	1ce2      	adds	r2, r4, #3
 802a948:	b2d2      	uxtb	r2, r2
 802a94a:	5ceb      	ldrb	r3, [r5, r3]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 802a94c:	1d20      	adds	r0, r4, #4
 802a94e:	b2c0      	uxtb	r0, r0
 802a950:	5caa      	ldrb	r2, [r5, r2]
 802a952:	0212      	lsls	r2, r2, #8
 802a954:	4313      	orrs	r3, r2
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 802a956:	3405      	adds	r4, #5
 802a958:	b2e4      	uxtb	r4, r4
 802a95a:	5c2a      	ldrb	r2, [r5, r0]
 802a95c:	0412      	lsls	r2, r2, #16
 802a95e:	4313      	orrs	r3, r2
                dlChannelReq.Rx1Frequency *= 100;
 802a960:	2264      	movs	r2, #100	; 0x64
 802a962:	4353      	muls	r3, r2
 802a964:	604b      	str	r3, [r1, #4]
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 802a966:	4a0d      	ldr	r2, [pc, #52]	; (802a99c <ProcessMacCommands+0x3ec>)
 802a968:	2340      	movs	r3, #64	; 0x40
 802a96a:	5cd0      	ldrb	r0, [r2, r3]
 802a96c:	f003 ff9b 	bl	802e8a6 <RegionDlChannelReq>
 802a970:	b2c3      	uxtb	r3, r0
 802a972:	703b      	strb	r3, [r7, #0]
                if( ( int8_t )status >= 0 )
 802a974:	2800      	cmp	r0, #0
 802a976:	da00      	bge.n	802a97a <ProcessMacCommands+0x3ca>
 802a978:	e62d      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    macCmdPayload[0] = status;
 802a97a:	a90d      	add	r1, sp, #52	; 0x34
 802a97c:	700b      	strb	r3, [r1, #0]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 802a97e:	2201      	movs	r2, #1
 802a980:	200a      	movs	r0, #10
 802a982:	f002 ff4d 	bl	802d820 <LoRaMacCommandsAddCmd>
                    SetMlmeScheduleUplinkIndication( );
 802a986:	f7ff fb6d 	bl	802a064 <SetMlmeScheduleUplinkIndication>
                break;
 802a98a:	e624      	b.n	802a5d6 <ProcessMacCommands+0x26>
 802a98c:	08034e90 	.word	0x08034e90
 802a990:	2000a534 	.word	0x2000a534
 802a994:	00000454 	.word	0x00000454
 802a998:	00000455 	.word	0x00000455
 802a99c:	2000aa3c 	.word	0x2000aa3c
 802a9a0:	080350a0 	.word	0x080350a0
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 802a9a4:	200a      	movs	r0, #10
 802a9a6:	f003 f909 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802a9aa:	2800      	cmp	r0, #0
 802a9ac:	d101      	bne.n	802a9b2 <ProcessMacCommands+0x402>
        switch( payload[macIndex++] )
 802a9ae:	0034      	movs	r4, r6
 802a9b0:	e611      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 802a9b2:	210a      	movs	r1, #10
 802a9b4:	2000      	movs	r0, #0
 802a9b6:	f003 f8b1 	bl	802db1c <LoRaMacConfirmQueueSetStatus>
                    SysTime_t gpsEpochTime = { 0 };
 802a9ba:	af05      	add	r7, sp, #20
 802a9bc:	2300      	movs	r3, #0
 802a9be:	80fb      	strh	r3, [r7, #6]
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 802a9c0:	1ca2      	adds	r2, r4, #2
 802a9c2:	b2d2      	uxtb	r2, r2
 802a9c4:	5da8      	ldrb	r0, [r5, r6]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 802a9c6:	1ce3      	adds	r3, r4, #3
 802a9c8:	b2db      	uxtb	r3, r3
 802a9ca:	5caa      	ldrb	r2, [r5, r2]
 802a9cc:	0212      	lsls	r2, r2, #8
 802a9ce:	4310      	orrs	r0, r2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 802a9d0:	1d22      	adds	r2, r4, #4
 802a9d2:	b2d2      	uxtb	r2, r2
 802a9d4:	5ceb      	ldrb	r3, [r5, r3]
 802a9d6:	041b      	lsls	r3, r3, #16
 802a9d8:	4318      	orrs	r0, r3
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 802a9da:	1d63      	adds	r3, r4, #5
 802a9dc:	b2db      	uxtb	r3, r3
 802a9de:	5caa      	ldrb	r2, [r5, r2]
 802a9e0:	0612      	lsls	r2, r2, #24
 802a9e2:	4310      	orrs	r0, r2
 802a9e4:	9005      	str	r0, [sp, #20]
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 802a9e6:	3406      	adds	r4, #6
 802a9e8:	b2e4      	uxtb	r4, r4
 802a9ea:	5ce9      	ldrb	r1, [r5, r3]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 802a9ec:	014b      	lsls	r3, r1, #5
 802a9ee:	1a5b      	subs	r3, r3, r1
 802a9f0:	009b      	lsls	r3, r3, #2
 802a9f2:	185b      	adds	r3, r3, r1
 802a9f4:	115b      	asrs	r3, r3, #5
 802a9f6:	80bb      	strh	r3, [r7, #4]
                    sysTime = gpsEpochTime;
 802a9f8:	ae07      	add	r6, sp, #28
 802a9fa:	0033      	movs	r3, r6
 802a9fc:	cf06      	ldmia	r7!, {r1, r2}
 802a9fe:	c306      	stmia	r3!, {r1, r2}
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 802aa00:	4b4e      	ldr	r3, [pc, #312]	; (802ab3c <ProcessMacCommands+0x58c>)
 802aa02:	469c      	mov	ip, r3
 802aa04:	4460      	add	r0, ip
 802aa06:	9007      	str	r0, [sp, #28]
                    sysTimeCurrent = SysTimeGet( );
 802aa08:	a809      	add	r0, sp, #36	; 0x24
 802aa0a:	f009 fad5 	bl	8033fb8 <SysTimeGet>
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 802aa0e:	4f4c      	ldr	r7, [pc, #304]	; (802ab40 <ProcessMacCommands+0x590>)
 802aa10:	23cf      	movs	r3, #207	; 0xcf
 802aa12:	009b      	lsls	r3, r3, #2
 802aa14:	18fb      	adds	r3, r7, r3
 802aa16:	681b      	ldr	r3, [r3, #0]
 802aa18:	9300      	str	r3, [sp, #0]
 802aa1a:	23ce      	movs	r3, #206	; 0xce
 802aa1c:	009b      	lsls	r3, r3, #2
 802aa1e:	58fb      	ldr	r3, [r7, r3]
 802aa20:	9907      	ldr	r1, [sp, #28]
 802aa22:	6872      	ldr	r2, [r6, #4]
 802aa24:	a80e      	add	r0, sp, #56	; 0x38
 802aa26:	f009 fa8b 	bl	8033f40 <SysTimeSub>
 802aa2a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802aa2c:	9300      	str	r3, [sp, #0]
 802aa2e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802aa30:	9909      	ldr	r1, [sp, #36]	; 0x24
 802aa32:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802aa34:	0030      	movs	r0, r6
 802aa36:	f009 fa65 	bl	8033f04 <SysTimeAdd>
                    SysTimeSet( sysTime );
 802aa3a:	9807      	ldr	r0, [sp, #28]
 802aa3c:	6871      	ldr	r1, [r6, #4]
 802aa3e:	f009 fa99 	bl	8033f74 <SysTimeSet>
                    LoRaMacClassBDeviceTimeAns( );
 802aa42:	f002 fe4a 	bl	802d6da <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 802aa46:	4b3f      	ldr	r3, [pc, #252]	; (802ab44 <ProcessMacCommands+0x594>)
 802aa48:	2201      	movs	r2, #1
 802aa4a:	54fa      	strb	r2, [r7, r3]
 802aa4c:	e5c3      	b.n	802a5d6 <ProcessMacCommands+0x26>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 802aa4e:	200d      	movs	r0, #13
 802aa50:	f003 f8b4 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802aa54:	2800      	cmp	r0, #0
 802aa56:	d101      	bne.n	802aa5c <ProcessMacCommands+0x4ac>
        switch( payload[macIndex++] )
 802aa58:	0034      	movs	r4, r6
 802aa5a:	e5bc      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 802aa5c:	210d      	movs	r1, #13
 802aa5e:	2000      	movs	r0, #0
 802aa60:	f003 f85c 	bl	802db1c <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 802aa64:	4a36      	ldr	r2, [pc, #216]	; (802ab40 <ProcessMacCommands+0x590>)
 802aa66:	2390      	movs	r3, #144	; 0x90
 802aa68:	00db      	lsls	r3, r3, #3
 802aa6a:	5cd3      	ldrb	r3, [r2, r3]
 802aa6c:	3b04      	subs	r3, #4
 802aa6e:	b2db      	uxtb	r3, r3
 802aa70:	2b01      	cmp	r3, #1
 802aa72:	d801      	bhi.n	802aa78 <ProcessMacCommands+0x4c8>
        switch( payload[macIndex++] )
 802aa74:	0034      	movs	r4, r6
 802aa76:	e5ae      	b.n	802a5d6 <ProcessMacCommands+0x26>
                        LoRaMacClassBPingSlotInfoAns( );
 802aa78:	f002 fe2b 	bl	802d6d2 <LoRaMacClassBPingSlotInfoAns>
        switch( payload[macIndex++] )
 802aa7c:	0034      	movs	r4, r6
 802aa7e:	e5aa      	b.n	802a5d6 <ProcessMacCommands+0x26>
                frequency = ( uint32_t )payload[macIndex++];
 802aa80:	1ca2      	adds	r2, r4, #2
 802aa82:	b2d2      	uxtb	r2, r2
 802aa84:	5da9      	ldrb	r1, [r5, r6]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 802aa86:	1ce3      	adds	r3, r4, #3
 802aa88:	b2db      	uxtb	r3, r3
 802aa8a:	5caa      	ldrb	r2, [r5, r2]
 802aa8c:	0212      	lsls	r2, r2, #8
 802aa8e:	4311      	orrs	r1, r2
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 802aa90:	1d22      	adds	r2, r4, #4
 802aa92:	b2d2      	uxtb	r2, r2
 802aa94:	5ceb      	ldrb	r3, [r5, r3]
 802aa96:	041b      	lsls	r3, r3, #16
 802aa98:	4319      	orrs	r1, r3
                frequency *= 100;
 802aa9a:	2364      	movs	r3, #100	; 0x64
 802aa9c:	4359      	muls	r1, r3
                datarate = payload[macIndex++] & 0x0F;
 802aa9e:	3405      	adds	r4, #5
 802aaa0:	b2e4      	uxtb	r4, r4
 802aaa2:	5cab      	ldrb	r3, [r5, r2]
 802aaa4:	200f      	movs	r0, #15
 802aaa6:	4018      	ands	r0, r3
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 802aaa8:	f002 fe14 	bl	802d6d4 <LoRaMacClassBPingSlotChannelReq>
                macCmdPayload[0] = status;
 802aaac:	a90d      	add	r1, sp, #52	; 0x34
 802aaae:	7008      	strb	r0, [r1, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 802aab0:	2201      	movs	r2, #1
 802aab2:	2011      	movs	r0, #17
 802aab4:	f002 feb4 	bl	802d820 <LoRaMacCommandsAddCmd>
                break;
 802aab8:	e58d      	b.n	802a5d6 <ProcessMacCommands+0x26>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 802aaba:	200e      	movs	r0, #14
 802aabc:	f003 f87e 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802aac0:	2800      	cmp	r0, #0
 802aac2:	d101      	bne.n	802aac8 <ProcessMacCommands+0x518>
        switch( payload[macIndex++] )
 802aac4:	0034      	movs	r4, r6
 802aac6:	e586      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 802aac8:	210e      	movs	r1, #14
 802aaca:	2000      	movs	r0, #0
 802aacc:	f003 f826 	bl	802db1c <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 802aad0:	1ca2      	adds	r2, r4, #2
 802aad2:	b2d2      	uxtb	r2, r2
 802aad4:	5da9      	ldrb	r1, [r5, r6]
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 802aad6:	1ce3      	adds	r3, r4, #3
 802aad8:	b2db      	uxtb	r3, r3
 802aada:	5ca8      	ldrb	r0, [r5, r2]
 802aadc:	0200      	lsls	r0, r0, #8
 802aade:	4308      	orrs	r0, r1
                    beaconTimingChannel = payload[macIndex++];
 802aae0:	3404      	adds	r4, #4
 802aae2:	b2e4      	uxtb	r4, r4
 802aae4:	5ce9      	ldrb	r1, [r5, r3]
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 802aae6:	4b18      	ldr	r3, [pc, #96]	; (802ab48 <ProcessMacCommands+0x598>)
 802aae8:	681a      	ldr	r2, [r3, #0]
 802aaea:	f002 fdf5 	bl	802d6d8 <LoRaMacClassBBeaconTimingAns>
 802aaee:	e572      	b.n	802a5d6 <ProcessMacCommands+0x26>
                    frequency = ( uint32_t )payload[macIndex++];
 802aaf0:	1ca2      	adds	r2, r4, #2
 802aaf2:	b2d2      	uxtb	r2, r2
 802aaf4:	5da8      	ldrb	r0, [r5, r6]
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 802aaf6:	1ce3      	adds	r3, r4, #3
 802aaf8:	b2db      	uxtb	r3, r3
 802aafa:	5caa      	ldrb	r2, [r5, r2]
 802aafc:	0212      	lsls	r2, r2, #8
 802aafe:	4310      	orrs	r0, r2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 802ab00:	3404      	adds	r4, #4
 802ab02:	b2e4      	uxtb	r4, r4
 802ab04:	5ceb      	ldrb	r3, [r5, r3]
 802ab06:	041b      	lsls	r3, r3, #16
 802ab08:	4318      	orrs	r0, r3
                    frequency *= 100;
 802ab0a:	2364      	movs	r3, #100	; 0x64
 802ab0c:	4358      	muls	r0, r3
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 802ab0e:	f002 fde5 	bl	802d6dc <LoRaMacClassBBeaconFreqReq>
 802ab12:	2800      	cmp	r0, #0
 802ab14:	d008      	beq.n	802ab28 <ProcessMacCommands+0x578>
                        macCmdPayload[0] = 1;
 802ab16:	ab0d      	add	r3, sp, #52	; 0x34
 802ab18:	2201      	movs	r2, #1
 802ab1a:	701a      	strb	r2, [r3, #0]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 802ab1c:	2201      	movs	r2, #1
 802ab1e:	a90d      	add	r1, sp, #52	; 0x34
 802ab20:	2013      	movs	r0, #19
 802ab22:	f002 fe7d 	bl	802d820 <LoRaMacCommandsAddCmd>
                break;
 802ab26:	e556      	b.n	802a5d6 <ProcessMacCommands+0x26>
                        macCmdPayload[0] = 0;
 802ab28:	ab0d      	add	r3, sp, #52	; 0x34
 802ab2a:	2200      	movs	r2, #0
 802ab2c:	701a      	strb	r2, [r3, #0]
 802ab2e:	e7f5      	b.n	802ab1c <ProcessMacCommands+0x56c>
}
 802ab30:	b010      	add	sp, #64	; 0x40
 802ab32:	bce0      	pop	{r5, r6, r7}
 802ab34:	46ba      	mov	sl, r7
 802ab36:	46b1      	mov	r9, r6
 802ab38:	46a8      	mov	r8, r5
 802ab3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ab3c:	12d53d80 	.word	0x12d53d80
 802ab40:	2000a534 	.word	0x2000a534
 802ab44:	00000434 	.word	0x00000434
 802ab48:	2000bcfc 	.word	0x2000bcfc

0802ab4c <ProcessRadioRxDone>:
{
 802ab4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ab4e:	46ce      	mov	lr, r9
 802ab50:	4647      	mov	r7, r8
 802ab52:	b580      	push	{r7, lr}
 802ab54:	b0a5      	sub	sp, #148	; 0x94
    uint8_t *payload = RxDoneParams.Payload;
 802ab56:	4baa      	ldr	r3, [pc, #680]	; (802ae00 <ProcessRadioRxDone+0x2b4>)
 802ab58:	685e      	ldr	r6, [r3, #4]
    uint16_t size = RxDoneParams.Size;
 802ab5a:	891d      	ldrh	r5, [r3, #8]
    int16_t rssi = RxDoneParams.Rssi;
 802ab5c:	210a      	movs	r1, #10
 802ab5e:	5e5a      	ldrsh	r2, [r3, r1]
 802ab60:	4690      	mov	r8, r2
    int8_t snr = RxDoneParams.Snr;
 802ab62:	270c      	movs	r7, #12
 802ab64:	57df      	ldrsb	r7, [r3, r7]
    uint32_t downLinkCounter = 0;
 802ab66:	2300      	movs	r3, #0
 802ab68:	9308      	str	r3, [sp, #32]
    uint32_t address = Nvm.MacGroup2.DevAddr;
 802ab6a:	49a6      	ldr	r1, [pc, #664]	; (802ae04 <ProcessRadioRxDone+0x2b8>)
 802ab6c:	22cc      	movs	r2, #204	; 0xcc
 802ab6e:	588a      	ldr	r2, [r1, r2]
 802ab70:	4691      	mov	r9, r2
    MacCtx.McpsConfirm.AckReceived = false;
 802ab72:	4ca5      	ldr	r4, [pc, #660]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802ab74:	4aa5      	ldr	r2, [pc, #660]	; (802ae0c <ProcessRadioRxDone+0x2c0>)
 802ab76:	54a3      	strb	r3, [r4, r2]
    MacCtx.RxStatus.Rssi = rssi;
 802ab78:	4aa5      	ldr	r2, [pc, #660]	; (802ae10 <ProcessRadioRxDone+0x2c4>)
 802ab7a:	4641      	mov	r1, r8
 802ab7c:	52a1      	strh	r1, [r4, r2]
    MacCtx.RxStatus.Snr = snr;
 802ab7e:	4aa5      	ldr	r2, [pc, #660]	; (802ae14 <ProcessRadioRxDone+0x2c8>)
 802ab80:	54a7      	strb	r7, [r4, r2]
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 802ab82:	3202      	adds	r2, #2
 802ab84:	5ca1      	ldrb	r1, [r4, r2]
 802ab86:	4aa4      	ldr	r2, [pc, #656]	; (802ae18 <ProcessRadioRxDone+0x2cc>)
 802ab88:	54a1      	strb	r1, [r4, r2]
    MacCtx.McpsIndication.Port = 0;
 802ab8a:	4aa4      	ldr	r2, [pc, #656]	; (802ae1c <ProcessRadioRxDone+0x2d0>)
 802ab8c:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.Multicast = 0;
 802ab8e:	4aa4      	ldr	r2, [pc, #656]	; (802ae20 <ProcessRadioRxDone+0x2d4>)
 802ab90:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.FramePending = 0;
 802ab92:	4aa4      	ldr	r2, [pc, #656]	; (802ae24 <ProcessRadioRxDone+0x2d8>)
 802ab94:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.Buffer = NULL;
 802ab96:	4aa4      	ldr	r2, [pc, #656]	; (802ae28 <ProcessRadioRxDone+0x2dc>)
 802ab98:	50a3      	str	r3, [r4, r2]
    MacCtx.McpsIndication.BufferSize = 0;
 802ab9a:	3204      	adds	r2, #4
 802ab9c:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.RxData = false;
 802ab9e:	4aa3      	ldr	r2, [pc, #652]	; (802ae2c <ProcessRadioRxDone+0x2e0>)
 802aba0:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.AckReceived = false;
 802aba2:	4aa3      	ldr	r2, [pc, #652]	; (802ae30 <ProcessRadioRxDone+0x2e4>)
 802aba4:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.DownLinkCounter = 0;
 802aba6:	4aa3      	ldr	r2, [pc, #652]	; (802ae34 <ProcessRadioRxDone+0x2e8>)
 802aba8:	50a3      	str	r3, [r4, r2]
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 802abaa:	4aa3      	ldr	r2, [pc, #652]	; (802ae38 <ProcessRadioRxDone+0x2ec>)
 802abac:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.DevAddress = 0;
 802abae:	3214      	adds	r2, #20
 802abb0:	50a3      	str	r3, [r4, r2]
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 802abb2:	4aa2      	ldr	r2, [pc, #648]	; (802ae3c <ProcessRadioRxDone+0x2f0>)
 802abb4:	54a3      	strb	r3, [r4, r2]
    Radio.Sleep( );
 802abb6:	4ba2      	ldr	r3, [pc, #648]	; (802ae40 <ProcessRadioRxDone+0x2f4>)
 802abb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802abba:	4798      	blx	r3
    TimerStop( &MacCtx.RxWindowTimer2 );
 802abbc:	23e6      	movs	r3, #230	; 0xe6
 802abbe:	009b      	lsls	r3, r3, #2
 802abc0:	18e0      	adds	r0, r4, r3
 802abc2:	f009 fae1 	bl	8034188 <UTIL_TIMER_Stop>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 802abc6:	0029      	movs	r1, r5
 802abc8:	0030      	movs	r0, r6
 802abca:	f002 fd6f 	bl	802d6ac <LoRaMacClassBRxBeacon>
 802abce:	2800      	cmp	r0, #0
 802abd0:	d140      	bne.n	802ac54 <ProcessRadioRxDone+0x108>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802abd2:	4a8c      	ldr	r2, [pc, #560]	; (802ae04 <ProcessRadioRxDone+0x2b8>)
 802abd4:	23fc      	movs	r3, #252	; 0xfc
 802abd6:	5cd3      	ldrb	r3, [r2, r3]
 802abd8:	2b01      	cmp	r3, #1
 802abda:	d042      	beq.n	802ac62 <ProcessRadioRxDone+0x116>
    macHdr.Value = payload[pktHeaderLen++];
 802abdc:	7834      	ldrb	r4, [r6, #0]
    switch( macHdr.Bits.MType )
 802abde:	0963      	lsrs	r3, r4, #5
 802abe0:	2b05      	cmp	r3, #5
 802abe2:	d100      	bne.n	802abe6 <ProcessRadioRxDone+0x9a>
 802abe4:	e105      	b.n	802adf2 <ProcessRadioRxDone+0x2a6>
 802abe6:	d85a      	bhi.n	802ac9e <ProcessRadioRxDone+0x152>
 802abe8:	2b01      	cmp	r3, #1
 802abea:	d100      	bne.n	802abee <ProcessRadioRxDone+0xa2>
 802abec:	e082      	b.n	802acf4 <ProcessRadioRxDone+0x1a8>
 802abee:	2b03      	cmp	r3, #3
 802abf0:	d000      	beq.n	802abf4 <ProcessRadioRxDone+0xa8>
 802abf2:	e2ce      	b.n	802b192 <ProcessRadioRxDone+0x646>
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802abf4:	4a83      	ldr	r2, [pc, #524]	; (802ae04 <ProcessRadioRxDone+0x2b8>)
 802abf6:	2375      	movs	r3, #117	; 0x75
 802abf8:	5cd1      	ldrb	r1, [r2, r3]
 802abfa:	ab20      	add	r3, sp, #128	; 0x80
 802abfc:	7099      	strb	r1, [r3, #2]
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 802abfe:	4882      	ldr	r0, [pc, #520]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802ac00:	2184      	movs	r1, #132	; 0x84
 802ac02:	00c9      	lsls	r1, r1, #3
 802ac04:	5641      	ldrsb	r1, [r0, r1]
 802ac06:	7059      	strb	r1, [r3, #1]
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 802ac08:	210d      	movs	r1, #13
 802ac0a:	7019      	strb	r1, [r3, #0]
            if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 802ac0c:	2380      	movs	r3, #128	; 0x80
 802ac0e:	5cd3      	ldrb	r3, [r2, r3]
 802ac10:	2b00      	cmp	r3, #0
 802ac12:	d002      	beq.n	802ac1a <ProcessRadioRxDone+0xce>
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 802ac14:	ab20      	add	r3, sp, #128	; 0x80
 802ac16:	220e      	movs	r2, #14
 802ac18:	701a      	strb	r2, [r3, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ac1a:	4a7a      	ldr	r2, [pc, #488]	; (802ae04 <ProcessRadioRxDone+0x2b8>)
 802ac1c:	2340      	movs	r3, #64	; 0x40
 802ac1e:	5cd0      	ldrb	r0, [r2, r3]
 802ac20:	a920      	add	r1, sp, #128	; 0x80
 802ac22:	f003 fd67 	bl	802e6f4 <RegionGetPhyParam>
 802ac26:	901f      	str	r0, [sp, #124]	; 0x7c
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 802ac28:	002b      	movs	r3, r5
 802ac2a:	3b0d      	subs	r3, #13
 802ac2c:	b21b      	sxth	r3, r3
 802ac2e:	1c1a      	adds	r2, r3, #0
 802ac30:	2b00      	cmp	r3, #0
 802ac32:	da00      	bge.n	802ac36 <ProcessRadioRxDone+0xea>
 802ac34:	e0e2      	b.n	802adfc <ProcessRadioRxDone+0x2b0>
 802ac36:	b212      	sxth	r2, r2
 802ac38:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 802ac3a:	b21b      	sxth	r3, r3
 802ac3c:	429a      	cmp	r2, r3
 802ac3e:	dc02      	bgt.n	802ac46 <ProcessRadioRxDone+0xfa>
 802ac40:	2d0b      	cmp	r5, #11
 802ac42:	d900      	bls.n	802ac46 <ProcessRadioRxDone+0xfa>
 802ac44:	e10c      	b.n	802ae60 <ProcessRadioRxDone+0x314>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802ac46:	4a70      	ldr	r2, [pc, #448]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802ac48:	4b7e      	ldr	r3, [pc, #504]	; (802ae44 <ProcessRadioRxDone+0x2f8>)
 802ac4a:	2101      	movs	r1, #1
 802ac4c:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802ac4e:	f7ff fc27 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802ac52:	e2d2      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 802ac54:	4b6c      	ldr	r3, [pc, #432]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802ac56:	4a7c      	ldr	r2, [pc, #496]	; (802ae48 <ProcessRadioRxDone+0x2fc>)
 802ac58:	4641      	mov	r1, r8
 802ac5a:	5299      	strh	r1, [r3, r2]
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 802ac5c:	4a7b      	ldr	r2, [pc, #492]	; (802ae4c <ProcessRadioRxDone+0x300>)
 802ac5e:	549f      	strb	r7, [r3, r2]
        return;
 802ac60:	e2cb      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
        if( LoRaMacClassBIsPingExpected( ) == true )
 802ac62:	f002 fd27 	bl	802d6b4 <LoRaMacClassBIsPingExpected>
 802ac66:	2800      	cmp	r0, #0
 802ac68:	d00a      	beq.n	802ac80 <ProcessRadioRxDone+0x134>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802ac6a:	2000      	movs	r0, #0
 802ac6c:	f002 fd17 	bl	802d69e <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 802ac70:	2000      	movs	r0, #0
 802ac72:	f002 fd19 	bl	802d6a8 <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 802ac76:	4a64      	ldr	r2, [pc, #400]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802ac78:	4b67      	ldr	r3, [pc, #412]	; (802ae18 <ProcessRadioRxDone+0x2cc>)
 802ac7a:	2104      	movs	r1, #4
 802ac7c:	54d1      	strb	r1, [r2, r3]
 802ac7e:	e7ad      	b.n	802abdc <ProcessRadioRxDone+0x90>
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 802ac80:	f002 fd1a 	bl	802d6b8 <LoRaMacClassBIsMulticastExpected>
 802ac84:	2800      	cmp	r0, #0
 802ac86:	d0a9      	beq.n	802abdc <ProcessRadioRxDone+0x90>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802ac88:	2000      	movs	r0, #0
 802ac8a:	f002 fd09 	bl	802d6a0 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 802ac8e:	2000      	movs	r0, #0
 802ac90:	f002 fd0b 	bl	802d6aa <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 802ac94:	4a5c      	ldr	r2, [pc, #368]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802ac96:	4b60      	ldr	r3, [pc, #384]	; (802ae18 <ProcessRadioRxDone+0x2cc>)
 802ac98:	2105      	movs	r1, #5
 802ac9a:	54d1      	strb	r1, [r2, r3]
 802ac9c:	e79e      	b.n	802abdc <ProcessRadioRxDone+0x90>
    switch( macHdr.Bits.MType )
 802ac9e:	2b07      	cmp	r3, #7
 802aca0:	d000      	beq.n	802aca4 <ProcessRadioRxDone+0x158>
 802aca2:	e276      	b.n	802b192 <ProcessRadioRxDone+0x646>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 802aca4:	1c71      	adds	r1, r6, #1
 802aca6:	1e6a      	subs	r2, r5, #1
 802aca8:	b292      	uxth	r2, r2
 802acaa:	4c69      	ldr	r4, [pc, #420]	; (802ae50 <ProcessRadioRxDone+0x304>)
 802acac:	0020      	movs	r0, r4
 802acae:	f006 fd74 	bl	803179a <memcpy1>
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 802acb2:	4b68      	ldr	r3, [pc, #416]	; (802ae54 <ProcessRadioRxDone+0x308>)
 802acb4:	18e3      	adds	r3, r4, r3
 802acb6:	4a60      	ldr	r2, [pc, #384]	; (802ae38 <ProcessRadioRxDone+0x2ec>)
 802acb8:	2103      	movs	r1, #3
 802acba:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802acbc:	4a61      	ldr	r2, [pc, #388]	; (802ae44 <ProcessRadioRxDone+0x2f8>)
 802acbe:	2100      	movs	r1, #0
 802acc0:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 802acc2:	4a59      	ldr	r2, [pc, #356]	; (802ae28 <ProcessRadioRxDone+0x2dc>)
 802acc4:	509c      	str	r4, [r3, r2]
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 802acc6:	3d01      	subs	r5, #1
 802acc8:	3204      	adds	r2, #4
 802acca:	549d      	strb	r5, [r3, r2]
            MacCtx.MacFlags.Bits.McpsInd = 1;
 802accc:	4962      	ldr	r1, [pc, #392]	; (802ae58 <ProcessRadioRxDone+0x30c>)
 802acce:	5c5a      	ldrb	r2, [r3, r1]
 802acd0:	2002      	movs	r0, #2
 802acd2:	4302      	orrs	r2, r0
 802acd4:	545a      	strb	r2, [r3, r1]
    if( MacCtx.NodeAckRequested == true )
 802acd6:	4a4c      	ldr	r2, [pc, #304]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802acd8:	4b60      	ldr	r3, [pc, #384]	; (802ae5c <ProcessRadioRxDone+0x310>)
 802acda:	5cd3      	ldrb	r3, [r2, r3]
 802acdc:	2b00      	cmp	r3, #0
 802acde:	d100      	bne.n	802ace2 <ProcessRadioRxDone+0x196>
 802ace0:	e27e      	b.n	802b1e0 <ProcessRadioRxDone+0x694>
        if( MacCtx.McpsConfirm.AckReceived == true )
 802ace2:	4b4a      	ldr	r3, [pc, #296]	; (802ae0c <ProcessRadioRxDone+0x2c0>)
 802ace4:	5cd3      	ldrb	r3, [r2, r3]
 802ace6:	2b00      	cmp	r3, #0
 802ace8:	d100      	bne.n	802acec <ProcessRadioRxDone+0x1a0>
 802acea:	e27e      	b.n	802b1ea <ProcessRadioRxDone+0x69e>
            OnAckTimeoutTimerEvent( NULL );
 802acec:	2000      	movs	r0, #0
 802acee:	f7ff fba1 	bl	802a434 <OnAckTimeoutTimerEvent>
 802acf2:	e27a      	b.n	802b1ea <ProcessRadioRxDone+0x69e>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 802acf4:	2d10      	cmp	r5, #16
 802acf6:	d95f      	bls.n	802adb8 <ProcessRadioRxDone+0x26c>
            macMsgJoinAccept.Buffer = payload;
 802acf8:	9609      	str	r6, [sp, #36]	; 0x24
            macMsgJoinAccept.BufSize = size;
 802acfa:	b2ed      	uxtb	r5, r5
 802acfc:	ab09      	add	r3, sp, #36	; 0x24
 802acfe:	711d      	strb	r5, [r3, #4]
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 802ad00:	4a40      	ldr	r2, [pc, #256]	; (802ae04 <ProcessRadioRxDone+0x2b8>)
 802ad02:	2388      	movs	r3, #136	; 0x88
 802ad04:	005b      	lsls	r3, r3, #1
 802ad06:	5cd3      	ldrb	r3, [r2, r3]
 802ad08:	2b00      	cmp	r3, #0
 802ad0a:	d15c      	bne.n	802adc6 <ProcessRadioRxDone+0x27a>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
 802ad0c:	f006 fd18 	bl	8031740 <SecureElementGetJoinEui>
 802ad10:	0001      	movs	r1, r0
 802ad12:	aa09      	add	r2, sp, #36	; 0x24
 802ad14:	20ff      	movs	r0, #255	; 0xff
 802ad16:	f003 fb0f 	bl	802e338 <LoRaMacCryptoHandleJoinAccept>
            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )
 802ad1a:	2800      	cmp	r0, #0
 802ad1c:	d15f      	bne.n	802adde <ProcessRadioRxDone+0x292>
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 802ad1e:	a909      	add	r1, sp, #36	; 0x24
 802ad20:	7a4b      	ldrb	r3, [r1, #9]
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 802ad22:	7a8a      	ldrb	r2, [r1, #10]
 802ad24:	0212      	lsls	r2, r2, #8
 802ad26:	4313      	orrs	r3, r2
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 802ad28:	7ac8      	ldrb	r0, [r1, #11]
 802ad2a:	0400      	lsls	r0, r0, #16
 802ad2c:	4a35      	ldr	r2, [pc, #212]	; (802ae04 <ProcessRadioRxDone+0x2b8>)
 802ad2e:	4303      	orrs	r3, r0
 802ad30:	20c8      	movs	r0, #200	; 0xc8
 802ad32:	5013      	str	r3, [r2, r0]
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 802ad34:	23cc      	movs	r3, #204	; 0xcc
 802ad36:	980c      	ldr	r0, [sp, #48]	; 0x30
 802ad38:	50d0      	str	r0, [r2, r3]
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 802ad3a:	7c0b      	ldrb	r3, [r1, #16]
 802ad3c:	0658      	lsls	r0, r3, #25
 802ad3e:	0f40      	lsrs	r0, r0, #29
 802ad40:	2461      	movs	r4, #97	; 0x61
 802ad42:	5510      	strb	r0, [r2, r4]
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 802ad44:	071b      	lsls	r3, r3, #28
 802ad46:	0f1b      	lsrs	r3, r3, #28
 802ad48:	2068      	movs	r0, #104	; 0x68
 802ad4a:	5413      	strb	r3, [r2, r0]
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 802ad4c:	3008      	adds	r0, #8
 802ad4e:	5413      	strb	r3, [r2, r0]
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 802ad50:	7c4b      	ldrb	r3, [r1, #17]
 802ad52:	6513      	str	r3, [r2, #80]	; 0x50
                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )
 802ad54:	2b00      	cmp	r3, #0
 802ad56:	d102      	bne.n	802ad5e <ProcessRadioRxDone+0x212>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 802ad58:	0013      	movs	r3, r2
 802ad5a:	2201      	movs	r2, #1
 802ad5c:	651a      	str	r2, [r3, #80]	; 0x50
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 802ad5e:	4c29      	ldr	r4, [pc, #164]	; (802ae04 <ProcessRadioRxDone+0x2b8>)
 802ad60:	6d22      	ldr	r2, [r4, #80]	; 0x50
 802ad62:	0153      	lsls	r3, r2, #5
 802ad64:	1a9b      	subs	r3, r3, r2
 802ad66:	009b      	lsls	r3, r3, #2
 802ad68:	189b      	adds	r3, r3, r2
 802ad6a:	00db      	lsls	r3, r3, #3
 802ad6c:	6523      	str	r3, [r4, #80]	; 0x50
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 802ad6e:	22fa      	movs	r2, #250	; 0xfa
 802ad70:	0092      	lsls	r2, r2, #2
 802ad72:	4694      	mov	ip, r2
 802ad74:	4463      	add	r3, ip
 802ad76:	6563      	str	r3, [r4, #84]	; 0x54
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 802ad78:	2387      	movs	r3, #135	; 0x87
 802ad7a:	005b      	lsls	r3, r3, #1
 802ad7c:	2200      	movs	r2, #0
 802ad7e:	54e2      	strb	r2, [r4, r3]
                applyCFList.Payload = macMsgJoinAccept.CFList;
 802ad80:	a922      	add	r1, sp, #136	; 0x88
 802ad82:	3be0      	subs	r3, #224	; 0xe0
 802ad84:	aa02      	add	r2, sp, #8
 802ad86:	4694      	mov	ip, r2
 802ad88:	4463      	add	r3, ip
 802ad8a:	9322      	str	r3, [sp, #136]	; 0x88
                applyCFList.Size = size - 17;
 802ad8c:	3d11      	subs	r5, #17
 802ad8e:	710d      	strb	r5, [r1, #4]
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 802ad90:	2340      	movs	r3, #64	; 0x40
 802ad92:	5ce0      	ldrb	r0, [r4, r3]
 802ad94:	f003 fcf1 	bl	802e77a <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 802ad98:	2388      	movs	r3, #136	; 0x88
 802ad9a:	005b      	lsls	r3, r3, #1
 802ad9c:	2202      	movs	r2, #2
 802ad9e:	54e2      	strb	r2, [r4, r3]
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 802ada0:	2001      	movs	r0, #1
 802ada2:	f002 ff0b 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802ada6:	2800      	cmp	r0, #0
 802ada8:	d114      	bne.n	802add4 <ProcessRadioRxDone+0x288>
            MacCtx.MacFlags.Bits.MlmeInd = 1;
 802adaa:	4917      	ldr	r1, [pc, #92]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802adac:	4a2a      	ldr	r2, [pc, #168]	; (802ae58 <ProcessRadioRxDone+0x30c>)
 802adae:	5c8b      	ldrb	r3, [r1, r2]
 802adb0:	2008      	movs	r0, #8
 802adb2:	4303      	orrs	r3, r0
 802adb4:	548b      	strb	r3, [r1, r2]
            break;
 802adb6:	e78e      	b.n	802acd6 <ProcessRadioRxDone+0x18a>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802adb8:	4a13      	ldr	r2, [pc, #76]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802adba:	4b22      	ldr	r3, [pc, #136]	; (802ae44 <ProcessRadioRxDone+0x2f8>)
 802adbc:	2101      	movs	r1, #1
 802adbe:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802adc0:	f7ff fb6e 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802adc4:	e219      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802adc6:	4a10      	ldr	r2, [pc, #64]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802adc8:	4b1e      	ldr	r3, [pc, #120]	; (802ae44 <ProcessRadioRxDone+0x2f8>)
 802adca:	2101      	movs	r1, #1
 802adcc:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802adce:	f7ff fb67 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802add2:	e212      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );
 802add4:	2101      	movs	r1, #1
 802add6:	2000      	movs	r0, #0
 802add8:	f002 fea0 	bl	802db1c <LoRaMacConfirmQueueSetStatus>
 802addc:	e7e5      	b.n	802adaa <ProcessRadioRxDone+0x25e>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 802adde:	2001      	movs	r0, #1
 802ade0:	f002 feec 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802ade4:	2800      	cmp	r0, #0
 802ade6:	d0e0      	beq.n	802adaa <ProcessRadioRxDone+0x25e>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 802ade8:	2101      	movs	r1, #1
 802adea:	2007      	movs	r0, #7
 802adec:	f002 fe96 	bl	802db1c <LoRaMacConfirmQueueSetStatus>
 802adf0:	e7db      	b.n	802adaa <ProcessRadioRxDone+0x25e>
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 802adf2:	4a05      	ldr	r2, [pc, #20]	; (802ae08 <ProcessRadioRxDone+0x2bc>)
 802adf4:	4b10      	ldr	r3, [pc, #64]	; (802ae38 <ProcessRadioRxDone+0x2ec>)
 802adf6:	2101      	movs	r1, #1
 802adf8:	54d1      	strb	r1, [r2, r3]
 802adfa:	e6fb      	b.n	802abf4 <ProcessRadioRxDone+0xa8>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 802adfc:	2200      	movs	r2, #0
 802adfe:	e71a      	b.n	802ac36 <ProcessRadioRxDone+0xea>
 802ae00:	2000bcfc 	.word	0x2000bcfc
 802ae04:	2000aa3c 	.word	0x2000aa3c
 802ae08:	2000a534 	.word	0x2000a534
 802ae0c:	0000043c 	.word	0x0000043c
 802ae10:	0000047c 	.word	0x0000047c
 802ae14:	0000047e 	.word	0x0000047e
 802ae18:	0000047f 	.word	0x0000047f
 802ae1c:	0000041f 	.word	0x0000041f
 802ae20:	0000041e 	.word	0x0000041e
 802ae24:	00000421 	.word	0x00000421
 802ae28:	00000424 	.word	0x00000424
 802ae2c:	00000429 	.word	0x00000429
 802ae30:	0000042a 	.word	0x0000042a
 802ae34:	0000042c 	.word	0x0000042c
 802ae38:	0000041c 	.word	0x0000041c
 802ae3c:	00000434 	.word	0x00000434
 802ae40:	080356b4 	.word	0x080356b4
 802ae44:	0000041d 	.word	0x0000041d
 802ae48:	00000472 	.word	0x00000472
 802ae4c:	00000474 	.word	0x00000474
 802ae50:	2000a76c 	.word	0x2000a76c
 802ae54:	fffffdc8 	.word	0xfffffdc8
 802ae58:	00000481 	.word	0x00000481
 802ae5c:	00000414 	.word	0x00000414
            macMsgData.Buffer = payload;
 802ae60:	9613      	str	r6, [sp, #76]	; 0x4c
            macMsgData.BufSize = size;
 802ae62:	ab02      	add	r3, sp, #8
 802ae64:	2248      	movs	r2, #72	; 0x48
 802ae66:	189b      	adds	r3, r3, r2
 802ae68:	701d      	strb	r5, [r3, #0]
            macMsgData.FRMPayload = MacCtx.RxPayload;
 802ae6a:	4bcd      	ldr	r3, [pc, #820]	; (802b1a0 <ProcessRadioRxDone+0x654>)
 802ae6c:	931c      	str	r3, [sp, #112]	; 0x70
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 802ae6e:	2328      	movs	r3, #40	; 0x28
 802ae70:	32b7      	adds	r2, #183	; 0xb7
 802ae72:	a902      	add	r1, sp, #8
 802ae74:	2044      	movs	r0, #68	; 0x44
 802ae76:	1809      	adds	r1, r1, r0
 802ae78:	54ca      	strb	r2, [r1, r3]
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 802ae7a:	a813      	add	r0, sp, #76	; 0x4c
 802ae7c:	f003 fb23 	bl	802e4c6 <LoRaMacParserData>
 802ae80:	2800      	cmp	r0, #0
 802ae82:	d153      	bne.n	802af2c <ProcessRadioRxDone+0x3e0>
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 802ae84:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802ae86:	9305      	str	r3, [sp, #20]
 802ae88:	4ac6      	ldr	r2, [pc, #792]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802ae8a:	2386      	movs	r3, #134	; 0x86
 802ae8c:	00db      	lsls	r3, r3, #3
 802ae8e:	9905      	ldr	r1, [sp, #20]
 802ae90:	50d1      	str	r1, [r2, r3]
            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )
 802ae92:	2116      	movs	r1, #22
 802ae94:	ab02      	add	r3, sp, #8
 802ae96:	469c      	mov	ip, r3
 802ae98:	4461      	add	r1, ip
 802ae9a:	a813      	add	r0, sp, #76	; 0x4c
 802ae9c:	f7ff f91c 	bl	802a0d8 <DetermineFrameType>
 802aea0:	1e05      	subs	r5, r0, #0
 802aea2:	d14a      	bne.n	802af3a <ProcessRadioRxDone+0x3ee>
            downLinkCounter = 0;
 802aea4:	2300      	movs	r3, #0
 802aea6:	9308      	str	r3, [sp, #32]
            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802aea8:	2800      	cmp	r0, #0
 802aeaa:	d04d      	beq.n	802af48 <ProcessRadioRxDone+0x3fc>
    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;
 802aeac:	2601      	movs	r6, #1
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 802aeae:	2d01      	cmp	r5, #1
 802aeb0:	d10b      	bne.n	802aeca <ProcessRadioRxDone+0x37e>
 802aeb2:	2316      	movs	r3, #22
 802aeb4:	aa02      	add	r2, sp, #8
 802aeb6:	4694      	mov	ip, r2
 802aeb8:	4463      	add	r3, ip
 802aeba:	781b      	ldrb	r3, [r3, #0]
 802aebc:	2b03      	cmp	r3, #3
 802aebe:	d16e      	bne.n	802af9e <ProcessRadioRxDone+0x452>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 802aec0:	ab13      	add	r3, sp, #76	; 0x4c
 802aec2:	7b1b      	ldrb	r3, [r3, #12]
 802aec4:	2260      	movs	r2, #96	; 0x60
 802aec6:	421a      	tst	r2, r3
 802aec8:	d169      	bne.n	802af9e <ProcessRadioRxDone+0x452>
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 802aeca:	a920      	add	r1, sp, #128	; 0x80
 802aecc:	2315      	movs	r3, #21
 802aece:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802aed0:	4bb5      	ldr	r3, [pc, #724]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802aed2:	4698      	mov	r8, r3
 802aed4:	2340      	movs	r3, #64	; 0x40
 802aed6:	4642      	mov	r2, r8
 802aed8:	5cd0      	ldrb	r0, [r2, r3]
 802aeda:	f003 fc0b 	bl	802e6f4 <RegionGetPhyParam>
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, phyParam.Value, &fCntID, &downLinkCounter );
 802aede:	2386      	movs	r3, #134	; 0x86
 802aee0:	005b      	lsls	r3, r3, #1
 802aee2:	4642      	mov	r2, r8
 802aee4:	58d3      	ldr	r3, [r2, r3]
 802aee6:	4698      	mov	r8, r3
 802aee8:	2216      	movs	r2, #22
 802aeea:	ab02      	add	r3, sp, #8
 802aeec:	469c      	mov	ip, r3
 802aeee:	4462      	add	r2, ip
 802aef0:	7811      	ldrb	r1, [r2, #0]
 802aef2:	aa08      	add	r2, sp, #32
 802aef4:	9202      	str	r2, [sp, #8]
 802aef6:	2217      	movs	r2, #23
 802aef8:	4462      	add	r2, ip
 802aefa:	9201      	str	r2, [sp, #4]
 802aefc:	b280      	uxth	r0, r0
 802aefe:	9000      	str	r0, [sp, #0]
 802af00:	4643      	mov	r3, r8
 802af02:	aa13      	add	r2, sp, #76	; 0x4c
 802af04:	0030      	movs	r0, r6
 802af06:	f7ff fb0f 	bl	802a528 <GetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 802af0a:	2800      	cmp	r0, #0
 802af0c:	d06a      	beq.n	802afe4 <ProcessRadioRxDone+0x498>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 802af0e:	2807      	cmp	r0, #7
 802af10:	d04c      	beq.n	802afac <ProcessRadioRxDone+0x460>
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 802af12:	2808      	cmp	r0, #8
 802af14:	d061      	beq.n	802afda <ProcessRadioRxDone+0x48e>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802af16:	4aa3      	ldr	r2, [pc, #652]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802af18:	4ba4      	ldr	r3, [pc, #656]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802af1a:	2101      	movs	r1, #1
 802af1c:	54d1      	strb	r1, [r2, r3]
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 802af1e:	4aa1      	ldr	r2, [pc, #644]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802af20:	4ba3      	ldr	r3, [pc, #652]	; (802b1b0 <ProcessRadioRxDone+0x664>)
 802af22:	9908      	ldr	r1, [sp, #32]
 802af24:	50d1      	str	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802af26:	f7ff fabb 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802af2a:	e166      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802af2c:	4a9d      	ldr	r2, [pc, #628]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802af2e:	4b9f      	ldr	r3, [pc, #636]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802af30:	2101      	movs	r1, #1
 802af32:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802af34:	f7ff fab4 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802af38:	e15f      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802af3a:	4a9a      	ldr	r2, [pc, #616]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802af3c:	4b9b      	ldr	r3, [pc, #620]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802af3e:	2101      	movs	r1, #1
 802af40:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802af42:	f7ff faad 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802af46:	e158      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 802af48:	212c      	movs	r1, #44	; 0x2c
 802af4a:	4341      	muls	r1, r0
 802af4c:	4b96      	ldr	r3, [pc, #600]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802af4e:	185b      	adds	r3, r3, r1
 802af50:	33d4      	adds	r3, #212	; 0xd4
 802af52:	681b      	ldr	r3, [r3, #0]
 802af54:	9915      	ldr	r1, [sp, #84]	; 0x54
 802af56:	428b      	cmp	r3, r1
 802af58:	d002      	beq.n	802af60 <ProcessRadioRxDone+0x414>
            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802af5a:	3001      	adds	r0, #1
 802af5c:	b2c0      	uxtb	r0, r0
 802af5e:	e7a3      	b.n	802aea8 <ProcessRadioRxDone+0x35c>
                    ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) )
 802af60:	262c      	movs	r6, #44	; 0x2c
 802af62:	4346      	muls	r6, r0
 802af64:	4990      	ldr	r1, [pc, #576]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802af66:	1989      	adds	r1, r1, r6
 802af68:	31d2      	adds	r1, #210	; 0xd2
 802af6a:	7809      	ldrb	r1, [r1, #0]
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 802af6c:	2900      	cmp	r1, #0
 802af6e:	d0f4      	beq.n	802af5a <ProcessRadioRxDone+0x40e>
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 802af70:	488d      	ldr	r0, [pc, #564]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802af72:	1982      	adds	r2, r0, r6
 802af74:	0011      	movs	r1, r2
 802af76:	31d3      	adds	r1, #211	; 0xd3
 802af78:	780e      	ldrb	r6, [r1, #0]
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 802af7a:	32f0      	adds	r2, #240	; 0xf0
 802af7c:	6812      	ldr	r2, [r2, #0]
 802af7e:	6812      	ldr	r2, [r2, #0]
 802af80:	9208      	str	r2, [sp, #32]
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 802af82:	22fc      	movs	r2, #252	; 0xfc
 802af84:	5c82      	ldrb	r2, [r0, r2]
 802af86:	2a02      	cmp	r2, #2
 802af88:	d002      	beq.n	802af90 <ProcessRadioRxDone+0x444>
                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;
 802af8a:	4699      	mov	r9, r3
                    multicast = 1;
 802af8c:	2501      	movs	r5, #1
 802af8e:	e78e      	b.n	802aeae <ProcessRadioRxDone+0x362>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 802af90:	4984      	ldr	r1, [pc, #528]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802af92:	4a88      	ldr	r2, [pc, #544]	; (802b1b4 <ProcessRadioRxDone+0x668>)
 802af94:	2003      	movs	r0, #3
 802af96:	5488      	strb	r0, [r1, r2]
                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;
 802af98:	4699      	mov	r9, r3
                    multicast = 1;
 802af9a:	2501      	movs	r5, #1
 802af9c:	e787      	b.n	802aeae <ProcessRadioRxDone+0x362>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802af9e:	4a81      	ldr	r2, [pc, #516]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802afa0:	4b82      	ldr	r3, [pc, #520]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802afa2:	2101      	movs	r1, #1
 802afa4:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802afa6:	f7ff fa7b 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802afaa:	e126      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 802afac:	4a7d      	ldr	r2, [pc, #500]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802afae:	4b7f      	ldr	r3, [pc, #508]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802afb0:	2108      	movs	r1, #8
 802afb2:	54d1      	strb	r1, [r2, r3]
                    if( ( Nvm.MacGroup2.Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( Nvm.MacGroup1.LastRxMic == macMsgData.MIC ) )
 802afb4:	4a7c      	ldr	r2, [pc, #496]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802afb6:	2387      	movs	r3, #135	; 0x87
 802afb8:	005b      	lsls	r3, r3, #1
 802afba:	5cd3      	ldrb	r3, [r2, r3]
 802afbc:	2b00      	cmp	r3, #0
 802afbe:	d1ae      	bne.n	802af1e <ProcessRadioRxDone+0x3d2>
 802afc0:	331f      	adds	r3, #31
 802afc2:	439c      	bics	r4, r3
 802afc4:	2ca0      	cmp	r4, #160	; 0xa0
 802afc6:	d1aa      	bne.n	802af1e <ProcessRadioRxDone+0x3d2>
 802afc8:	6b53      	ldr	r3, [r2, #52]	; 0x34
 802afca:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 802afcc:	4293      	cmp	r3, r2
 802afce:	d1a6      	bne.n	802af1e <ProcessRadioRxDone+0x3d2>
                        Nvm.MacGroup1.SrvAckRequested = true;
 802afd0:	4a75      	ldr	r2, [pc, #468]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802afd2:	233a      	movs	r3, #58	; 0x3a
 802afd4:	3907      	subs	r1, #7
 802afd6:	54d1      	strb	r1, [r2, r3]
 802afd8:	e7a1      	b.n	802af1e <ProcessRadioRxDone+0x3d2>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 802afda:	4a72      	ldr	r2, [pc, #456]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802afdc:	4b73      	ldr	r3, [pc, #460]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802afde:	210a      	movs	r1, #10
 802afe0:	54d1      	strb	r1, [r2, r3]
 802afe2:	e79c      	b.n	802af1e <ProcessRadioRxDone+0x3d2>
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 802afe4:	2317      	movs	r3, #23
 802afe6:	aa02      	add	r2, sp, #8
 802afe8:	4694      	mov	ip, r2
 802afea:	4463      	add	r3, ip
 802afec:	781a      	ldrb	r2, [r3, #0]
 802afee:	ab13      	add	r3, sp, #76	; 0x4c
 802aff0:	9300      	str	r3, [sp, #0]
 802aff2:	9b08      	ldr	r3, [sp, #32]
 802aff4:	4649      	mov	r1, r9
 802aff6:	0030      	movs	r0, r6
 802aff8:	f003 f8e6 	bl	802e1c8 <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 802affc:	2800      	cmp	r0, #0
 802affe:	d152      	bne.n	802b0a6 <ProcessRadioRxDone+0x55a>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802b000:	4b68      	ldr	r3, [pc, #416]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b002:	2100      	movs	r1, #0
 802b004:	4a69      	ldr	r2, [pc, #420]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802b006:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Multicast = multicast;
 802b008:	4a6b      	ldr	r2, [pc, #428]	; (802b1b8 <ProcessRadioRxDone+0x66c>)
 802b00a:	549d      	strb	r5, [r3, r2]
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 802b00c:	aa13      	add	r2, sp, #76	; 0x4c
 802b00e:	7b12      	ldrb	r2, [r2, #12]
 802b010:	06d0      	lsls	r0, r2, #27
 802b012:	0fc0      	lsrs	r0, r0, #31
 802b014:	4e69      	ldr	r6, [pc, #420]	; (802b1bc <ProcessRadioRxDone+0x670>)
 802b016:	5598      	strb	r0, [r3, r6]
            MacCtx.McpsIndication.Buffer = NULL;
 802b018:	4869      	ldr	r0, [pc, #420]	; (802b1c0 <ProcessRadioRxDone+0x674>)
 802b01a:	5019      	str	r1, [r3, r0]
            MacCtx.McpsIndication.BufferSize = 0;
 802b01c:	3004      	adds	r0, #4
 802b01e:	5419      	strb	r1, [r3, r0]
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 802b020:	4863      	ldr	r0, [pc, #396]	; (802b1b0 <ProcessRadioRxDone+0x664>)
 802b022:	9e08      	ldr	r6, [sp, #32]
 802b024:	501e      	str	r6, [r3, r0]
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 802b026:	0692      	lsls	r2, r2, #26
 802b028:	0fd2      	lsrs	r2, r2, #31
 802b02a:	4866      	ldr	r0, [pc, #408]	; (802b1c4 <ProcessRadioRxDone+0x678>)
 802b02c:	541a      	strb	r2, [r3, r0]
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802b02e:	4866      	ldr	r0, [pc, #408]	; (802b1c8 <ProcessRadioRxDone+0x67c>)
 802b030:	5419      	strb	r1, [r3, r0]
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 802b032:	4966      	ldr	r1, [pc, #408]	; (802b1cc <ProcessRadioRxDone+0x680>)
 802b034:	545a      	strb	r2, [r3, r1]
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 802b036:	4a5f      	ldr	r2, [pc, #380]	; (802b1b4 <ProcessRadioRxDone+0x668>)
 802b038:	5c98      	ldrb	r0, [r3, r2]
 802b03a:	2801      	cmp	r0, #1
 802b03c:	d941      	bls.n	802b0c2 <ProcessRadioRxDone+0x576>
            if( multicast == 1 )
 802b03e:	2d01      	cmp	r5, #1
 802b040:	d043      	beq.n	802b0ca <ProcessRadioRxDone+0x57e>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 802b042:	231f      	movs	r3, #31
 802b044:	439c      	bics	r4, r3
 802b046:	2ca0      	cmp	r4, #160	; 0xa0
 802b048:	d044      	beq.n	802b0d4 <ProcessRadioRxDone+0x588>
                    Nvm.MacGroup1.SrvAckRequested = false;
 802b04a:	2300      	movs	r3, #0
 802b04c:	4956      	ldr	r1, [pc, #344]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802b04e:	223a      	movs	r2, #58	; 0x3a
 802b050:	548b      	strb	r3, [r1, r2]
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 802b052:	4954      	ldr	r1, [pc, #336]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b054:	4a5e      	ldr	r2, [pc, #376]	; (802b1d0 <ProcessRadioRxDone+0x684>)
 802b056:	548b      	strb	r3, [r1, r2]
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 802b058:	4a52      	ldr	r2, [pc, #328]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b05a:	2387      	movs	r3, #135	; 0x87
 802b05c:	00db      	lsls	r3, r3, #3
 802b05e:	5cd2      	ldrb	r2, [r2, r3]
 802b060:	ab13      	add	r3, sp, #76	; 0x4c
 802b062:	7b19      	ldrb	r1, [r3, #12]
 802b064:	f7ff fa96 	bl	802a594 <RemoveMacCommands>
            switch( fType )
 802b068:	2316      	movs	r3, #22
 802b06a:	aa02      	add	r2, sp, #8
 802b06c:	4694      	mov	ip, r2
 802b06e:	4463      	add	r3, ip
 802b070:	781b      	ldrb	r3, [r3, #0]
 802b072:	2b02      	cmp	r3, #2
 802b074:	d075      	beq.n	802b162 <ProcessRadioRxDone+0x616>
 802b076:	d83d      	bhi.n	802b0f4 <ProcessRadioRxDone+0x5a8>
 802b078:	2b00      	cmp	r3, #0
 802b07a:	d04f      	beq.n	802b11c <ProcessRadioRxDone+0x5d0>
 802b07c:	2b01      	cmp	r3, #1
 802b07e:	d000      	beq.n	802b082 <ProcessRadioRxDone+0x536>
 802b080:	e080      	b.n	802b184 <ProcessRadioRxDone+0x638>
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 802b082:	ac13      	add	r4, sp, #76	; 0x4c
 802b084:	7b22      	ldrb	r2, [r4, #12]
 802b086:	0712      	lsls	r2, r2, #28
 802b088:	0f12      	lsrs	r2, r2, #28
 802b08a:	4d46      	ldr	r5, [pc, #280]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b08c:	4b49      	ldr	r3, [pc, #292]	; (802b1b4 <ProcessRadioRxDone+0x668>)
 802b08e:	5ceb      	ldrb	r3, [r5, r3]
 802b090:	9300      	str	r3, [sp, #0]
 802b092:	003b      	movs	r3, r7
 802b094:	2100      	movs	r1, #0
 802b096:	a817      	add	r0, sp, #92	; 0x5c
 802b098:	f7ff fa8a 	bl	802a5b0 <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b09c:	2320      	movs	r3, #32
 802b09e:	5ce2      	ldrb	r2, [r4, r3]
 802b0a0:	4b4c      	ldr	r3, [pc, #304]	; (802b1d4 <ProcessRadioRxDone+0x688>)
 802b0a2:	54ea      	strb	r2, [r5, r3]
                    break;
 802b0a4:	e056      	b.n	802b154 <ProcessRadioRxDone+0x608>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )
 802b0a6:	2802      	cmp	r0, #2
 802b0a8:	d006      	beq.n	802b0b8 <ProcessRadioRxDone+0x56c>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 802b0aa:	4a3e      	ldr	r2, [pc, #248]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b0ac:	4b3f      	ldr	r3, [pc, #252]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802b0ae:	210c      	movs	r1, #12
 802b0b0:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b0b2:	f7ff f9f5 	bl	802a4a0 <PrepareRxDoneAbort>
                return;
 802b0b6:	e0a0      	b.n	802b1fa <ProcessRadioRxDone+0x6ae>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;
 802b0b8:	4a3a      	ldr	r2, [pc, #232]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b0ba:	4b3c      	ldr	r3, [pc, #240]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802b0bc:	210b      	movs	r1, #11
 802b0be:	54d1      	strb	r1, [r2, r3]
 802b0c0:	e7f7      	b.n	802b0b2 <ProcessRadioRxDone+0x566>
                Nvm.MacGroup1.AdrAckCounter = 0;
 802b0c2:	4b39      	ldr	r3, [pc, #228]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802b0c4:	2200      	movs	r2, #0
 802b0c6:	629a      	str	r2, [r3, #40]	; 0x28
 802b0c8:	e7b9      	b.n	802b03e <ProcessRadioRxDone+0x4f2>
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 802b0ca:	4a36      	ldr	r2, [pc, #216]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b0cc:	4b40      	ldr	r3, [pc, #256]	; (802b1d0 <ProcessRadioRxDone+0x684>)
 802b0ce:	2102      	movs	r1, #2
 802b0d0:	54d1      	strb	r1, [r2, r3]
 802b0d2:	e7c1      	b.n	802b058 <ProcessRadioRxDone+0x50c>
                    Nvm.MacGroup1.SrvAckRequested = true;
 802b0d4:	4b34      	ldr	r3, [pc, #208]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802b0d6:	223a      	movs	r2, #58	; 0x3a
 802b0d8:	2101      	movs	r1, #1
 802b0da:	5499      	strb	r1, [r3, r2]
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 802b0dc:	32d4      	adds	r2, #212	; 0xd4
 802b0de:	5c9b      	ldrb	r3, [r3, r2]
 802b0e0:	2b00      	cmp	r3, #0
 802b0e2:	d102      	bne.n	802b0ea <ProcessRadioRxDone+0x59e>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 802b0e4:	4b30      	ldr	r3, [pc, #192]	; (802b1a8 <ProcessRadioRxDone+0x65c>)
 802b0e6:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 802b0e8:	635a      	str	r2, [r3, #52]	; 0x34
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 802b0ea:	4a2e      	ldr	r2, [pc, #184]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b0ec:	4b38      	ldr	r3, [pc, #224]	; (802b1d0 <ProcessRadioRxDone+0x684>)
 802b0ee:	2101      	movs	r1, #1
 802b0f0:	54d1      	strb	r1, [r2, r3]
 802b0f2:	e7b1      	b.n	802b058 <ProcessRadioRxDone+0x50c>
 802b0f4:	2b03      	cmp	r3, #3
 802b0f6:	d145      	bne.n	802b184 <ProcessRadioRxDone+0x638>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b0f8:	aa13      	add	r2, sp, #76	; 0x4c
 802b0fa:	2320      	movs	r3, #32
 802b0fc:	5cd0      	ldrb	r0, [r2, r3]
 802b0fe:	4b29      	ldr	r3, [pc, #164]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b100:	4934      	ldr	r1, [pc, #208]	; (802b1d4 <ProcessRadioRxDone+0x688>)
 802b102:	5458      	strb	r0, [r3, r1]
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 802b104:	492e      	ldr	r1, [pc, #184]	; (802b1c0 <ProcessRadioRxDone+0x674>)
 802b106:	981c      	ldr	r0, [sp, #112]	; 0x70
 802b108:	5058      	str	r0, [r3, r1]
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 802b10a:	2128      	movs	r1, #40	; 0x28
 802b10c:	5c51      	ldrb	r1, [r2, r1]
 802b10e:	2285      	movs	r2, #133	; 0x85
 802b110:	00d2      	lsls	r2, r2, #3
 802b112:	5499      	strb	r1, [r3, r2]
                    MacCtx.McpsIndication.RxData = true;
 802b114:	4a30      	ldr	r2, [pc, #192]	; (802b1d8 <ProcessRadioRxDone+0x68c>)
 802b116:	2101      	movs	r1, #1
 802b118:	5499      	strb	r1, [r3, r2]
                    break;
 802b11a:	e01b      	b.n	802b154 <ProcessRadioRxDone+0x608>
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 802b11c:	ad13      	add	r5, sp, #76	; 0x4c
 802b11e:	7b2a      	ldrb	r2, [r5, #12]
 802b120:	0712      	lsls	r2, r2, #28
 802b122:	0f12      	lsrs	r2, r2, #28
 802b124:	4c1f      	ldr	r4, [pc, #124]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b126:	4b23      	ldr	r3, [pc, #140]	; (802b1b4 <ProcessRadioRxDone+0x668>)
 802b128:	5ce3      	ldrb	r3, [r4, r3]
 802b12a:	9300      	str	r3, [sp, #0]
 802b12c:	003b      	movs	r3, r7
 802b12e:	2100      	movs	r1, #0
 802b130:	a817      	add	r0, sp, #92	; 0x5c
 802b132:	f7ff fa3d 	bl	802a5b0 <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b136:	2320      	movs	r3, #32
 802b138:	5cea      	ldrb	r2, [r5, r3]
 802b13a:	4b26      	ldr	r3, [pc, #152]	; (802b1d4 <ProcessRadioRxDone+0x688>)
 802b13c:	54e2      	strb	r2, [r4, r3]
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 802b13e:	4b20      	ldr	r3, [pc, #128]	; (802b1c0 <ProcessRadioRxDone+0x674>)
 802b140:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 802b142:	50e2      	str	r2, [r4, r3]
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 802b144:	2328      	movs	r3, #40	; 0x28
 802b146:	5cea      	ldrb	r2, [r5, r3]
 802b148:	2385      	movs	r3, #133	; 0x85
 802b14a:	00db      	lsls	r3, r3, #3
 802b14c:	54e2      	strb	r2, [r4, r3]
                    MacCtx.McpsIndication.RxData = true;
 802b14e:	4b22      	ldr	r3, [pc, #136]	; (802b1d8 <ProcessRadioRxDone+0x68c>)
 802b150:	2201      	movs	r2, #1
 802b152:	54e2      	strb	r2, [r4, r3]
            MacCtx.MacFlags.Bits.McpsInd = 1;
 802b154:	4913      	ldr	r1, [pc, #76]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b156:	4a21      	ldr	r2, [pc, #132]	; (802b1dc <ProcessRadioRxDone+0x690>)
 802b158:	5c8b      	ldrb	r3, [r1, r2]
 802b15a:	2002      	movs	r0, #2
 802b15c:	4303      	orrs	r3, r0
 802b15e:	548b      	strb	r3, [r1, r2]
            break;
 802b160:	e5b9      	b.n	802acd6 <ProcessRadioRxDone+0x18a>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 802b162:	ac13      	add	r4, sp, #76	; 0x4c
 802b164:	2328      	movs	r3, #40	; 0x28
 802b166:	5ce2      	ldrb	r2, [r4, r3]
 802b168:	4d0e      	ldr	r5, [pc, #56]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b16a:	4b12      	ldr	r3, [pc, #72]	; (802b1b4 <ProcessRadioRxDone+0x668>)
 802b16c:	5ceb      	ldrb	r3, [r5, r3]
 802b16e:	9300      	str	r3, [sp, #0]
 802b170:	003b      	movs	r3, r7
 802b172:	2100      	movs	r1, #0
 802b174:	981c      	ldr	r0, [sp, #112]	; 0x70
 802b176:	f7ff fa1b 	bl	802a5b0 <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b17a:	2320      	movs	r3, #32
 802b17c:	5ce2      	ldrb	r2, [r4, r3]
 802b17e:	4b15      	ldr	r3, [pc, #84]	; (802b1d4 <ProcessRadioRxDone+0x688>)
 802b180:	54ea      	strb	r2, [r5, r3]
                    break;
 802b182:	e7e7      	b.n	802b154 <ProcessRadioRxDone+0x608>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b184:	4a07      	ldr	r2, [pc, #28]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b186:	4b09      	ldr	r3, [pc, #36]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802b188:	2101      	movs	r1, #1
 802b18a:	54d1      	strb	r1, [r2, r3]
                    PrepareRxDoneAbort( );
 802b18c:	f7ff f988 	bl	802a4a0 <PrepareRxDoneAbort>
                    break;
 802b190:	e7e0      	b.n	802b154 <ProcessRadioRxDone+0x608>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b192:	4a04      	ldr	r2, [pc, #16]	; (802b1a4 <ProcessRadioRxDone+0x658>)
 802b194:	4b05      	ldr	r3, [pc, #20]	; (802b1ac <ProcessRadioRxDone+0x660>)
 802b196:	2101      	movs	r1, #1
 802b198:	54d1      	strb	r1, [r2, r3]
            PrepareRxDoneAbort( );
 802b19a:	f7ff f981 	bl	802a4a0 <PrepareRxDoneAbort>
            break;
 802b19e:	e59a      	b.n	802acd6 <ProcessRadioRxDone+0x18a>
 802b1a0:	2000a76c 	.word	0x2000a76c
 802b1a4:	2000a534 	.word	0x2000a534
 802b1a8:	2000aa3c 	.word	0x2000aa3c
 802b1ac:	0000041d 	.word	0x0000041d
 802b1b0:	0000042c 	.word	0x0000042c
 802b1b4:	0000047f 	.word	0x0000047f
 802b1b8:	0000041e 	.word	0x0000041e
 802b1bc:	00000421 	.word	0x00000421
 802b1c0:	00000424 	.word	0x00000424
 802b1c4:	0000042a 	.word	0x0000042a
 802b1c8:	00000439 	.word	0x00000439
 802b1cc:	0000043c 	.word	0x0000043c
 802b1d0:	0000041c 	.word	0x0000041c
 802b1d4:	0000041f 	.word	0x0000041f
 802b1d8:	00000429 	.word	0x00000429
 802b1dc:	00000481 	.word	0x00000481
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 802b1e0:	4a0a      	ldr	r2, [pc, #40]	; (802b20c <ProcessRadioRxDone+0x6c0>)
 802b1e2:	23fc      	movs	r3, #252	; 0xfc
 802b1e4:	5cd3      	ldrb	r3, [r2, r3]
 802b1e6:	2b02      	cmp	r3, #2
 802b1e8:	d00c      	beq.n	802b204 <ProcessRadioRxDone+0x6b8>
    MacCtx.MacFlags.Bits.MacDone = 1;
 802b1ea:	4909      	ldr	r1, [pc, #36]	; (802b210 <ProcessRadioRxDone+0x6c4>)
 802b1ec:	4a09      	ldr	r2, [pc, #36]	; (802b214 <ProcessRadioRxDone+0x6c8>)
 802b1ee:	5c8b      	ldrb	r3, [r1, r2]
 802b1f0:	2020      	movs	r0, #32
 802b1f2:	4303      	orrs	r3, r0
 802b1f4:	548b      	strb	r3, [r1, r2]
    UpdateRxSlotIdleState( );
 802b1f6:	f7fe feb7 	bl	8029f68 <UpdateRxSlotIdleState>
}
 802b1fa:	b025      	add	sp, #148	; 0x94
 802b1fc:	bcc0      	pop	{r6, r7}
 802b1fe:	46b9      	mov	r9, r7
 802b200:	46b0      	mov	r8, r6
 802b202:	bdf0      	pop	{r4, r5, r6, r7, pc}
            OnAckTimeoutTimerEvent( NULL );
 802b204:	2000      	movs	r0, #0
 802b206:	f7ff f915 	bl	802a434 <OnAckTimeoutTimerEvent>
 802b20a:	e7ee      	b.n	802b1ea <ProcessRadioRxDone+0x69e>
 802b20c:	2000aa3c 	.word	0x2000aa3c
 802b210:	2000a534 	.word	0x2000a534
 802b214:	00000481 	.word	0x00000481

0802b218 <ProcessRadioTxTimeout>:
{
 802b218:	b510      	push	{r4, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802b21a:	4a10      	ldr	r2, [pc, #64]	; (802b25c <ProcessRadioTxTimeout+0x44>)
 802b21c:	23fc      	movs	r3, #252	; 0xfc
 802b21e:	5cd3      	ldrb	r3, [r2, r3]
 802b220:	2b02      	cmp	r3, #2
 802b222:	d002      	beq.n	802b22a <ProcessRadioTxTimeout+0x12>
        Radio.Sleep( );
 802b224:	4b0e      	ldr	r3, [pc, #56]	; (802b260 <ProcessRadioTxTimeout+0x48>)
 802b226:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802b228:	4798      	blx	r3
    UpdateRxSlotIdleState( );
 802b22a:	f7fe fe9d 	bl	8029f68 <UpdateRxSlotIdleState>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 802b22e:	4c0d      	ldr	r4, [pc, #52]	; (802b264 <ProcessRadioTxTimeout+0x4c>)
 802b230:	4b0d      	ldr	r3, [pc, #52]	; (802b268 <ProcessRadioTxTimeout+0x50>)
 802b232:	2202      	movs	r2, #2
 802b234:	54e2      	strb	r2, [r4, r3]
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 802b236:	2002      	movs	r0, #2
 802b238:	f002 fca2 	bl	802db80 <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 802b23c:	4b0b      	ldr	r3, [pc, #44]	; (802b26c <ProcessRadioTxTimeout+0x54>)
 802b23e:	5ce3      	ldrb	r3, [r4, r3]
 802b240:	2b00      	cmp	r3, #0
 802b242:	d003      	beq.n	802b24c <ProcessRadioTxTimeout+0x34>
        MacCtx.AckTimeoutRetry = true;
 802b244:	4a07      	ldr	r2, [pc, #28]	; (802b264 <ProcessRadioTxTimeout+0x4c>)
 802b246:	4b0a      	ldr	r3, [pc, #40]	; (802b270 <ProcessRadioTxTimeout+0x58>)
 802b248:	2101      	movs	r1, #1
 802b24a:	54d1      	strb	r1, [r2, r3]
    MacCtx.MacFlags.Bits.MacDone = 1;
 802b24c:	4905      	ldr	r1, [pc, #20]	; (802b264 <ProcessRadioTxTimeout+0x4c>)
 802b24e:	4a09      	ldr	r2, [pc, #36]	; (802b274 <ProcessRadioTxTimeout+0x5c>)
 802b250:	5c8b      	ldrb	r3, [r1, r2]
 802b252:	2020      	movs	r0, #32
 802b254:	4303      	orrs	r3, r0
 802b256:	548b      	strb	r3, [r1, r2]
}
 802b258:	bd10      	pop	{r4, pc}
 802b25a:	46c0      	nop			; (mov r8, r8)
 802b25c:	2000aa3c 	.word	0x2000aa3c
 802b260:	080356b4 	.word	0x080356b4
 802b264:	2000a534 	.word	0x2000a534
 802b268:	00000439 	.word	0x00000439
 802b26c:	00000414 	.word	0x00000414
 802b270:	00000413 	.word	0x00000413
 802b274:	00000481 	.word	0x00000481

0802b278 <CheckForClassBCollision>:
{
 802b278:	b510      	push	{r4, lr}
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 802b27a:	f002 fa19 	bl	802d6b0 <LoRaMacClassBIsBeaconExpected>
 802b27e:	2800      	cmp	r0, #0
 802b280:	d110      	bne.n	802b2a4 <CheckForClassBCollision+0x2c>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802b282:	4a0a      	ldr	r2, [pc, #40]	; (802b2ac <CheckForClassBCollision+0x34>)
 802b284:	23fc      	movs	r3, #252	; 0xfc
 802b286:	5cd3      	ldrb	r3, [r2, r3]
 802b288:	2b01      	cmp	r3, #1
 802b28a:	d001      	beq.n	802b290 <CheckForClassBCollision+0x18>
    return LORAMAC_STATUS_OK;
 802b28c:	2000      	movs	r0, #0
}
 802b28e:	bd10      	pop	{r4, pc}
        if( LoRaMacClassBIsPingExpected( ) == true )
 802b290:	f002 fa10 	bl	802d6b4 <LoRaMacClassBIsPingExpected>
 802b294:	2800      	cmp	r0, #0
 802b296:	d107      	bne.n	802b2a8 <CheckForClassBCollision+0x30>
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 802b298:	f002 fa0e 	bl	802d6b8 <LoRaMacClassBIsMulticastExpected>
 802b29c:	2800      	cmp	r0, #0
 802b29e:	d0f6      	beq.n	802b28e <CheckForClassBCollision+0x16>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 802b2a0:	200f      	movs	r0, #15
 802b2a2:	e7f4      	b.n	802b28e <CheckForClassBCollision+0x16>
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 802b2a4:	200e      	movs	r0, #14
 802b2a6:	e7f2      	b.n	802b28e <CheckForClassBCollision+0x16>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 802b2a8:	200f      	movs	r0, #15
 802b2aa:	e7f0      	b.n	802b28e <CheckForClassBCollision+0x16>
 802b2ac:	2000aa3c 	.word	0x2000aa3c

0802b2b0 <HandleRadioRxErrorTimeout>:
{
 802b2b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b2b2:	0006      	movs	r6, r0
 802b2b4:	000d      	movs	r5, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802b2b6:	4a38      	ldr	r2, [pc, #224]	; (802b398 <HandleRadioRxErrorTimeout+0xe8>)
 802b2b8:	23fc      	movs	r3, #252	; 0xfc
 802b2ba:	5cd3      	ldrb	r3, [r2, r3]
 802b2bc:	2b02      	cmp	r3, #2
 802b2be:	d002      	beq.n	802b2c6 <HandleRadioRxErrorTimeout+0x16>
        Radio.Sleep( );
 802b2c0:	4b36      	ldr	r3, [pc, #216]	; (802b39c <HandleRadioRxErrorTimeout+0xec>)
 802b2c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802b2c4:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 802b2c6:	f002 f9f3 	bl	802d6b0 <LoRaMacClassBIsBeaconExpected>
 802b2ca:	1e04      	subs	r4, r0, #0
 802b2cc:	d122      	bne.n	802b314 <HandleRadioRxErrorTimeout+0x64>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802b2ce:	4a32      	ldr	r2, [pc, #200]	; (802b398 <HandleRadioRxErrorTimeout+0xe8>)
 802b2d0:	23fc      	movs	r3, #252	; 0xfc
 802b2d2:	5cd3      	ldrb	r3, [r2, r3]
 802b2d4:	2b01      	cmp	r3, #1
 802b2d6:	d024      	beq.n	802b322 <HandleRadioRxErrorTimeout+0x72>
    if( classBRx == false )
 802b2d8:	2c00      	cmp	r4, #0
 802b2da:	d118      	bne.n	802b30e <HandleRadioRxErrorTimeout+0x5e>
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 802b2dc:	4a30      	ldr	r2, [pc, #192]	; (802b3a0 <HandleRadioRxErrorTimeout+0xf0>)
 802b2de:	2390      	movs	r3, #144	; 0x90
 802b2e0:	00db      	lsls	r3, r3, #3
 802b2e2:	5cd3      	ldrb	r3, [r2, r3]
 802b2e4:	2b00      	cmp	r3, #0
 802b2e6:	d140      	bne.n	802b36a <HandleRadioRxErrorTimeout+0xba>
            if( MacCtx.NodeAckRequested == true )
 802b2e8:	4b2e      	ldr	r3, [pc, #184]	; (802b3a4 <HandleRadioRxErrorTimeout+0xf4>)
 802b2ea:	5cd3      	ldrb	r3, [r2, r3]
 802b2ec:	2b00      	cmp	r3, #0
 802b2ee:	d001      	beq.n	802b2f4 <HandleRadioRxErrorTimeout+0x44>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 802b2f0:	4b2d      	ldr	r3, [pc, #180]	; (802b3a8 <HandleRadioRxErrorTimeout+0xf8>)
 802b2f2:	54d6      	strb	r6, [r2, r3]
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 802b2f4:	0030      	movs	r0, r6
 802b2f6:	f002 fc43 	bl	802db80 <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 802b2fa:	4b27      	ldr	r3, [pc, #156]	; (802b398 <HandleRadioRxErrorTimeout+0xe8>)
 802b2fc:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 802b2fe:	f008 ff0d 	bl	803411c <UTIL_TIMER_GetElapsedTime>
 802b302:	4a27      	ldr	r2, [pc, #156]	; (802b3a0 <HandleRadioRxErrorTimeout+0xf0>)
 802b304:	23ed      	movs	r3, #237	; 0xed
 802b306:	009b      	lsls	r3, r3, #2
 802b308:	58d3      	ldr	r3, [r2, r3]
 802b30a:	4298      	cmp	r0, r3
 802b30c:	d220      	bcs.n	802b350 <HandleRadioRxErrorTimeout+0xa0>
    UpdateRxSlotIdleState( );
 802b30e:	f7fe fe2b 	bl	8029f68 <UpdateRxSlotIdleState>
}
 802b312:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 802b314:	2002      	movs	r0, #2
 802b316:	f002 f9c1 	bl	802d69c <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 802b31a:	2000      	movs	r0, #0
 802b31c:	f002 f9c3 	bl	802d6a6 <LoRaMacClassBBeaconTimerEvent>
        classBRx = true;
 802b320:	e7d5      	b.n	802b2ce <HandleRadioRxErrorTimeout+0x1e>
        if( LoRaMacClassBIsPingExpected( ) == true )
 802b322:	f002 f9c7 	bl	802d6b4 <LoRaMacClassBIsPingExpected>
 802b326:	1e07      	subs	r7, r0, #0
 802b328:	d10a      	bne.n	802b340 <HandleRadioRxErrorTimeout+0x90>
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 802b32a:	f002 f9c5 	bl	802d6b8 <LoRaMacClassBIsMulticastExpected>
 802b32e:	2800      	cmp	r0, #0
 802b330:	d0d2      	beq.n	802b2d8 <HandleRadioRxErrorTimeout+0x28>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b332:	2000      	movs	r0, #0
 802b334:	f002 f9b4 	bl	802d6a0 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 802b338:	2000      	movs	r0, #0
 802b33a:	f002 f9b6 	bl	802d6aa <LoRaMacClassBMulticastSlotTimerEvent>
    if( classBRx == false )
 802b33e:	e7e6      	b.n	802b30e <HandleRadioRxErrorTimeout+0x5e>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b340:	2000      	movs	r0, #0
 802b342:	f002 f9ac 	bl	802d69e <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 802b346:	2000      	movs	r0, #0
 802b348:	f002 f9ae 	bl	802d6a8 <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 802b34c:	003c      	movs	r4, r7
 802b34e:	e7ec      	b.n	802b32a <HandleRadioRxErrorTimeout+0x7a>
                TimerStop( &MacCtx.RxWindowTimer2 );
 802b350:	4c16      	ldr	r4, [pc, #88]	; (802b3ac <HandleRadioRxErrorTimeout+0xfc>)
 802b352:	0020      	movs	r0, r4
 802b354:	f008 ff18 	bl	8034188 <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 802b358:	4b15      	ldr	r3, [pc, #84]	; (802b3b0 <HandleRadioRxErrorTimeout+0x100>)
 802b35a:	469c      	mov	ip, r3
 802b35c:	4464      	add	r4, ip
 802b35e:	4a15      	ldr	r2, [pc, #84]	; (802b3b4 <HandleRadioRxErrorTimeout+0x104>)
 802b360:	5ca3      	ldrb	r3, [r4, r2]
 802b362:	2120      	movs	r1, #32
 802b364:	430b      	orrs	r3, r1
 802b366:	54a3      	strb	r3, [r4, r2]
 802b368:	e7d1      	b.n	802b30e <HandleRadioRxErrorTimeout+0x5e>
            if( MacCtx.NodeAckRequested == true )
 802b36a:	4a0d      	ldr	r2, [pc, #52]	; (802b3a0 <HandleRadioRxErrorTimeout+0xf0>)
 802b36c:	4b0d      	ldr	r3, [pc, #52]	; (802b3a4 <HandleRadioRxErrorTimeout+0xf4>)
 802b36e:	5cd3      	ldrb	r3, [r2, r3]
 802b370:	2b00      	cmp	r3, #0
 802b372:	d001      	beq.n	802b378 <HandleRadioRxErrorTimeout+0xc8>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 802b374:	4b0c      	ldr	r3, [pc, #48]	; (802b3a8 <HandleRadioRxErrorTimeout+0xf8>)
 802b376:	54d5      	strb	r5, [r2, r3]
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 802b378:	0028      	movs	r0, r5
 802b37a:	f002 fc01 	bl	802db80 <LoRaMacConfirmQueueSetStatusCmn>
            if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802b37e:	4a06      	ldr	r2, [pc, #24]	; (802b398 <HandleRadioRxErrorTimeout+0xe8>)
 802b380:	23fc      	movs	r3, #252	; 0xfc
 802b382:	5cd3      	ldrb	r3, [r2, r3]
 802b384:	2b02      	cmp	r3, #2
 802b386:	d0c2      	beq.n	802b30e <HandleRadioRxErrorTimeout+0x5e>
                MacCtx.MacFlags.Bits.MacDone = 1;
 802b388:	4905      	ldr	r1, [pc, #20]	; (802b3a0 <HandleRadioRxErrorTimeout+0xf0>)
 802b38a:	4a0a      	ldr	r2, [pc, #40]	; (802b3b4 <HandleRadioRxErrorTimeout+0x104>)
 802b38c:	5c8b      	ldrb	r3, [r1, r2]
 802b38e:	2020      	movs	r0, #32
 802b390:	4303      	orrs	r3, r0
 802b392:	548b      	strb	r3, [r1, r2]
 802b394:	e7bb      	b.n	802b30e <HandleRadioRxErrorTimeout+0x5e>
 802b396:	46c0      	nop			; (mov r8, r8)
 802b398:	2000aa3c 	.word	0x2000aa3c
 802b39c:	080356b4 	.word	0x080356b4
 802b3a0:	2000a534 	.word	0x2000a534
 802b3a4:	00000414 	.word	0x00000414
 802b3a8:	00000439 	.word	0x00000439
 802b3ac:	2000a8cc 	.word	0x2000a8cc
 802b3b0:	fffffc68 	.word	0xfffffc68
 802b3b4:	00000481 	.word	0x00000481

0802b3b8 <ProcessRadioRxError>:
{
 802b3b8:	b510      	push	{r4, lr}
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 802b3ba:	2106      	movs	r1, #6
 802b3bc:	2005      	movs	r0, #5
 802b3be:	f7ff ff77 	bl	802b2b0 <HandleRadioRxErrorTimeout>
}
 802b3c2:	bd10      	pop	{r4, pc}

0802b3c4 <ProcessRadioRxTimeout>:
{
 802b3c4:	b510      	push	{r4, lr}
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 802b3c6:	2104      	movs	r1, #4
 802b3c8:	2003      	movs	r0, #3
 802b3ca:	f7ff ff71 	bl	802b2b0 <HandleRadioRxErrorTimeout>
}
 802b3ce:	bd10      	pop	{r4, pc}

0802b3d0 <LoRaMacHandleIrqEvents>:
{
 802b3d0:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802b3d2:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802b3d6:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 802b3d8:	4a11      	ldr	r2, [pc, #68]	; (802b420 <LoRaMacHandleIrqEvents+0x50>)
 802b3da:	6813      	ldr	r3, [r2, #0]
    LoRaMacRadioEvents.Value = 0;
 802b3dc:	2000      	movs	r0, #0
 802b3de:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802b3e0:	f381 8810 	msr	PRIMASK, r1
    if( events.Value != 0 )
 802b3e4:	2b00      	cmp	r3, #0
 802b3e6:	d00a      	beq.n	802b3fe <LoRaMacHandleIrqEvents+0x2e>
        if( events.Events.TxDone == 1 )
 802b3e8:	b2dc      	uxtb	r4, r3
 802b3ea:	06db      	lsls	r3, r3, #27
 802b3ec:	d408      	bmi.n	802b400 <LoRaMacHandleIrqEvents+0x30>
        if( events.Events.RxDone == 1 )
 802b3ee:	0723      	lsls	r3, r4, #28
 802b3f0:	d409      	bmi.n	802b406 <LoRaMacHandleIrqEvents+0x36>
        if( events.Events.TxTimeout == 1 )
 802b3f2:	0763      	lsls	r3, r4, #29
 802b3f4:	d40a      	bmi.n	802b40c <LoRaMacHandleIrqEvents+0x3c>
        if( events.Events.RxError == 1 )
 802b3f6:	07a3      	lsls	r3, r4, #30
 802b3f8:	d40b      	bmi.n	802b412 <LoRaMacHandleIrqEvents+0x42>
        if( events.Events.RxTimeout == 1 )
 802b3fa:	07e3      	lsls	r3, r4, #31
 802b3fc:	d40c      	bmi.n	802b418 <LoRaMacHandleIrqEvents+0x48>
}
 802b3fe:	bd10      	pop	{r4, pc}
            ProcessRadioTxDone( );
 802b400:	f7fe ff8c 	bl	802a31c <ProcessRadioTxDone>
 802b404:	e7f3      	b.n	802b3ee <LoRaMacHandleIrqEvents+0x1e>
            ProcessRadioRxDone( );
 802b406:	f7ff fba1 	bl	802ab4c <ProcessRadioRxDone>
 802b40a:	e7f2      	b.n	802b3f2 <LoRaMacHandleIrqEvents+0x22>
            ProcessRadioTxTimeout( );
 802b40c:	f7ff ff04 	bl	802b218 <ProcessRadioTxTimeout>
 802b410:	e7f1      	b.n	802b3f6 <LoRaMacHandleIrqEvents+0x26>
            ProcessRadioRxError( );
 802b412:	f7ff ffd1 	bl	802b3b8 <ProcessRadioRxError>
 802b416:	e7f0      	b.n	802b3fa <LoRaMacHandleIrqEvents+0x2a>
            ProcessRadioRxTimeout( );
 802b418:	f7ff ffd4 	bl	802b3c4 <ProcessRadioRxTimeout>
}
 802b41c:	e7ef      	b.n	802b3fe <LoRaMacHandleIrqEvents+0x2e>
 802b41e:	46c0      	nop			; (mov r8, r8)
 802b420:	2000a530 	.word	0x2000a530

0802b424 <LoRaMacHandleMlmeRequest>:
{
 802b424:	b510      	push	{r4, lr}
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 802b426:	4a18      	ldr	r2, [pc, #96]	; (802b488 <LoRaMacHandleMlmeRequest+0x64>)
 802b428:	4b18      	ldr	r3, [pc, #96]	; (802b48c <LoRaMacHandleMlmeRequest+0x68>)
 802b42a:	5cd3      	ldrb	r3, [r2, r3]
 802b42c:	075b      	lsls	r3, r3, #29
 802b42e:	d400      	bmi.n	802b432 <LoRaMacHandleMlmeRequest+0xe>
}
 802b430:	bd10      	pop	{r4, pc}
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 802b432:	2001      	movs	r0, #1
 802b434:	f002 fbc2 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802b438:	2800      	cmp	r0, #0
 802b43a:	d011      	beq.n	802b460 <LoRaMacHandleMlmeRequest+0x3c>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 802b43c:	2001      	movs	r0, #1
 802b43e:	f002 fb85 	bl	802db4c <LoRaMacConfirmQueueGetStatus>
 802b442:	2800      	cmp	r0, #0
 802b444:	d104      	bne.n	802b450 <LoRaMacHandleMlmeRequest+0x2c>
                MacCtx.ChannelsNbTransCounter = 0;
 802b446:	4a10      	ldr	r2, [pc, #64]	; (802b488 <LoRaMacHandleMlmeRequest+0x64>)
 802b448:	2382      	movs	r3, #130	; 0x82
 802b44a:	00db      	lsls	r3, r3, #3
 802b44c:	2100      	movs	r1, #0
 802b44e:	54d1      	strb	r1, [r2, r3]
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802b450:	490d      	ldr	r1, [pc, #52]	; (802b488 <LoRaMacHandleMlmeRequest+0x64>)
 802b452:	22d0      	movs	r2, #208	; 0xd0
 802b454:	0092      	lsls	r2, r2, #2
 802b456:	2302      	movs	r3, #2
 802b458:	5888      	ldr	r0, [r1, r2]
 802b45a:	4398      	bics	r0, r3
 802b45c:	5088      	str	r0, [r1, r2]
 802b45e:	e7e7      	b.n	802b430 <LoRaMacHandleMlmeRequest+0xc>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 802b460:	2005      	movs	r0, #5
 802b462:	f002 fbab 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
 802b466:	2800      	cmp	r0, #0
 802b468:	d007      	beq.n	802b47a <LoRaMacHandleMlmeRequest+0x56>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802b46a:	4907      	ldr	r1, [pc, #28]	; (802b488 <LoRaMacHandleMlmeRequest+0x64>)
 802b46c:	22d0      	movs	r2, #208	; 0xd0
 802b46e:	0092      	lsls	r2, r2, #2
 802b470:	2302      	movs	r3, #2
 802b472:	5888      	ldr	r0, [r1, r2]
 802b474:	4398      	bics	r0, r3
 802b476:	5088      	str	r0, [r1, r2]
}
 802b478:	e7da      	b.n	802b430 <LoRaMacHandleMlmeRequest+0xc>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 802b47a:	3006      	adds	r0, #6
 802b47c:	f002 fb9e 	bl	802dbbc <LoRaMacConfirmQueueIsCmdActive>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 802b480:	2800      	cmp	r0, #0
 802b482:	d0d5      	beq.n	802b430 <LoRaMacHandleMlmeRequest+0xc>
 802b484:	e7f1      	b.n	802b46a <LoRaMacHandleMlmeRequest+0x46>
 802b486:	46c0      	nop			; (mov r8, r8)
 802b488:	2000a534 	.word	0x2000a534
 802b48c:	00000481 	.word	0x00000481

0802b490 <AckTimeoutRetriesFinalize>:
{
 802b490:	b500      	push	{lr}
 802b492:	b085      	sub	sp, #20
    if( MacCtx.McpsConfirm.AckReceived == false )
 802b494:	4a10      	ldr	r2, [pc, #64]	; (802b4d8 <AckTimeoutRetriesFinalize+0x48>)
 802b496:	4b11      	ldr	r3, [pc, #68]	; (802b4dc <AckTimeoutRetriesFinalize+0x4c>)
 802b498:	5cd3      	ldrb	r3, [r2, r3]
 802b49a:	2b00      	cmp	r3, #0
 802b49c:	d006      	beq.n	802b4ac <AckTimeoutRetriesFinalize+0x1c>
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 802b49e:	4b0e      	ldr	r3, [pc, #56]	; (802b4d8 <AckTimeoutRetriesFinalize+0x48>)
 802b4a0:	4a0f      	ldr	r2, [pc, #60]	; (802b4e0 <AckTimeoutRetriesFinalize+0x50>)
 802b4a2:	5c99      	ldrb	r1, [r3, r2]
 802b4a4:	4a0f      	ldr	r2, [pc, #60]	; (802b4e4 <AckTimeoutRetriesFinalize+0x54>)
 802b4a6:	5499      	strb	r1, [r3, r2]
}
 802b4a8:	b005      	add	sp, #20
 802b4aa:	bd00      	pop	{pc}
        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 802b4ac:	a901      	add	r1, sp, #4
 802b4ae:	3302      	adds	r3, #2
 802b4b0:	720b      	strb	r3, [r1, #8]
        params.NvmGroup1 = &Nvm.RegionGroup1;
 802b4b2:	4b0d      	ldr	r3, [pc, #52]	; (802b4e8 <AckTimeoutRetriesFinalize+0x58>)
 802b4b4:	9301      	str	r3, [sp, #4]
        params.NvmGroup2 = &Nvm.RegionGroup2;
 802b4b6:	001a      	movs	r2, r3
 802b4b8:	32a4      	adds	r2, #164	; 0xa4
 802b4ba:	604a      	str	r2, [r1, #4]
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 802b4bc:	4a0b      	ldr	r2, [pc, #44]	; (802b4ec <AckTimeoutRetriesFinalize+0x5c>)
 802b4be:	4694      	mov	ip, r2
 802b4c0:	4463      	add	r3, ip
 802b4c2:	2240      	movs	r2, #64	; 0x40
 802b4c4:	5c98      	ldrb	r0, [r3, r2]
 802b4c6:	f003 f93a 	bl	802e73e <RegionInitDefaults>
        MacCtx.NodeAckRequested = false;
 802b4ca:	4b03      	ldr	r3, [pc, #12]	; (802b4d8 <AckTimeoutRetriesFinalize+0x48>)
 802b4cc:	2200      	movs	r2, #0
 802b4ce:	4908      	ldr	r1, [pc, #32]	; (802b4f0 <AckTimeoutRetriesFinalize+0x60>)
 802b4d0:	545a      	strb	r2, [r3, r1]
        MacCtx.McpsConfirm.AckReceived = false;
 802b4d2:	4902      	ldr	r1, [pc, #8]	; (802b4dc <AckTimeoutRetriesFinalize+0x4c>)
 802b4d4:	545a      	strb	r2, [r3, r1]
 802b4d6:	e7e2      	b.n	802b49e <AckTimeoutRetriesFinalize+0xe>
 802b4d8:	2000a534 	.word	0x2000a534
 802b4dc:	0000043c 	.word	0x0000043c
 802b4e0:	00000412 	.word	0x00000412
 802b4e4:	0000043d 	.word	0x0000043d
 802b4e8:	2000ac58 	.word	0x2000ac58
 802b4ec:	fffffde4 	.word	0xfffffde4
 802b4f0:	00000414 	.word	0x00000414

0802b4f4 <SerializeTxFrame>:
{
 802b4f4:	b510      	push	{r4, lr}
    switch( MacCtx.TxMsg.Type )
 802b4f6:	4a12      	ldr	r2, [pc, #72]	; (802b540 <SerializeTxFrame+0x4c>)
 802b4f8:	2382      	movs	r3, #130	; 0x82
 802b4fa:	005b      	lsls	r3, r3, #1
 802b4fc:	5cd3      	ldrb	r3, [r2, r3]
 802b4fe:	2b00      	cmp	r3, #0
 802b500:	d003      	beq.n	802b50a <SerializeTxFrame+0x16>
 802b502:	2b04      	cmp	r3, #4
 802b504:	d00c      	beq.n	802b520 <SerializeTxFrame+0x2c>
 802b506:	2003      	movs	r0, #3
}
 802b508:	bd10      	pop	{r4, pc}
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 802b50a:	480e      	ldr	r0, [pc, #56]	; (802b544 <SerializeTxFrame+0x50>)
 802b50c:	f003 f83b 	bl	802e586 <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 802b510:	2800      	cmp	r0, #0
 802b512:	d110      	bne.n	802b536 <SerializeTxFrame+0x42>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;
 802b514:	4b0a      	ldr	r3, [pc, #40]	; (802b540 <SerializeTxFrame+0x4c>)
 802b516:	2286      	movs	r2, #134	; 0x86
 802b518:	0052      	lsls	r2, r2, #1
 802b51a:	5c9a      	ldrb	r2, [r3, r2]
 802b51c:	801a      	strh	r2, [r3, #0]
            break;
 802b51e:	e7f3      	b.n	802b508 <SerializeTxFrame+0x14>
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 802b520:	4808      	ldr	r0, [pc, #32]	; (802b544 <SerializeTxFrame+0x50>)
 802b522:	f003 f866 	bl	802e5f2 <LoRaMacSerializerData>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 802b526:	2800      	cmp	r0, #0
 802b528:	d107      	bne.n	802b53a <SerializeTxFrame+0x46>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 802b52a:	4b05      	ldr	r3, [pc, #20]	; (802b540 <SerializeTxFrame+0x4c>)
 802b52c:	2286      	movs	r2, #134	; 0x86
 802b52e:	0052      	lsls	r2, r2, #1
 802b530:	5c9a      	ldrb	r2, [r3, r2]
 802b532:	801a      	strh	r2, [r3, #0]
            break;
 802b534:	e7e8      	b.n	802b508 <SerializeTxFrame+0x14>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802b536:	2011      	movs	r0, #17
 802b538:	e7e6      	b.n	802b508 <SerializeTxFrame+0x14>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802b53a:	2011      	movs	r0, #17
 802b53c:	e7e4      	b.n	802b508 <SerializeTxFrame+0x14>
 802b53e:	46c0      	nop			; (mov r8, r8)
 802b540:	2000a534 	.word	0x2000a534
 802b544:	2000a63c 	.word	0x2000a63c

0802b548 <ComputeRxWindowParameters>:
{
 802b548:	b5f0      	push	{r4, r5, r6, r7, lr}
 802b54a:	46c6      	mov	lr, r8
 802b54c:	b500      	push	{lr}
 802b54e:	b082      	sub	sp, #8
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802b550:	4c22      	ldr	r4, [pc, #136]	; (802b5dc <ComputeRxWindowParameters+0x94>)
 802b552:	2640      	movs	r6, #64	; 0x40
 802b554:	5da3      	ldrb	r3, [r4, r6]
 802b556:	4698      	mov	r8, r3
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 802b558:	2361      	movs	r3, #97	; 0x61
 802b55a:	56e3      	ldrsb	r3, [r4, r3]
 802b55c:	2239      	movs	r2, #57	; 0x39
 802b55e:	56a2      	ldrsb	r2, [r4, r2]
 802b560:	2175      	movs	r1, #117	; 0x75
 802b562:	5c61      	ldrb	r1, [r4, r1]
 802b564:	4640      	mov	r0, r8
 802b566:	f003 f9de 	bl	802e926 <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802b56a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802b56c:	2748      	movs	r7, #72	; 0x48
 802b56e:	5de2      	ldrb	r2, [r4, r7]
 802b570:	b241      	sxtb	r1, r0
 802b572:	4d1b      	ldr	r5, [pc, #108]	; (802b5e0 <ComputeRxWindowParameters+0x98>)
 802b574:	9500      	str	r5, [sp, #0]
 802b576:	4640      	mov	r0, r8
 802b578:	f003 f91c 	bl	802e7b4 <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802b57c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802b57e:	5de2      	ldrb	r2, [r4, r7]
 802b580:	2168      	movs	r1, #104	; 0x68
 802b582:	5661      	ldrsb	r1, [r4, r1]
 802b584:	5da0      	ldrb	r0, [r4, r6]
 802b586:	002e      	movs	r6, r5
 802b588:	3614      	adds	r6, #20
 802b58a:	9600      	str	r6, [sp, #0]
 802b58c:	f003 f912 	bl	802e7b4 <RegionComputeRxWindowParameters>
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 802b590:	4b14      	ldr	r3, [pc, #80]	; (802b5e4 <ComputeRxWindowParameters+0x9c>)
 802b592:	18eb      	adds	r3, r5, r3
 802b594:	22f1      	movs	r2, #241	; 0xf1
 802b596:	0092      	lsls	r2, r2, #2
 802b598:	5898      	ldr	r0, [r3, r2]
 802b59a:	6d22      	ldr	r2, [r4, #80]	; 0x50
 802b59c:	1812      	adds	r2, r2, r0
 802b59e:	21ec      	movs	r1, #236	; 0xec
 802b5a0:	0089      	lsls	r1, r1, #2
 802b5a2:	505a      	str	r2, [r3, r1]
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 802b5a4:	22f6      	movs	r2, #246	; 0xf6
 802b5a6:	0092      	lsls	r2, r2, #2
 802b5a8:	5899      	ldr	r1, [r3, r2]
 802b5aa:	6d62      	ldr	r2, [r4, #84]	; 0x54
 802b5ac:	1852      	adds	r2, r2, r1
 802b5ae:	25ed      	movs	r5, #237	; 0xed
 802b5b0:	00ad      	lsls	r5, r5, #2
 802b5b2:	515a      	str	r2, [r3, r5]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 802b5b4:	2388      	movs	r3, #136	; 0x88
 802b5b6:	005b      	lsls	r3, r3, #1
 802b5b8:	5ce3      	ldrb	r3, [r4, r3]
 802b5ba:	2b00      	cmp	r3, #0
 802b5bc:	d10a      	bne.n	802b5d4 <ComputeRxWindowParameters+0x8c>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 802b5be:	4a07      	ldr	r2, [pc, #28]	; (802b5dc <ComputeRxWindowParameters+0x94>)
 802b5c0:	6d93      	ldr	r3, [r2, #88]	; 0x58
 802b5c2:	469c      	mov	ip, r3
 802b5c4:	4460      	add	r0, ip
 802b5c6:	4b08      	ldr	r3, [pc, #32]	; (802b5e8 <ComputeRxWindowParameters+0xa0>)
 802b5c8:	24ec      	movs	r4, #236	; 0xec
 802b5ca:	00a4      	lsls	r4, r4, #2
 802b5cc:	5118      	str	r0, [r3, r4]
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 802b5ce:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 802b5d0:	1889      	adds	r1, r1, r2
 802b5d2:	5159      	str	r1, [r3, r5]
}
 802b5d4:	b002      	add	sp, #8
 802b5d6:	bc80      	pop	{r7}
 802b5d8:	46b8      	mov	r8, r7
 802b5da:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802b5dc:	2000aa3c 	.word	0x2000aa3c
 802b5e0:	2000a8ec 	.word	0x2000a8ec
 802b5e4:	fffffc48 	.word	0xfffffc48
 802b5e8:	2000a534 	.word	0x2000a534

0802b5ec <VerifyTxFrame>:
{
 802b5ec:	b510      	push	{r4, lr}
 802b5ee:	b082      	sub	sp, #8
    size_t macCmdsSize = 0;
 802b5f0:	2300      	movs	r3, #0
 802b5f2:	9301      	str	r3, [sp, #4]
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 802b5f4:	4a0e      	ldr	r2, [pc, #56]	; (802b630 <VerifyTxFrame+0x44>)
 802b5f6:	3311      	adds	r3, #17
 802b5f8:	33ff      	adds	r3, #255	; 0xff
 802b5fa:	5cd4      	ldrb	r4, [r2, r3]
 802b5fc:	2c00      	cmp	r4, #0
 802b5fe:	d102      	bne.n	802b606 <VerifyTxFrame+0x1a>
}
 802b600:	0020      	movs	r0, r4
 802b602:	b002      	add	sp, #8
 802b604:	bd10      	pop	{r4, pc}
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 802b606:	a801      	add	r0, sp, #4
 802b608:	f002 f97e 	bl	802d908 <LoRaMacCommandsGetSizeSerializedCmds>
 802b60c:	1e04      	subs	r4, r0, #0
 802b60e:	d10d      	bne.n	802b62c <VerifyTxFrame+0x40>
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 802b610:	9b01      	ldr	r3, [sp, #4]
 802b612:	b2da      	uxtb	r2, r3
 802b614:	4906      	ldr	r1, [pc, #24]	; (802b630 <VerifyTxFrame+0x44>)
 802b616:	2339      	movs	r3, #57	; 0x39
 802b618:	56c9      	ldrsb	r1, [r1, r3]
 802b61a:	4806      	ldr	r0, [pc, #24]	; (802b634 <VerifyTxFrame+0x48>)
 802b61c:	4b06      	ldr	r3, [pc, #24]	; (802b638 <VerifyTxFrame+0x4c>)
 802b61e:	5cc0      	ldrb	r0, [r0, r3]
 802b620:	f7fe fe6a 	bl	802a2f8 <ValidatePayloadLength>
 802b624:	2800      	cmp	r0, #0
 802b626:	d1eb      	bne.n	802b600 <VerifyTxFrame+0x14>
            return LORAMAC_STATUS_LENGTH_ERROR;
 802b628:	2408      	movs	r4, #8
 802b62a:	e7e9      	b.n	802b600 <VerifyTxFrame+0x14>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802b62c:	2413      	movs	r4, #19
 802b62e:	e7e7      	b.n	802b600 <VerifyTxFrame+0x14>
 802b630:	2000aa3c 	.word	0x2000aa3c
 802b634:	2000a534 	.word	0x2000a534
 802b638:	00000237 	.word	0x00000237

0802b63c <SecureFrame>:
{
 802b63c:	b530      	push	{r4, r5, lr}
 802b63e:	b083      	sub	sp, #12
 802b640:	0004      	movs	r4, r0
 802b642:	000d      	movs	r5, r1
    uint32_t fCntUp = 0;
 802b644:	2300      	movs	r3, #0
 802b646:	9301      	str	r3, [sp, #4]
    switch( MacCtx.TxMsg.Type )
 802b648:	4a1d      	ldr	r2, [pc, #116]	; (802b6c0 <SecureFrame+0x84>)
 802b64a:	3305      	adds	r3, #5
 802b64c:	33ff      	adds	r3, #255	; 0xff
 802b64e:	5cd3      	ldrb	r3, [r2, r3]
 802b650:	2b00      	cmp	r3, #0
 802b652:	d004      	beq.n	802b65e <SecureFrame+0x22>
 802b654:	2b04      	cmp	r3, #4
 802b656:	d00d      	beq.n	802b674 <SecureFrame+0x38>
 802b658:	2003      	movs	r0, #3
}
 802b65a:	b003      	add	sp, #12
 802b65c:	bd30      	pop	{r4, r5, pc}
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 802b65e:	4819      	ldr	r0, [pc, #100]	; (802b6c4 <SecureFrame+0x88>)
 802b660:	f002 fd3c 	bl	802e0dc <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 802b664:	2800      	cmp	r0, #0
 802b666:	d125      	bne.n	802b6b4 <SecureFrame+0x78>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;
 802b668:	4b15      	ldr	r3, [pc, #84]	; (802b6c0 <SecureFrame+0x84>)
 802b66a:	2286      	movs	r2, #134	; 0x86
 802b66c:	0052      	lsls	r2, r2, #1
 802b66e:	5c9a      	ldrb	r2, [r3, r2]
 802b670:	801a      	strh	r2, [r3, #0]
            break;
 802b672:	e7f2      	b.n	802b65a <SecureFrame+0x1e>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 802b674:	a801      	add	r0, sp, #4
 802b676:	f002 fcc9 	bl	802e00c <LoRaMacCryptoGetFCntUp>
 802b67a:	2800      	cmp	r0, #0
 802b67c:	d11c      	bne.n	802b6b8 <SecureFrame+0x7c>
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 802b67e:	4a10      	ldr	r2, [pc, #64]	; (802b6c0 <SecureFrame+0x84>)
 802b680:	2382      	movs	r3, #130	; 0x82
 802b682:	00db      	lsls	r3, r3, #3
 802b684:	5cd3      	ldrb	r3, [r2, r3]
 802b686:	2b00      	cmp	r3, #0
 802b688:	d103      	bne.n	802b692 <SecureFrame+0x56>
 802b68a:	4b0f      	ldr	r3, [pc, #60]	; (802b6c8 <SecureFrame+0x8c>)
 802b68c:	5cd3      	ldrb	r3, [r2, r3]
 802b68e:	2b01      	cmp	r3, #1
 802b690:	d902      	bls.n	802b698 <SecureFrame+0x5c>
                fCntUp -= 1;
 802b692:	9b01      	ldr	r3, [sp, #4]
 802b694:	3b01      	subs	r3, #1
 802b696:	9301      	str	r3, [sp, #4]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 802b698:	4b0a      	ldr	r3, [pc, #40]	; (802b6c4 <SecureFrame+0x88>)
 802b69a:	002a      	movs	r2, r5
 802b69c:	0021      	movs	r1, r4
 802b69e:	9801      	ldr	r0, [sp, #4]
 802b6a0:	f002 fd4a 	bl	802e138 <LoRaMacCryptoSecureMessage>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 802b6a4:	2800      	cmp	r0, #0
 802b6a6:	d109      	bne.n	802b6bc <SecureFrame+0x80>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 802b6a8:	4b05      	ldr	r3, [pc, #20]	; (802b6c0 <SecureFrame+0x84>)
 802b6aa:	2286      	movs	r2, #134	; 0x86
 802b6ac:	0052      	lsls	r2, r2, #1
 802b6ae:	5c9a      	ldrb	r2, [r3, r2]
 802b6b0:	801a      	strh	r2, [r3, #0]
            break;
 802b6b2:	e7d2      	b.n	802b65a <SecureFrame+0x1e>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802b6b4:	2011      	movs	r0, #17
 802b6b6:	e7d0      	b.n	802b65a <SecureFrame+0x1e>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 802b6b8:	2012      	movs	r0, #18
 802b6ba:	e7ce      	b.n	802b65a <SecureFrame+0x1e>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802b6bc:	2011      	movs	r0, #17
 802b6be:	e7cc      	b.n	802b65a <SecureFrame+0x1e>
 802b6c0:	2000a534 	.word	0x2000a534
 802b6c4:	2000a63c 	.word	0x2000a63c
 802b6c8:	00000412 	.word	0x00000412

0802b6cc <SendFrameOnChannel>:
{
 802b6cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 802b6ce:	b087      	sub	sp, #28
 802b6d0:	0006      	movs	r6, r0
    int8_t txPower = 0;
 802b6d2:	2300      	movs	r3, #0
 802b6d4:	466a      	mov	r2, sp
 802b6d6:	71d3      	strb	r3, [r2, #7]
    txConfig.Channel = channel;
 802b6d8:	a902      	add	r1, sp, #8
 802b6da:	7008      	strb	r0, [r1, #0]
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802b6dc:	4d32      	ldr	r5, [pc, #200]	; (802b7a8 <SendFrameOnChannel+0xdc>)
 802b6de:	2739      	movs	r7, #57	; 0x39
 802b6e0:	57eb      	ldrsb	r3, [r5, r7]
 802b6e2:	704b      	strb	r3, [r1, #1]
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 802b6e4:	2338      	movs	r3, #56	; 0x38
 802b6e6:	56eb      	ldrsb	r3, [r5, r3]
 802b6e8:	708b      	strb	r3, [r1, #2]
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 802b6ea:	6fab      	ldr	r3, [r5, #120]	; 0x78
 802b6ec:	604b      	str	r3, [r1, #4]
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 802b6ee:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 802b6f0:	608b      	str	r3, [r1, #8]
    txConfig.PktLen = MacCtx.PktBufferLen;
 802b6f2:	4c2e      	ldr	r4, [pc, #184]	; (802b7ac <SendFrameOnChannel+0xe0>)
 802b6f4:	8823      	ldrh	r3, [r4, #0]
 802b6f6:	818b      	strh	r3, [r1, #12]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 802b6f8:	2383      	movs	r3, #131	; 0x83
 802b6fa:	00db      	lsls	r3, r3, #3
 802b6fc:	18e3      	adds	r3, r4, r3
 802b6fe:	2240      	movs	r2, #64	; 0x40
 802b700:	5ca8      	ldrb	r0, [r5, r2]
 802b702:	466a      	mov	r2, sp
 802b704:	3207      	adds	r2, #7
 802b706:	f003 f877 	bl	802e7f8 <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b70a:	4b29      	ldr	r3, [pc, #164]	; (802b7b0 <SendFrameOnChannel+0xe4>)
 802b70c:	2201      	movs	r2, #1
 802b70e:	54e2      	strb	r2, [r4, r3]
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802b710:	5dea      	ldrb	r2, [r5, r7]
 802b712:	4b28      	ldr	r3, [pc, #160]	; (802b7b4 <SendFrameOnChannel+0xe8>)
 802b714:	54e2      	strb	r2, [r4, r3]
    MacCtx.McpsConfirm.TxPower = txPower;
 802b716:	466b      	mov	r3, sp
 802b718:	79da      	ldrb	r2, [r3, #7]
 802b71a:	4b27      	ldr	r3, [pc, #156]	; (802b7b8 <SendFrameOnChannel+0xec>)
 802b71c:	54e2      	strb	r2, [r4, r3]
    MacCtx.McpsConfirm.Channel = channel;
 802b71e:	330d      	adds	r3, #13
 802b720:	50e6      	str	r6, [r4, r3]
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 802b722:	3b30      	subs	r3, #48	; 0x30
 802b724:	58e3      	ldr	r3, [r4, r3]
 802b726:	2288      	movs	r2, #136	; 0x88
 802b728:	00d2      	lsls	r2, r2, #3
 802b72a:	50a3      	str	r3, [r4, r2]
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 802b72c:	3210      	adds	r2, #16
 802b72e:	50a3      	str	r3, [r4, r2]
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 802b730:	f001 ffc4 	bl	802d6bc <LoRaMacClassBIsBeaconModeActive>
 802b734:	2800      	cmp	r0, #0
 802b736:	d129      	bne.n	802b78c <SendFrameOnChannel+0xc0>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802b738:	4a1b      	ldr	r2, [pc, #108]	; (802b7a8 <SendFrameOnChannel+0xdc>)
 802b73a:	23fc      	movs	r3, #252	; 0xfc
 802b73c:	5cd3      	ldrb	r3, [r2, r3]
 802b73e:	2b01      	cmp	r3, #1
 802b740:	d02e      	beq.n	802b7a0 <SendFrameOnChannel+0xd4>
    LoRaMacClassBHaltBeaconing( );
 802b742:	f001 ffbe 	bl	802d6c2 <LoRaMacClassBHaltBeaconing>
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 802b746:	4a19      	ldr	r2, [pc, #100]	; (802b7ac <SendFrameOnChannel+0xe0>)
 802b748:	4b1c      	ldr	r3, [pc, #112]	; (802b7bc <SendFrameOnChannel+0xf0>)
 802b74a:	5cd1      	ldrb	r1, [r2, r3]
 802b74c:	4a16      	ldr	r2, [pc, #88]	; (802b7a8 <SendFrameOnChannel+0xdc>)
 802b74e:	2339      	movs	r3, #57	; 0x39
 802b750:	5cd0      	ldrb	r0, [r2, r3]
 802b752:	f7ff ff73 	bl	802b63c <SecureFrame>
 802b756:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802b758:	d115      	bne.n	802b786 <SendFrameOnChannel+0xba>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 802b75a:	4b14      	ldr	r3, [pc, #80]	; (802b7ac <SendFrameOnChannel+0xe0>)
 802b75c:	21d0      	movs	r1, #208	; 0xd0
 802b75e:	0089      	lsls	r1, r1, #2
 802b760:	2202      	movs	r2, #2
 802b762:	5858      	ldr	r0, [r3, r1]
 802b764:	4302      	orrs	r2, r0
 802b766:	505a      	str	r2, [r3, r1]
    if( MacCtx.NodeAckRequested == false )
 802b768:	4a15      	ldr	r2, [pc, #84]	; (802b7c0 <SendFrameOnChannel+0xf4>)
 802b76a:	5c9b      	ldrb	r3, [r3, r2]
 802b76c:	2b00      	cmp	r3, #0
 802b76e:	d104      	bne.n	802b77a <SendFrameOnChannel+0xae>
        MacCtx.ChannelsNbTransCounter++;
 802b770:	490e      	ldr	r1, [pc, #56]	; (802b7ac <SendFrameOnChannel+0xe0>)
 802b772:	3a04      	subs	r2, #4
 802b774:	5c8b      	ldrb	r3, [r1, r2]
 802b776:	3301      	adds	r3, #1
 802b778:	548b      	strb	r3, [r1, r2]
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 802b77a:	4b12      	ldr	r3, [pc, #72]	; (802b7c4 <SendFrameOnChannel+0xf8>)
 802b77c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802b77e:	480b      	ldr	r0, [pc, #44]	; (802b7ac <SendFrameOnChannel+0xe0>)
 802b780:	7801      	ldrb	r1, [r0, #0]
 802b782:	3002      	adds	r0, #2
 802b784:	4798      	blx	r3
}
 802b786:	0020      	movs	r0, r4
 802b788:	b007      	add	sp, #28
 802b78a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 802b78c:	4a07      	ldr	r2, [pc, #28]	; (802b7ac <SendFrameOnChannel+0xe0>)
 802b78e:	2383      	movs	r3, #131	; 0x83
 802b790:	00db      	lsls	r3, r3, #3
 802b792:	58d0      	ldr	r0, [r2, r3]
 802b794:	f001 ffa4 	bl	802d6e0 <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 802b798:	2800      	cmp	r0, #0
 802b79a:	d0cd      	beq.n	802b738 <SendFrameOnChannel+0x6c>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 802b79c:	2410      	movs	r4, #16
 802b79e:	e7f2      	b.n	802b786 <SendFrameOnChannel+0xba>
        LoRaMacClassBStopRxSlots( );
 802b7a0:	f001 ffa0 	bl	802d6e4 <LoRaMacClassBStopRxSlots>
 802b7a4:	e7cd      	b.n	802b742 <SendFrameOnChannel+0x76>
 802b7a6:	46c0      	nop			; (mov r8, r8)
 802b7a8:	2000aa3c 	.word	0x2000aa3c
 802b7ac:	2000a534 	.word	0x2000a534
 802b7b0:	00000439 	.word	0x00000439
 802b7b4:	0000043a 	.word	0x0000043a
 802b7b8:	0000043b 	.word	0x0000043b
 802b7bc:	00000415 	.word	0x00000415
 802b7c0:	00000414 	.word	0x00000414
 802b7c4:	080356b4 	.word	0x080356b4

0802b7c8 <ScheduleTx>:
{
 802b7c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802b7ca:	b08f      	sub	sp, #60	; 0x3c
 802b7cc:	9003      	str	r0, [sp, #12]
    status = CheckForClassBCollision( );
 802b7ce:	f7ff fd53 	bl	802b278 <CheckForClassBCollision>
 802b7d2:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802b7d4:	d002      	beq.n	802b7dc <ScheduleTx+0x14>
}
 802b7d6:	0020      	movs	r0, r4
 802b7d8:	b00f      	add	sp, #60	; 0x3c
 802b7da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CalculateBackOff( );
 802b7dc:	f7fe fc4e 	bl	802a07c <CalculateBackOff>
    status = SerializeTxFrame( );
 802b7e0:	f7ff fe88 	bl	802b4f4 <SerializeTxFrame>
 802b7e4:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802b7e6:	d1f6      	bne.n	802b7d6 <ScheduleTx+0xe>
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 802b7e8:	4e36      	ldr	r6, [pc, #216]	; (802b8c4 <ScheduleTx+0xfc>)
 802b7ea:	af06      	add	r7, sp, #24
 802b7ec:	6b33      	ldr	r3, [r6, #48]	; 0x30
 802b7ee:	9306      	str	r3, [sp, #24]
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802b7f0:	2339      	movs	r3, #57	; 0x39
 802b7f2:	56f3      	ldrsb	r3, [r6, r3]
 802b7f4:	723b      	strb	r3, [r7, #8]
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 802b7f6:	2380      	movs	r3, #128	; 0x80
 802b7f8:	005b      	lsls	r3, r3, #1
 802b7fa:	5cf3      	ldrb	r3, [r6, r3]
 802b7fc:	72bb      	strb	r3, [r7, #10]
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 802b7fe:	a80c      	add	r0, sp, #48	; 0x30
 802b800:	f008 fbfa 	bl	8033ff8 <SysTimeGetMcuTime>
 802b804:	ad04      	add	r5, sp, #16
 802b806:	0033      	movs	r3, r6
 802b808:	3309      	adds	r3, #9
 802b80a:	33ff      	adds	r3, #255	; 0xff
 802b80c:	681b      	ldr	r3, [r3, #0]
 802b80e:	9300      	str	r3, [sp, #0]
 802b810:	2382      	movs	r3, #130	; 0x82
 802b812:	005b      	lsls	r3, r3, #1
 802b814:	58f3      	ldr	r3, [r6, r3]
 802b816:	990c      	ldr	r1, [sp, #48]	; 0x30
 802b818:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802b81a:	0028      	movs	r0, r5
 802b81c:	f008 fb90 	bl	8033f40 <SysTimeSub>
 802b820:	aa09      	add	r2, sp, #36	; 0x24
 802b822:	cd0a      	ldmia	r5!, {r1, r3}
 802b824:	c20a      	stmia	r2!, {r1, r3}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 802b826:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 802b828:	607b      	str	r3, [r7, #4]
    nextChan.LastTxIsJoinRequest = false;
 802b82a:	2300      	movs	r3, #0
 802b82c:	753b      	strb	r3, [r7, #20]
    nextChan.Joined = true;
 802b82e:	3301      	adds	r3, #1
 802b830:	727b      	strb	r3, [r7, #9]
    nextChan.PktLen = MacCtx.PktBufferLen;
 802b832:	4b25      	ldr	r3, [pc, #148]	; (802b8c8 <ScheduleTx+0x100>)
 802b834:	881b      	ldrh	r3, [r3, #0]
 802b836:	82fb      	strh	r3, [r7, #22]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 802b838:	2388      	movs	r3, #136	; 0x88
 802b83a:	005b      	lsls	r3, r3, #1
 802b83c:	5cf3      	ldrb	r3, [r6, r3]
 802b83e:	2b00      	cmp	r3, #0
 802b840:	d104      	bne.n	802b84c <ScheduleTx+0x84>
        nextChan.LastTxIsJoinRequest = true;
 802b842:	ab06      	add	r3, sp, #24
 802b844:	2201      	movs	r2, #1
 802b846:	751a      	strb	r2, [r3, #20]
        nextChan.Joined = false;
 802b848:	2200      	movs	r2, #0
 802b84a:	725a      	strb	r2, [r3, #9]
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 802b84c:	4b1f      	ldr	r3, [pc, #124]	; (802b8cc <ScheduleTx+0x104>)
 802b84e:	001a      	movs	r2, r3
 802b850:	3a6f      	subs	r2, #111	; 0x6f
 802b852:	491c      	ldr	r1, [pc, #112]	; (802b8c4 <ScheduleTx+0xfc>)
 802b854:	2040      	movs	r0, #64	; 0x40
 802b856:	5c08      	ldrb	r0, [r1, r0]
 802b858:	3130      	adds	r1, #48	; 0x30
 802b85a:	9100      	str	r1, [sp, #0]
 802b85c:	a906      	add	r1, sp, #24
 802b85e:	f003 f841 	bl	802e8e4 <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 802b862:	2800      	cmp	r0, #0
 802b864:	d01b      	beq.n	802b89e <ScheduleTx+0xd6>
        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
 802b866:	280b      	cmp	r0, #11
 802b868:	d127      	bne.n	802b8ba <ScheduleTx+0xf2>
 802b86a:	9b03      	ldr	r3, [sp, #12]
 802b86c:	2b00      	cmp	r3, #0
 802b86e:	d026      	beq.n	802b8be <ScheduleTx+0xf6>
            if( MacCtx.DutyCycleWaitTime != 0 )
 802b870:	4a15      	ldr	r2, [pc, #84]	; (802b8c8 <ScheduleTx+0x100>)
 802b872:	4b17      	ldr	r3, [pc, #92]	; (802b8d0 <ScheduleTx+0x108>)
 802b874:	58d1      	ldr	r1, [r2, r3]
 802b876:	2900      	cmp	r1, #0
 802b878:	d0ad      	beq.n	802b7d6 <ScheduleTx+0xe>
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 802b87a:	0015      	movs	r5, r2
 802b87c:	22d0      	movs	r2, #208	; 0xd0
 802b87e:	0092      	lsls	r2, r2, #2
 802b880:	2320      	movs	r3, #32
 802b882:	58a8      	ldr	r0, [r5, r2]
 802b884:	4303      	orrs	r3, r0
 802b886:	50ab      	str	r3, [r5, r2]
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 802b888:	23da      	movs	r3, #218	; 0xda
 802b88a:	009b      	lsls	r3, r3, #2
 802b88c:	469c      	mov	ip, r3
 802b88e:	4465      	add	r5, ip
 802b890:	0028      	movs	r0, r5
 802b892:	f008 fd21 	bl	80342d8 <UTIL_TIMER_SetPeriod>
                TimerStart( &MacCtx.TxDelayedTimer );
 802b896:	0028      	movs	r0, r5
 802b898:	f008 fcd8 	bl	803424c <UTIL_TIMER_Start>
            return LORAMAC_STATUS_OK;
 802b89c:	e79b      	b.n	802b7d6 <ScheduleTx+0xe>
    ComputeRxWindowParameters( );
 802b89e:	f7ff fe53 	bl	802b548 <ComputeRxWindowParameters>
    status = VerifyTxFrame( );
 802b8a2:	f7ff fea3 	bl	802b5ec <VerifyTxFrame>
 802b8a6:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802b8a8:	d000      	beq.n	802b8ac <ScheduleTx+0xe4>
 802b8aa:	e794      	b.n	802b7d6 <ScheduleTx+0xe>
    return SendFrameOnChannel( MacCtx.Channel );
 802b8ac:	4a06      	ldr	r2, [pc, #24]	; (802b8c8 <ScheduleTx+0x100>)
 802b8ae:	4b09      	ldr	r3, [pc, #36]	; (802b8d4 <ScheduleTx+0x10c>)
 802b8b0:	5cd0      	ldrb	r0, [r2, r3]
 802b8b2:	f7ff ff0b 	bl	802b6cc <SendFrameOnChannel>
 802b8b6:	0004      	movs	r4, r0
 802b8b8:	e78d      	b.n	802b7d6 <ScheduleTx+0xe>
            return status;
 802b8ba:	0004      	movs	r4, r0
 802b8bc:	e78b      	b.n	802b7d6 <ScheduleTx+0xe>
 802b8be:	0004      	movs	r4, r0
 802b8c0:	e789      	b.n	802b7d6 <ScheduleTx+0xe>
 802b8c2:	46c0      	nop			; (mov r8, r8)
 802b8c4:	2000aa3c 	.word	0x2000aa3c
 802b8c8:	2000a534 	.word	0x2000a534
 802b8cc:	2000a9b8 	.word	0x2000a9b8
 802b8d0:	00000484 	.word	0x00000484
 802b8d4:	00000415 	.word	0x00000415

0802b8d8 <OnTxDelayedTimerEvent>:
{
 802b8d8:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.TxDelayedTimer );
 802b8da:	4c14      	ldr	r4, [pc, #80]	; (802b92c <OnTxDelayedTimerEvent+0x54>)
 802b8dc:	0020      	movs	r0, r4
 802b8de:	f008 fc53 	bl	8034188 <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 802b8e2:	4b13      	ldr	r3, [pc, #76]	; (802b930 <OnTxDelayedTimerEvent+0x58>)
 802b8e4:	469c      	mov	ip, r3
 802b8e6:	4464      	add	r4, ip
 802b8e8:	22d0      	movs	r2, #208	; 0xd0
 802b8ea:	0092      	lsls	r2, r2, #2
 802b8ec:	2320      	movs	r3, #32
 802b8ee:	58a1      	ldr	r1, [r4, r2]
 802b8f0:	4399      	bics	r1, r3
 802b8f2:	50a1      	str	r1, [r4, r2]
    switch( ScheduleTx( true ) )
 802b8f4:	2001      	movs	r0, #1
 802b8f6:	f7ff ff67 	bl	802b7c8 <ScheduleTx>
 802b8fa:	2800      	cmp	r0, #0
 802b8fc:	d001      	beq.n	802b902 <OnTxDelayedTimerEvent+0x2a>
 802b8fe:	280b      	cmp	r0, #11
 802b900:	d100      	bne.n	802b904 <OnTxDelayedTimerEvent+0x2c>
}
 802b902:	bd10      	pop	{r4, pc}
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802b904:	4a0b      	ldr	r2, [pc, #44]	; (802b934 <OnTxDelayedTimerEvent+0x5c>)
 802b906:	2339      	movs	r3, #57	; 0x39
 802b908:	5cd1      	ldrb	r1, [r2, r3]
 802b90a:	4b0b      	ldr	r3, [pc, #44]	; (802b938 <OnTxDelayedTimerEvent+0x60>)
 802b90c:	4a0b      	ldr	r2, [pc, #44]	; (802b93c <OnTxDelayedTimerEvent+0x64>)
 802b90e:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 802b910:	4a0b      	ldr	r2, [pc, #44]	; (802b940 <OnTxDelayedTimerEvent+0x68>)
 802b912:	5c99      	ldrb	r1, [r3, r2]
 802b914:	4a0b      	ldr	r2, [pc, #44]	; (802b944 <OnTxDelayedTimerEvent+0x6c>)
 802b916:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 802b918:	4a0b      	ldr	r2, [pc, #44]	; (802b948 <OnTxDelayedTimerEvent+0x70>)
 802b91a:	2109      	movs	r1, #9
 802b91c:	5499      	strb	r1, [r3, r2]
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 802b91e:	2009      	movs	r0, #9
 802b920:	f002 f92e 	bl	802db80 <LoRaMacConfirmQueueSetStatusCmn>
            StopRetransmission( );
 802b924:	f7fe fc56 	bl	802a1d4 <StopRetransmission>
}
 802b928:	e7eb      	b.n	802b902 <OnTxDelayedTimerEvent+0x2a>
 802b92a:	46c0      	nop			; (mov r8, r8)
 802b92c:	2000a89c 	.word	0x2000a89c
 802b930:	fffffc98 	.word	0xfffffc98
 802b934:	2000aa3c 	.word	0x2000aa3c
 802b938:	2000a534 	.word	0x2000a534
 802b93c:	0000043a 	.word	0x0000043a
 802b940:	00000412 	.word	0x00000412
 802b944:	0000043d 	.word	0x0000043d
 802b948:	00000439 	.word	0x00000439

0802b94c <LoRaMacHandleMcpsRequest>:
{
 802b94c:	b510      	push	{r4, lr}
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 802b94e:	4a26      	ldr	r2, [pc, #152]	; (802b9e8 <LoRaMacHandleMcpsRequest+0x9c>)
 802b950:	4b26      	ldr	r3, [pc, #152]	; (802b9ec <LoRaMacHandleMcpsRequest+0xa0>)
 802b952:	5cd3      	ldrb	r3, [r2, r3]
 802b954:	07db      	lsls	r3, r3, #31
 802b956:	d511      	bpl.n	802b97c <LoRaMacHandleMcpsRequest+0x30>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 802b958:	2387      	movs	r3, #135	; 0x87
 802b95a:	00db      	lsls	r3, r3, #3
 802b95c:	5cd3      	ldrb	r3, [r2, r3]
 802b95e:	2b00      	cmp	r3, #0
 802b960:	d005      	beq.n	802b96e <LoRaMacHandleMcpsRequest+0x22>
 802b962:	2b03      	cmp	r3, #3
 802b964:	d003      	beq.n	802b96e <LoRaMacHandleMcpsRequest+0x22>
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 802b966:	2b01      	cmp	r3, #1
 802b968:	d009      	beq.n	802b97e <LoRaMacHandleMcpsRequest+0x32>
        bool waitForRetransmission = false;
 802b96a:	2400      	movs	r4, #0
 802b96c:	e004      	b.n	802b978 <LoRaMacHandleMcpsRequest+0x2c>
            stopRetransmission = CheckRetransUnconfirmedUplink( );
 802b96e:	f7fe fbe9 	bl	802a144 <CheckRetransUnconfirmedUplink>
 802b972:	0004      	movs	r4, r0
        if( stopRetransmission == true )
 802b974:	2c00      	cmp	r4, #0
 802b976:	d118      	bne.n	802b9aa <LoRaMacHandleMcpsRequest+0x5e>
        else if( waitForRetransmission == false )
 802b978:	2c00      	cmp	r4, #0
 802b97a:	d028      	beq.n	802b9ce <LoRaMacHandleMcpsRequest+0x82>
}
 802b97c:	bd10      	pop	{r4, pc}
            if( MacCtx.AckTimeoutRetry == true )
 802b97e:	4a1a      	ldr	r2, [pc, #104]	; (802b9e8 <LoRaMacHandleMcpsRequest+0x9c>)
 802b980:	4b1b      	ldr	r3, [pc, #108]	; (802b9f0 <LoRaMacHandleMcpsRequest+0xa4>)
 802b982:	5cd3      	ldrb	r3, [r2, r3]
 802b984:	2b00      	cmp	r3, #0
 802b986:	d020      	beq.n	802b9ca <LoRaMacHandleMcpsRequest+0x7e>
                stopRetransmission = CheckRetransConfirmedUplink( );
 802b988:	f7fe fc06 	bl	802a198 <CheckRetransConfirmedUplink>
 802b98c:	0004      	movs	r4, r0
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 802b98e:	4a19      	ldr	r2, [pc, #100]	; (802b9f4 <LoRaMacHandleMcpsRequest+0xa8>)
 802b990:	2387      	movs	r3, #135	; 0x87
 802b992:	005b      	lsls	r3, r3, #1
 802b994:	5cd3      	ldrb	r3, [r2, r3]
 802b996:	2b00      	cmp	r3, #0
 802b998:	d1ec      	bne.n	802b974 <LoRaMacHandleMcpsRequest+0x28>
                    if( stopRetransmission == false )
 802b99a:	2800      	cmp	r0, #0
 802b99c:	d102      	bne.n	802b9a4 <LoRaMacHandleMcpsRequest+0x58>
                        AckTimeoutRetriesProcess( );
 802b99e:	f7fe fc65 	bl	802a26c <AckTimeoutRetriesProcess>
 802b9a2:	e7e7      	b.n	802b974 <LoRaMacHandleMcpsRequest+0x28>
                        AckTimeoutRetriesFinalize( );
 802b9a4:	f7ff fd74 	bl	802b490 <AckTimeoutRetriesFinalize>
 802b9a8:	e7e4      	b.n	802b974 <LoRaMacHandleMcpsRequest+0x28>
            TimerStop( &MacCtx.TxDelayedTimer );
 802b9aa:	4c13      	ldr	r4, [pc, #76]	; (802b9f8 <LoRaMacHandleMcpsRequest+0xac>)
 802b9ac:	0020      	movs	r0, r4
 802b9ae:	f008 fbeb 	bl	8034188 <UTIL_TIMER_Stop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 802b9b2:	4b12      	ldr	r3, [pc, #72]	; (802b9fc <LoRaMacHandleMcpsRequest+0xb0>)
 802b9b4:	469c      	mov	ip, r3
 802b9b6:	4464      	add	r4, ip
 802b9b8:	22d0      	movs	r2, #208	; 0xd0
 802b9ba:	0092      	lsls	r2, r2, #2
 802b9bc:	2320      	movs	r3, #32
 802b9be:	58a1      	ldr	r1, [r4, r2]
 802b9c0:	4399      	bics	r1, r3
 802b9c2:	50a1      	str	r1, [r4, r2]
            StopRetransmission( );
 802b9c4:	f7fe fc06 	bl	802a1d4 <StopRetransmission>
 802b9c8:	e7d8      	b.n	802b97c <LoRaMacHandleMcpsRequest+0x30>
                waitForRetransmission = true;
 802b9ca:	2401      	movs	r4, #1
 802b9cc:	e7d4      	b.n	802b978 <LoRaMacHandleMcpsRequest+0x2c>
            MacCtx.MacFlags.Bits.MacDone = 0;
 802b9ce:	4b06      	ldr	r3, [pc, #24]	; (802b9e8 <LoRaMacHandleMcpsRequest+0x9c>)
 802b9d0:	4906      	ldr	r1, [pc, #24]	; (802b9ec <LoRaMacHandleMcpsRequest+0xa0>)
 802b9d2:	5c5a      	ldrb	r2, [r3, r1]
 802b9d4:	2020      	movs	r0, #32
 802b9d6:	4382      	bics	r2, r0
 802b9d8:	545a      	strb	r2, [r3, r1]
            MacCtx.AckTimeoutRetry = false;
 802b9da:	4a05      	ldr	r2, [pc, #20]	; (802b9f0 <LoRaMacHandleMcpsRequest+0xa4>)
 802b9dc:	2100      	movs	r1, #0
 802b9de:	5499      	strb	r1, [r3, r2]
            OnTxDelayedTimerEvent( NULL );
 802b9e0:	2000      	movs	r0, #0
 802b9e2:	f7ff ff79 	bl	802b8d8 <OnTxDelayedTimerEvent>
}
 802b9e6:	e7c9      	b.n	802b97c <LoRaMacHandleMcpsRequest+0x30>
 802b9e8:	2000a534 	.word	0x2000a534
 802b9ec:	00000481 	.word	0x00000481
 802b9f0:	00000413 	.word	0x00000413
 802b9f4:	2000aa3c 	.word	0x2000aa3c
 802b9f8:	2000a89c 	.word	0x2000a89c
 802b9fc:	fffffc98 	.word	0xfffffc98

0802ba00 <LoRaMacHandleRequestEvents>:
{
 802ba00:	b570      	push	{r4, r5, r6, lr}
    if( MacCtx.MacState == LORAMAC_IDLE )
 802ba02:	4a23      	ldr	r2, [pc, #140]	; (802ba90 <LoRaMacHandleRequestEvents+0x90>)
 802ba04:	23d0      	movs	r3, #208	; 0xd0
 802ba06:	009b      	lsls	r3, r3, #2
 802ba08:	58d3      	ldr	r3, [r2, r3]
 802ba0a:	2b00      	cmp	r3, #0
 802ba0c:	d130      	bne.n	802ba70 <LoRaMacHandleRequestEvents+0x70>
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 802ba0e:	4b21      	ldr	r3, [pc, #132]	; (802ba94 <LoRaMacHandleRequestEvents+0x94>)
 802ba10:	5cd4      	ldrb	r4, [r2, r3]
 802ba12:	2301      	movs	r3, #1
 802ba14:	001d      	movs	r5, r3
 802ba16:	4025      	ands	r5, r4
 802ba18:	4223      	tst	r3, r4
 802ba1a:	d005      	beq.n	802ba28 <LoRaMacHandleRequestEvents+0x28>
            MacCtx.MacFlags.Bits.McpsReq = 0;
 802ba1c:	0011      	movs	r1, r2
 802ba1e:	4a1d      	ldr	r2, [pc, #116]	; (802ba94 <LoRaMacHandleRequestEvents+0x94>)
 802ba20:	0023      	movs	r3, r4
 802ba22:	2001      	movs	r0, #1
 802ba24:	4383      	bics	r3, r0
 802ba26:	548b      	strb	r3, [r1, r2]
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 802ba28:	4a19      	ldr	r2, [pc, #100]	; (802ba90 <LoRaMacHandleRequestEvents+0x90>)
 802ba2a:	4b1a      	ldr	r3, [pc, #104]	; (802ba94 <LoRaMacHandleRequestEvents+0x94>)
 802ba2c:	5cd3      	ldrb	r3, [r2, r3]
 802ba2e:	075b      	lsls	r3, r3, #29
 802ba30:	d505      	bpl.n	802ba3e <LoRaMacHandleRequestEvents+0x3e>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 802ba32:	0011      	movs	r1, r2
 802ba34:	4a17      	ldr	r2, [pc, #92]	; (802ba94 <LoRaMacHandleRequestEvents+0x94>)
 802ba36:	5c8b      	ldrb	r3, [r1, r2]
 802ba38:	2004      	movs	r0, #4
 802ba3a:	4383      	bics	r3, r0
 802ba3c:	548b      	strb	r3, [r1, r2]
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 802ba3e:	2001      	movs	r0, #1
 802ba40:	f7fe faa8 	bl	8029f94 <LoRaMacEnableRequests>
        if( reqEvents.Bits.McpsReq == 1 )
 802ba44:	2d00      	cmp	r5, #0
 802ba46:	d009      	beq.n	802ba5c <LoRaMacHandleRequestEvents+0x5c>
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 802ba48:	4811      	ldr	r0, [pc, #68]	; (802ba90 <LoRaMacHandleRequestEvents+0x90>)
 802ba4a:	23d1      	movs	r3, #209	; 0xd1
 802ba4c:	009b      	lsls	r3, r3, #2
 802ba4e:	58c3      	ldr	r3, [r0, r3]
 802ba50:	681b      	ldr	r3, [r3, #0]
 802ba52:	2287      	movs	r2, #135	; 0x87
 802ba54:	00d2      	lsls	r2, r2, #3
 802ba56:	4694      	mov	ip, r2
 802ba58:	4460      	add	r0, ip
 802ba5a:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 802ba5c:	0763      	lsls	r3, r4, #29
 802ba5e:	d408      	bmi.n	802ba72 <LoRaMacHandleRequestEvents+0x72>
        LoRaMacClassBResumeBeaconing( );
 802ba60:	f001 fe30 	bl	802d6c4 <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 802ba64:	490a      	ldr	r1, [pc, #40]	; (802ba90 <LoRaMacHandleRequestEvents+0x90>)
 802ba66:	4a0b      	ldr	r2, [pc, #44]	; (802ba94 <LoRaMacHandleRequestEvents+0x94>)
 802ba68:	5c8b      	ldrb	r3, [r1, r2]
 802ba6a:	2020      	movs	r0, #32
 802ba6c:	4383      	bics	r3, r0
 802ba6e:	548b      	strb	r3, [r1, r2]
}
 802ba70:	bd70      	pop	{r4, r5, r6, pc}
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 802ba72:	4809      	ldr	r0, [pc, #36]	; (802ba98 <LoRaMacHandleRequestEvents+0x98>)
 802ba74:	f002 f8ae 	bl	802dbd4 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 802ba78:	f002 f8dc 	bl	802dc34 <LoRaMacConfirmQueueGetCnt>
 802ba7c:	2800      	cmp	r0, #0
 802ba7e:	d0ef      	beq.n	802ba60 <LoRaMacHandleRequestEvents+0x60>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 802ba80:	4903      	ldr	r1, [pc, #12]	; (802ba90 <LoRaMacHandleRequestEvents+0x90>)
 802ba82:	4a04      	ldr	r2, [pc, #16]	; (802ba94 <LoRaMacHandleRequestEvents+0x94>)
 802ba84:	5c8b      	ldrb	r3, [r1, r2]
 802ba86:	2004      	movs	r0, #4
 802ba88:	4303      	orrs	r3, r0
 802ba8a:	548b      	strb	r3, [r1, r2]
 802ba8c:	e7e8      	b.n	802ba60 <LoRaMacHandleRequestEvents+0x60>
 802ba8e:	46c0      	nop			; (mov r8, r8)
 802ba90:	2000a534 	.word	0x2000a534
 802ba94:	00000481 	.word	0x00000481
 802ba98:	2000a980 	.word	0x2000a980

0802ba9c <LoRaMacHandleScheduleUplinkEvent>:
{
 802ba9c:	b500      	push	{lr}
 802ba9e:	b083      	sub	sp, #12
    if( MacCtx.MacState == LORAMAC_IDLE )
 802baa0:	4a09      	ldr	r2, [pc, #36]	; (802bac8 <LoRaMacHandleScheduleUplinkEvent+0x2c>)
 802baa2:	23d0      	movs	r3, #208	; 0xd0
 802baa4:	009b      	lsls	r3, r3, #2
 802baa6:	58d3      	ldr	r3, [r2, r3]
 802baa8:	2b00      	cmp	r3, #0
 802baaa:	d001      	beq.n	802bab0 <LoRaMacHandleScheduleUplinkEvent+0x14>
}
 802baac:	b003      	add	sp, #12
 802baae:	bd00      	pop	{pc}
        bool isStickyMacCommandPending = false;
 802bab0:	466a      	mov	r2, sp
 802bab2:	71d3      	strb	r3, [r2, #7]
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 802bab4:	1dd0      	adds	r0, r2, #7
 802bab6:	f001 ff6d 	bl	802d994 <LoRaMacCommandsStickyCmdsPending>
        if( isStickyMacCommandPending == true )
 802baba:	466b      	mov	r3, sp
 802babc:	79db      	ldrb	r3, [r3, #7]
 802babe:	2b00      	cmp	r3, #0
 802bac0:	d0f4      	beq.n	802baac <LoRaMacHandleScheduleUplinkEvent+0x10>
            SetMlmeScheduleUplinkIndication( );
 802bac2:	f7fe facf 	bl	802a064 <SetMlmeScheduleUplinkIndication>
}
 802bac6:	e7f1      	b.n	802baac <LoRaMacHandleScheduleUplinkEvent+0x10>
 802bac8:	2000a534 	.word	0x2000a534

0802bacc <LoRaMacHandleNvm>:
{
 802bacc:	b570      	push	{r4, r5, r6, lr}
 802bace:	0004      	movs	r4, r0
    if( MacCtx.MacState != LORAMAC_IDLE )
 802bad0:	4a3a      	ldr	r2, [pc, #232]	; (802bbbc <LoRaMacHandleNvm+0xf0>)
 802bad2:	23d0      	movs	r3, #208	; 0xd0
 802bad4:	009b      	lsls	r3, r3, #2
 802bad6:	58d3      	ldr	r3, [r2, r3]
 802bad8:	2b00      	cmp	r3, #0
 802bada:	d000      	beq.n	802bade <LoRaMacHandleNvm+0x12>
}
 802badc:	bd70      	pop	{r4, r5, r6, pc}
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 802bade:	2124      	movs	r1, #36	; 0x24
 802bae0:	f005 fe7c 	bl	80317dc <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 802bae4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802bae6:	4283      	cmp	r3, r0
 802bae8:	d066      	beq.n	802bbb8 <LoRaMacHandleNvm+0xec>
        nvmData->Crypto.Crc32 = crc;
 802baea:	6260      	str	r0, [r4, #36]	; 0x24
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 802baec:	2501      	movs	r5, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 802baee:	0020      	movs	r0, r4
 802baf0:	3028      	adds	r0, #40	; 0x28
 802baf2:	2114      	movs	r1, #20
 802baf4:	f005 fe72 	bl	80317dc <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 802baf8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 802bafa:	4283      	cmp	r3, r0
 802bafc:	d003      	beq.n	802bb06 <LoRaMacHandleNvm+0x3a>
        nvmData->MacGroup1.Crc32 = crc;
 802bafe:	63e0      	str	r0, [r4, #60]	; 0x3c
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 802bb00:	2302      	movs	r3, #2
 802bb02:	431d      	orrs	r5, r3
 802bb04:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 802bb06:	0020      	movs	r0, r4
 802bb08:	3040      	adds	r0, #64	; 0x40
 802bb0a:	21d4      	movs	r1, #212	; 0xd4
 802bb0c:	f005 fe66 	bl	80317dc <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 802bb10:	238a      	movs	r3, #138	; 0x8a
 802bb12:	005b      	lsls	r3, r3, #1
 802bb14:	58e3      	ldr	r3, [r4, r3]
 802bb16:	4283      	cmp	r3, r0
 802bb18:	d005      	beq.n	802bb26 <LoRaMacHandleNvm+0x5a>
        nvmData->MacGroup2.Crc32 = crc;
 802bb1a:	238a      	movs	r3, #138	; 0x8a
 802bb1c:	005b      	lsls	r3, r3, #1
 802bb1e:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 802bb20:	2304      	movs	r3, #4
 802bb22:	431d      	orrs	r5, r3
 802bb24:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 802bb26:	0020      	movs	r0, r4
 802bb28:	3019      	adds	r0, #25
 802bb2a:	30ff      	adds	r0, #255	; 0xff
 802bb2c:	2180      	movs	r1, #128	; 0x80
 802bb2e:	0049      	lsls	r1, r1, #1
 802bb30:	f005 fe54 	bl	80317dc <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 802bb34:	2386      	movs	r3, #134	; 0x86
 802bb36:	009b      	lsls	r3, r3, #2
 802bb38:	58e3      	ldr	r3, [r4, r3]
 802bb3a:	4283      	cmp	r3, r0
 802bb3c:	d005      	beq.n	802bb4a <LoRaMacHandleNvm+0x7e>
        nvmData->SecureElement.Crc32 = crc;
 802bb3e:	2386      	movs	r3, #134	; 0x86
 802bb40:	009b      	lsls	r3, r3, #2
 802bb42:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 802bb44:	2308      	movs	r3, #8
 802bb46:	431d      	orrs	r5, r3
 802bb48:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 802bb4a:	2387      	movs	r3, #135	; 0x87
 802bb4c:	009b      	lsls	r3, r3, #2
 802bb4e:	18e0      	adds	r0, r4, r3
 802bb50:	21a0      	movs	r1, #160	; 0xa0
 802bb52:	f005 fe43 	bl	80317dc <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 802bb56:	23af      	movs	r3, #175	; 0xaf
 802bb58:	009b      	lsls	r3, r3, #2
 802bb5a:	58e3      	ldr	r3, [r4, r3]
 802bb5c:	4283      	cmp	r3, r0
 802bb5e:	d005      	beq.n	802bb6c <LoRaMacHandleNvm+0xa0>
        nvmData->RegionGroup1.Crc32 = crc;
 802bb60:	23af      	movs	r3, #175	; 0xaf
 802bb62:	009b      	lsls	r3, r3, #2
 802bb64:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 802bb66:	2310      	movs	r3, #16
 802bb68:	431d      	orrs	r5, r3
 802bb6a:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 802bb6c:	23b0      	movs	r3, #176	; 0xb0
 802bb6e:	009b      	lsls	r3, r3, #2
 802bb70:	18e0      	adds	r0, r4, r3
 802bb72:	21de      	movs	r1, #222	; 0xde
 802bb74:	0089      	lsls	r1, r1, #2
 802bb76:	f005 fe31 	bl	80317dc <Crc32>
    if( crc != nvmData->RegionGroup2.Crc32 )
 802bb7a:	23c7      	movs	r3, #199	; 0xc7
 802bb7c:	00db      	lsls	r3, r3, #3
 802bb7e:	58e3      	ldr	r3, [r4, r3]
 802bb80:	4283      	cmp	r3, r0
 802bb82:	d005      	beq.n	802bb90 <LoRaMacHandleNvm+0xc4>
        nvmData->RegionGroup2.Crc32 = crc;
 802bb84:	23c7      	movs	r3, #199	; 0xc7
 802bb86:	00db      	lsls	r3, r3, #3
 802bb88:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 802bb8a:	2320      	movs	r3, #32
 802bb8c:	431d      	orrs	r5, r3
 802bb8e:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 802bb90:	2114      	movs	r1, #20
 802bb92:	4b0b      	ldr	r3, [pc, #44]	; (802bbc0 <LoRaMacHandleNvm+0xf4>)
 802bb94:	18e0      	adds	r0, r4, r3
 802bb96:	f005 fe21 	bl	80317dc <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 802bb9a:	23ca      	movs	r3, #202	; 0xca
 802bb9c:	00db      	lsls	r3, r3, #3
 802bb9e:	58e3      	ldr	r3, [r4, r3]
 802bba0:	4283      	cmp	r3, r0
 802bba2:	d005      	beq.n	802bbb0 <LoRaMacHandleNvm+0xe4>
        nvmData->ClassB.Crc32 = crc;
 802bba4:	23ca      	movs	r3, #202	; 0xca
 802bba6:	00db      	lsls	r3, r3, #3
 802bba8:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 802bbaa:	2340      	movs	r3, #64	; 0x40
 802bbac:	431d      	orrs	r5, r3
 802bbae:	b2ad      	uxth	r5, r5
    CallNvmDataChangeCallback( notifyFlags );
 802bbb0:	0028      	movs	r0, r5
 802bbb2:	f7fe fb3d 	bl	802a230 <CallNvmDataChangeCallback>
 802bbb6:	e791      	b.n	802badc <LoRaMacHandleNvm+0x10>
    uint16_t notifyFlags = LORAMAC_NVM_NOTIFY_FLAG_NONE;
 802bbb8:	2500      	movs	r5, #0
 802bbba:	e798      	b.n	802baee <LoRaMacHandleNvm+0x22>
 802bbbc:	2000a534 	.word	0x2000a534
 802bbc0:	0000063c 	.word	0x0000063c

0802bbc4 <RestoreNvmData>:
{
 802bbc4:	b570      	push	{r4, r5, r6, lr}
 802bbc6:	1e04      	subs	r4, r0, #0
    if( nvm == NULL )
 802bbc8:	d100      	bne.n	802bbcc <RestoreNvmData+0x8>
 802bbca:	e082      	b.n	802bcd2 <RestoreNvmData+0x10e>
    if( MacCtx.MacState != LORAMAC_STOPPED )
 802bbcc:	4a42      	ldr	r2, [pc, #264]	; (802bcd8 <RestoreNvmData+0x114>)
 802bbce:	23d0      	movs	r3, #208	; 0xd0
 802bbd0:	009b      	lsls	r3, r3, #2
 802bbd2:	58d3      	ldr	r3, [r2, r3]
 802bbd4:	2b01      	cmp	r3, #1
 802bbd6:	d001      	beq.n	802bbdc <RestoreNvmData+0x18>
        return LORAMAC_STATUS_BUSY;
 802bbd8:	2001      	movs	r0, #1
}
 802bbda:	bd70      	pop	{r4, r5, r6, pc}
    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -
 802bbdc:	2124      	movs	r1, #36	; 0x24
 802bbde:	f005 fdfd 	bl	80317dc <Crc32>
    if( crc == nvm->Crypto.Crc32 )
 802bbe2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802bbe4:	4283      	cmp	r3, r0
 802bbe6:	d039      	beq.n	802bc5c <RestoreNvmData+0x98>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -
 802bbe8:	0025      	movs	r5, r4
 802bbea:	3528      	adds	r5, #40	; 0x28
 802bbec:	2114      	movs	r1, #20
 802bbee:	0028      	movs	r0, r5
 802bbf0:	f005 fdf4 	bl	80317dc <Crc32>
    if( crc == nvm->MacGroup1.Crc32 )
 802bbf4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 802bbf6:	4283      	cmp	r3, r0
 802bbf8:	d036      	beq.n	802bc68 <RestoreNvmData+0xa4>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -
 802bbfa:	0025      	movs	r5, r4
 802bbfc:	3540      	adds	r5, #64	; 0x40
 802bbfe:	21d4      	movs	r1, #212	; 0xd4
 802bc00:	0028      	movs	r0, r5
 802bc02:	f005 fdeb 	bl	80317dc <Crc32>
    if( crc == nvm->MacGroup2.Crc32 )
 802bc06:	238a      	movs	r3, #138	; 0x8a
 802bc08:	005b      	lsls	r3, r3, #1
 802bc0a:	58e3      	ldr	r3, [r4, r3]
 802bc0c:	4283      	cmp	r3, r0
 802bc0e:	d031      	beq.n	802bc74 <RestoreNvmData+0xb0>
    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -
 802bc10:	0025      	movs	r5, r4
 802bc12:	3519      	adds	r5, #25
 802bc14:	35ff      	adds	r5, #255	; 0xff
 802bc16:	2180      	movs	r1, #128	; 0x80
 802bc18:	0049      	lsls	r1, r1, #1
 802bc1a:	0028      	movs	r0, r5
 802bc1c:	f005 fdde 	bl	80317dc <Crc32>
    if( crc == nvm->SecureElement.Crc32 )
 802bc20:	2386      	movs	r3, #134	; 0x86
 802bc22:	009b      	lsls	r3, r3, #2
 802bc24:	58e3      	ldr	r3, [r4, r3]
 802bc26:	4283      	cmp	r3, r0
 802bc28:	d03f      	beq.n	802bcaa <RestoreNvmData+0xe6>
    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -
 802bc2a:	2387      	movs	r3, #135	; 0x87
 802bc2c:	009b      	lsls	r3, r3, #2
 802bc2e:	18e5      	adds	r5, r4, r3
 802bc30:	21a0      	movs	r1, #160	; 0xa0
 802bc32:	0028      	movs	r0, r5
 802bc34:	f005 fdd2 	bl	80317dc <Crc32>
    if( crc == nvm->RegionGroup1.Crc32 )
 802bc38:	23af      	movs	r3, #175	; 0xaf
 802bc3a:	009b      	lsls	r3, r3, #2
 802bc3c:	58e3      	ldr	r3, [r4, r3]
 802bc3e:	4283      	cmp	r3, r0
 802bc40:	d03a      	beq.n	802bcb8 <RestoreNvmData+0xf4>
    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -
 802bc42:	4b26      	ldr	r3, [pc, #152]	; (802bcdc <RestoreNvmData+0x118>)
 802bc44:	18e5      	adds	r5, r4, r3
 802bc46:	2114      	movs	r1, #20
 802bc48:	0028      	movs	r0, r5
 802bc4a:	f005 fdc7 	bl	80317dc <Crc32>
    if( crc == nvm->ClassB.Crc32 )
 802bc4e:	23ca      	movs	r3, #202	; 0xca
 802bc50:	00db      	lsls	r3, r3, #3
 802bc52:	58e3      	ldr	r3, [r4, r3]
 802bc54:	4283      	cmp	r3, r0
 802bc56:	d035      	beq.n	802bcc4 <RestoreNvmData+0x100>
    return LORAMAC_STATUS_OK;
 802bc58:	2000      	movs	r0, #0
 802bc5a:	e7be      	b.n	802bbda <RestoreNvmData+0x16>
        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,
 802bc5c:	2228      	movs	r2, #40	; 0x28
 802bc5e:	0021      	movs	r1, r4
 802bc60:	481f      	ldr	r0, [pc, #124]	; (802bce0 <RestoreNvmData+0x11c>)
 802bc62:	f005 fd9a 	bl	803179a <memcpy1>
 802bc66:	e7bf      	b.n	802bbe8 <RestoreNvmData+0x24>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,
 802bc68:	2218      	movs	r2, #24
 802bc6a:	0029      	movs	r1, r5
 802bc6c:	481d      	ldr	r0, [pc, #116]	; (802bce4 <RestoreNvmData+0x120>)
 802bc6e:	f005 fd94 	bl	803179a <memcpy1>
 802bc72:	e7c2      	b.n	802bbfa <RestoreNvmData+0x36>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,
 802bc74:	4e1c      	ldr	r6, [pc, #112]	; (802bce8 <RestoreNvmData+0x124>)
 802bc76:	22d8      	movs	r2, #216	; 0xd8
 802bc78:	0029      	movs	r1, r5
 802bc7a:	0030      	movs	r0, r6
 802bc7c:	f005 fd8d 	bl	803179a <memcpy1>
        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 802bc80:	4b15      	ldr	r3, [pc, #84]	; (802bcd8 <RestoreNvmData+0x114>)
 802bc82:	4a1a      	ldr	r2, [pc, #104]	; (802bcec <RestoreNvmData+0x128>)
 802bc84:	5c99      	ldrb	r1, [r3, r2]
 802bc86:	3a35      	subs	r2, #53	; 0x35
 802bc88:	5499      	strb	r1, [r3, r2]
        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 802bc8a:	3204      	adds	r2, #4
 802bc8c:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 802bc8e:	3e40      	subs	r6, #64	; 0x40
 802bc90:	5099      	str	r1, [r3, r2]
        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802bc92:	2275      	movs	r2, #117	; 0x75
 802bc94:	5cb1      	ldrb	r1, [r6, r2]
 802bc96:	22fc      	movs	r2, #252	; 0xfc
 802bc98:	0092      	lsls	r2, r2, #2
 802bc9a:	5499      	strb	r1, [r3, r2]
        MacCtx.RxWindowCConfig.RxContinuous = true;
 802bc9c:	4a14      	ldr	r2, [pc, #80]	; (802bcf0 <RestoreNvmData+0x12c>)
 802bc9e:	2101      	movs	r1, #1
 802bca0:	5499      	strb	r1, [r3, r2]
        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802bca2:	4a14      	ldr	r2, [pc, #80]	; (802bcf4 <RestoreNvmData+0x130>)
 802bca4:	3101      	adds	r1, #1
 802bca6:	5499      	strb	r1, [r3, r2]
 802bca8:	e7b2      	b.n	802bc10 <RestoreNvmData+0x4c>
        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,
 802bcaa:	2282      	movs	r2, #130	; 0x82
 802bcac:	0052      	lsls	r2, r2, #1
 802bcae:	0029      	movs	r1, r5
 802bcb0:	4811      	ldr	r0, [pc, #68]	; (802bcf8 <RestoreNvmData+0x134>)
 802bcb2:	f005 fd72 	bl	803179a <memcpy1>
 802bcb6:	e7b8      	b.n	802bc2a <RestoreNvmData+0x66>
        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,
 802bcb8:	22a4      	movs	r2, #164	; 0xa4
 802bcba:	0029      	movs	r1, r5
 802bcbc:	480f      	ldr	r0, [pc, #60]	; (802bcfc <RestoreNvmData+0x138>)
 802bcbe:	f005 fd6c 	bl	803179a <memcpy1>
 802bcc2:	e7be      	b.n	802bc42 <RestoreNvmData+0x7e>
        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,
 802bcc4:	2218      	movs	r2, #24
 802bcc6:	0029      	movs	r1, r5
 802bcc8:	480d      	ldr	r0, [pc, #52]	; (802bd00 <RestoreNvmData+0x13c>)
 802bcca:	f005 fd66 	bl	803179a <memcpy1>
    return LORAMAC_STATUS_OK;
 802bcce:	2000      	movs	r0, #0
 802bcd0:	e783      	b.n	802bbda <RestoreNvmData+0x16>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802bcd2:	2003      	movs	r0, #3
 802bcd4:	e781      	b.n	802bbda <RestoreNvmData+0x16>
 802bcd6:	46c0      	nop			; (mov r8, r8)
 802bcd8:	2000a534 	.word	0x2000a534
 802bcdc:	0000063c 	.word	0x0000063c
 802bce0:	2000aa3c 	.word	0x2000aa3c
 802bce4:	2000aa64 	.word	0x2000aa64
 802bce8:	2000aa7c 	.word	0x2000aa7c
 802bcec:	00000415 	.word	0x00000415
 802bcf0:	000003f2 	.word	0x000003f2
 802bcf4:	000003f3 	.word	0x000003f3
 802bcf8:	2000ab54 	.word	0x2000ab54
 802bcfc:	2000ac58 	.word	0x2000ac58
 802bd00:	2000b078 	.word	0x2000b078

0802bd04 <OpenContinuousRxCWindow>:
{
 802bd04:	b570      	push	{r4, r5, r6, lr}
 802bd06:	b082      	sub	sp, #8
                                     Nvm.MacGroup2.MacParams.RxCChannel.Datarate,
 802bd08:	4c13      	ldr	r4, [pc, #76]	; (802bd58 <OpenContinuousRxCWindow+0x54>)
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802bd0a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802bd0c:	2248      	movs	r2, #72	; 0x48
 802bd0e:	5ca2      	ldrb	r2, [r4, r2]
 802bd10:	2170      	movs	r1, #112	; 0x70
 802bd12:	5661      	ldrsb	r1, [r4, r1]
 802bd14:	2640      	movs	r6, #64	; 0x40
 802bd16:	5da0      	ldrb	r0, [r4, r6]
 802bd18:	4d10      	ldr	r5, [pc, #64]	; (802bd5c <OpenContinuousRxCWindow+0x58>)
 802bd1a:	9500      	str	r5, [sp, #0]
 802bd1c:	f002 fd4a 	bl	802e7b4 <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802bd20:	4b0f      	ldr	r3, [pc, #60]	; (802bd60 <OpenContinuousRxCWindow+0x5c>)
 802bd22:	18ea      	adds	r2, r5, r3
 802bd24:	4b0f      	ldr	r3, [pc, #60]	; (802bd64 <OpenContinuousRxCWindow+0x60>)
 802bd26:	2102      	movs	r1, #2
 802bd28:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 802bd2a:	4b0f      	ldr	r3, [pc, #60]	; (802bd68 <OpenContinuousRxCWindow+0x64>)
 802bd2c:	3901      	subs	r1, #1
 802bd2e:	54d1      	strb	r1, [r2, r3]
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 802bd30:	332e      	adds	r3, #46	; 0x2e
 802bd32:	469c      	mov	ip, r3
 802bd34:	4462      	add	r2, ip
 802bd36:	5da0      	ldrb	r0, [r4, r6]
 802bd38:	0029      	movs	r1, r5
 802bd3a:	f002 fd4d 	bl	802e7d8 <RegionRxConfig>
 802bd3e:	2800      	cmp	r0, #0
 802bd40:	d008      	beq.n	802bd54 <OpenContinuousRxCWindow+0x50>
        Radio.Rx( 0 ); // Continuous mode
 802bd42:	4b0a      	ldr	r3, [pc, #40]	; (802bd6c <OpenContinuousRxCWindow+0x68>)
 802bd44:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802bd46:	2000      	movs	r0, #0
 802bd48:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 802bd4a:	4b09      	ldr	r3, [pc, #36]	; (802bd70 <OpenContinuousRxCWindow+0x6c>)
 802bd4c:	4a05      	ldr	r2, [pc, #20]	; (802bd64 <OpenContinuousRxCWindow+0x60>)
 802bd4e:	5c99      	ldrb	r1, [r3, r2]
 802bd50:	328d      	adds	r2, #141	; 0x8d
 802bd52:	5499      	strb	r1, [r3, r2]
}
 802bd54:	b002      	add	sp, #8
 802bd56:	bd70      	pop	{r4, r5, r6, pc}
 802bd58:	2000aa3c 	.word	0x2000aa3c
 802bd5c:	2000a914 	.word	0x2000a914
 802bd60:	fffffc20 	.word	0xfffffc20
 802bd64:	000003f3 	.word	0x000003f3
 802bd68:	000003f2 	.word	0x000003f2
 802bd6c:	080356b4 	.word	0x080356b4
 802bd70:	2000a534 	.word	0x2000a534

0802bd74 <RxWindowSetup>:
{
 802bd74:	b510      	push	{r4, lr}
 802bd76:	000c      	movs	r4, r1
    TimerStop( rxTimer );
 802bd78:	f008 fa06 	bl	8034188 <UTIL_TIMER_Stop>
    Radio.Standby( );
 802bd7c:	4b0b      	ldr	r3, [pc, #44]	; (802bdac <RxWindowSetup+0x38>)
 802bd7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802bd80:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 802bd82:	4a0b      	ldr	r2, [pc, #44]	; (802bdb0 <RxWindowSetup+0x3c>)
 802bd84:	2340      	movs	r3, #64	; 0x40
 802bd86:	5cd0      	ldrb	r0, [r2, r3]
 802bd88:	4a0a      	ldr	r2, [pc, #40]	; (802bdb4 <RxWindowSetup+0x40>)
 802bd8a:	0021      	movs	r1, r4
 802bd8c:	f002 fd24 	bl	802e7d8 <RegionRxConfig>
 802bd90:	2800      	cmp	r0, #0
 802bd92:	d009      	beq.n	802bda8 <RxWindowSetup+0x34>
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 802bd94:	4b05      	ldr	r3, [pc, #20]	; (802bdac <RxWindowSetup+0x38>)
 802bd96:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802bd98:	4a05      	ldr	r2, [pc, #20]	; (802bdb0 <RxWindowSetup+0x3c>)
 802bd9a:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 802bd9c:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 802bd9e:	7ce1      	ldrb	r1, [r4, #19]
 802bda0:	4a05      	ldr	r2, [pc, #20]	; (802bdb8 <RxWindowSetup+0x44>)
 802bda2:	2390      	movs	r3, #144	; 0x90
 802bda4:	00db      	lsls	r3, r3, #3
 802bda6:	54d1      	strb	r1, [r2, r3]
}
 802bda8:	bd10      	pop	{r4, pc}
 802bdaa:	46c0      	nop			; (mov r8, r8)
 802bdac:	080356b4 	.word	0x080356b4
 802bdb0:	2000aa3c 	.word	0x2000aa3c
 802bdb4:	2000a954 	.word	0x2000a954
 802bdb8:	2000a534 	.word	0x2000a534

0802bdbc <OnRxWindow2TimerEvent>:
{
 802bdbc:	b510      	push	{r4, lr}
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 802bdbe:	4a14      	ldr	r2, [pc, #80]	; (802be10 <OnRxWindow2TimerEvent+0x54>)
 802bdc0:	2390      	movs	r3, #144	; 0x90
 802bdc2:	00db      	lsls	r3, r3, #3
 802bdc4:	5cd3      	ldrb	r3, [r2, r3]
 802bdc6:	2b00      	cmp	r3, #0
 802bdc8:	d100      	bne.n	802bdcc <OnRxWindow2TimerEvent+0x10>
}
 802bdca:	bd10      	pop	{r4, pc}
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 802bdcc:	0010      	movs	r0, r2
 802bdce:	4b11      	ldr	r3, [pc, #68]	; (802be14 <OnRxWindow2TimerEvent+0x58>)
 802bdd0:	5cd2      	ldrb	r2, [r2, r3]
 802bdd2:	3b49      	subs	r3, #73	; 0x49
 802bdd4:	54c2      	strb	r2, [r0, r3]
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 802bdd6:	4b10      	ldr	r3, [pc, #64]	; (802be18 <OnRxWindow2TimerEvent+0x5c>)
 802bdd8:	22f4      	movs	r2, #244	; 0xf4
 802bdda:	0092      	lsls	r2, r2, #2
 802bddc:	6e59      	ldr	r1, [r3, #100]	; 0x64
 802bdde:	5081      	str	r1, [r0, r2]
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802bde0:	2275      	movs	r2, #117	; 0x75
 802bde2:	5c99      	ldrb	r1, [r3, r2]
 802bde4:	22f7      	movs	r2, #247	; 0xf7
 802bde6:	0092      	lsls	r2, r2, #2
 802bde8:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 802bdea:	2280      	movs	r2, #128	; 0x80
 802bdec:	5c9a      	ldrb	r2, [r3, r2]
 802bdee:	4b0b      	ldr	r3, [pc, #44]	; (802be1c <OnRxWindow2TimerEvent+0x60>)
 802bdf0:	54c2      	strb	r2, [r0, r3]
    MacCtx.RxWindow2Config.RxContinuous = false;
 802bdf2:	4b0b      	ldr	r3, [pc, #44]	; (802be20 <OnRxWindow2TimerEvent+0x64>)
 802bdf4:	2200      	movs	r2, #0
 802bdf6:	54c2      	strb	r2, [r0, r3]
    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;
 802bdf8:	4b0a      	ldr	r3, [pc, #40]	; (802be24 <OnRxWindow2TimerEvent+0x68>)
 802bdfa:	3201      	adds	r2, #1
 802bdfc:	54c2      	strb	r2, [r0, r3]
    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 802bdfe:	3b13      	subs	r3, #19
 802be00:	18c1      	adds	r1, r0, r3
 802be02:	3b34      	subs	r3, #52	; 0x34
 802be04:	469c      	mov	ip, r3
 802be06:	4460      	add	r0, ip
 802be08:	f7ff ffb4 	bl	802bd74 <RxWindowSetup>
 802be0c:	e7dd      	b.n	802bdca <OnRxWindow2TimerEvent+0xe>
 802be0e:	46c0      	nop			; (mov r8, r8)
 802be10:	2000a534 	.word	0x2000a534
 802be14:	00000415 	.word	0x00000415
 802be18:	2000aa3c 	.word	0x2000aa3c
 802be1c:	000003dd 	.word	0x000003dd
 802be20:	000003de 	.word	0x000003de
 802be24:	000003df 	.word	0x000003df

0802be28 <OnRxWindow1TimerEvent>:
{
 802be28:	b510      	push	{r4, lr}
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 802be2a:	4810      	ldr	r0, [pc, #64]	; (802be6c <OnRxWindow1TimerEvent+0x44>)
 802be2c:	4b10      	ldr	r3, [pc, #64]	; (802be70 <OnRxWindow1TimerEvent+0x48>)
 802be2e:	5cc2      	ldrb	r2, [r0, r3]
 802be30:	3b5d      	subs	r3, #93	; 0x5d
 802be32:	54c2      	strb	r2, [r0, r3]
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 802be34:	4b0f      	ldr	r3, [pc, #60]	; (802be74 <OnRxWindow1TimerEvent+0x4c>)
 802be36:	2261      	movs	r2, #97	; 0x61
 802be38:	5699      	ldrsb	r1, [r3, r2]
 802be3a:	4a0f      	ldr	r2, [pc, #60]	; (802be78 <OnRxWindow1TimerEvent+0x50>)
 802be3c:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802be3e:	2275      	movs	r2, #117	; 0x75
 802be40:	5c99      	ldrb	r1, [r3, r2]
 802be42:	22f2      	movs	r2, #242	; 0xf2
 802be44:	0092      	lsls	r2, r2, #2
 802be46:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 802be48:	2280      	movs	r2, #128	; 0x80
 802be4a:	5c9a      	ldrb	r2, [r3, r2]
 802be4c:	4b0b      	ldr	r3, [pc, #44]	; (802be7c <OnRxWindow1TimerEvent+0x54>)
 802be4e:	54c2      	strb	r2, [r0, r3]
    MacCtx.RxWindow1Config.RxContinuous = false;
 802be50:	2300      	movs	r3, #0
 802be52:	4a0b      	ldr	r2, [pc, #44]	; (802be80 <OnRxWindow1TimerEvent+0x58>)
 802be54:	5483      	strb	r3, [r0, r2]
    MacCtx.RxWindow1Config.RxSlot = RX_SLOT_WIN_1;
 802be56:	4a0b      	ldr	r2, [pc, #44]	; (802be84 <OnRxWindow1TimerEvent+0x5c>)
 802be58:	5483      	strb	r3, [r0, r2]
    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 802be5a:	23ee      	movs	r3, #238	; 0xee
 802be5c:	009b      	lsls	r3, r3, #2
 802be5e:	18c1      	adds	r1, r0, r3
 802be60:	3b38      	subs	r3, #56	; 0x38
 802be62:	469c      	mov	ip, r3
 802be64:	4460      	add	r0, ip
 802be66:	f7ff ff85 	bl	802bd74 <RxWindowSetup>
}
 802be6a:	bd10      	pop	{r4, pc}
 802be6c:	2000a534 	.word	0x2000a534
 802be70:	00000415 	.word	0x00000415
 802be74:	2000aa3c 	.word	0x2000aa3c
 802be78:	000003bb 	.word	0x000003bb
 802be7c:	000003c9 	.word	0x000003c9
 802be80:	000003ca 	.word	0x000003ca
 802be84:	000003cb 	.word	0x000003cb

0802be88 <OnRadioRxTimeout>:
{
 802be88:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 802be8a:	4a0b      	ldr	r2, [pc, #44]	; (802beb8 <OnRadioRxTimeout+0x30>)
 802be8c:	7813      	ldrb	r3, [r2, #0]
 802be8e:	2101      	movs	r1, #1
 802be90:	430b      	orrs	r3, r1
 802be92:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 802be94:	4a09      	ldr	r2, [pc, #36]	; (802bebc <OnRadioRxTimeout+0x34>)
 802be96:	23d2      	movs	r3, #210	; 0xd2
 802be98:	009b      	lsls	r3, r3, #2
 802be9a:	58d3      	ldr	r3, [r2, r3]
 802be9c:	2b00      	cmp	r3, #0
 802be9e:	d003      	beq.n	802bea8 <OnRadioRxTimeout+0x20>
 802bea0:	691b      	ldr	r3, [r3, #16]
 802bea2:	2b00      	cmp	r3, #0
 802bea4:	d000      	beq.n	802bea8 <OnRadioRxTimeout+0x20>
        MacCtx.MacCallbacks->MacProcessNotify( );
 802bea6:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 802bea8:	4b05      	ldr	r3, [pc, #20]	; (802bec0 <OnRadioRxTimeout+0x38>)
 802beaa:	2201      	movs	r2, #1
 802beac:	2100      	movs	r1, #0
 802beae:	2002      	movs	r0, #2
 802beb0:	f007 fe02 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 802beb4:	bd10      	pop	{r4, pc}
 802beb6:	46c0      	nop			; (mov r8, r8)
 802beb8:	2000a530 	.word	0x2000a530
 802bebc:	2000a534 	.word	0x2000a534
 802bec0:	08034ee0 	.word	0x08034ee0

0802bec4 <OnRadioTxTimeout>:
{
 802bec4:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 802bec6:	4a0b      	ldr	r2, [pc, #44]	; (802bef4 <OnRadioTxTimeout+0x30>)
 802bec8:	7813      	ldrb	r3, [r2, #0]
 802beca:	2104      	movs	r1, #4
 802becc:	430b      	orrs	r3, r1
 802bece:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 802bed0:	4a09      	ldr	r2, [pc, #36]	; (802bef8 <OnRadioTxTimeout+0x34>)
 802bed2:	23d2      	movs	r3, #210	; 0xd2
 802bed4:	009b      	lsls	r3, r3, #2
 802bed6:	58d3      	ldr	r3, [r2, r3]
 802bed8:	2b00      	cmp	r3, #0
 802beda:	d003      	beq.n	802bee4 <OnRadioTxTimeout+0x20>
 802bedc:	691b      	ldr	r3, [r3, #16]
 802bede:	2b00      	cmp	r3, #0
 802bee0:	d000      	beq.n	802bee4 <OnRadioTxTimeout+0x20>
        MacCtx.MacCallbacks->MacProcessNotify( );
 802bee2:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 802bee4:	4b05      	ldr	r3, [pc, #20]	; (802befc <OnRadioTxTimeout+0x38>)
 802bee6:	2201      	movs	r2, #1
 802bee8:	2100      	movs	r1, #0
 802beea:	2002      	movs	r0, #2
 802beec:	f007 fde4 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 802bef0:	bd10      	pop	{r4, pc}
 802bef2:	46c0      	nop			; (mov r8, r8)
 802bef4:	2000a530 	.word	0x2000a530
 802bef8:	2000a534 	.word	0x2000a534
 802befc:	08034ef0 	.word	0x08034ef0

0802bf00 <OnRadioRxDone>:
{
 802bf00:	b5f0      	push	{r4, r5, r6, r7, lr}
 802bf02:	46c6      	mov	lr, r8
 802bf04:	b500      	push	{lr}
 802bf06:	4680      	mov	r8, r0
 802bf08:	000f      	movs	r7, r1
 802bf0a:	0016      	movs	r6, r2
 802bf0c:	001d      	movs	r5, r3
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 802bf0e:	f008 f8fb 	bl	8034108 <UTIL_TIMER_GetCurrentTime>
 802bf12:	4c0f      	ldr	r4, [pc, #60]	; (802bf50 <OnRadioRxDone+0x50>)
 802bf14:	6020      	str	r0, [r4, #0]
    RxDoneParams.Payload = payload;
 802bf16:	4643      	mov	r3, r8
 802bf18:	6063      	str	r3, [r4, #4]
    RxDoneParams.Size = size;
 802bf1a:	8127      	strh	r7, [r4, #8]
    RxDoneParams.Rssi = rssi;
 802bf1c:	8166      	strh	r6, [r4, #10]
    RxDoneParams.Snr = snr;
 802bf1e:	7325      	strb	r5, [r4, #12]
    LoRaMacRadioEvents.Events.RxDone = 1;
 802bf20:	4a0c      	ldr	r2, [pc, #48]	; (802bf54 <OnRadioRxDone+0x54>)
 802bf22:	7813      	ldrb	r3, [r2, #0]
 802bf24:	2108      	movs	r1, #8
 802bf26:	430b      	orrs	r3, r1
 802bf28:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 802bf2a:	4a0b      	ldr	r2, [pc, #44]	; (802bf58 <OnRadioRxDone+0x58>)
 802bf2c:	23d2      	movs	r3, #210	; 0xd2
 802bf2e:	009b      	lsls	r3, r3, #2
 802bf30:	58d3      	ldr	r3, [r2, r3]
 802bf32:	2b00      	cmp	r3, #0
 802bf34:	d003      	beq.n	802bf3e <OnRadioRxDone+0x3e>
 802bf36:	691b      	ldr	r3, [r3, #16]
 802bf38:	2b00      	cmp	r3, #0
 802bf3a:	d000      	beq.n	802bf3e <OnRadioRxDone+0x3e>
        MacCtx.MacCallbacks->MacProcessNotify( );
 802bf3c:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 802bf3e:	4b07      	ldr	r3, [pc, #28]	; (802bf5c <OnRadioRxDone+0x5c>)
 802bf40:	2201      	movs	r2, #1
 802bf42:	2100      	movs	r1, #0
 802bf44:	2002      	movs	r0, #2
 802bf46:	f007 fdb7 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 802bf4a:	bc80      	pop	{r7}
 802bf4c:	46b8      	mov	r8, r7
 802bf4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802bf50:	2000bcfc 	.word	0x2000bcfc
 802bf54:	2000a530 	.word	0x2000a530
 802bf58:	2000a534 	.word	0x2000a534
 802bf5c:	08034f00 	.word	0x08034f00

0802bf60 <OnRadioTxDone>:
{
 802bf60:	b530      	push	{r4, r5, lr}
 802bf62:	b083      	sub	sp, #12
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 802bf64:	f008 f8d0 	bl	8034108 <UTIL_TIMER_GetCurrentTime>
 802bf68:	4b10      	ldr	r3, [pc, #64]	; (802bfac <OnRadioTxDone+0x4c>)
 802bf6a:	6018      	str	r0, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 802bf6c:	4d10      	ldr	r5, [pc, #64]	; (802bfb0 <OnRadioTxDone+0x50>)
 802bf6e:	466c      	mov	r4, sp
 802bf70:	0020      	movs	r0, r4
 802bf72:	f008 f821 	bl	8033fb8 <SysTimeGet>
 802bf76:	23ce      	movs	r3, #206	; 0xce
 802bf78:	009b      	lsls	r3, r3, #2
 802bf7a:	18eb      	adds	r3, r5, r3
 802bf7c:	cc06      	ldmia	r4!, {r1, r2}
 802bf7e:	c306      	stmia	r3!, {r1, r2}
    LoRaMacRadioEvents.Events.TxDone = 1;
 802bf80:	4a0c      	ldr	r2, [pc, #48]	; (802bfb4 <OnRadioTxDone+0x54>)
 802bf82:	7813      	ldrb	r3, [r2, #0]
 802bf84:	2110      	movs	r1, #16
 802bf86:	430b      	orrs	r3, r1
 802bf88:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 802bf8a:	23d2      	movs	r3, #210	; 0xd2
 802bf8c:	009b      	lsls	r3, r3, #2
 802bf8e:	58eb      	ldr	r3, [r5, r3]
 802bf90:	2b00      	cmp	r3, #0
 802bf92:	d003      	beq.n	802bf9c <OnRadioTxDone+0x3c>
 802bf94:	691b      	ldr	r3, [r3, #16]
 802bf96:	2b00      	cmp	r3, #0
 802bf98:	d000      	beq.n	802bf9c <OnRadioTxDone+0x3c>
        MacCtx.MacCallbacks->MacProcessNotify( );
 802bf9a:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 802bf9c:	4b06      	ldr	r3, [pc, #24]	; (802bfb8 <OnRadioTxDone+0x58>)
 802bf9e:	2201      	movs	r2, #1
 802bfa0:	2100      	movs	r1, #0
 802bfa2:	2002      	movs	r0, #2
 802bfa4:	f007 fd88 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 802bfa8:	b003      	add	sp, #12
 802bfaa:	bd30      	pop	{r4, r5, pc}
 802bfac:	2000bcf8 	.word	0x2000bcf8
 802bfb0:	2000a534 	.word	0x2000a534
 802bfb4:	2000a530 	.word	0x2000a530
 802bfb8:	08034f10 	.word	0x08034f10

0802bfbc <ResetMacParameters>:
{
 802bfbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 802bfbe:	46c6      	mov	lr, r8
 802bfc0:	b500      	push	{lr}
 802bfc2:	b08e      	sub	sp, #56	; 0x38
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 802bfc4:	4c4d      	ldr	r4, [pc, #308]	; (802c0fc <ResetMacParameters+0x140>)
 802bfc6:	2600      	movs	r6, #0
 802bfc8:	2388      	movs	r3, #136	; 0x88
 802bfca:	005b      	lsls	r3, r3, #1
 802bfcc:	54e6      	strb	r6, [r4, r3]
    Nvm.MacGroup1.AdrAckCounter = 0;
 802bfce:	62a6      	str	r6, [r4, #40]	; 0x28
    MacCtx.ChannelsNbTransCounter = 0;
 802bfd0:	4d4b      	ldr	r5, [pc, #300]	; (802c100 <ResetMacParameters+0x144>)
 802bfd2:	2382      	movs	r3, #130	; 0x82
 802bfd4:	00db      	lsls	r3, r3, #3
 802bfd6:	54ee      	strb	r6, [r5, r3]
    MacCtx.AckTimeoutRetries = 1;
 802bfd8:	2301      	movs	r3, #1
 802bfda:	2701      	movs	r7, #1
 802bfdc:	4a49      	ldr	r2, [pc, #292]	; (802c104 <ResetMacParameters+0x148>)
 802bfde:	54ab      	strb	r3, [r5, r2]
    MacCtx.AckTimeoutRetriesCounter = 1;
 802bfe0:	4a49      	ldr	r2, [pc, #292]	; (802c108 <ResetMacParameters+0x14c>)
 802bfe2:	54ab      	strb	r3, [r5, r2]
    MacCtx.AckTimeoutRetry = false;
 802bfe4:	4a49      	ldr	r2, [pc, #292]	; (802c10c <ResetMacParameters+0x150>)
 802bfe6:	54ae      	strb	r6, [r5, r2]
    Nvm.MacGroup2.MaxDCycle = 0;
 802bfe8:	22ff      	movs	r2, #255	; 0xff
 802bfea:	54a6      	strb	r6, [r4, r2]
    Nvm.MacGroup2.AggregatedDCycle = 1;
 802bfec:	3203      	adds	r2, #3
 802bfee:	52a3      	strh	r3, [r4, r2]
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 802bff0:	33c3      	adds	r3, #195	; 0xc3
 802bff2:	56e2      	ldrsb	r2, [r4, r3]
 802bff4:	3b8c      	subs	r3, #140	; 0x8c
 802bff6:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup1.ChannelsDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 802bff8:	338d      	adds	r3, #141	; 0x8d
 802bffa:	56e2      	ldrsb	r2, [r4, r3]
 802bffc:	3b8c      	subs	r3, #140	; 0x8c
 802bffe:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 802c000:	3368      	adds	r3, #104	; 0x68
 802c002:	5ce2      	ldrb	r2, [r4, r3]
 802c004:	3b40      	subs	r3, #64	; 0x40
 802c006:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 802c008:	0023      	movs	r3, r4
 802c00a:	3364      	adds	r3, #100	; 0x64
 802c00c:	0022      	movs	r2, r4
 802c00e:	32a4      	adds	r2, #164	; 0xa4
 802c010:	ca03      	ldmia	r2!, {r0, r1}
 802c012:	c303      	stmia	r3!, {r0, r1}
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 802c014:	0023      	movs	r3, r4
 802c016:	336c      	adds	r3, #108	; 0x6c
 802c018:	0022      	movs	r2, r4
 802c01a:	32ac      	adds	r2, #172	; 0xac
 802c01c:	ca03      	ldmia	r2!, {r0, r1}
 802c01e:	c303      	stmia	r3!, {r0, r1}
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 802c020:	23b4      	movs	r3, #180	; 0xb4
 802c022:	5ce2      	ldrb	r2, [r4, r3]
 802c024:	3b40      	subs	r3, #64	; 0x40
 802c026:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.DownlinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime;
 802c028:	3341      	adds	r3, #65	; 0x41
 802c02a:	5ce3      	ldrb	r3, [r4, r3]
 802c02c:	2275      	movs	r2, #117	; 0x75
 802c02e:	4690      	mov	r8, r2
 802c030:	54a3      	strb	r3, [r4, r2]
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 802c032:	23b8      	movs	r3, #184	; 0xb8
 802c034:	58e3      	ldr	r3, [r4, r3]
 802c036:	67a3      	str	r3, [r4, #120]	; 0x78
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 802c038:	23bc      	movs	r3, #188	; 0xbc
 802c03a:	58e3      	ldr	r3, [r4, r3]
 802c03c:	67e3      	str	r3, [r4, #124]	; 0x7c
    MacCtx.NodeAckRequested = false;
 802c03e:	4b34      	ldr	r3, [pc, #208]	; (802c110 <ResetMacParameters+0x154>)
 802c040:	54ee      	strb	r6, [r5, r3]
    Nvm.MacGroup1.SrvAckRequested = false;
 802c042:	233a      	movs	r3, #58	; 0x3a
 802c044:	54e6      	strb	r6, [r4, r3]
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 802c046:	a901      	add	r1, sp, #4
 802c048:	2301      	movs	r3, #1
 802c04a:	720b      	strb	r3, [r1, #8]
    params.NvmGroup1 = &Nvm.RegionGroup1;
 802c04c:	2387      	movs	r3, #135	; 0x87
 802c04e:	009b      	lsls	r3, r3, #2
 802c050:	18e3      	adds	r3, r4, r3
 802c052:	9301      	str	r3, [sp, #4]
    params.NvmGroup2 = &Nvm.RegionGroup2;
 802c054:	23b0      	movs	r3, #176	; 0xb0
 802c056:	009b      	lsls	r3, r3, #2
 802c058:	18e3      	adds	r3, r4, r3
 802c05a:	604b      	str	r3, [r1, #4]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 802c05c:	2340      	movs	r3, #64	; 0x40
 802c05e:	5ce0      	ldrb	r0, [r4, r3]
 802c060:	f002 fb6d 	bl	802e73e <RegionInitDefaults>
    MacCtx.Channel = 0;
 802c064:	4b2b      	ldr	r3, [pc, #172]	; (802c114 <ResetMacParameters+0x158>)
 802c066:	54ee      	strb	r6, [r5, r3]
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 802c068:	3b49      	subs	r3, #73	; 0x49
 802c06a:	54ee      	strb	r6, [r5, r3]
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 802c06c:	3304      	adds	r3, #4
 802c06e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 802c070:	50ea      	str	r2, [r5, r3]
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802c072:	4643      	mov	r3, r8
 802c074:	5ce2      	ldrb	r2, [r4, r3]
 802c076:	23f7      	movs	r3, #247	; 0xf7
 802c078:	009b      	lsls	r3, r3, #2
 802c07a:	54ea      	strb	r2, [r5, r3]
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 802c07c:	2380      	movs	r3, #128	; 0x80
 802c07e:	5ce2      	ldrb	r2, [r4, r3]
 802c080:	4b25      	ldr	r3, [pc, #148]	; (802c118 <ResetMacParameters+0x15c>)
 802c082:	54ea      	strb	r2, [r5, r3]
    MacCtx.RxWindow2Config.RxContinuous = false;
 802c084:	4b25      	ldr	r3, [pc, #148]	; (802c11c <ResetMacParameters+0x160>)
 802c086:	54ee      	strb	r6, [r5, r3]
    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;
 802c088:	4b25      	ldr	r3, [pc, #148]	; (802c120 <ResetMacParameters+0x164>)
 802c08a:	54ef      	strb	r7, [r5, r3]
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 802c08c:	3301      	adds	r3, #1
 802c08e:	18eb      	adds	r3, r5, r3
 802c090:	22f3      	movs	r2, #243	; 0xf3
 802c092:	0092      	lsls	r2, r2, #2
 802c094:	18aa      	adds	r2, r5, r2
 802c096:	ca13      	ldmia	r2!, {r0, r1, r4}
 802c098:	c313      	stmia	r3!, {r0, r1, r4}
 802c09a:	ca03      	ldmia	r2!, {r0, r1}
 802c09c:	c303      	stmia	r3!, {r0, r1}
    MacCtx.RxWindowCConfig.RxContinuous = true;
 802c09e:	4b21      	ldr	r3, [pc, #132]	; (802c124 <ResetMacParameters+0x168>)
 802c0a0:	54ef      	strb	r7, [r5, r3]
    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802c0a2:	4b21      	ldr	r3, [pc, #132]	; (802c128 <ResetMacParameters+0x16c>)
 802c0a4:	2202      	movs	r2, #2
 802c0a6:	54ea      	strb	r2, [r5, r3]
    classBCallbacks.GetTemperatureLevel = NULL;
 802c0a8:	960c      	str	r6, [sp, #48]	; 0x30
    classBCallbacks.MacProcessNotify = NULL;
 802c0aa:	960d      	str	r6, [sp, #52]	; 0x34
    if( MacCtx.MacCallbacks != NULL )
 802c0ac:	3bab      	subs	r3, #171	; 0xab
 802c0ae:	58eb      	ldr	r3, [r5, r3]
 802c0b0:	2b00      	cmp	r3, #0
 802c0b2:	d003      	beq.n	802c0bc <ResetMacParameters+0x100>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 802c0b4:	685a      	ldr	r2, [r3, #4]
 802c0b6:	920c      	str	r2, [sp, #48]	; 0x30
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 802c0b8:	691b      	ldr	r3, [r3, #16]
 802c0ba:	930d      	str	r3, [sp, #52]	; 0x34
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 802c0bc:	4b1b      	ldr	r3, [pc, #108]	; (802c12c <ResetMacParameters+0x170>)
 802c0be:	9304      	str	r3, [sp, #16]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 802c0c0:	001a      	movs	r2, r3
 802c0c2:	3a44      	subs	r2, #68	; 0x44
 802c0c4:	9205      	str	r2, [sp, #20]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 802c0c6:	001a      	movs	r2, r3
 802c0c8:	3a14      	subs	r2, #20
 802c0ca:	9206      	str	r2, [sp, #24]
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 802c0cc:	3321      	adds	r3, #33	; 0x21
 802c0ce:	9307      	str	r3, [sp, #28]
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 802c0d0:	4a17      	ldr	r2, [pc, #92]	; (802c130 <ResetMacParameters+0x174>)
 802c0d2:	9208      	str	r2, [sp, #32]
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 802c0d4:	0013      	movs	r3, r2
 802c0d6:	3b8c      	subs	r3, #140	; 0x8c
 802c0d8:	9309      	str	r3, [sp, #36]	; 0x24
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 802c0da:	0013      	movs	r3, r2
 802c0dc:	3b88      	subs	r3, #136	; 0x88
 802c0de:	930a      	str	r3, [sp, #40]	; 0x28
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 802c0e0:	1d13      	adds	r3, r2, #4
 802c0e2:	930b      	str	r3, [sp, #44]	; 0x2c
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 802c0e4:	23ae      	movs	r3, #174	; 0xae
 802c0e6:	00db      	lsls	r3, r3, #3
 802c0e8:	469c      	mov	ip, r3
 802c0ea:	4462      	add	r2, ip
 802c0ec:	a90c      	add	r1, sp, #48	; 0x30
 802c0ee:	a804      	add	r0, sp, #16
 802c0f0:	f001 fad3 	bl	802d69a <LoRaMacClassBInit>
}
 802c0f4:	b00e      	add	sp, #56	; 0x38
 802c0f6:	bc80      	pop	{r7}
 802c0f8:	46b8      	mov	r8, r7
 802c0fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802c0fc:	2000aa3c 	.word	0x2000aa3c
 802c100:	2000a534 	.word	0x2000a534
 802c104:	00000411 	.word	0x00000411
 802c108:	00000412 	.word	0x00000412
 802c10c:	00000413 	.word	0x00000413
 802c110:	00000414 	.word	0x00000414
 802c114:	00000415 	.word	0x00000415
 802c118:	000003dd 	.word	0x000003dd
 802c11c:	000003de 	.word	0x000003de
 802c120:	000003df 	.word	0x000003df
 802c124:	000003f2 	.word	0x000003f2
 802c128:	000003f3 	.word	0x000003f3
 802c12c:	2000a994 	.word	0x2000a994
 802c130:	2000ab08 	.word	0x2000ab08

0802c134 <SwitchClass>:
{
 802c134:	b570      	push	{r4, r5, r6, lr}
 802c136:	0004      	movs	r4, r0
    switch( Nvm.MacGroup2.DeviceClass )
 802c138:	4a3f      	ldr	r2, [pc, #252]	; (802c238 <SwitchClass+0x104>)
 802c13a:	23fc      	movs	r3, #252	; 0xfc
 802c13c:	5cd5      	ldrb	r5, [r2, r3]
 802c13e:	2d01      	cmp	r5, #1
 802c140:	d066      	beq.n	802c210 <SwitchClass+0xdc>
 802c142:	2d02      	cmp	r5, #2
 802c144:	d100      	bne.n	802c148 <SwitchClass+0x14>
 802c146:	e06b      	b.n	802c220 <SwitchClass+0xec>
 802c148:	2d00      	cmp	r5, #0
 802c14a:	d001      	beq.n	802c150 <SwitchClass+0x1c>
 802c14c:	2003      	movs	r0, #3
}
 802c14e:	bd70      	pop	{r4, r5, r6, pc}
            if( deviceClass == CLASS_A )
 802c150:	2800      	cmp	r0, #0
 802c152:	d104      	bne.n	802c15e <SwitchClass+0x2a>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 802c154:	0013      	movs	r3, r2
 802c156:	326c      	adds	r2, #108	; 0x6c
 802c158:	3364      	adds	r3, #100	; 0x64
 802c15a:	cb03      	ldmia	r3!, {r0, r1}
 802c15c:	c203      	stmia	r2!, {r0, r1}
            if( deviceClass == CLASS_B )
 802c15e:	2c01      	cmp	r4, #1
 802c160:	d021      	beq.n	802c1a6 <SwitchClass+0x72>
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 802c162:	2003      	movs	r0, #3
            if( deviceClass == CLASS_C )
 802c164:	2c02      	cmp	r4, #2
 802c166:	d1f2      	bne.n	802c14e <SwitchClass+0x1a>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 802c168:	4a33      	ldr	r2, [pc, #204]	; (802c238 <SwitchClass+0x104>)
 802c16a:	23fc      	movs	r3, #252	; 0xfc
 802c16c:	54d4      	strb	r4, [r2, r3]
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 802c16e:	4933      	ldr	r1, [pc, #204]	; (802c23c <SwitchClass+0x108>)
 802c170:	23f8      	movs	r3, #248	; 0xf8
 802c172:	009b      	lsls	r3, r3, #2
 802c174:	18cb      	adds	r3, r1, r3
 802c176:	22f3      	movs	r2, #243	; 0xf3
 802c178:	0092      	lsls	r2, r2, #2
 802c17a:	188a      	adds	r2, r1, r2
 802c17c:	ca51      	ldmia	r2!, {r0, r4, r6}
 802c17e:	c351      	stmia	r3!, {r0, r4, r6}
 802c180:	ca11      	ldmia	r2!, {r0, r4}
 802c182:	c311      	stmia	r3!, {r0, r4}
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802c184:	4b2e      	ldr	r3, [pc, #184]	; (802c240 <SwitchClass+0x10c>)
 802c186:	2202      	movs	r2, #2
 802c188:	54ca      	strb	r2, [r1, r3]
                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802c18a:	2300      	movs	r3, #0
 802c18c:	2b00      	cmp	r3, #0
 802c18e:	dd13      	ble.n	802c1b8 <SwitchClass+0x84>
                MacCtx.NodeAckRequested = false;
 802c190:	4a2a      	ldr	r2, [pc, #168]	; (802c23c <SwitchClass+0x108>)
 802c192:	4b2c      	ldr	r3, [pc, #176]	; (802c244 <SwitchClass+0x110>)
 802c194:	2100      	movs	r1, #0
 802c196:	54d1      	strb	r1, [r2, r3]
                Radio.Sleep( );
 802c198:	4b2b      	ldr	r3, [pc, #172]	; (802c248 <SwitchClass+0x114>)
 802c19a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c19c:	4798      	blx	r3
                OpenContinuousRxCWindow( );
 802c19e:	f7ff fdb1 	bl	802bd04 <OpenContinuousRxCWindow>
                status = LORAMAC_STATUS_OK;
 802c1a2:	0028      	movs	r0, r5
 802c1a4:	e7d3      	b.n	802c14e <SwitchClass+0x1a>
                status = LoRaMacClassBSwitchClass( deviceClass );
 802c1a6:	0020      	movs	r0, r4
 802c1a8:	f001 fa8d 	bl	802d6c6 <LoRaMacClassBSwitchClass>
                if( status == LORAMAC_STATUS_OK )
 802c1ac:	2800      	cmp	r0, #0
 802c1ae:	d1d9      	bne.n	802c164 <SwitchClass+0x30>
                    Nvm.MacGroup2.DeviceClass = deviceClass;
 802c1b0:	4a21      	ldr	r2, [pc, #132]	; (802c238 <SwitchClass+0x104>)
 802c1b2:	23fc      	movs	r3, #252	; 0xfc
 802c1b4:	54d4      	strb	r4, [r2, r3]
 802c1b6:	e7d5      	b.n	802c164 <SwitchClass+0x30>
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 802c1b8:	212c      	movs	r1, #44	; 0x2c
 802c1ba:	4359      	muls	r1, r3
 802c1bc:	4a1e      	ldr	r2, [pc, #120]	; (802c238 <SwitchClass+0x104>)
 802c1be:	1852      	adds	r2, r2, r1
 802c1c0:	32d2      	adds	r2, #210	; 0xd2
 802c1c2:	7812      	ldrb	r2, [r2, #0]
 802c1c4:	2a00      	cmp	r2, #0
 802c1c6:	d102      	bne.n	802c1ce <SwitchClass+0x9a>
                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802c1c8:	3301      	adds	r3, #1
 802c1ca:	b25b      	sxtb	r3, r3
 802c1cc:	e7de      	b.n	802c18c <SwitchClass+0x58>
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;
 802c1ce:	4a1a      	ldr	r2, [pc, #104]	; (802c238 <SwitchClass+0x104>)
 802c1d0:	1850      	adds	r0, r2, r1
 802c1d2:	0003      	movs	r3, r0
 802c1d4:	33e8      	adds	r3, #232	; 0xe8
 802c1d6:	6819      	ldr	r1, [r3, #0]
 802c1d8:	66d1      	str	r1, [r2, #108]	; 0x6c
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 802c1da:	30ec      	adds	r0, #236	; 0xec
 802c1dc:	7800      	ldrb	r0, [r0, #0]
 802c1de:	2370      	movs	r3, #112	; 0x70
 802c1e0:	54d0      	strb	r0, [r2, r3]
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 802c1e2:	4b16      	ldr	r3, [pc, #88]	; (802c23c <SwitchClass+0x108>)
 802c1e4:	4819      	ldr	r0, [pc, #100]	; (802c24c <SwitchClass+0x118>)
 802c1e6:	5c1c      	ldrb	r4, [r3, r0]
 802c1e8:	3835      	subs	r0, #53	; 0x35
 802c1ea:	541c      	strb	r4, [r3, r0]
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 802c1ec:	3004      	adds	r0, #4
 802c1ee:	5019      	str	r1, [r3, r0]
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802c1f0:	2175      	movs	r1, #117	; 0x75
 802c1f2:	5c50      	ldrb	r0, [r2, r1]
 802c1f4:	21fc      	movs	r1, #252	; 0xfc
 802c1f6:	0089      	lsls	r1, r1, #2
 802c1f8:	5458      	strb	r0, [r3, r1]
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 802c1fa:	2180      	movs	r1, #128	; 0x80
 802c1fc:	5c51      	ldrb	r1, [r2, r1]
 802c1fe:	4a14      	ldr	r2, [pc, #80]	; (802c250 <SwitchClass+0x11c>)
 802c200:	5499      	strb	r1, [r3, r2]
                        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 802c202:	4a0f      	ldr	r2, [pc, #60]	; (802c240 <SwitchClass+0x10c>)
 802c204:	2103      	movs	r1, #3
 802c206:	5499      	strb	r1, [r3, r2]
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 802c208:	4a12      	ldr	r2, [pc, #72]	; (802c254 <SwitchClass+0x120>)
 802c20a:	3902      	subs	r1, #2
 802c20c:	5499      	strb	r1, [r3, r2]
                        break;
 802c20e:	e7bf      	b.n	802c190 <SwitchClass+0x5c>
            status = LoRaMacClassBSwitchClass( deviceClass );
 802c210:	f001 fa59 	bl	802d6c6 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 802c214:	2800      	cmp	r0, #0
 802c216:	d19a      	bne.n	802c14e <SwitchClass+0x1a>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 802c218:	4a07      	ldr	r2, [pc, #28]	; (802c238 <SwitchClass+0x104>)
 802c21a:	23fc      	movs	r3, #252	; 0xfc
 802c21c:	54d4      	strb	r4, [r2, r3]
 802c21e:	e796      	b.n	802c14e <SwitchClass+0x1a>
            if( deviceClass == CLASS_A )
 802c220:	2800      	cmp	r0, #0
 802c222:	d107      	bne.n	802c234 <SwitchClass+0x100>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 802c224:	4a04      	ldr	r2, [pc, #16]	; (802c238 <SwitchClass+0x104>)
 802c226:	23fc      	movs	r3, #252	; 0xfc
 802c228:	54d0      	strb	r0, [r2, r3]
                Radio.Sleep( );
 802c22a:	4b07      	ldr	r3, [pc, #28]	; (802c248 <SwitchClass+0x114>)
 802c22c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c22e:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 802c230:	0020      	movs	r0, r4
 802c232:	e78c      	b.n	802c14e <SwitchClass+0x1a>
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 802c234:	2003      	movs	r0, #3
 802c236:	e78a      	b.n	802c14e <SwitchClass+0x1a>
 802c238:	2000aa3c 	.word	0x2000aa3c
 802c23c:	2000a534 	.word	0x2000a534
 802c240:	000003f3 	.word	0x000003f3
 802c244:	00000414 	.word	0x00000414
 802c248:	080356b4 	.word	0x080356b4
 802c24c:	00000415 	.word	0x00000415
 802c250:	000003f1 	.word	0x000003f1
 802c254:	000003f2 	.word	0x000003f2

0802c258 <SendReJoinReq>:
{
 802c258:	b510      	push	{r4, lr}
    switch( joinReqType )
 802c25a:	28ff      	cmp	r0, #255	; 0xff
 802c25c:	d003      	beq.n	802c266 <SendReJoinReq+0xe>
    bool allowDelayedTx = true;
 802c25e:	2001      	movs	r0, #1
    status = ScheduleTx( allowDelayedTx );
 802c260:	f7ff fab2 	bl	802b7c8 <ScheduleTx>
}
 802c264:	bd10      	pop	{r4, pc}
            SwitchClass( CLASS_A );
 802c266:	2000      	movs	r0, #0
 802c268:	f7ff ff64 	bl	802c134 <SwitchClass>
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 802c26c:	4c11      	ldr	r4, [pc, #68]	; (802c2b4 <SendReJoinReq+0x5c>)
 802c26e:	2382      	movs	r3, #130	; 0x82
 802c270:	005b      	lsls	r3, r3, #1
 802c272:	2200      	movs	r2, #0
 802c274:	54e2      	strb	r2, [r4, r3]
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 802c276:	1ca2      	adds	r2, r4, #2
 802c278:	3304      	adds	r3, #4
 802c27a:	50e2      	str	r2, [r4, r3]
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 802c27c:	3304      	adds	r3, #4
 802c27e:	22ff      	movs	r2, #255	; 0xff
 802c280:	54e2      	strb	r2, [r4, r3]
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 802c282:	2200      	movs	r2, #0
 802c284:	230e      	movs	r3, #14
 802c286:	33ff      	adds	r3, #255	; 0xff
 802c288:	54e2      	strb	r2, [r4, r3]
            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );
 802c28a:	f005 fa59 	bl	8031740 <SecureElementGetJoinEui>
 802c28e:	0001      	movs	r1, r0
 802c290:	0020      	movs	r0, r4
 802c292:	300f      	adds	r0, #15
 802c294:	30ff      	adds	r0, #255	; 0xff
 802c296:	2208      	movs	r2, #8
 802c298:	f005 fa7f 	bl	803179a <memcpy1>
            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );
 802c29c:	f005 fa3a 	bl	8031714 <SecureElementGetDevEui>
 802c2a0:	0001      	movs	r1, r0
 802c2a2:	0020      	movs	r0, r4
 802c2a4:	3017      	adds	r0, #23
 802c2a6:	30ff      	adds	r0, #255	; 0xff
 802c2a8:	2208      	movs	r2, #8
 802c2aa:	f005 fa76 	bl	803179a <memcpy1>
            allowDelayedTx = false;
 802c2ae:	2000      	movs	r0, #0
            break;
 802c2b0:	e7d6      	b.n	802c260 <SendReJoinReq+0x8>
 802c2b2:	46c0      	nop			; (mov r8, r8)
 802c2b4:	2000a534 	.word	0x2000a534

0802c2b8 <SetTxContinuousWave>:
{
 802c2b8:	b510      	push	{r4, lr}
 802c2ba:	b084      	sub	sp, #16
    continuousWave.Channel = MacCtx.Channel;
 802c2bc:	4c0f      	ldr	r4, [pc, #60]	; (802c2fc <SetTxContinuousWave+0x44>)
 802c2be:	4b10      	ldr	r3, [pc, #64]	; (802c300 <SetTxContinuousWave+0x48>)
 802c2c0:	5ce3      	ldrb	r3, [r4, r3]
 802c2c2:	466a      	mov	r2, sp
 802c2c4:	7013      	strb	r3, [r2, #0]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802c2c6:	4b0f      	ldr	r3, [pc, #60]	; (802c304 <SetTxContinuousWave+0x4c>)
 802c2c8:	2239      	movs	r2, #57	; 0x39
 802c2ca:	569a      	ldrsb	r2, [r3, r2]
 802c2cc:	4669      	mov	r1, sp
 802c2ce:	704a      	strb	r2, [r1, #1]
    continuousWave.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 802c2d0:	2238      	movs	r2, #56	; 0x38
 802c2d2:	569a      	ldrsb	r2, [r3, r2]
 802c2d4:	708a      	strb	r2, [r1, #2]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 802c2d6:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 802c2d8:	9201      	str	r2, [sp, #4]
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 802c2da:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 802c2dc:	9202      	str	r2, [sp, #8]
    continuousWave.Timeout = timeout;
 802c2de:	8188      	strh	r0, [r1, #12]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 802c2e0:	2240      	movs	r2, #64	; 0x40
 802c2e2:	5c98      	ldrb	r0, [r3, r2]
 802c2e4:	f002 fb11 	bl	802e90a <RegionSetContinuousWave>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 802c2e8:	22d0      	movs	r2, #208	; 0xd0
 802c2ea:	0092      	lsls	r2, r2, #2
 802c2ec:	2302      	movs	r3, #2
 802c2ee:	58a1      	ldr	r1, [r4, r2]
 802c2f0:	430b      	orrs	r3, r1
 802c2f2:	50a3      	str	r3, [r4, r2]
}
 802c2f4:	2000      	movs	r0, #0
 802c2f6:	b004      	add	sp, #16
 802c2f8:	bd10      	pop	{r4, pc}
 802c2fa:	46c0      	nop			; (mov r8, r8)
 802c2fc:	2000a534 	.word	0x2000a534
 802c300:	00000415 	.word	0x00000415
 802c304:	2000aa3c 	.word	0x2000aa3c

0802c308 <PrepareFrame>:
{
 802c308:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c30a:	b085      	sub	sp, #20
 802c30c:	0007      	movs	r7, r0
 802c30e:	9100      	str	r1, [sp, #0]
 802c310:	9201      	str	r2, [sp, #4]
 802c312:	001e      	movs	r6, r3
 802c314:	ab0a      	add	r3, sp, #40	; 0x28
 802c316:	881c      	ldrh	r4, [r3, #0]
    MacCtx.PktBufferLen = 0;
 802c318:	4a63      	ldr	r2, [pc, #396]	; (802c4a8 <PrepareFrame+0x1a0>)
 802c31a:	2300      	movs	r3, #0
 802c31c:	8013      	strh	r3, [r2, #0]
    MacCtx.NodeAckRequested = false;
 802c31e:	2000      	movs	r0, #0
 802c320:	4962      	ldr	r1, [pc, #392]	; (802c4ac <PrepareFrame+0x1a4>)
 802c322:	5450      	strb	r0, [r2, r1]
    uint32_t fCntUp = 0;
 802c324:	9303      	str	r3, [sp, #12]
    size_t macCmdsSize = 0;
 802c326:	9302      	str	r3, [sp, #8]
    if( fBuffer == NULL )
 802c328:	2e00      	cmp	r6, #0
 802c32a:	d019      	beq.n	802c360 <PrepareFrame+0x58>
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 802c32c:	4d60      	ldr	r5, [pc, #384]	; (802c4b0 <PrepareFrame+0x1a8>)
 802c32e:	0022      	movs	r2, r4
 802c330:	0031      	movs	r1, r6
 802c332:	0028      	movs	r0, r5
 802c334:	f005 fa31 	bl	803179a <memcpy1>
    MacCtx.AppDataSize = fBufferSize;
 802c338:	b2e0      	uxtb	r0, r4
 802c33a:	002b      	movs	r3, r5
 802c33c:	3b39      	subs	r3, #57	; 0x39
 802c33e:	3bff      	subs	r3, #255	; 0xff
 802c340:	4a5c      	ldr	r2, [pc, #368]	; (802c4b4 <PrepareFrame+0x1ac>)
 802c342:	5498      	strb	r0, [r3, r2]
    MacCtx.PktBuffer[0] = macHdr->Value;
 802c344:	783a      	ldrb	r2, [r7, #0]
 802c346:	709a      	strb	r2, [r3, #2]
    switch( macHdr->Bits.MType )
 802c348:	783a      	ldrb	r2, [r7, #0]
 802c34a:	0952      	lsrs	r2, r2, #5
 802c34c:	2a04      	cmp	r2, #4
 802c34e:	d009      	beq.n	802c364 <PrepareFrame+0x5c>
 802c350:	2a07      	cmp	r2, #7
 802c352:	d100      	bne.n	802c356 <PrepareFrame+0x4e>
 802c354:	e08a      	b.n	802c46c <PrepareFrame+0x164>
 802c356:	2a02      	cmp	r2, #2
 802c358:	d008      	beq.n	802c36c <PrepareFrame+0x64>
 802c35a:	2002      	movs	r0, #2
}
 802c35c:	b005      	add	sp, #20
 802c35e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        fBufferSize = 0;
 802c360:	2400      	movs	r4, #0
 802c362:	e7e3      	b.n	802c32c <PrepareFrame+0x24>
            MacCtx.NodeAckRequested = true;
 802c364:	4a50      	ldr	r2, [pc, #320]	; (802c4a8 <PrepareFrame+0x1a0>)
 802c366:	4b51      	ldr	r3, [pc, #324]	; (802c4ac <PrepareFrame+0x1a4>)
 802c368:	2101      	movs	r1, #1
 802c36a:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 802c36c:	4b4e      	ldr	r3, [pc, #312]	; (802c4a8 <PrepareFrame+0x1a0>)
 802c36e:	2282      	movs	r2, #130	; 0x82
 802c370:	0052      	lsls	r2, r2, #1
 802c372:	2104      	movs	r1, #4
 802c374:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 802c376:	1c99      	adds	r1, r3, #2
 802c378:	3204      	adds	r2, #4
 802c37a:	5099      	str	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 802c37c:	3204      	adds	r2, #4
 802c37e:	21ff      	movs	r1, #255	; 0xff
 802c380:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 802c382:	7839      	ldrb	r1, [r7, #0]
 802c384:	220e      	movs	r2, #14
 802c386:	32ff      	adds	r2, #255	; 0xff
 802c388:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 802c38a:	321b      	adds	r2, #27
 802c38c:	9901      	ldr	r1, [sp, #4]
 802c38e:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 802c390:	4949      	ldr	r1, [pc, #292]	; (802c4b8 <PrepareFrame+0x1b0>)
 802c392:	3a5c      	subs	r2, #92	; 0x5c
 802c394:	5889      	ldr	r1, [r1, r2]
 802c396:	3244      	adds	r2, #68	; 0x44
 802c398:	5099      	str	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 802c39a:	9a00      	ldr	r2, [sp, #0]
 802c39c:	7811      	ldrb	r1, [r2, #0]
 802c39e:	228a      	movs	r2, #138	; 0x8a
 802c3a0:	0052      	lsls	r2, r2, #1
 802c3a2:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 802c3a4:	321c      	adds	r2, #28
 802c3a6:	5498      	strb	r0, [r3, r2]
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 802c3a8:	0019      	movs	r1, r3
 802c3aa:	3139      	adds	r1, #57	; 0x39
 802c3ac:	31ff      	adds	r1, #255	; 0xff
 802c3ae:	3a04      	subs	r2, #4
 802c3b0:	5099      	str	r1, [r3, r2]
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 802c3b2:	a803      	add	r0, sp, #12
 802c3b4:	f001 fe2a 	bl	802e00c <LoRaMacCryptoGetFCntUp>
 802c3b8:	2800      	cmp	r0, #0
 802c3ba:	d169      	bne.n	802c490 <PrepareFrame+0x188>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 802c3bc:	9a03      	ldr	r2, [sp, #12]
 802c3be:	4b3a      	ldr	r3, [pc, #232]	; (802c4a8 <PrepareFrame+0x1a0>)
 802c3c0:	218b      	movs	r1, #139	; 0x8b
 802c3c2:	0049      	lsls	r1, r1, #1
 802c3c4:	525a      	strh	r2, [r3, r1]
            MacCtx.McpsConfirm.NbRetries = 0;
 802c3c6:	2100      	movs	r1, #0
 802c3c8:	483c      	ldr	r0, [pc, #240]	; (802c4bc <PrepareFrame+0x1b4>)
 802c3ca:	5419      	strb	r1, [r3, r0]
            MacCtx.McpsConfirm.AckReceived = false;
 802c3cc:	483c      	ldr	r0, [pc, #240]	; (802c4c0 <PrepareFrame+0x1b8>)
 802c3ce:	5419      	strb	r1, [r3, r0]
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 802c3d0:	493c      	ldr	r1, [pc, #240]	; (802c4c4 <PrepareFrame+0x1bc>)
 802c3d2:	505a      	str	r2, [r3, r1]
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 802c3d4:	a802      	add	r0, sp, #8
 802c3d6:	f001 fa97 	bl	802d908 <LoRaMacCommandsGetSizeSerializedCmds>
 802c3da:	2800      	cmp	r0, #0
 802c3dc:	d15a      	bne.n	802c494 <PrepareFrame+0x18c>
            if( macCmdsSize > 0 )
 802c3de:	9b02      	ldr	r3, [sp, #8]
 802c3e0:	2b00      	cmp	r3, #0
 802c3e2:	d0bb      	beq.n	802c35c <PrepareFrame+0x54>
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 802c3e4:	4a34      	ldr	r2, [pc, #208]	; (802c4b8 <PrepareFrame+0x1b0>)
 802c3e6:	2339      	movs	r3, #57	; 0x39
 802c3e8:	56d0      	ldrsb	r0, [r2, r3]
 802c3ea:	f7fd ff69 	bl	802a2c0 <GetMaxAppPayloadWithoutFOptsLength>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 802c3ee:	4a2e      	ldr	r2, [pc, #184]	; (802c4a8 <PrepareFrame+0x1a0>)
 802c3f0:	4b30      	ldr	r3, [pc, #192]	; (802c4b4 <PrepareFrame+0x1ac>)
 802c3f2:	5cd3      	ldrb	r3, [r2, r3]
 802c3f4:	2b00      	cmp	r3, #0
 802c3f6:	d002      	beq.n	802c3fe <PrepareFrame+0xf6>
 802c3f8:	9a02      	ldr	r2, [sp, #8]
 802c3fa:	2a0f      	cmp	r2, #15
 802c3fc:	d919      	bls.n	802c432 <PrepareFrame+0x12a>
                else if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize > LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 802c3fe:	2b00      	cmp	r3, #0
 802c400:	d002      	beq.n	802c408 <PrepareFrame+0x100>
 802c402:	9b02      	ldr	r3, [sp, #8]
 802c404:	2b0f      	cmp	r3, #15
 802c406:	d829      	bhi.n	802c45c <PrepareFrame+0x154>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 802c408:	4a2f      	ldr	r2, [pc, #188]	; (802c4c8 <PrepareFrame+0x1c0>)
 802c40a:	a902      	add	r1, sp, #8
 802c40c:	f001 fa88 	bl	802d920 <LoRaMacCommandsSerializeCmds>
 802c410:	2800      	cmp	r0, #0
 802c412:	d145      	bne.n	802c4a0 <PrepareFrame+0x198>
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 802c414:	4b24      	ldr	r3, [pc, #144]	; (802c4a8 <PrepareFrame+0x1a0>)
 802c416:	2294      	movs	r2, #148	; 0x94
 802c418:	0052      	lsls	r2, r2, #1
 802c41a:	2100      	movs	r1, #0
 802c41c:	5499      	strb	r1, [r3, r2]
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 802c41e:	2291      	movs	r2, #145	; 0x91
 802c420:	00d2      	lsls	r2, r2, #3
 802c422:	1899      	adds	r1, r3, r2
 802c424:	2296      	movs	r2, #150	; 0x96
 802c426:	0052      	lsls	r2, r2, #1
 802c428:	5099      	str	r1, [r3, r2]
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 802c42a:	3204      	adds	r2, #4
 802c42c:	9902      	ldr	r1, [sp, #8]
 802c42e:	5499      	strb	r1, [r3, r2]
 802c430:	e794      	b.n	802c35c <PrepareFrame+0x54>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 802c432:	4a26      	ldr	r2, [pc, #152]	; (802c4cc <PrepareFrame+0x1c4>)
 802c434:	a902      	add	r1, sp, #8
 802c436:	200f      	movs	r0, #15
 802c438:	f001 fa72 	bl	802d920 <LoRaMacCommandsSerializeCmds>
 802c43c:	2800      	cmp	r0, #0
 802c43e:	d12b      	bne.n	802c498 <PrepareFrame+0x190>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 802c440:	220f      	movs	r2, #15
 802c442:	9b02      	ldr	r3, [sp, #8]
 802c444:	401a      	ands	r2, r3
 802c446:	9c00      	ldr	r4, [sp, #0]
 802c448:	7823      	ldrb	r3, [r4, #0]
 802c44a:	210f      	movs	r1, #15
 802c44c:	438b      	bics	r3, r1
 802c44e:	4313      	orrs	r3, r2
 802c450:	7023      	strb	r3, [r4, #0]
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 802c452:	4915      	ldr	r1, [pc, #84]	; (802c4a8 <PrepareFrame+0x1a0>)
 802c454:	228a      	movs	r2, #138	; 0x8a
 802c456:	0052      	lsls	r2, r2, #1
 802c458:	548b      	strb	r3, [r1, r2]
 802c45a:	e77f      	b.n	802c35c <PrepareFrame+0x54>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 802c45c:	4a1a      	ldr	r2, [pc, #104]	; (802c4c8 <PrepareFrame+0x1c0>)
 802c45e:	a902      	add	r1, sp, #8
 802c460:	f001 fa5e 	bl	802d920 <LoRaMacCommandsSerializeCmds>
 802c464:	2800      	cmp	r0, #0
 802c466:	d019      	beq.n	802c49c <PrepareFrame+0x194>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802c468:	2013      	movs	r0, #19
 802c46a:	e777      	b.n	802c35c <PrepareFrame+0x54>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 802c46c:	2e00      	cmp	r6, #0
 802c46e:	d019      	beq.n	802c4a4 <PrepareFrame+0x19c>
 802c470:	2800      	cmp	r0, #0
 802c472:	d100      	bne.n	802c476 <PrepareFrame+0x16e>
 802c474:	e772      	b.n	802c35c <PrepareFrame+0x54>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 802c476:	b282      	uxth	r2, r0
 802c478:	4c15      	ldr	r4, [pc, #84]	; (802c4d0 <PrepareFrame+0x1c8>)
 802c47a:	0031      	movs	r1, r6
 802c47c:	0020      	movs	r0, r4
 802c47e:	f005 f98c 	bl	803179a <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 802c482:	3c03      	subs	r4, #3
 802c484:	4b0b      	ldr	r3, [pc, #44]	; (802c4b4 <PrepareFrame+0x1ac>)
 802c486:	5ce3      	ldrb	r3, [r4, r3]
 802c488:	3301      	adds	r3, #1
 802c48a:	8023      	strh	r3, [r4, #0]
    return LORAMAC_STATUS_OK;
 802c48c:	2000      	movs	r0, #0
 802c48e:	e765      	b.n	802c35c <PrepareFrame+0x54>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 802c490:	2012      	movs	r0, #18
 802c492:	e763      	b.n	802c35c <PrepareFrame+0x54>
                return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802c494:	2013      	movs	r0, #19
 802c496:	e761      	b.n	802c35c <PrepareFrame+0x54>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802c498:	2013      	movs	r0, #19
 802c49a:	e75f      	b.n	802c35c <PrepareFrame+0x54>
                    return LORAMAC_STATUS_SKIPPED_APP_DATA;
 802c49c:	200a      	movs	r0, #10
 802c49e:	e75d      	b.n	802c35c <PrepareFrame+0x54>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802c4a0:	2013      	movs	r0, #19
 802c4a2:	e75b      	b.n	802c35c <PrepareFrame+0x54>
    return LORAMAC_STATUS_OK;
 802c4a4:	2000      	movs	r0, #0
 802c4a6:	e759      	b.n	802c35c <PrepareFrame+0x54>
 802c4a8:	2000a534 	.word	0x2000a534
 802c4ac:	00000414 	.word	0x00000414
 802c4b0:	2000a66c 	.word	0x2000a66c
 802c4b4:	00000237 	.word	0x00000237
 802c4b8:	2000aa3c 	.word	0x2000aa3c
 802c4bc:	0000043d 	.word	0x0000043d
 802c4c0:	0000043c 	.word	0x0000043c
 802c4c4:	00000444 	.word	0x00000444
 802c4c8:	2000a9bc 	.word	0x2000a9bc
 802c4cc:	2000a64c 	.word	0x2000a64c
 802c4d0:	2000a537 	.word	0x2000a537

0802c4d4 <Send>:
{
 802c4d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c4d6:	46de      	mov	lr, fp
 802c4d8:	4657      	mov	r7, sl
 802c4da:	464e      	mov	r6, r9
 802c4dc:	4645      	mov	r5, r8
 802c4de:	b5e0      	push	{r5, r6, r7, lr}
 802c4e0:	b08b      	sub	sp, #44	; 0x2c
 802c4e2:	4680      	mov	r8, r0
 802c4e4:	4689      	mov	r9, r1
 802c4e6:	4692      	mov	sl, r2
 802c4e8:	001f      	movs	r7, r3
 802c4ea:	ab14      	add	r3, sp, #80	; 0x50
 802c4ec:	781b      	ldrb	r3, [r3, #0]
 802c4ee:	469b      	mov	fp, r3
    int8_t datarate = Nvm.MacGroup1.ChannelsDatarate;
 802c4f0:	4b44      	ldr	r3, [pc, #272]	; (802c604 <Send+0x130>)
 802c4f2:	2239      	movs	r2, #57	; 0x39
 802c4f4:	569e      	ldrsb	r6, [r3, r2]
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 802c4f6:	3a01      	subs	r2, #1
 802c4f8:	569d      	ldrsb	r5, [r3, r2]
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802c4fa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 802c4fc:	9208      	str	r2, [sp, #32]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 802c4fe:	2188      	movs	r1, #136	; 0x88
 802c500:	0049      	lsls	r1, r1, #1
 802c502:	5c5b      	ldrb	r3, [r3, r1]
 802c504:	2b00      	cmp	r3, #0
 802c506:	d100      	bne.n	802c50a <Send+0x36>
 802c508:	e079      	b.n	802c5fe <Send+0x12a>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 802c50a:	493e      	ldr	r1, [pc, #248]	; (802c604 <Send+0x130>)
 802c50c:	23ff      	movs	r3, #255	; 0xff
 802c50e:	5ccb      	ldrb	r3, [r1, r3]
 802c510:	2b00      	cmp	r3, #0
 802c512:	d102      	bne.n	802c51a <Send+0x46>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 802c514:	000b      	movs	r3, r1
 802c516:	2100      	movs	r1, #0
 802c518:	6319      	str	r1, [r3, #48]	; 0x30
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 802c51a:	4b3a      	ldr	r3, [pc, #232]	; (802c604 <Send+0x130>)
 802c51c:	21fe      	movs	r1, #254	; 0xfe
 802c51e:	5c5c      	ldrb	r4, [r3, r1]
 802c520:	01e0      	lsls	r0, r4, #7
 802c522:	a909      	add	r1, sp, #36	; 0x24
 802c524:	7008      	strb	r0, [r1, #0]
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802c526:	21fc      	movs	r1, #252	; 0xfc
 802c528:	5c5b      	ldrb	r3, [r3, r1]
 802c52a:	2b01      	cmp	r3, #1
 802c52c:	d055      	beq.n	802c5da <Send+0x106>
        fCtrl.Bits.FPending      = 0;
 802c52e:	a909      	add	r1, sp, #36	; 0x24
 802c530:	780b      	ldrb	r3, [r1, #0]
 802c532:	2010      	movs	r0, #16
 802c534:	4383      	bics	r3, r0
 802c536:	700b      	strb	r3, [r1, #0]
    if( Nvm.MacGroup1.SrvAckRequested == true )
 802c538:	4932      	ldr	r1, [pc, #200]	; (802c604 <Send+0x130>)
 802c53a:	233a      	movs	r3, #58	; 0x3a
 802c53c:	5ccb      	ldrb	r3, [r1, r3]
 802c53e:	2b00      	cmp	r3, #0
 802c540:	d004      	beq.n	802c54c <Send+0x78>
        fCtrl.Bits.Ack = 1;
 802c542:	a909      	add	r1, sp, #36	; 0x24
 802c544:	780b      	ldrb	r3, [r1, #0]
 802c546:	2020      	movs	r0, #32
 802c548:	4303      	orrs	r3, r0
 802c54a:	700b      	strb	r3, [r1, #0]
    adrNext.Version = Nvm.MacGroup2.Version;
 802c54c:	a803      	add	r0, sp, #12
 802c54e:	492d      	ldr	r1, [pc, #180]	; (802c604 <Send+0x130>)
 802c550:	2386      	movs	r3, #134	; 0x86
 802c552:	005b      	lsls	r3, r3, #1
 802c554:	58cb      	ldr	r3, [r1, r3]
 802c556:	9303      	str	r3, [sp, #12]
    adrNext.UpdateChanMask = true;
 802c558:	2301      	movs	r3, #1
 802c55a:	7103      	strb	r3, [r0, #4]
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 802c55c:	7144      	strb	r4, [r0, #5]
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802c55e:	6082      	str	r2, [r0, #8]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 802c560:	4b29      	ldr	r3, [pc, #164]	; (802c608 <Send+0x134>)
 802c562:	22fd      	movs	r2, #253	; 0xfd
 802c564:	0092      	lsls	r2, r2, #2
 802c566:	5a9a      	ldrh	r2, [r3, r2]
 802c568:	8182      	strh	r2, [r0, #12]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
 802c56a:	4a28      	ldr	r2, [pc, #160]	; (802c60c <Send+0x138>)
 802c56c:	5a9b      	ldrh	r3, [r3, r2]
 802c56e:	81c3      	strh	r3, [r0, #14]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802c570:	7406      	strb	r6, [r0, #16]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 802c572:	7445      	strb	r5, [r0, #17]
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802c574:	2374      	movs	r3, #116	; 0x74
 802c576:	5ccb      	ldrb	r3, [r1, r3]
 802c578:	7483      	strb	r3, [r0, #18]
    adrNext.Region = Nvm.MacGroup2.Region;
 802c57a:	2440      	movs	r4, #64	; 0x40
 802c57c:	5d0b      	ldrb	r3, [r1, r4]
 802c57e:	74c3      	strb	r3, [r0, #19]
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 802c580:	000a      	movs	r2, r1
 802c582:	3238      	adds	r2, #56	; 0x38
 802c584:	3139      	adds	r1, #57	; 0x39
 802c586:	ab08      	add	r3, sp, #32
 802c588:	f001 f87e 	bl	802d688 <LoRaMacAdrCalcNext>
 802c58c:	2301      	movs	r3, #1
 802c58e:	4003      	ands	r3, r0
 802c590:	019b      	lsls	r3, r3, #6
 802c592:	4669      	mov	r1, sp
 802c594:	2224      	movs	r2, #36	; 0x24
 802c596:	1889      	adds	r1, r1, r2
 802c598:	7808      	ldrb	r0, [r1, #0]
 802c59a:	43a0      	bics	r0, r4
 802c59c:	4318      	orrs	r0, r3
 802c59e:	7008      	strb	r0, [r1, #0]
    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );
 802c5a0:	9700      	str	r7, [sp, #0]
 802c5a2:	4653      	mov	r3, sl
 802c5a4:	464a      	mov	r2, r9
 802c5a6:	4640      	mov	r0, r8
 802c5a8:	f7ff feae 	bl	802c308 <PrepareFrame>
 802c5ac:	1e04      	subs	r4, r0, #0
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 802c5ae:	d001      	beq.n	802c5b4 <Send+0xe0>
 802c5b0:	280a      	cmp	r0, #10
 802c5b2:	d103      	bne.n	802c5bc <Send+0xe8>
        status = ScheduleTx( allowDelayedTx ); /* ST_WORKAROUND: Update Send request with new input parameter to allow delayed tx */
 802c5b4:	4658      	mov	r0, fp
 802c5b6:	f7ff f907 	bl	802b7c8 <ScheduleTx>
 802c5ba:	0004      	movs	r4, r0
    if( status != LORAMAC_STATUS_OK )
 802c5bc:	2c00      	cmp	r4, #0
 802c5be:	d012      	beq.n	802c5e6 <Send+0x112>
        Nvm.MacGroup1.ChannelsDatarate = datarate;
 802c5c0:	4b10      	ldr	r3, [pc, #64]	; (802c604 <Send+0x130>)
 802c5c2:	2239      	movs	r2, #57	; 0x39
 802c5c4:	549e      	strb	r6, [r3, r2]
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 802c5c6:	3a01      	subs	r2, #1
 802c5c8:	549d      	strb	r5, [r3, r2]
}
 802c5ca:	0020      	movs	r0, r4
 802c5cc:	b00b      	add	sp, #44	; 0x2c
 802c5ce:	bcf0      	pop	{r4, r5, r6, r7}
 802c5d0:	46bb      	mov	fp, r7
 802c5d2:	46b2      	mov	sl, r6
 802c5d4:	46a9      	mov	r9, r5
 802c5d6:	46a0      	mov	r8, r4
 802c5d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        fCtrl.Bits.FPending      = 1;
 802c5da:	a909      	add	r1, sp, #36	; 0x24
 802c5dc:	b2c3      	uxtb	r3, r0
 802c5de:	2010      	movs	r0, #16
 802c5e0:	4303      	orrs	r3, r0
 802c5e2:	700b      	strb	r3, [r1, #0]
 802c5e4:	e7a8      	b.n	802c538 <Send+0x64>
        Nvm.MacGroup1.SrvAckRequested = false;
 802c5e6:	4b07      	ldr	r3, [pc, #28]	; (802c604 <Send+0x130>)
 802c5e8:	223a      	movs	r2, #58	; 0x3a
 802c5ea:	2100      	movs	r1, #0
 802c5ec:	5499      	strb	r1, [r3, r2]
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 802c5ee:	9a08      	ldr	r2, [sp, #32]
 802c5f0:	629a      	str	r2, [r3, #40]	; 0x28
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 802c5f2:	f001 f961 	bl	802d8b8 <LoRaMacCommandsRemoveNoneStickyCmds>
 802c5f6:	2800      	cmp	r0, #0
 802c5f8:	d0e7      	beq.n	802c5ca <Send+0xf6>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802c5fa:	2413      	movs	r4, #19
 802c5fc:	e7e5      	b.n	802c5ca <Send+0xf6>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 802c5fe:	2407      	movs	r4, #7
 802c600:	e7e3      	b.n	802c5ca <Send+0xf6>
 802c602:	46c0      	nop			; (mov r8, r8)
 802c604:	2000aa3c 	.word	0x2000aa3c
 802c608:	2000a534 	.word	0x2000a534
 802c60c:	000003f6 	.word	0x000003f6

0802c610 <LoRaMacIsBusy>:
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 802c610:	4a07      	ldr	r2, [pc, #28]	; (802c630 <LoRaMacIsBusy+0x20>)
 802c612:	23d0      	movs	r3, #208	; 0xd0
 802c614:	009b      	lsls	r3, r3, #2
 802c616:	58d3      	ldr	r3, [r2, r3]
 802c618:	2b00      	cmp	r3, #0
 802c61a:	d105      	bne.n	802c628 <LoRaMacIsBusy+0x18>
        ( MacCtx.AllowRequests == LORAMAC_REQUEST_HANDLING_ON ) )
 802c61c:	4b05      	ldr	r3, [pc, #20]	; (802c634 <LoRaMacIsBusy+0x24>)
 802c61e:	5cd3      	ldrb	r3, [r2, r3]
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 802c620:	2b01      	cmp	r3, #1
 802c622:	d003      	beq.n	802c62c <LoRaMacIsBusy+0x1c>
    return true;
 802c624:	2001      	movs	r0, #1
 802c626:	e000      	b.n	802c62a <LoRaMacIsBusy+0x1a>
 802c628:	2001      	movs	r0, #1
}
 802c62a:	4770      	bx	lr
        return false;
 802c62c:	2000      	movs	r0, #0
 802c62e:	e7fc      	b.n	802c62a <LoRaMacIsBusy+0x1a>
 802c630:	2000a534 	.word	0x2000a534
 802c634:	00000482 	.word	0x00000482

0802c638 <LoRaMacProcess>:
{
 802c638:	b510      	push	{r4, lr}
    LoRaMacHandleIrqEvents( );
 802c63a:	f7fe fec9 	bl	802b3d0 <LoRaMacHandleIrqEvents>
    LoRaMacClassBProcess( );
 802c63e:	f001 f852 	bl	802d6e6 <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 802c642:	4a16      	ldr	r2, [pc, #88]	; (802c69c <LoRaMacProcess+0x64>)
 802c644:	4b16      	ldr	r3, [pc, #88]	; (802c6a0 <LoRaMacProcess+0x68>)
 802c646:	5cd3      	ldrb	r3, [r2, r3]
 802c648:	069b      	lsls	r3, r3, #26
 802c64a:	d408      	bmi.n	802c65e <LoRaMacProcess+0x26>
    LoRaMacHandleIndicationEvents( );
 802c64c:	f7fd fcaa 	bl	8029fa4 <LoRaMacHandleIndicationEvents>
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 802c650:	4a12      	ldr	r2, [pc, #72]	; (802c69c <LoRaMacProcess+0x64>)
 802c652:	2390      	movs	r3, #144	; 0x90
 802c654:	00db      	lsls	r3, r3, #3
 802c656:	5cd3      	ldrb	r3, [r2, r3]
 802c658:	2b02      	cmp	r3, #2
 802c65a:	d01c      	beq.n	802c696 <LoRaMacProcess+0x5e>
}
 802c65c:	bd10      	pop	{r4, pc}
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_OFF );
 802c65e:	2000      	movs	r0, #0
 802c660:	f7fd fc98 	bl	8029f94 <LoRaMacEnableRequests>
        LoRaMacCheckForRxAbort( );
 802c664:	f7fd fcec 	bl	802a040 <LoRaMacCheckForRxAbort>
        if( IsRequestPending( ) > 0 )
 802c668:	f7fd fdf0 	bl	802a24c <IsRequestPending>
 802c66c:	2800      	cmp	r0, #0
 802c66e:	d003      	beq.n	802c678 <LoRaMacProcess+0x40>
            noTx |= LoRaMacCheckForBeaconAcquisition( );
 802c670:	f7fd ff38 	bl	802a4e4 <LoRaMacCheckForBeaconAcquisition>
        if( noTx == 0x00 )
 802c674:	2800      	cmp	r0, #0
 802c676:	d103      	bne.n	802c680 <LoRaMacProcess+0x48>
            LoRaMacHandleMlmeRequest( );
 802c678:	f7fe fed4 	bl	802b424 <LoRaMacHandleMlmeRequest>
            LoRaMacHandleMcpsRequest( );
 802c67c:	f7ff f966 	bl	802b94c <LoRaMacHandleMcpsRequest>
        LoRaMacHandleRequestEvents( );
 802c680:	f7ff f9be 	bl	802ba00 <LoRaMacHandleRequestEvents>
        LoRaMacHandleScheduleUplinkEvent( );
 802c684:	f7ff fa0a 	bl	802ba9c <LoRaMacHandleScheduleUplinkEvent>
        LoRaMacHandleNvm( &Nvm );
 802c688:	4806      	ldr	r0, [pc, #24]	; (802c6a4 <LoRaMacProcess+0x6c>)
 802c68a:	f7ff fa1f 	bl	802bacc <LoRaMacHandleNvm>
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 802c68e:	2001      	movs	r0, #1
 802c690:	f7fd fc80 	bl	8029f94 <LoRaMacEnableRequests>
 802c694:	e7da      	b.n	802c64c <LoRaMacProcess+0x14>
        OpenContinuousRxCWindow( );
 802c696:	f7ff fb35 	bl	802bd04 <OpenContinuousRxCWindow>
}
 802c69a:	e7df      	b.n	802c65c <LoRaMacProcess+0x24>
 802c69c:	2000a534 	.word	0x2000a534
 802c6a0:	00000481 	.word	0x00000481
 802c6a4:	2000aa3c 	.word	0x2000aa3c

0802c6a8 <LoRaMacInitialization>:


LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 802c6a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c6aa:	46de      	mov	lr, fp
 802c6ac:	4657      	mov	r7, sl
 802c6ae:	464e      	mov	r6, r9
 802c6b0:	4645      	mov	r5, r8
 802c6b2:	b5e0      	push	{r5, r6, r7, lr}
 802c6b4:	b08b      	sub	sp, #44	; 0x2c
 802c6b6:	0006      	movs	r6, r0
 802c6b8:	4689      	mov	r9, r1
 802c6ba:	0015      	movs	r5, r2
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 802c6bc:	2800      	cmp	r0, #0
 802c6be:	d100      	bne.n	802c6c2 <LoRaMacInitialization+0x1a>
 802c6c0:	e194      	b.n	802c9ec <LoRaMacInitialization+0x344>
 802c6c2:	2900      	cmp	r1, #0
 802c6c4:	d100      	bne.n	802c6c8 <LoRaMacInitialization+0x20>
 802c6c6:	e193      	b.n	802c9f0 <LoRaMacInitialization+0x348>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 802c6c8:	6803      	ldr	r3, [r0, #0]
 802c6ca:	2b00      	cmp	r3, #0
 802c6cc:	d100      	bne.n	802c6d0 <LoRaMacInitialization+0x28>
 802c6ce:	e191      	b.n	802c9f4 <LoRaMacInitialization+0x34c>
 802c6d0:	6843      	ldr	r3, [r0, #4]
 802c6d2:	2b00      	cmp	r3, #0
 802c6d4:	d100      	bne.n	802c6d8 <LoRaMacInitialization+0x30>
 802c6d6:	e18f      	b.n	802c9f8 <LoRaMacInitialization+0x350>
        ( primitives->MacMcpsIndication == NULL ) ||
 802c6d8:	6883      	ldr	r3, [r0, #8]
 802c6da:	2b00      	cmp	r3, #0
 802c6dc:	d100      	bne.n	802c6e0 <LoRaMacInitialization+0x38>
 802c6de:	e18d      	b.n	802c9fc <LoRaMacInitialization+0x354>
        ( primitives->MacMlmeConfirm == NULL ) ||
 802c6e0:	68c3      	ldr	r3, [r0, #12]
 802c6e2:	2b00      	cmp	r3, #0
 802c6e4:	d100      	bne.n	802c6e8 <LoRaMacInitialization+0x40>
 802c6e6:	e18b      	b.n	802ca00 <LoRaMacInitialization+0x358>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 802c6e8:	0010      	movs	r0, r2
 802c6ea:	f001 fff9 	bl	802e6e0 <RegionIsActive>
 802c6ee:	2800      	cmp	r0, #0
 802c6f0:	d100      	bne.n	802c6f4 <LoRaMacInitialization+0x4c>
 802c6f2:	e187      	b.n	802ca04 <LoRaMacInitialization+0x35c>
    {
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
    }

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );
 802c6f4:	0030      	movs	r0, r6
 802c6f6:	f001 f9c1 	bl	802da7c <LoRaMacConfirmQueueInit>

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 802c6fa:	4ccb      	ldr	r4, [pc, #812]	; (802ca28 <LoRaMacInitialization+0x380>)
 802c6fc:	4acb      	ldr	r2, [pc, #812]	; (802ca2c <LoRaMacInitialization+0x384>)
 802c6fe:	2100      	movs	r1, #0
 802c700:	0020      	movs	r0, r4
 802c702:	f005 f862 	bl	80317ca <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 802c706:	22a1      	movs	r2, #161	; 0xa1
 802c708:	4fc9      	ldr	r7, [pc, #804]	; (802ca30 <LoRaMacInitialization+0x388>)
 802c70a:	00d2      	lsls	r2, r2, #3
 802c70c:	2100      	movs	r1, #0
 802c70e:	0038      	movs	r0, r7
 802c710:	f005 f85b 	bl	80317ca <memset1>

    // Set non zero variables to its default value
    MacCtx.AckTimeoutRetriesCounter = 1;
 802c714:	2301      	movs	r3, #1
 802c716:	469b      	mov	fp, r3
 802c718:	4bc6      	ldr	r3, [pc, #792]	; (802ca34 <LoRaMacInitialization+0x38c>)
 802c71a:	465a      	mov	r2, fp
 802c71c:	54fa      	strb	r2, [r7, r3]
    MacCtx.AckTimeoutRetries = 1;
 802c71e:	4bc6      	ldr	r3, [pc, #792]	; (802ca38 <LoRaMacInitialization+0x390>)
 802c720:	54fa      	strb	r2, [r7, r3]
    Nvm.MacGroup2.Region = region;
 802c722:	2340      	movs	r3, #64	; 0x40
 802c724:	4698      	mov	r8, r3
 802c726:	0028      	movs	r0, r5
 802c728:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 802c72a:	2300      	movs	r3, #0
 802c72c:	469a      	mov	sl, r3
 802c72e:	33fc      	adds	r3, #252	; 0xfc
 802c730:	4652      	mov	r2, sl
 802c732:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */
 802c734:	3b7c      	subs	r3, #124	; 0x7c
 802c736:	54e2      	strb	r2, [r4, r3]

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 802c738:	338c      	adds	r3, #140	; 0x8c
 802c73a:	4ac0      	ldr	r2, [pc, #768]	; (802ca3c <LoRaMacInitialization+0x394>)
 802c73c:	50e2      	str	r2, [r4, r3]

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 802c73e:	ad08      	add	r5, sp, #32
 802c740:	3bfd      	subs	r3, #253	; 0xfd
 802c742:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c744:	0029      	movs	r1, r5
 802c746:	f001 ffd5 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 802c74a:	1e43      	subs	r3, r0, #1
 802c74c:	4198      	sbcs	r0, r3
 802c74e:	2380      	movs	r3, #128	; 0x80
 802c750:	005b      	lsls	r3, r3, #1
 802c752:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_TX_POWER;
 802c754:	220a      	movs	r2, #10
 802c756:	702a      	strb	r2, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c758:	4643      	mov	r3, r8
 802c75a:	5ce0      	ldrb	r0, [r4, r3]
 802c75c:	0029      	movs	r1, r5
 802c75e:	f001 ffc9 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 802c762:	23c4      	movs	r3, #196	; 0xc4
 802c764:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_TX_DR;
 802c766:	2106      	movs	r1, #6
 802c768:	7029      	strb	r1, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c76a:	4643      	mov	r3, r8
 802c76c:	5ce0      	ldrb	r0, [r4, r3]
 802c76e:	0029      	movs	r1, r5
 802c770:	f001 ffc0 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 802c774:	23c5      	movs	r3, #197	; 0xc5
 802c776:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 802c778:	3bb5      	subs	r3, #181	; 0xb5
 802c77a:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c77c:	4643      	mov	r3, r8
 802c77e:	5ce0      	ldrb	r0, [r4, r3]
 802c780:	0029      	movs	r1, r5
 802c782:	f001 ffb7 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 802c786:	238c      	movs	r3, #140	; 0x8c
 802c788:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 802c78a:	3b7b      	subs	r3, #123	; 0x7b
 802c78c:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c78e:	4640      	mov	r0, r8
 802c790:	5c20      	ldrb	r0, [r4, r0]
 802c792:	0029      	movs	r1, r5
 802c794:	f001 ffae 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 802c798:	2390      	movs	r3, #144	; 0x90
 802c79a:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 802c79c:	3b7e      	subs	r3, #126	; 0x7e
 802c79e:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c7a0:	4640      	mov	r0, r8
 802c7a2:	5c20      	ldrb	r0, [r4, r0]
 802c7a4:	0029      	movs	r1, r5
 802c7a6:	f001 ffa5 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 802c7aa:	2294      	movs	r2, #148	; 0x94
 802c7ac:	50a0      	str	r0, [r4, r2]

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 802c7ae:	2313      	movs	r3, #19
 802c7b0:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c7b2:	4640      	mov	r0, r8
 802c7b4:	5c20      	ldrb	r0, [r4, r0]
 802c7b6:	0029      	movs	r1, r5
 802c7b8:	f001 ff9c 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 802c7bc:	2198      	movs	r1, #152	; 0x98
 802c7be:	5060      	str	r0, [r4, r1]

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 802c7c0:	2314      	movs	r3, #20
 802c7c2:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c7c4:	4640      	mov	r0, r8
 802c7c6:	5c20      	ldrb	r0, [r4, r0]
 802c7c8:	0029      	movs	r1, r5
 802c7ca:	f001 ff93 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 802c7ce:	239c      	movs	r3, #156	; 0x9c
 802c7d0:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 802c7d2:	3b85      	subs	r3, #133	; 0x85
 802c7d4:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c7d6:	4640      	mov	r0, r8
 802c7d8:	5c20      	ldrb	r0, [r4, r0]
 802c7da:	0029      	movs	r1, r5
 802c7dc:	f001 ff8a 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 802c7e0:	23a1      	movs	r3, #161	; 0xa1
 802c7e2:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 802c7e4:	3b89      	subs	r3, #137	; 0x89
 802c7e6:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c7e8:	4640      	mov	r0, r8
 802c7ea:	5c20      	ldrb	r0, [r4, r0]
 802c7ec:	0029      	movs	r1, r5
 802c7ee:	f001 ff81 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 802c7f2:	23a4      	movs	r3, #164	; 0xa4
 802c7f4:	50e0      	str	r0, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 802c7f6:	3308      	adds	r3, #8
 802c7f8:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_RX2_DR;
 802c7fa:	3b93      	subs	r3, #147	; 0x93
 802c7fc:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c7fe:	4640      	mov	r0, r8
 802c800:	5c20      	ldrb	r0, [r4, r0]
 802c802:	0029      	movs	r1, r5
 802c804:	f001 ff76 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 802c808:	b2c0      	uxtb	r0, r0
 802c80a:	23a8      	movs	r3, #168	; 0xa8
 802c80c:	54e0      	strb	r0, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 802c80e:	3308      	adds	r3, #8
 802c810:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 802c812:	3b92      	subs	r3, #146	; 0x92
 802c814:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c816:	4640      	mov	r0, r8
 802c818:	5c20      	ldrb	r0, [r4, r0]
 802c81a:	0029      	movs	r1, r5
 802c81c:	f001 ff6a 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 802c820:	23b4      	movs	r3, #180	; 0xb4
 802c822:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 802c824:	3b95      	subs	r3, #149	; 0x95
 802c826:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c828:	4640      	mov	r0, r8
 802c82a:	5c20      	ldrb	r0, [r4, r0]
 802c82c:	0029      	movs	r1, r5
 802c82e:	f001 ff61 	bl	802e6f4 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 802c832:	23b5      	movs	r3, #181	; 0xb5
 802c834:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 802c836:	3b95      	subs	r3, #149	; 0x95
 802c838:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c83a:	4640      	mov	r0, r8
 802c83c:	5c20      	ldrb	r0, [r4, r0]
 802c83e:	0029      	movs	r1, r5
 802c840:	f001 ff58 	bl	802e6f4 <RegionGetPhyParam>
 802c844:	9007      	str	r0, [sp, #28]
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 802c846:	23b8      	movs	r3, #184	; 0xb8
 802c848:	9807      	ldr	r0, [sp, #28]
 802c84a:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 802c84c:	3b97      	subs	r3, #151	; 0x97
 802c84e:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c850:	4640      	mov	r0, r8
 802c852:	5c20      	ldrb	r0, [r4, r0]
 802c854:	0029      	movs	r1, r5
 802c856:	f001 ff4d 	bl	802e6f4 <RegionGetPhyParam>
 802c85a:	9007      	str	r0, [sp, #28]
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 802c85c:	23bc      	movs	r3, #188	; 0xbc
 802c85e:	9807      	ldr	r0, [sp, #28]
 802c860:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 802c862:	3bb1      	subs	r3, #177	; 0xb1
 802c864:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c866:	4640      	mov	r0, r8
 802c868:	5c20      	ldrb	r0, [r4, r0]
 802c86a:	0029      	movs	r1, r5
 802c86c:	f001 ff42 	bl	802e6f4 <RegionGetPhyParam>
    MacCtx.AdrAckLimit = phyParam.Value;
 802c870:	23fd      	movs	r3, #253	; 0xfd
 802c872:	009b      	lsls	r3, r3, #2
 802c874:	52f8      	strh	r0, [r7, r3]

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 802c876:	230c      	movs	r3, #12
 802c878:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802c87a:	4640      	mov	r0, r8
 802c87c:	5c20      	ldrb	r0, [r4, r0]
 802c87e:	0029      	movs	r1, r5
 802c880:	f001 ff38 	bl	802e6f4 <RegionGetPhyParam>
    MacCtx.AdrAckDelay = phyParam.Value;
 802c884:	4b6e      	ldr	r3, [pc, #440]	; (802ca40 <LoRaMacInitialization+0x398>)
 802c886:	52f8      	strh	r0, [r7, r3]

    // Init parameters which are not set in function ResetMacParameters
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 802c888:	23a0      	movs	r3, #160	; 0xa0
 802c88a:	4658      	mov	r0, fp
 802c88c:	54e0      	strb	r0, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 802c88e:	3b1c      	subs	r3, #28
 802c890:	220a      	movs	r2, #10
 802c892:	50e2      	str	r2, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 802c894:	3304      	adds	r3, #4
 802c896:	2106      	movs	r1, #6
 802c898:	54e1      	strb	r1, [r4, r3]

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 802c89a:	6462      	str	r2, [r4, #68]	; 0x44
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 802c89c:	3b40      	subs	r3, #64	; 0x40
 802c89e:	54e1      	strb	r1, [r4, r3]
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 802c8a0:	3344      	adds	r3, #68	; 0x44
 802c8a2:	58e0      	ldr	r0, [r4, r3]
 802c8a4:	64e0      	str	r0, [r4, #76]	; 0x4c
    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;
 802c8a6:	3304      	adds	r3, #4
 802c8a8:	58e0      	ldr	r0, [r4, r3]
 802c8aa:	6520      	str	r0, [r4, #80]	; 0x50
    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;
 802c8ac:	328a      	adds	r2, #138	; 0x8a
 802c8ae:	58a2      	ldr	r2, [r4, r2]
 802c8b0:	6562      	str	r2, [r4, #84]	; 0x54
    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;
 802c8b2:	3192      	adds	r1, #146	; 0x92
 802c8b4:	5862      	ldr	r2, [r4, r1]
 802c8b6:	65a2      	str	r2, [r4, #88]	; 0x58
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 802c8b8:	330c      	adds	r3, #12
 802c8ba:	58e3      	ldr	r3, [r4, r3]
 802c8bc:	65e3      	str	r3, [r4, #92]	; 0x5c
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 802c8be:	2360      	movs	r3, #96	; 0x60
 802c8c0:	465a      	mov	r2, fp
 802c8c2:	54e2      	strb	r2, [r4, r3]

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
 802c8c4:	a904      	add	r1, sp, #16
 802c8c6:	4653      	mov	r3, sl
 802c8c8:	720b      	strb	r3, [r1, #8]
    params.NvmGroup1 = &Nvm.RegionGroup1;
 802c8ca:	2387      	movs	r3, #135	; 0x87
 802c8cc:	009b      	lsls	r3, r3, #2
 802c8ce:	18e3      	adds	r3, r4, r3
 802c8d0:	9304      	str	r3, [sp, #16]
    params.NvmGroup2 = &Nvm.RegionGroup2;
 802c8d2:	23b0      	movs	r3, #176	; 0xb0
 802c8d4:	009b      	lsls	r3, r3, #2
 802c8d6:	18e3      	adds	r3, r4, r3
 802c8d8:	604b      	str	r3, [r1, #4]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 802c8da:	4643      	mov	r3, r8
 802c8dc:	5ce0      	ldrb	r0, [r4, r3]
 802c8de:	f001 ff2e 	bl	802e73e <RegionInitDefaults>

    MacCtx.MacCallbacks = callbacks;
 802c8e2:	23d2      	movs	r3, #210	; 0xd2
 802c8e4:	009b      	lsls	r3, r3, #2
 802c8e6:	464a      	mov	r2, r9
 802c8e8:	50fa      	str	r2, [r7, r3]
    ResetMacParameters( );
 802c8ea:	f7ff fb67 	bl	802bfbc <ResetMacParameters>

    Nvm.MacGroup2.PublicNetwork = true;
 802c8ee:	23fd      	movs	r3, #253	; 0xfd
 802c8f0:	465a      	mov	r2, fp
 802c8f2:	54e2      	strb	r2, [r4, r3]

    MacCtx.MacPrimitives = primitives;
 802c8f4:	23d1      	movs	r3, #209	; 0xd1
 802c8f6:	009b      	lsls	r3, r3, #2
 802c8f8:	50fe      	str	r6, [r7, r3]
    MacCtx.MacFlags.Value = 0;
 802c8fa:	4b52      	ldr	r3, [pc, #328]	; (802ca44 <LoRaMacInitialization+0x39c>)
 802c8fc:	4652      	mov	r2, sl
 802c8fe:	54fa      	strb	r2, [r7, r3]
    MacCtx.MacState = LORAMAC_STOPPED;
 802c900:	3b42      	subs	r3, #66	; 0x42
 802c902:	3bff      	subs	r3, #255	; 0xff
 802c904:	465a      	mov	r2, fp
 802c906:	50fa      	str	r2, [r7, r3]

    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
 802c908:	4653      	mov	r3, sl
 802c90a:	62e3      	str	r3, [r4, #44]	; 0x2c
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 802c90c:	6323      	str	r3, [r4, #48]	; 0x30

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 802c90e:	2501      	movs	r5, #1
 802c910:	426d      	negs	r5, r5
 802c912:	23da      	movs	r3, #218	; 0xda
 802c914:	009b      	lsls	r3, r3, #2
 802c916:	18f8      	adds	r0, r7, r3
 802c918:	4653      	mov	r3, sl
 802c91a:	9300      	str	r3, [sp, #0]
 802c91c:	4b4a      	ldr	r3, [pc, #296]	; (802ca48 <LoRaMacInitialization+0x3a0>)
 802c91e:	2200      	movs	r2, #0
 802c920:	0029      	movs	r1, r5
 802c922:	f007 fbd1 	bl	80340c8 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 802c926:	23e0      	movs	r3, #224	; 0xe0
 802c928:	009b      	lsls	r3, r3, #2
 802c92a:	18f8      	adds	r0, r7, r3
 802c92c:	4653      	mov	r3, sl
 802c92e:	9300      	str	r3, [sp, #0]
 802c930:	4b46      	ldr	r3, [pc, #280]	; (802ca4c <LoRaMacInitialization+0x3a4>)
 802c932:	2200      	movs	r2, #0
 802c934:	0029      	movs	r1, r5
 802c936:	f007 fbc7 	bl	80340c8 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 802c93a:	23e6      	movs	r3, #230	; 0xe6
 802c93c:	009b      	lsls	r3, r3, #2
 802c93e:	18f8      	adds	r0, r7, r3
 802c940:	4653      	mov	r3, sl
 802c942:	9300      	str	r3, [sp, #0]
 802c944:	4b42      	ldr	r3, [pc, #264]	; (802ca50 <LoRaMacInitialization+0x3a8>)
 802c946:	2200      	movs	r2, #0
 802c948:	0029      	movs	r1, r5
 802c94a:	f007 fbbd 	bl	80340c8 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 802c94e:	23fe      	movs	r3, #254	; 0xfe
 802c950:	009b      	lsls	r3, r3, #2
 802c952:	18f8      	adds	r0, r7, r3
 802c954:	4653      	mov	r3, sl
 802c956:	9300      	str	r3, [sp, #0]
 802c958:	4b3e      	ldr	r3, [pc, #248]	; (802ca54 <LoRaMacInitialization+0x3ac>)
 802c95a:	2200      	movs	r2, #0
 802c95c:	0029      	movs	r1, r5
 802c95e:	f007 fbb3 	bl	80340c8 <UTIL_TIMER_Create>

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 802c962:	ad02      	add	r5, sp, #8
 802c964:	0028      	movs	r0, r5
 802c966:	f007 fb47 	bl	8033ff8 <SysTimeGetMcuTime>
 802c96a:	1d63      	adds	r3, r4, #5
 802c96c:	33ff      	adds	r3, #255	; 0xff
 802c96e:	cd06      	ldmia	r5!, {r1, r2}
 802c970:	c306      	stmia	r3!, {r1, r2}

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 802c972:	23d3      	movs	r3, #211	; 0xd3
 802c974:	009b      	lsls	r3, r3, #2
 802c976:	4a38      	ldr	r2, [pc, #224]	; (802ca58 <LoRaMacInitialization+0x3b0>)
 802c978:	50fa      	str	r2, [r7, r3]
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 802c97a:	3308      	adds	r3, #8
 802c97c:	4a37      	ldr	r2, [pc, #220]	; (802ca5c <LoRaMacInitialization+0x3b4>)
 802c97e:	50fa      	str	r2, [r7, r3]
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 802c980:	3308      	adds	r3, #8
 802c982:	4a37      	ldr	r2, [pc, #220]	; (802ca60 <LoRaMacInitialization+0x3b8>)
 802c984:	50fa      	str	r2, [r7, r3]
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 802c986:	3b0c      	subs	r3, #12
 802c988:	4a36      	ldr	r2, [pc, #216]	; (802ca64 <LoRaMacInitialization+0x3bc>)
 802c98a:	50fa      	str	r2, [r7, r3]
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 802c98c:	3308      	adds	r3, #8
 802c98e:	4a36      	ldr	r2, [pc, #216]	; (802ca68 <LoRaMacInitialization+0x3c0>)
 802c990:	50fa      	str	r2, [r7, r3]
    Radio.Init( &MacCtx.RadioEvents );
 802c992:	4b36      	ldr	r3, [pc, #216]	; (802ca6c <LoRaMacInitialization+0x3c4>)
 802c994:	681b      	ldr	r3, [r3, #0]
 802c996:	22d3      	movs	r2, #211	; 0xd3
 802c998:	0092      	lsls	r2, r2, #2
 802c99a:	18b8      	adds	r0, r7, r2
 802c99c:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement, callbacks->GetUniqueId ) != SECURE_ELEMENT_SUCCESS ) /* ST_WORKAROUND: Add unique ID callback as input parameter */
 802c99e:	464b      	mov	r3, r9
 802c9a0:	6899      	ldr	r1, [r3, #8]
 802c9a2:	0020      	movs	r0, r4
 802c9a4:	3019      	adds	r0, #25
 802c9a6:	30ff      	adds	r0, #255	; 0xff
 802c9a8:	f004 fbda 	bl	8031160 <SecureElementInit>
 802c9ac:	2800      	cmp	r0, #0
 802c9ae:	d132      	bne.n	802ca16 <LoRaMacInitialization+0x36e>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Initialize Crypto module
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 802c9b0:	481d      	ldr	r0, [pc, #116]	; (802ca28 <LoRaMacInitialization+0x380>)
 802c9b2:	f001 fb0b 	bl	802dfcc <LoRaMacCryptoInit>
 802c9b6:	2800      	cmp	r0, #0
 802c9b8:	d12f      	bne.n	802ca1a <LoRaMacInitialization+0x372>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Initialize MAC commands module
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 802c9ba:	f000 ff23 	bl	802d804 <LoRaMacCommandsInit>
 802c9be:	2800      	cmp	r0, #0
 802c9c0:	d12d      	bne.n	802ca1e <LoRaMacInitialization+0x376>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Set multicast downlink counter reference
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 802c9c2:	482b      	ldr	r0, [pc, #172]	; (802ca70 <LoRaMacInitialization+0x3c8>)
 802c9c4:	f001 fb72 	bl	802e0ac <LoRaMacCryptoSetMulticastReference>
 802c9c8:	1e04      	subs	r4, r0, #0
 802c9ca:	d12a      	bne.n	802ca22 <LoRaMacInitialization+0x37a>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Random seed initialization
    srand1( Radio.Random( ) );
 802c9cc:	4d27      	ldr	r5, [pc, #156]	; (802ca6c <LoRaMacInitialization+0x3c4>)
 802c9ce:	696b      	ldr	r3, [r5, #20]
 802c9d0:	4798      	blx	r3
 802c9d2:	f004 fed1 	bl	8031778 <srand1>

    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 802c9d6:	4a14      	ldr	r2, [pc, #80]	; (802ca28 <LoRaMacInitialization+0x380>)
 802c9d8:	23fd      	movs	r3, #253	; 0xfd
 802c9da:	5cd0      	ldrb	r0, [r2, r3]
 802c9dc:	6dab      	ldr	r3, [r5, #88]	; 0x58
 802c9de:	4798      	blx	r3
    Radio.Sleep( );
 802c9e0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 802c9e2:	4798      	blx	r3

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 802c9e4:	2001      	movs	r0, #1
 802c9e6:	f7fd fad5 	bl	8029f94 <LoRaMacEnableRequests>

    return LORAMAC_STATUS_OK;
 802c9ea:	e00c      	b.n	802ca06 <LoRaMacInitialization+0x35e>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802c9ec:	2403      	movs	r4, #3
 802c9ee:	e00a      	b.n	802ca06 <LoRaMacInitialization+0x35e>
 802c9f0:	2403      	movs	r4, #3
 802c9f2:	e008      	b.n	802ca06 <LoRaMacInitialization+0x35e>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802c9f4:	2403      	movs	r4, #3
 802c9f6:	e006      	b.n	802ca06 <LoRaMacInitialization+0x35e>
 802c9f8:	2403      	movs	r4, #3
 802c9fa:	e004      	b.n	802ca06 <LoRaMacInitialization+0x35e>
 802c9fc:	2403      	movs	r4, #3
 802c9fe:	e002      	b.n	802ca06 <LoRaMacInitialization+0x35e>
 802ca00:	2403      	movs	r4, #3
 802ca02:	e000      	b.n	802ca06 <LoRaMacInitialization+0x35e>
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 802ca04:	2409      	movs	r4, #9
}
 802ca06:	0020      	movs	r0, r4
 802ca08:	b00b      	add	sp, #44	; 0x2c
 802ca0a:	bcf0      	pop	{r4, r5, r6, r7}
 802ca0c:	46bb      	mov	fp, r7
 802ca0e:	46b2      	mov	sl, r6
 802ca10:	46a9      	mov	r9, r5
 802ca12:	46a0      	mov	r8, r4
 802ca14:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_CRYPTO_ERROR;
 802ca16:	2411      	movs	r4, #17
 802ca18:	e7f5      	b.n	802ca06 <LoRaMacInitialization+0x35e>
        return LORAMAC_STATUS_CRYPTO_ERROR;
 802ca1a:	2411      	movs	r4, #17
 802ca1c:	e7f3      	b.n	802ca06 <LoRaMacInitialization+0x35e>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802ca1e:	2413      	movs	r4, #19
 802ca20:	e7f1      	b.n	802ca06 <LoRaMacInitialization+0x35e>
        return LORAMAC_STATUS_CRYPTO_ERROR;
 802ca22:	2411      	movs	r4, #17
 802ca24:	e7ef      	b.n	802ca06 <LoRaMacInitialization+0x35e>
 802ca26:	46c0      	nop			; (mov r8, r8)
 802ca28:	2000aa3c 	.word	0x2000aa3c
 802ca2c:	00000654 	.word	0x00000654
 802ca30:	2000a534 	.word	0x2000a534
 802ca34:	00000412 	.word	0x00000412
 802ca38:	00000411 	.word	0x00000411
 802ca3c:	01000300 	.word	0x01000300
 802ca40:	000003f6 	.word	0x000003f6
 802ca44:	00000481 	.word	0x00000481
 802ca48:	0802b8d9 	.word	0x0802b8d9
 802ca4c:	0802be29 	.word	0x0802be29
 802ca50:	0802bdbd 	.word	0x0802bdbd
 802ca54:	0802a435 	.word	0x0802a435
 802ca58:	0802bf61 	.word	0x0802bf61
 802ca5c:	0802bf01 	.word	0x0802bf01
 802ca60:	08029f3d 	.word	0x08029f3d
 802ca64:	0802bec5 	.word	0x0802bec5
 802ca68:	0802be89 	.word	0x0802be89
 802ca6c:	080356b4 	.word	0x080356b4
 802ca70:	2000ab0c 	.word	0x2000ab0c

0802ca74 <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
    MacCtx.MacState = LORAMAC_IDLE;
 802ca74:	4a03      	ldr	r2, [pc, #12]	; (802ca84 <LoRaMacStart+0x10>)
 802ca76:	23d0      	movs	r3, #208	; 0xd0
 802ca78:	009b      	lsls	r3, r3, #2
 802ca7a:	2100      	movs	r1, #0
 802ca7c:	50d1      	str	r1, [r2, r3]
    return LORAMAC_STATUS_OK;
}
 802ca7e:	2000      	movs	r0, #0
 802ca80:	4770      	bx	lr
 802ca82:	46c0      	nop			; (mov r8, r8)
 802ca84:	2000a534 	.word	0x2000a534

0802ca88 <LoRaMacStop>:

LoRaMacStatus_t LoRaMacStop( void )
{
 802ca88:	b510      	push	{r4, lr}
    if( LoRaMacIsBusy( ) == false )
 802ca8a:	f7ff fdc1 	bl	802c610 <LoRaMacIsBusy>
 802ca8e:	2800      	cmp	r0, #0
 802ca90:	d007      	beq.n	802caa2 <LoRaMacStop+0x1a>
    {
        MacCtx.MacState = LORAMAC_STOPPED;
        return LORAMAC_STATUS_OK;
    }
    else if(  MacCtx.MacState == LORAMAC_STOPPED )
 802ca92:	4a08      	ldr	r2, [pc, #32]	; (802cab4 <LoRaMacStop+0x2c>)
 802ca94:	23d0      	movs	r3, #208	; 0xd0
 802ca96:	009b      	lsls	r3, r3, #2
 802ca98:	58d3      	ldr	r3, [r2, r3]
 802ca9a:	2b01      	cmp	r3, #1
 802ca9c:	d007      	beq.n	802caae <LoRaMacStop+0x26>
    {
        return LORAMAC_STATUS_OK;
    }
    return LORAMAC_STATUS_BUSY;
 802ca9e:	2001      	movs	r0, #1
}
 802caa0:	bd10      	pop	{r4, pc}
        MacCtx.MacState = LORAMAC_STOPPED;
 802caa2:	4a04      	ldr	r2, [pc, #16]	; (802cab4 <LoRaMacStop+0x2c>)
 802caa4:	23d0      	movs	r3, #208	; 0xd0
 802caa6:	009b      	lsls	r3, r3, #2
 802caa8:	2101      	movs	r1, #1
 802caaa:	50d1      	str	r1, [r2, r3]
        return LORAMAC_STATUS_OK;
 802caac:	e7f8      	b.n	802caa0 <LoRaMacStop+0x18>
        return LORAMAC_STATUS_OK;
 802caae:	2000      	movs	r0, #0
 802cab0:	e7f6      	b.n	802caa0 <LoRaMacStop+0x18>
 802cab2:	46c0      	nop			; (mov r8, r8)
 802cab4:	2000a534 	.word	0x2000a534

0802cab8 <LoRaMacQueryTxPossible>:

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 802cab8:	b570      	push	{r4, r5, r6, lr}
 802caba:	b088      	sub	sp, #32
 802cabc:	0005      	movs	r5, r0
 802cabe:	000c      	movs	r4, r1
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802cac0:	4b2c      	ldr	r3, [pc, #176]	; (802cb74 <LoRaMacQueryTxPossible+0xbc>)
 802cac2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 802cac4:	9202      	str	r2, [sp, #8]
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 802cac6:	21c5      	movs	r1, #197	; 0xc5
 802cac8:	5658      	ldrsb	r0, [r3, r1]
 802caca:	4669      	mov	r1, sp
 802cacc:	71c8      	strb	r0, [r1, #7]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 802cace:	21c4      	movs	r1, #196	; 0xc4
 802cad0:	5659      	ldrsb	r1, [r3, r1]
 802cad2:	466b      	mov	r3, sp
 802cad4:	7199      	strb	r1, [r3, #6]
    size_t macCmdsSize = 0;
 802cad6:	2300      	movs	r3, #0
 802cad8:	9300      	str	r3, [sp, #0]

    if( txInfo == NULL )
 802cada:	2c00      	cmp	r4, #0
 802cadc:	d044      	beq.n	802cb68 <LoRaMacQueryTxPossible+0xb0>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // Setup ADR request
    adrNext.Version = Nvm.MacGroup2.Version;
 802cade:	a803      	add	r0, sp, #12
 802cae0:	4b24      	ldr	r3, [pc, #144]	; (802cb74 <LoRaMacQueryTxPossible+0xbc>)
 802cae2:	2186      	movs	r1, #134	; 0x86
 802cae4:	0049      	lsls	r1, r1, #1
 802cae6:	5859      	ldr	r1, [r3, r1]
 802cae8:	9103      	str	r1, [sp, #12]
    adrNext.UpdateChanMask = false;
 802caea:	2100      	movs	r1, #0
 802caec:	7101      	strb	r1, [r0, #4]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 802caee:	31fe      	adds	r1, #254	; 0xfe
 802caf0:	5c59      	ldrb	r1, [r3, r1]
 802caf2:	7141      	strb	r1, [r0, #5]
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802caf4:	6082      	str	r2, [r0, #8]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 802caf6:	4a20      	ldr	r2, [pc, #128]	; (802cb78 <LoRaMacQueryTxPossible+0xc0>)
 802caf8:	21fd      	movs	r1, #253	; 0xfd
 802cafa:	0089      	lsls	r1, r1, #2
 802cafc:	5a51      	ldrh	r1, [r2, r1]
 802cafe:	8181      	strh	r1, [r0, #12]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
 802cb00:	491e      	ldr	r1, [pc, #120]	; (802cb7c <LoRaMacQueryTxPossible+0xc4>)
 802cb02:	5a52      	ldrh	r2, [r2, r1]
 802cb04:	81c2      	strh	r2, [r0, #14]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802cb06:	2239      	movs	r2, #57	; 0x39
 802cb08:	569a      	ldrsb	r2, [r3, r2]
 802cb0a:	7402      	strb	r2, [r0, #16]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 802cb0c:	2238      	movs	r2, #56	; 0x38
 802cb0e:	569a      	ldrsb	r2, [r3, r2]
 802cb10:	7442      	strb	r2, [r0, #17]
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802cb12:	2274      	movs	r2, #116	; 0x74
 802cb14:	5c9a      	ldrb	r2, [r3, r2]
 802cb16:	7482      	strb	r2, [r0, #18]
    adrNext.Region = Nvm.MacGroup2.Region;
 802cb18:	2240      	movs	r2, #64	; 0x40
 802cb1a:	5c9b      	ldrb	r3, [r3, r2]
 802cb1c:	74c3      	strb	r3, [r0, #19]

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 802cb1e:	466b      	mov	r3, sp
 802cb20:	1dde      	adds	r6, r3, #7
 802cb22:	ab02      	add	r3, sp, #8
 802cb24:	466a      	mov	r2, sp
 802cb26:	3206      	adds	r2, #6
 802cb28:	0031      	movs	r1, r6
 802cb2a:	f000 fdad 	bl	802d688 <LoRaMacAdrCalcNext>

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 802cb2e:	2000      	movs	r0, #0
 802cb30:	5630      	ldrsb	r0, [r6, r0]
 802cb32:	f7fd fbc5 	bl	802a2c0 <GetMaxAppPayloadWithoutFOptsLength>
 802cb36:	7060      	strb	r0, [r4, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 802cb38:	4668      	mov	r0, sp
 802cb3a:	f000 fee5 	bl	802d908 <LoRaMacCommandsGetSizeSerializedCmds>
 802cb3e:	2800      	cmp	r0, #0
 802cb40:	d114      	bne.n	802cb6c <LoRaMacQueryTxPossible+0xb4>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 802cb42:	9a00      	ldr	r2, [sp, #0]
 802cb44:	2a0f      	cmp	r2, #15
 802cb46:	d80b      	bhi.n	802cb60 <LoRaMacQueryTxPossible+0xa8>
 802cb48:	7863      	ldrb	r3, [r4, #1]
 802cb4a:	0019      	movs	r1, r3
 802cb4c:	429a      	cmp	r2, r3
 802cb4e:	d807      	bhi.n	802cb60 <LoRaMacQueryTxPossible+0xa8>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 802cb50:	1a9b      	subs	r3, r3, r2
 802cb52:	7023      	strb	r3, [r4, #0]

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 802cb54:	4694      	mov	ip, r2
 802cb56:	4465      	add	r5, ip
 802cb58:	42a9      	cmp	r1, r5
 802cb5a:	d309      	bcc.n	802cb70 <LoRaMacQueryTxPossible+0xb8>
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 802cb5c:	b008      	add	sp, #32
 802cb5e:	bd70      	pop	{r4, r5, r6, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 802cb60:	2300      	movs	r3, #0
 802cb62:	7023      	strb	r3, [r4, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 802cb64:	2008      	movs	r0, #8
 802cb66:	e7f9      	b.n	802cb5c <LoRaMacQueryTxPossible+0xa4>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802cb68:	2003      	movs	r0, #3
 802cb6a:	e7f7      	b.n	802cb5c <LoRaMacQueryTxPossible+0xa4>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802cb6c:	2013      	movs	r0, #19
 802cb6e:	e7f5      	b.n	802cb5c <LoRaMacQueryTxPossible+0xa4>
           return LORAMAC_STATUS_LENGTH_ERROR;
 802cb70:	2008      	movs	r0, #8
 802cb72:	e7f3      	b.n	802cb5c <LoRaMacQueryTxPossible+0xa4>
 802cb74:	2000aa3c 	.word	0x2000aa3c
 802cb78:	2000a534 	.word	0x2000a534
 802cb7c:	000003f6 	.word	0x000003f6

0802cb80 <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 802cb80:	b510      	push	{r4, lr}
 802cb82:	b084      	sub	sp, #16
 802cb84:	1e04      	subs	r4, r0, #0
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 802cb86:	d100      	bne.n	802cb8a <LoRaMacMibGetRequestConfirm+0xa>
 802cb88:	e0d8      	b.n	802cd3c <LoRaMacMibGetRequestConfirm+0x1bc>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 802cb8a:	7800      	ldrb	r0, [r0, #0]
 802cb8c:	2828      	cmp	r0, #40	; 0x28
 802cb8e:	d900      	bls.n	802cb92 <LoRaMacMibGetRequestConfirm+0x12>
 802cb90:	e0d0      	b.n	802cd34 <LoRaMacMibGetRequestConfirm+0x1b4>
 802cb92:	0083      	lsls	r3, r0, #2
 802cb94:	4a6b      	ldr	r2, [pc, #428]	; (802cd44 <LoRaMacMibGetRequestConfirm+0x1c4>)
 802cb96:	58d3      	ldr	r3, [r2, r3]
 802cb98:	469f      	mov	pc, r3
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 802cb9a:	4a6b      	ldr	r2, [pc, #428]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cb9c:	23fc      	movs	r3, #252	; 0xfc
 802cb9e:	5cd3      	ldrb	r3, [r2, r3]
 802cba0:	7123      	strb	r3, [r4, #4]
            break;
 802cba2:	e0cc      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_NETWORK_ACTIVATION:
        {
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 802cba4:	4a68      	ldr	r2, [pc, #416]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cba6:	2388      	movs	r3, #136	; 0x88
 802cba8:	005b      	lsls	r3, r3, #1
 802cbaa:	5cd3      	ldrb	r3, [r2, r3]
 802cbac:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbae:	2000      	movs	r0, #0
            break;
 802cbb0:	e0c5      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_DEV_EUI:
        {
            mibGet->Param.DevEui = SecureElementGetDevEui( );
 802cbb2:	f004 fdaf 	bl	8031714 <SecureElementGetDevEui>
 802cbb6:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbb8:	2000      	movs	r0, #0
            break;
 802cbba:	e0c0      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_JOIN_EUI:
        {
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 802cbbc:	f004 fdc0 	bl	8031740 <SecureElementGetJoinEui>
 802cbc0:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbc2:	2000      	movs	r0, #0
            break;
 802cbc4:	e0bb      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_ADR:
        {
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 802cbc6:	4a60      	ldr	r2, [pc, #384]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cbc8:	23fe      	movs	r3, #254	; 0xfe
 802cbca:	5cd3      	ldrb	r3, [r2, r3]
 802cbcc:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbce:	2000      	movs	r0, #0
            break;
 802cbd0:	e0b5      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_NET_ID:
        {
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 802cbd2:	4a5d      	ldr	r2, [pc, #372]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cbd4:	23c8      	movs	r3, #200	; 0xc8
 802cbd6:	58d3      	ldr	r3, [r2, r3]
 802cbd8:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbda:	2000      	movs	r0, #0
            break;
 802cbdc:	e0af      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_DEV_ADDR:
        {
            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;
 802cbde:	4a5a      	ldr	r2, [pc, #360]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cbe0:	23cc      	movs	r3, #204	; 0xcc
 802cbe2:	58d3      	ldr	r3, [r2, r3]
 802cbe4:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbe6:	2000      	movs	r0, #0
            break;
 802cbe8:	e0a9      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_PUBLIC_NETWORK:
        {
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 802cbea:	4a57      	ldr	r2, [pc, #348]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cbec:	23fd      	movs	r3, #253	; 0xfd
 802cbee:	5cd3      	ldrb	r3, [r2, r3]
 802cbf0:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbf2:	2000      	movs	r0, #0
            break;
 802cbf4:	e0a3      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        /* ST_WORKAROUND_BEGIN: Keep repeater feature */
        case MIB_REPEATER_SUPPORT:
        {
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 802cbf6:	4a54      	ldr	r2, [pc, #336]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cbf8:	2380      	movs	r3, #128	; 0x80
 802cbfa:	5cd3      	ldrb	r3, [r2, r3]
 802cbfc:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cbfe:	2000      	movs	r0, #0
            break;
 802cc00:	e09d      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        /* ST_WORKAROUND_END */
        case MIB_CHANNELS:
        {
            getPhy.Attribute = PHY_CHANNELS;
 802cc02:	a902      	add	r1, sp, #8
 802cc04:	231d      	movs	r3, #29
 802cc06:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cc08:	4a4f      	ldr	r2, [pc, #316]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc0a:	3323      	adds	r3, #35	; 0x23
 802cc0c:	5cd0      	ldrb	r0, [r2, r3]
 802cc0e:	f001 fd71 	bl	802e6f4 <RegionGetPhyParam>

            mibGet->Param.ChannelList = phyParam.Channels;
 802cc12:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc14:	2000      	movs	r0, #0
            break;
 802cc16:	e092      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_RX2_CHANNEL:
        {
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 802cc18:	3404      	adds	r4, #4
 802cc1a:	4b4b      	ldr	r3, [pc, #300]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc1c:	3364      	adds	r3, #100	; 0x64
 802cc1e:	cb06      	ldmia	r3!, {r1, r2}
 802cc20:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc22:	2000      	movs	r0, #0
            break;
 802cc24:	e08b      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_RX2_DEFAULT_CHANNEL:
        {
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 802cc26:	3404      	adds	r4, #4
 802cc28:	4b47      	ldr	r3, [pc, #284]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc2a:	33a4      	adds	r3, #164	; 0xa4
 802cc2c:	cb06      	ldmia	r3!, {r1, r2}
 802cc2e:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc30:	2000      	movs	r0, #0
            break;
 802cc32:	e084      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_RXC_CHANNEL:
        {
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 802cc34:	3404      	adds	r4, #4
 802cc36:	4b44      	ldr	r3, [pc, #272]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc38:	336c      	adds	r3, #108	; 0x6c
 802cc3a:	cb06      	ldmia	r3!, {r1, r2}
 802cc3c:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc3e:	2000      	movs	r0, #0
            break;
 802cc40:	e07d      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_RXC_DEFAULT_CHANNEL:
        {
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 802cc42:	3404      	adds	r4, #4
 802cc44:	4b40      	ldr	r3, [pc, #256]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc46:	33ac      	adds	r3, #172	; 0xac
 802cc48:	cb06      	ldmia	r3!, {r1, r2}
 802cc4a:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc4c:	2000      	movs	r0, #0
            break;
 802cc4e:	e076      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_CHANNELS_DEFAULT_MASK:
        {
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 802cc50:	a902      	add	r1, sp, #8
 802cc52:	231b      	movs	r3, #27
 802cc54:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cc56:	4a3c      	ldr	r2, [pc, #240]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc58:	3325      	adds	r3, #37	; 0x25
 802cc5a:	5cd0      	ldrb	r0, [r2, r3]
 802cc5c:	f001 fd4a 	bl	802e6f4 <RegionGetPhyParam>

            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;
 802cc60:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc62:	2000      	movs	r0, #0
            break;
 802cc64:	e06b      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_CHANNELS_MASK:
        {
            getPhy.Attribute = PHY_CHANNELS_MASK;
 802cc66:	a902      	add	r1, sp, #8
 802cc68:	231a      	movs	r3, #26
 802cc6a:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cc6c:	4a36      	ldr	r2, [pc, #216]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc6e:	3326      	adds	r3, #38	; 0x26
 802cc70:	5cd0      	ldrb	r0, [r2, r3]
 802cc72:	f001 fd3f 	bl	802e6f4 <RegionGetPhyParam>

            mibGet->Param.ChannelsMask = phyParam.ChannelsMask;
 802cc76:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc78:	2000      	movs	r0, #0
            break;
 802cc7a:	e060      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_CHANNELS_NB_TRANS:
        {
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 802cc7c:	4a32      	ldr	r2, [pc, #200]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc7e:	2360      	movs	r3, #96	; 0x60
 802cc80:	5cd3      	ldrb	r3, [r2, r3]
 802cc82:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc84:	2000      	movs	r0, #0
            break;
 802cc86:	e05a      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_MAX_RX_WINDOW_DURATION:
        {
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 802cc88:	4b2f      	ldr	r3, [pc, #188]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc8a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802cc8c:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc8e:	2000      	movs	r0, #0
            break;
 802cc90:	e055      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_RECEIVE_DELAY_1:
        {
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 802cc92:	4b2d      	ldr	r3, [pc, #180]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc94:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802cc96:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cc98:	2000      	movs	r0, #0
            break;
 802cc9a:	e050      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_RECEIVE_DELAY_2:
        {
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 802cc9c:	4b2a      	ldr	r3, [pc, #168]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cc9e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802cca0:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cca2:	2000      	movs	r0, #0
            break;
 802cca4:	e04b      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_JOIN_ACCEPT_DELAY_1:
        {
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 802cca6:	4b28      	ldr	r3, [pc, #160]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cca8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802ccaa:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ccac:	2000      	movs	r0, #0
            break;
 802ccae:	e046      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_JOIN_ACCEPT_DELAY_2:
        {
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 802ccb0:	4b25      	ldr	r3, [pc, #148]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802ccb2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802ccb4:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ccb6:	2000      	movs	r0, #0
            break;
 802ccb8:	e041      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_CHANNELS_DEFAULT_DATARATE:
        {
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 802ccba:	4a23      	ldr	r2, [pc, #140]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802ccbc:	23c5      	movs	r3, #197	; 0xc5
 802ccbe:	56d3      	ldrsb	r3, [r2, r3]
 802ccc0:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ccc2:	2000      	movs	r0, #0
            break;
 802ccc4:	e03b      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_CHANNELS_DATARATE:
        {
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 802ccc6:	4a20      	ldr	r2, [pc, #128]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802ccc8:	2339      	movs	r3, #57	; 0x39
 802ccca:	56d3      	ldrsb	r3, [r2, r3]
 802cccc:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ccce:	2000      	movs	r0, #0
            break;
 802ccd0:	e035      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_CHANNELS_DEFAULT_TX_POWER:
        {
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 802ccd2:	4a1d      	ldr	r2, [pc, #116]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802ccd4:	23c4      	movs	r3, #196	; 0xc4
 802ccd6:	56d3      	ldrsb	r3, [r2, r3]
 802ccd8:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ccda:	2000      	movs	r0, #0
            break;
 802ccdc:	e02f      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_CHANNELS_TX_POWER:
        {
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 802ccde:	4a1a      	ldr	r2, [pc, #104]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cce0:	2338      	movs	r3, #56	; 0x38
 802cce2:	56d3      	ldrsb	r3, [r2, r3]
 802cce4:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cce6:	2000      	movs	r0, #0
            break;
 802cce8:	e029      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_SYSTEM_MAX_RX_ERROR:
        {
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 802ccea:	4b17      	ldr	r3, [pc, #92]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802ccec:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802ccee:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ccf0:	2000      	movs	r0, #0
            break;
 802ccf2:	e024      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_MIN_RX_SYMBOLS:
        {
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 802ccf4:	4a14      	ldr	r2, [pc, #80]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802ccf6:	2348      	movs	r3, #72	; 0x48
 802ccf8:	5cd3      	ldrb	r3, [r2, r3]
 802ccfa:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ccfc:	2000      	movs	r0, #0
            break;
 802ccfe:	e01e      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_ANTENNA_GAIN:
        {
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 802cd00:	4b11      	ldr	r3, [pc, #68]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cd02:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 802cd04:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cd06:	2000      	movs	r0, #0
            break;
 802cd08:	e019      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_NVM_CTXS:
        {
            mibGet->Param.Contexts = GetNvmData( );
 802cd0a:	f7fd f9e1 	bl	802a0d0 <GetNvmData>
 802cd0e:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cd10:	2000      	movs	r0, #0
            break;
 802cd12:	e014      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_DEFAULT_ANTENNA_GAIN:
        {
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 802cd14:	4a0c      	ldr	r2, [pc, #48]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cd16:	23bc      	movs	r3, #188	; 0xbc
 802cd18:	58d3      	ldr	r3, [r2, r3]
 802cd1a:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cd1c:	2000      	movs	r0, #0
            break;
 802cd1e:	e00e      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        case MIB_LORAWAN_VERSION:
        {
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 802cd20:	4a09      	ldr	r2, [pc, #36]	; (802cd48 <LoRaMacMibGetRequestConfirm+0x1c8>)
 802cd22:	2386      	movs	r3, #134	; 0x86
 802cd24:	005b      	lsls	r3, r3, #1
 802cd26:	58d3      	ldr	r3, [r2, r3]
 802cd28:	6063      	str	r3, [r4, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 802cd2a:	f001 fe0d 	bl	802e948 <RegionGetVersion>
 802cd2e:	60a0      	str	r0, [r4, #8]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cd30:	2000      	movs	r0, #0
            break;
 802cd32:	e004      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        }
        default:
        {
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 802cd34:	0020      	movs	r0, r4
 802cd36:	f000 fcc8 	bl	802d6ca <LoRaMacClassBMibGetRequestConfirm>
            break;
 802cd3a:	e000      	b.n	802cd3e <LoRaMacMibGetRequestConfirm+0x1be>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802cd3c:	2003      	movs	r0, #3
        }
    }
    return status;
}
 802cd3e:	b004      	add	sp, #16
 802cd40:	bd10      	pop	{r4, pc}
 802cd42:	46c0      	nop			; (mov r8, r8)
 802cd44:	08034f20 	.word	0x08034f20
 802cd48:	2000aa3c 	.word	0x2000aa3c

0802cd4c <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 802cd4c:	b530      	push	{r4, r5, lr}
 802cd4e:	b085      	sub	sp, #20
 802cd50:	1e04      	subs	r4, r0, #0
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 802cd52:	d100      	bne.n	802cd56 <LoRaMacMibSetRequestConfirm+0xa>
 802cd54:	e20d      	b.n	802d172 <LoRaMacMibSetRequestConfirm+0x426>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 802cd56:	4ad2      	ldr	r2, [pc, #840]	; (802d0a0 <LoRaMacMibSetRequestConfirm+0x354>)
 802cd58:	23d0      	movs	r3, #208	; 0xd0
 802cd5a:	009b      	lsls	r3, r3, #2
 802cd5c:	58d3      	ldr	r3, [r2, r3]
 802cd5e:	079b      	lsls	r3, r3, #30
 802cd60:	d500      	bpl.n	802cd64 <LoRaMacMibSetRequestConfirm+0x18>
 802cd62:	e208      	b.n	802d176 <LoRaMacMibSetRequestConfirm+0x42a>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 802cd64:	7805      	ldrb	r5, [r0, #0]
 802cd66:	2d27      	cmp	r5, #39	; 0x27
 802cd68:	d900      	bls.n	802cd6c <LoRaMacMibSetRequestConfirm+0x20>
 802cd6a:	e1fd      	b.n	802d168 <LoRaMacMibSetRequestConfirm+0x41c>
 802cd6c:	00ab      	lsls	r3, r5, #2
 802cd6e:	4acd      	ldr	r2, [pc, #820]	; (802d0a4 <LoRaMacMibSetRequestConfirm+0x358>)
 802cd70:	58d3      	ldr	r3, [r2, r3]
 802cd72:	469f      	mov	pc, r3
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 802cd74:	7900      	ldrb	r0, [r0, #4]
 802cd76:	f7ff f9dd 	bl	802c134 <SwitchClass>
 802cd7a:	0005      	movs	r5, r0
            break;
 802cd7c:	e1fc      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_NETWORK_ACTIVATION:
        {
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 802cd7e:	7903      	ldrb	r3, [r0, #4]
 802cd80:	2b02      	cmp	r3, #2
 802cd82:	d100      	bne.n	802cd86 <LoRaMacMibSetRequestConfirm+0x3a>
 802cd84:	e1fb      	b.n	802d17e <LoRaMacMibSetRequestConfirm+0x432>
            {
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 802cd86:	49c8      	ldr	r1, [pc, #800]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cd88:	2288      	movs	r2, #136	; 0x88
 802cd8a:	0052      	lsls	r2, r2, #1
 802cd8c:	548b      	strb	r3, [r1, r2]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cd8e:	2500      	movs	r5, #0
 802cd90:	e1f2      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_DEV_EUI:
        {
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 802cd92:	6840      	ldr	r0, [r0, #4]
 802cd94:	f004 fcb0 	bl	80316f8 <SecureElementSetDevEui>
 802cd98:	1e05      	subs	r5, r0, #0
 802cd9a:	d100      	bne.n	802cd9e <LoRaMacMibSetRequestConfirm+0x52>
 802cd9c:	e1ec      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802cd9e:	2503      	movs	r5, #3
 802cda0:	e1ea      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_JOIN_EUI:
        {
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 802cda2:	6840      	ldr	r0, [r0, #4]
 802cda4:	f004 fcbc 	bl	8031720 <SecureElementSetJoinEui>
 802cda8:	2800      	cmp	r0, #0
 802cdaa:	d000      	beq.n	802cdae <LoRaMacMibSetRequestConfirm+0x62>
 802cdac:	e1e4      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cdae:	0005      	movs	r5, r0
 802cdb0:	e1e2      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_ADR:
        {
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 802cdb2:	7901      	ldrb	r1, [r0, #4]
 802cdb4:	4abc      	ldr	r2, [pc, #752]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cdb6:	23fe      	movs	r3, #254	; 0xfe
 802cdb8:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cdba:	2500      	movs	r5, #0
            break;
 802cdbc:	e1dc      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_NET_ID:
        {
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 802cdbe:	6841      	ldr	r1, [r0, #4]
 802cdc0:	4ab9      	ldr	r2, [pc, #740]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cdc2:	23c8      	movs	r3, #200	; 0xc8
 802cdc4:	50d1      	str	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cdc6:	2500      	movs	r5, #0
            break;
 802cdc8:	e1d6      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_DEV_ADDR:
        {
            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 802cdca:	6841      	ldr	r1, [r0, #4]
 802cdcc:	4ab6      	ldr	r2, [pc, #728]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cdce:	23cc      	movs	r3, #204	; 0xcc
 802cdd0:	50d1      	str	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cdd2:	2500      	movs	r5, #0
            break;
 802cdd4:	e1d0      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_APP_KEY:
        {
            if( mibSet->Param.AppKey != NULL )
 802cdd6:	6841      	ldr	r1, [r0, #4]
 802cdd8:	2900      	cmp	r1, #0
 802cdda:	d100      	bne.n	802cdde <LoRaMacMibSetRequestConfirm+0x92>
 802cddc:	e1d1      	b.n	802d182 <LoRaMacMibSetRequestConfirm+0x436>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 802cdde:	2000      	movs	r0, #0
 802cde0:	f001 fa8c 	bl	802e2fc <LoRaMacCryptoSetKey>
 802cde4:	1e05      	subs	r5, r0, #0
 802cde6:	d100      	bne.n	802cdea <LoRaMacMibSetRequestConfirm+0x9e>
 802cde8:	e1c6      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802cdea:	2511      	movs	r5, #17
 802cdec:	e1c4      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_NWK_KEY:
        {
            if( mibSet->Param.NwkKey != NULL )
 802cdee:	6841      	ldr	r1, [r0, #4]
 802cdf0:	2900      	cmp	r1, #0
 802cdf2:	d100      	bne.n	802cdf6 <LoRaMacMibSetRequestConfirm+0xaa>
 802cdf4:	e1c7      	b.n	802d186 <LoRaMacMibSetRequestConfirm+0x43a>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 802cdf6:	2001      	movs	r0, #1
 802cdf8:	f001 fa80 	bl	802e2fc <LoRaMacCryptoSetKey>
 802cdfc:	1e05      	subs	r5, r0, #0
 802cdfe:	d100      	bne.n	802ce02 <LoRaMacMibSetRequestConfirm+0xb6>
 802ce00:	e1ba      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802ce02:	2511      	movs	r5, #17
 802ce04:	e1b8      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            break;
        }
#else /* USE_LRWAN_1_1_X_CRYPTO == 0 */
        case MIB_NWK_S_KEY:
        {
            if( mibSet->Param.NwkSKey != NULL )
 802ce06:	6841      	ldr	r1, [r0, #4]
 802ce08:	2900      	cmp	r1, #0
 802ce0a:	d100      	bne.n	802ce0e <LoRaMacMibSetRequestConfirm+0xc2>
 802ce0c:	e1bd      	b.n	802d18a <LoRaMacMibSetRequestConfirm+0x43e>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 802ce0e:	2002      	movs	r0, #2
 802ce10:	f001 fa74 	bl	802e2fc <LoRaMacCryptoSetKey>
 802ce14:	1e05      	subs	r5, r0, #0
 802ce16:	d100      	bne.n	802ce1a <LoRaMacMibSetRequestConfirm+0xce>
 802ce18:	e1ae      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802ce1a:	2511      	movs	r5, #17
 802ce1c:	e1ac      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            break;
        }
#endif /* USE_LRWAN_1_1_X_CRYPTO */
        case MIB_APP_S_KEY:
        {
            if( mibSet->Param.AppSKey != NULL )
 802ce1e:	6841      	ldr	r1, [r0, #4]
 802ce20:	2900      	cmp	r1, #0
 802ce22:	d100      	bne.n	802ce26 <LoRaMacMibSetRequestConfirm+0xda>
 802ce24:	e1b3      	b.n	802d18e <LoRaMacMibSetRequestConfirm+0x442>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 802ce26:	2003      	movs	r0, #3
 802ce28:	f001 fa68 	bl	802e2fc <LoRaMacCryptoSetKey>
 802ce2c:	1e05      	subs	r5, r0, #0
 802ce2e:	d100      	bne.n	802ce32 <LoRaMacMibSetRequestConfirm+0xe6>
 802ce30:	e1a2      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802ce32:	2511      	movs	r5, #17
 802ce34:	e1a0      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_MC_KE_KEY:
        {
            if( mibSet->Param.McKEKey != NULL )
 802ce36:	6841      	ldr	r1, [r0, #4]
 802ce38:	2900      	cmp	r1, #0
 802ce3a:	d100      	bne.n	802ce3e <LoRaMacMibSetRequestConfirm+0xf2>
 802ce3c:	e1a9      	b.n	802d192 <LoRaMacMibSetRequestConfirm+0x446>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 802ce3e:	207f      	movs	r0, #127	; 0x7f
 802ce40:	f001 fa5c 	bl	802e2fc <LoRaMacCryptoSetKey>
 802ce44:	1e05      	subs	r5, r0, #0
 802ce46:	d100      	bne.n	802ce4a <LoRaMacMibSetRequestConfirm+0xfe>
 802ce48:	e196      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802ce4a:	2511      	movs	r5, #17
 802ce4c:	e194      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            break;
        }
#if ( LORAMAC_MAX_MC_CTX > 0 ) /* ST_WORKAROUND: reduced LORAMAC_MAX_MC_CTX */
        case MIB_MC_KEY_0:
        {
            if( mibSet->Param.McKey0 != NULL )
 802ce4e:	6841      	ldr	r1, [r0, #4]
 802ce50:	2900      	cmp	r1, #0
 802ce52:	d100      	bne.n	802ce56 <LoRaMacMibSetRequestConfirm+0x10a>
 802ce54:	e19f      	b.n	802d196 <LoRaMacMibSetRequestConfirm+0x44a>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 802ce56:	2080      	movs	r0, #128	; 0x80
 802ce58:	f001 fa50 	bl	802e2fc <LoRaMacCryptoSetKey>
 802ce5c:	1e05      	subs	r5, r0, #0
 802ce5e:	d100      	bne.n	802ce62 <LoRaMacMibSetRequestConfirm+0x116>
 802ce60:	e18a      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802ce62:	2511      	movs	r5, #17
 802ce64:	e188      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_MC_APP_S_KEY_0:
        {
            if( mibSet->Param.McAppSKey0 != NULL )
 802ce66:	6841      	ldr	r1, [r0, #4]
 802ce68:	2900      	cmp	r1, #0
 802ce6a:	d100      	bne.n	802ce6e <LoRaMacMibSetRequestConfirm+0x122>
 802ce6c:	e195      	b.n	802d19a <LoRaMacMibSetRequestConfirm+0x44e>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 802ce6e:	2081      	movs	r0, #129	; 0x81
 802ce70:	f001 fa44 	bl	802e2fc <LoRaMacCryptoSetKey>
 802ce74:	1e05      	subs	r5, r0, #0
 802ce76:	d100      	bne.n	802ce7a <LoRaMacMibSetRequestConfirm+0x12e>
 802ce78:	e17e      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802ce7a:	2511      	movs	r5, #17
 802ce7c:	e17c      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_MC_NWK_S_KEY_0:
        {
            if( mibSet->Param.McNwkSKey0 != NULL )
 802ce7e:	6841      	ldr	r1, [r0, #4]
 802ce80:	2900      	cmp	r1, #0
 802ce82:	d100      	bne.n	802ce86 <LoRaMacMibSetRequestConfirm+0x13a>
 802ce84:	e18b      	b.n	802d19e <LoRaMacMibSetRequestConfirm+0x452>
            {
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 802ce86:	2082      	movs	r0, #130	; 0x82
 802ce88:	f001 fa38 	bl	802e2fc <LoRaMacCryptoSetKey>
 802ce8c:	1e05      	subs	r5, r0, #0
 802ce8e:	d100      	bne.n	802ce92 <LoRaMacMibSetRequestConfirm+0x146>
 802ce90:	e172      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802ce92:	2511      	movs	r5, #17
 802ce94:	e170      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            break;
        }
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        case MIB_PUBLIC_NETWORK:
        {
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 802ce96:	7900      	ldrb	r0, [r0, #4]
 802ce98:	4a83      	ldr	r2, [pc, #524]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802ce9a:	23fd      	movs	r3, #253	; 0xfd
 802ce9c:	54d0      	strb	r0, [r2, r3]
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 802ce9e:	4c83      	ldr	r4, [pc, #524]	; (802d0ac <LoRaMacMibSetRequestConfirm+0x360>)
 802cea0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802cea2:	4798      	blx	r3
            /* ST_WORAROUND_BEGIN: Required to avoid keeping the radio active after init */
            Radio.Sleep( );
 802cea4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 802cea6:	4798      	blx	r3
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cea8:	2500      	movs	r5, #0
            /* ST_WORKAROUND_END */
            break;
 802ceaa:	e165      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        /* ST_WORKAROUND_BEGIN: Keep repeater feature */
        case MIB_REPEATER_SUPPORT:
        {
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 802ceac:	7901      	ldrb	r1, [r0, #4]
 802ceae:	4a7e      	ldr	r2, [pc, #504]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802ceb0:	2380      	movs	r3, #128	; 0x80
 802ceb2:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802ceb4:	2500      	movs	r5, #0
            break;
 802ceb6:	e15f      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        /* ST_WORKAROUND_END */
        case MIB_RX2_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 802ceb8:	2308      	movs	r3, #8
 802ceba:	56c3      	ldrsb	r3, [r0, r3]
 802cebc:	466a      	mov	r2, sp
 802cebe:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802cec0:	4b79      	ldr	r3, [pc, #484]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cec2:	2275      	movs	r2, #117	; 0x75
 802cec4:	5c9a      	ldrb	r2, [r3, r2]
 802cec6:	4669      	mov	r1, sp
 802cec8:	714a      	strb	r2, [r1, #5]
            /* ST_WORAROUND_BEGIN: Check also the Rx Frequency parameter */
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 802ceca:	2240      	movs	r2, #64	; 0x40
 802cecc:	5c98      	ldrb	r0, [r3, r2]
 802cece:	3a39      	subs	r2, #57	; 0x39
 802ced0:	a901      	add	r1, sp, #4
 802ced2:	f001 fc42 	bl	802e75a <RegionVerify>
 802ced6:	2800      	cmp	r0, #0
 802ced8:	d101      	bne.n	802cede <LoRaMacMibSetRequestConfirm+0x192>
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802ceda:	2503      	movs	r5, #3
 802cedc:	e14c      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            else
            {
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 802cede:	6863      	ldr	r3, [r4, #4]
 802cee0:	9301      	str	r3, [sp, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 802cee2:	4a71      	ldr	r2, [pc, #452]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cee4:	2340      	movs	r3, #64	; 0x40
 802cee6:	5cd0      	ldrb	r0, [r2, r3]
 802cee8:	2200      	movs	r2, #0
 802ceea:	a901      	add	r1, sp, #4
 802ceec:	f001 fc35 	bl	802e75a <RegionVerify>
 802cef0:	2800      	cmp	r0, #0
 802cef2:	d100      	bne.n	802cef6 <LoRaMacMibSetRequestConfirm+0x1aa>
 802cef4:	e155      	b.n	802d1a2 <LoRaMacMibSetRequestConfirm+0x456>
                {
                    status = LORAMAC_STATUS_PARAMETER_INVALID;
                }
                else
                {
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 802cef6:	4b6c      	ldr	r3, [pc, #432]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cef8:	3364      	adds	r3, #100	; 0x64
 802cefa:	3404      	adds	r4, #4
 802cefc:	cc06      	ldmia	r4!, {r1, r2}
 802cefe:	c306      	stmia	r3!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cf00:	2500      	movs	r5, #0
 802cf02:	e139      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            /* ST_WORKAROUND_END */
            break;
        }
        case MIB_RX2_DEFAULT_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 802cf04:	2308      	movs	r3, #8
 802cf06:	56c3      	ldrsb	r3, [r0, r3]
 802cf08:	466a      	mov	r2, sp
 802cf0a:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802cf0c:	4b66      	ldr	r3, [pc, #408]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cf0e:	2275      	movs	r2, #117	; 0x75
 802cf10:	5c9a      	ldrb	r2, [r3, r2]
 802cf12:	4669      	mov	r1, sp
 802cf14:	714a      	strb	r2, [r1, #5]

            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 802cf16:	2240      	movs	r2, #64	; 0x40
 802cf18:	5c98      	ldrb	r0, [r3, r2]
 802cf1a:	3a39      	subs	r2, #57	; 0x39
 802cf1c:	a901      	add	r1, sp, #4
 802cf1e:	f001 fc1c 	bl	802e75a <RegionVerify>
 802cf22:	2800      	cmp	r0, #0
 802cf24:	d100      	bne.n	802cf28 <LoRaMacMibSetRequestConfirm+0x1dc>
 802cf26:	e13e      	b.n	802d1a6 <LoRaMacMibSetRequestConfirm+0x45a>
            {
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 802cf28:	4b5f      	ldr	r3, [pc, #380]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cf2a:	33a4      	adds	r3, #164	; 0xa4
 802cf2c:	3404      	adds	r4, #4
 802cf2e:	cc06      	ldmia	r4!, {r1, r2}
 802cf30:	c306      	stmia	r3!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cf32:	2500      	movs	r5, #0
 802cf34:	e120      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_RXC_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 802cf36:	2308      	movs	r3, #8
 802cf38:	56c3      	ldrsb	r3, [r0, r3]
 802cf3a:	466a      	mov	r2, sp
 802cf3c:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802cf3e:	4b5a      	ldr	r3, [pc, #360]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cf40:	2275      	movs	r2, #117	; 0x75
 802cf42:	5c9a      	ldrb	r2, [r3, r2]
 802cf44:	4669      	mov	r1, sp
 802cf46:	714a      	strb	r2, [r1, #5]

            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 802cf48:	2240      	movs	r2, #64	; 0x40
 802cf4a:	5c98      	ldrb	r0, [r3, r2]
 802cf4c:	3a39      	subs	r2, #57	; 0x39
 802cf4e:	a901      	add	r1, sp, #4
 802cf50:	f001 fc03 	bl	802e75a <RegionVerify>
 802cf54:	2800      	cmp	r0, #0
 802cf56:	d100      	bne.n	802cf5a <LoRaMacMibSetRequestConfirm+0x20e>
 802cf58:	e127      	b.n	802d1aa <LoRaMacMibSetRequestConfirm+0x45e>
            {
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 802cf5a:	4a53      	ldr	r2, [pc, #332]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cf5c:	0013      	movs	r3, r2
 802cf5e:	336c      	adds	r3, #108	; 0x6c
 802cf60:	3404      	adds	r4, #4
 802cf62:	cc03      	ldmia	r4!, {r0, r1}
 802cf64:	c303      	stmia	r3!, {r0, r1}

                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 802cf66:	23fc      	movs	r3, #252	; 0xfc
 802cf68:	5cd3      	ldrb	r3, [r2, r3]
 802cf6a:	2b02      	cmp	r3, #2
 802cf6c:	d001      	beq.n	802cf72 <LoRaMacMibSetRequestConfirm+0x226>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cf6e:	2500      	movs	r5, #0
 802cf70:	e102      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 802cf72:	330f      	adds	r3, #15
 802cf74:	33ff      	adds	r3, #255	; 0xff
 802cf76:	5cd5      	ldrb	r5, [r2, r3]
 802cf78:	2d00      	cmp	r5, #0
 802cf7a:	d100      	bne.n	802cf7e <LoRaMacMibSetRequestConfirm+0x232>
 802cf7c:	e0fc      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                {
                    // We can only compute the RX window parameters directly, if we are already
                    // in class c mode and joined. We cannot setup an RX window in case of any other
                    // class type.
                    // Set the radio into sleep mode in case we are still in RX mode
                    Radio.Sleep( );
 802cf7e:	4b4b      	ldr	r3, [pc, #300]	; (802d0ac <LoRaMacMibSetRequestConfirm+0x360>)
 802cf80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802cf82:	4798      	blx	r3

                    OpenContinuousRxCWindow( );
 802cf84:	f7fe febe 	bl	802bd04 <OpenContinuousRxCWindow>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cf88:	2500      	movs	r5, #0
 802cf8a:	e0f5      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_RXC_DEFAULT_CHANNEL:
        {
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 802cf8c:	2308      	movs	r3, #8
 802cf8e:	56c3      	ldrsb	r3, [r0, r3]
 802cf90:	466a      	mov	r2, sp
 802cf92:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802cf94:	4b44      	ldr	r3, [pc, #272]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cf96:	2275      	movs	r2, #117	; 0x75
 802cf98:	5c9a      	ldrb	r2, [r3, r2]
 802cf9a:	4669      	mov	r1, sp
 802cf9c:	714a      	strb	r2, [r1, #5]

            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 802cf9e:	2240      	movs	r2, #64	; 0x40
 802cfa0:	5c98      	ldrb	r0, [r3, r2]
 802cfa2:	3a39      	subs	r2, #57	; 0x39
 802cfa4:	a901      	add	r1, sp, #4
 802cfa6:	f001 fbd8 	bl	802e75a <RegionVerify>
 802cfaa:	2800      	cmp	r0, #0
 802cfac:	d100      	bne.n	802cfb0 <LoRaMacMibSetRequestConfirm+0x264>
 802cfae:	e0fe      	b.n	802d1ae <LoRaMacMibSetRequestConfirm+0x462>
            {
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 802cfb0:	4b3d      	ldr	r3, [pc, #244]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cfb2:	33ac      	adds	r3, #172	; 0xac
 802cfb4:	3404      	adds	r4, #4
 802cfb6:	cc06      	ldmia	r4!, {r1, r2}
 802cfb8:	c306      	stmia	r3!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cfba:	2500      	movs	r5, #0
 802cfbc:	e0dc      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_CHANNELS_DEFAULT_MASK:
        {
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 802cfbe:	6843      	ldr	r3, [r0, #4]
 802cfc0:	9302      	str	r3, [sp, #8]
 802cfc2:	a902      	add	r1, sp, #8
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 802cfc4:	2301      	movs	r3, #1
 802cfc6:	710b      	strb	r3, [r1, #4]

            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 802cfc8:	4a37      	ldr	r2, [pc, #220]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cfca:	333f      	adds	r3, #63	; 0x3f
 802cfcc:	5cd0      	ldrb	r0, [r2, r3]
 802cfce:	f001 fbe2 	bl	802e796 <RegionChanMaskSet>
 802cfd2:	2800      	cmp	r0, #0
 802cfd4:	d100      	bne.n	802cfd8 <LoRaMacMibSetRequestConfirm+0x28c>
 802cfd6:	e0ec      	b.n	802d1b2 <LoRaMacMibSetRequestConfirm+0x466>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cfd8:	2500      	movs	r5, #0
 802cfda:	e0cd      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_CHANNELS_MASK:
        {
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 802cfdc:	6843      	ldr	r3, [r0, #4]
 802cfde:	9302      	str	r3, [sp, #8]
 802cfe0:	a902      	add	r1, sp, #8
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 802cfe2:	2300      	movs	r3, #0
 802cfe4:	710b      	strb	r3, [r1, #4]

            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 802cfe6:	4a30      	ldr	r2, [pc, #192]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802cfe8:	3340      	adds	r3, #64	; 0x40
 802cfea:	5cd0      	ldrb	r0, [r2, r3]
 802cfec:	f001 fbd3 	bl	802e796 <RegionChanMaskSet>
 802cff0:	2800      	cmp	r0, #0
 802cff2:	d100      	bne.n	802cff6 <LoRaMacMibSetRequestConfirm+0x2aa>
 802cff4:	e0df      	b.n	802d1b6 <LoRaMacMibSetRequestConfirm+0x46a>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802cff6:	2500      	movs	r5, #0
 802cff8:	e0be      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_CHANNELS_NB_TRANS:
        {
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 802cffa:	7902      	ldrb	r2, [r0, #4]
 802cffc:	1e53      	subs	r3, r2, #1
 802cffe:	b2db      	uxtb	r3, r3
 802d000:	2b0e      	cmp	r3, #14
 802d002:	d900      	bls.n	802d006 <LoRaMacMibSetRequestConfirm+0x2ba>
 802d004:	e0d9      	b.n	802d1ba <LoRaMacMibSetRequestConfirm+0x46e>
                ( mibSet->Param.ChannelsNbTrans <= 15 ) )
            {
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 802d006:	4928      	ldr	r1, [pc, #160]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d008:	2360      	movs	r3, #96	; 0x60
 802d00a:	54ca      	strb	r2, [r1, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d00c:	2500      	movs	r5, #0
 802d00e:	e0b3      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_MAX_RX_WINDOW_DURATION:
        {
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 802d010:	6842      	ldr	r2, [r0, #4]
 802d012:	4b25      	ldr	r3, [pc, #148]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d014:	64da      	str	r2, [r3, #76]	; 0x4c
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d016:	2500      	movs	r5, #0
            break;
 802d018:	e0ae      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_RECEIVE_DELAY_1:
        {
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 802d01a:	6842      	ldr	r2, [r0, #4]
 802d01c:	4b22      	ldr	r3, [pc, #136]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d01e:	651a      	str	r2, [r3, #80]	; 0x50
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d020:	2500      	movs	r5, #0
            break;
 802d022:	e0a9      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_RECEIVE_DELAY_2:
        {
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 802d024:	6842      	ldr	r2, [r0, #4]
 802d026:	4b20      	ldr	r3, [pc, #128]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d028:	655a      	str	r2, [r3, #84]	; 0x54
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d02a:	2500      	movs	r5, #0
            break;
 802d02c:	e0a4      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_JOIN_ACCEPT_DELAY_1:
        {
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 802d02e:	6842      	ldr	r2, [r0, #4]
 802d030:	4b1d      	ldr	r3, [pc, #116]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d032:	659a      	str	r2, [r3, #88]	; 0x58
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d034:	2500      	movs	r5, #0
            break;
 802d036:	e09f      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_JOIN_ACCEPT_DELAY_2:
        {
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 802d038:	6842      	ldr	r2, [r0, #4]
 802d03a:	4b1b      	ldr	r3, [pc, #108]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d03c:	65da      	str	r2, [r3, #92]	; 0x5c
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d03e:	2500      	movs	r5, #0
            break;
 802d040:	e09a      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_CHANNELS_DEFAULT_DATARATE:
        {
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 802d042:	2304      	movs	r3, #4
 802d044:	56c3      	ldrsb	r3, [r0, r3]
 802d046:	a901      	add	r1, sp, #4
 802d048:	700b      	strb	r3, [r1, #0]

            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 802d04a:	4a17      	ldr	r2, [pc, #92]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d04c:	2340      	movs	r3, #64	; 0x40
 802d04e:	5cd0      	ldrb	r0, [r2, r3]
 802d050:	2206      	movs	r2, #6
 802d052:	f001 fb82 	bl	802e75a <RegionVerify>
 802d056:	2800      	cmp	r0, #0
 802d058:	d100      	bne.n	802d05c <LoRaMacMibSetRequestConfirm+0x310>
 802d05a:	e0b0      	b.n	802d1be <LoRaMacMibSetRequestConfirm+0x472>
            {
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 802d05c:	ab01      	add	r3, sp, #4
 802d05e:	2100      	movs	r1, #0
 802d060:	5659      	ldrsb	r1, [r3, r1]
 802d062:	4a11      	ldr	r2, [pc, #68]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d064:	23c5      	movs	r3, #197	; 0xc5
 802d066:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d068:	2500      	movs	r5, #0
 802d06a:	e085      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_CHANNELS_DATARATE:
        {
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 802d06c:	2304      	movs	r3, #4
 802d06e:	56c3      	ldrsb	r3, [r0, r3]
 802d070:	466a      	mov	r2, sp
 802d072:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802d074:	4b0c      	ldr	r3, [pc, #48]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d076:	2274      	movs	r2, #116	; 0x74
 802d078:	5c9a      	ldrb	r2, [r3, r2]
 802d07a:	4669      	mov	r1, sp
 802d07c:	718a      	strb	r2, [r1, #6]

            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 802d07e:	2240      	movs	r2, #64	; 0x40
 802d080:	5c98      	ldrb	r0, [r3, r2]
 802d082:	3a3b      	subs	r2, #59	; 0x3b
 802d084:	a901      	add	r1, sp, #4
 802d086:	f001 fb68 	bl	802e75a <RegionVerify>
 802d08a:	2800      	cmp	r0, #0
 802d08c:	d100      	bne.n	802d090 <LoRaMacMibSetRequestConfirm+0x344>
 802d08e:	e098      	b.n	802d1c2 <LoRaMacMibSetRequestConfirm+0x476>
            {
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 802d090:	ab01      	add	r3, sp, #4
 802d092:	2100      	movs	r1, #0
 802d094:	5659      	ldrsb	r1, [r3, r1]
 802d096:	4a04      	ldr	r2, [pc, #16]	; (802d0a8 <LoRaMacMibSetRequestConfirm+0x35c>)
 802d098:	2339      	movs	r3, #57	; 0x39
 802d09a:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d09c:	2500      	movs	r5, #0
 802d09e:	e06b      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
 802d0a0:	2000a534 	.word	0x2000a534
 802d0a4:	08034fc4 	.word	0x08034fc4
 802d0a8:	2000aa3c 	.word	0x2000aa3c
 802d0ac:	080356b4 	.word	0x080356b4
            }
            break;
        }
        case MIB_CHANNELS_DEFAULT_TX_POWER:
        {
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 802d0b0:	2304      	movs	r3, #4
 802d0b2:	56c3      	ldrsb	r3, [r0, r3]
 802d0b4:	a901      	add	r1, sp, #4
 802d0b6:	700b      	strb	r3, [r1, #0]

            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 802d0b8:	4a46      	ldr	r2, [pc, #280]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d0ba:	2340      	movs	r3, #64	; 0x40
 802d0bc:	5cd0      	ldrb	r0, [r2, r3]
 802d0be:	220a      	movs	r2, #10
 802d0c0:	f001 fb4b 	bl	802e75a <RegionVerify>
 802d0c4:	2800      	cmp	r0, #0
 802d0c6:	d100      	bne.n	802d0ca <LoRaMacMibSetRequestConfirm+0x37e>
 802d0c8:	e07d      	b.n	802d1c6 <LoRaMacMibSetRequestConfirm+0x47a>
            {
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 802d0ca:	ab01      	add	r3, sp, #4
 802d0cc:	2100      	movs	r1, #0
 802d0ce:	5659      	ldrsb	r1, [r3, r1]
 802d0d0:	4a40      	ldr	r2, [pc, #256]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d0d2:	23c4      	movs	r3, #196	; 0xc4
 802d0d4:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d0d6:	2500      	movs	r5, #0
 802d0d8:	e04e      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_CHANNELS_TX_POWER:
        {
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 802d0da:	2304      	movs	r3, #4
 802d0dc:	56c3      	ldrsb	r3, [r0, r3]
 802d0de:	a901      	add	r1, sp, #4
 802d0e0:	700b      	strb	r3, [r1, #0]

            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 802d0e2:	4a3c      	ldr	r2, [pc, #240]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d0e4:	2340      	movs	r3, #64	; 0x40
 802d0e6:	5cd0      	ldrb	r0, [r2, r3]
 802d0e8:	2209      	movs	r2, #9
 802d0ea:	f001 fb36 	bl	802e75a <RegionVerify>
 802d0ee:	2800      	cmp	r0, #0
 802d0f0:	d100      	bne.n	802d0f4 <LoRaMacMibSetRequestConfirm+0x3a8>
 802d0f2:	e06a      	b.n	802d1ca <LoRaMacMibSetRequestConfirm+0x47e>
            {
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 802d0f4:	ab01      	add	r3, sp, #4
 802d0f6:	2100      	movs	r1, #0
 802d0f8:	5659      	ldrsb	r1, [r3, r1]
 802d0fa:	4a36      	ldr	r2, [pc, #216]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d0fc:	2338      	movs	r3, #56	; 0x38
 802d0fe:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d100:	2500      	movs	r5, #0
 802d102:	e039      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_SYSTEM_MAX_RX_ERROR:
        {
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 802d104:	6842      	ldr	r2, [r0, #4]
 802d106:	4b33      	ldr	r3, [pc, #204]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d108:	2184      	movs	r1, #132	; 0x84
 802d10a:	505a      	str	r2, [r3, r1]
 802d10c:	645a      	str	r2, [r3, #68]	; 0x44
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d10e:	2500      	movs	r5, #0
            break;
 802d110:	e032      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_MIN_RX_SYMBOLS:
        {
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 802d112:	7902      	ldrb	r2, [r0, #4]
 802d114:	4b2f      	ldr	r3, [pc, #188]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d116:	2188      	movs	r1, #136	; 0x88
 802d118:	545a      	strb	r2, [r3, r1]
 802d11a:	3940      	subs	r1, #64	; 0x40
 802d11c:	545a      	strb	r2, [r3, r1]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d11e:	2500      	movs	r5, #0
            break;
 802d120:	e02a      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_ANTENNA_GAIN:
        {
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 802d122:	6842      	ldr	r2, [r0, #4]
 802d124:	4b2b      	ldr	r3, [pc, #172]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d126:	67da      	str	r2, [r3, #124]	; 0x7c
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d128:	2500      	movs	r5, #0
            break;
 802d12a:	e025      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_DEFAULT_ANTENNA_GAIN:
        {
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 802d12c:	6841      	ldr	r1, [r0, #4]
 802d12e:	4a29      	ldr	r2, [pc, #164]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d130:	23bc      	movs	r3, #188	; 0xbc
 802d132:	50d1      	str	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d134:	2500      	movs	r5, #0
            break;
 802d136:	e01f      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        }
        case MIB_NVM_CTXS:
        {
            if( mibSet->Param.Contexts != 0 )
 802d138:	6840      	ldr	r0, [r0, #4]
 802d13a:	2800      	cmp	r0, #0
 802d13c:	d047      	beq.n	802d1ce <LoRaMacMibSetRequestConfirm+0x482>
            {
                status = RestoreNvmData( mibSet->Param.Contexts );
 802d13e:	f7fe fd41 	bl	802bbc4 <RestoreNvmData>
 802d142:	0005      	movs	r5, r0
 802d144:	e018      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        case MIB_ABP_LORAWAN_VERSION:
        {
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 802d146:	7983      	ldrb	r3, [r0, #6]
 802d148:	2b01      	cmp	r3, #1
 802d14a:	d901      	bls.n	802d150 <LoRaMacMibSetRequestConfirm+0x404>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
                }
            }
            else
            {
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d14c:	2503      	movs	r5, #3
 802d14e:	e013      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 802d150:	4a20      	ldr	r2, [pc, #128]	; (802d1d4 <LoRaMacMibSetRequestConfirm+0x488>)
 802d152:	2386      	movs	r3, #134	; 0x86
 802d154:	005b      	lsls	r3, r3, #1
 802d156:	6841      	ldr	r1, [r0, #4]
 802d158:	50d1      	str	r1, [r2, r3]
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 802d15a:	6840      	ldr	r0, [r0, #4]
 802d15c:	f000 ff4e 	bl	802dffc <LoRaMacCryptoSetLrWanVersion>
 802d160:	1e05      	subs	r5, r0, #0
 802d162:	d009      	beq.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d164:	2511      	movs	r5, #17
 802d166:	e007      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
            }
            break;
        }
        default:
        {
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 802d168:	0020      	movs	r0, r4
 802d16a:	f000 fab0 	bl	802d6ce <LoRaMacMibClassBSetRequestConfirm>
 802d16e:	0005      	movs	r5, r0
            break;
 802d170:	e002      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d172:	2503      	movs	r5, #3
 802d174:	e000      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
        return LORAMAC_STATUS_BUSY;
 802d176:	2501      	movs	r5, #1
        }
    }
    return status;
}
 802d178:	0028      	movs	r0, r5
 802d17a:	b005      	add	sp, #20
 802d17c:	bd30      	pop	{r4, r5, pc}
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d17e:	2503      	movs	r5, #3
 802d180:	e7fa      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d182:	2503      	movs	r5, #3
 802d184:	e7f8      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d186:	2503      	movs	r5, #3
 802d188:	e7f6      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d18a:	2503      	movs	r5, #3
 802d18c:	e7f4      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d18e:	2503      	movs	r5, #3
 802d190:	e7f2      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d192:	2503      	movs	r5, #3
 802d194:	e7f0      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d196:	2503      	movs	r5, #3
 802d198:	e7ee      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d19a:	2503      	movs	r5, #3
 802d19c:	e7ec      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d19e:	2503      	movs	r5, #3
 802d1a0:	e7ea      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                    status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1a2:	2503      	movs	r5, #3
 802d1a4:	e7e8      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1a6:	2503      	movs	r5, #3
 802d1a8:	e7e6      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1aa:	2503      	movs	r5, #3
 802d1ac:	e7e4      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1ae:	2503      	movs	r5, #3
 802d1b0:	e7e2      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1b2:	2503      	movs	r5, #3
 802d1b4:	e7e0      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1b6:	2503      	movs	r5, #3
 802d1b8:	e7de      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1ba:	2503      	movs	r5, #3
 802d1bc:	e7dc      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1be:	2503      	movs	r5, #3
 802d1c0:	e7da      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1c2:	2503      	movs	r5, #3
 802d1c4:	e7d8      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1c6:	2503      	movs	r5, #3
 802d1c8:	e7d6      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1ca:	2503      	movs	r5, #3
 802d1cc:	e7d4      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d1ce:	2503      	movs	r5, #3
 802d1d0:	e7d2      	b.n	802d178 <LoRaMacMibSetRequestConfirm+0x42c>
 802d1d2:	46c0      	nop			; (mov r8, r8)
 802d1d4:	2000aa3c 	.word	0x2000aa3c

0802d1d8 <LoRaMacMlmeRequest>:
    }
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 802d1d8:	b570      	push	{r4, r5, r6, lr}
 802d1da:	b082      	sub	sp, #8
 802d1dc:	0004      	movs	r4, r0
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 802d1de:	2300      	movs	r3, #0
 802d1e0:	466a      	mov	r2, sp
 802d1e2:	8013      	strh	r3, [r2, #0]

    if( mlmeRequest == NULL )
 802d1e4:	2800      	cmp	r0, #0
 802d1e6:	d100      	bne.n	802d1ea <LoRaMacMlmeRequest+0x12>
 802d1e8:	e0bb      	b.n	802d362 <LoRaMacMlmeRequest+0x18a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( LoRaMacIsBusy( ) == true )
 802d1ea:	f7ff fa11 	bl	802c610 <LoRaMacIsBusy>
 802d1ee:	2800      	cmp	r0, #0
 802d1f0:	d003      	beq.n	802d1fa <LoRaMacMlmeRequest+0x22>
    {
        return LORAMAC_STATUS_BUSY;
 802d1f2:	2501      	movs	r5, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 802d1f4:	0028      	movs	r0, r5
 802d1f6:	b002      	add	sp, #8
 802d1f8:	bd70      	pop	{r4, r5, r6, pc}
    if( LoRaMacConfirmQueueIsFull( ) == true )
 802d1fa:	f000 fd21 	bl	802dc40 <LoRaMacConfirmQueueIsFull>
 802d1fe:	2800      	cmp	r0, #0
 802d200:	d001      	beq.n	802d206 <LoRaMacMlmeRequest+0x2e>
        return LORAMAC_STATUS_BUSY;
 802d202:	2501      	movs	r5, #1
 802d204:	e7f6      	b.n	802d1f4 <LoRaMacMlmeRequest+0x1c>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 802d206:	f000 fd15 	bl	802dc34 <LoRaMacConfirmQueueGetCnt>
 802d20a:	2800      	cmp	r0, #0
 802d20c:	d016      	beq.n	802d23c <LoRaMacMlmeRequest+0x64>
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802d20e:	4b56      	ldr	r3, [pc, #344]	; (802d368 <LoRaMacMlmeRequest+0x190>)
 802d210:	2101      	movs	r1, #1
 802d212:	4a56      	ldr	r2, [pc, #344]	; (802d36c <LoRaMacMlmeRequest+0x194>)
 802d214:	5499      	strb	r1, [r3, r2]
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 802d216:	4856      	ldr	r0, [pc, #344]	; (802d370 <LoRaMacMlmeRequest+0x198>)
 802d218:	5c1a      	ldrb	r2, [r3, r0]
 802d21a:	2504      	movs	r5, #4
 802d21c:	432a      	orrs	r2, r5
 802d21e:	541a      	strb	r2, [r3, r0]
    queueElement.Request = mlmeRequest->Type;
 802d220:	7823      	ldrb	r3, [r4, #0]
 802d222:	aa01      	add	r2, sp, #4
 802d224:	7013      	strb	r3, [r2, #0]
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802d226:	7051      	strb	r1, [r2, #1]
    queueElement.RestrictCommonReadyToHandle = false;
 802d228:	2100      	movs	r1, #0
 802d22a:	70d1      	strb	r1, [r2, #3]
    switch( mlmeRequest->Type )
 802d22c:	001d      	movs	r5, r3
 802d22e:	2b0e      	cmp	r3, #14
 802d230:	d900      	bls.n	802d234 <LoRaMacMlmeRequest+0x5c>
 802d232:	e07c      	b.n	802d32e <LoRaMacMlmeRequest+0x156>
 802d234:	009b      	lsls	r3, r3, #2
 802d236:	4a4f      	ldr	r2, [pc, #316]	; (802d374 <LoRaMacMlmeRequest+0x19c>)
 802d238:	58d3      	ldr	r3, [r2, r3]
 802d23a:	469f      	mov	pc, r3
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 802d23c:	2214      	movs	r2, #20
 802d23e:	2100      	movs	r1, #0
 802d240:	484d      	ldr	r0, [pc, #308]	; (802d378 <LoRaMacMlmeRequest+0x1a0>)
 802d242:	f004 fac2 	bl	80317ca <memset1>
 802d246:	e7e2      	b.n	802d20e <LoRaMacMlmeRequest+0x36>
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 802d248:	4a47      	ldr	r2, [pc, #284]	; (802d368 <LoRaMacMlmeRequest+0x190>)
 802d24a:	23d0      	movs	r3, #208	; 0xd0
 802d24c:	009b      	lsls	r3, r3, #2
 802d24e:	58d3      	ldr	r3, [r2, r3]
 802d250:	069b      	lsls	r3, r3, #26
 802d252:	d4cf      	bmi.n	802d1f4 <LoRaMacMlmeRequest+0x1c>
            ResetMacParameters( );
 802d254:	f7fe feb2 	bl	802bfbc <ResetMacParameters>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 802d258:	2104      	movs	r1, #4
 802d25a:	5661      	ldrsb	r1, [r4, r1]
 802d25c:	4d47      	ldr	r5, [pc, #284]	; (802d37c <LoRaMacMlmeRequest+0x1a4>)
 802d25e:	2340      	movs	r3, #64	; 0x40
 802d260:	5ce8      	ldrb	r0, [r5, r3]
 802d262:	2200      	movs	r2, #0
 802d264:	f001 fb2e 	bl	802e8c4 <RegionAlternateDr>
 802d268:	2339      	movs	r3, #57	; 0x39
 802d26a:	54e8      	strb	r0, [r5, r3]
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 802d26c:	ab01      	add	r3, sp, #4
 802d26e:	2207      	movs	r2, #7
 802d270:	705a      	strb	r2, [r3, #1]
            status = SendReJoinReq( JOIN_REQ );
 802d272:	20ff      	movs	r0, #255	; 0xff
 802d274:	f7fe fff0 	bl	802c258 <SendReJoinReq>
 802d278:	1e05      	subs	r5, r0, #0
            if( status != LORAMAC_STATUS_OK )
 802d27a:	d059      	beq.n	802d330 <LoRaMacMlmeRequest+0x158>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 802d27c:	2104      	movs	r1, #4
 802d27e:	5661      	ldrsb	r1, [r4, r1]
 802d280:	4e3e      	ldr	r6, [pc, #248]	; (802d37c <LoRaMacMlmeRequest+0x1a4>)
 802d282:	2340      	movs	r3, #64	; 0x40
 802d284:	5cf0      	ldrb	r0, [r6, r3]
 802d286:	2201      	movs	r2, #1
 802d288:	f001 fb1c 	bl	802e8c4 <RegionAlternateDr>
 802d28c:	2339      	movs	r3, #57	; 0x39
 802d28e:	54f0      	strb	r0, [r6, r3]
 802d290:	e04e      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 802d292:	2200      	movs	r2, #0
 802d294:	4669      	mov	r1, sp
 802d296:	2002      	movs	r0, #2
 802d298:	f000 fac2 	bl	802d820 <LoRaMacCommandsAddCmd>
 802d29c:	1e05      	subs	r5, r0, #0
 802d29e:	d047      	beq.n	802d330 <LoRaMacMlmeRequest+0x158>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802d2a0:	2513      	movs	r5, #19
 802d2a2:	e045      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 802d2a4:	88a0      	ldrh	r0, [r4, #4]
 802d2a6:	f7ff f807 	bl	802c2b8 <SetTxContinuousWave>
 802d2aa:	0005      	movs	r5, r0
            break;
 802d2ac:	e040      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
            status = SetTxContinuousWave1( mlmeRequest->Req.TxCw.Timeout, mlmeRequest->Req.TxCw.Frequency, mlmeRequest->Req.TxCw.Power );
 802d2ae:	7b22      	ldrb	r2, [r4, #12]
 802d2b0:	88a0      	ldrh	r0, [r4, #4]
 802d2b2:	68a1      	ldr	r1, [r4, #8]
 802d2b4:	f7fc fef6 	bl	802a0a4 <SetTxContinuousWave1>
 802d2b8:	0005      	movs	r5, r0
            break;
 802d2ba:	e039      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 802d2bc:	2200      	movs	r2, #0
 802d2be:	4669      	mov	r1, sp
 802d2c0:	200d      	movs	r0, #13
 802d2c2:	f000 faad 	bl	802d820 <LoRaMacCommandsAddCmd>
 802d2c6:	1e05      	subs	r5, r0, #0
 802d2c8:	d032      	beq.n	802d330 <LoRaMacMlmeRequest+0x158>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802d2ca:	2513      	movs	r5, #19
 802d2cc:	e030      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 802d2ce:	4a2b      	ldr	r2, [pc, #172]	; (802d37c <LoRaMacMlmeRequest+0x1a4>)
 802d2d0:	23fc      	movs	r3, #252	; 0xfc
 802d2d2:	5cd3      	ldrb	r3, [r2, r3]
 802d2d4:	2b00      	cmp	r3, #0
 802d2d6:	d001      	beq.n	802d2dc <LoRaMacMlmeRequest+0x104>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 802d2d8:	2502      	movs	r5, #2
 802d2da:	e029      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 802d2dc:	7925      	ldrb	r5, [r4, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 802d2de:	0768      	lsls	r0, r5, #29
 802d2e0:	0f40      	lsrs	r0, r0, #29
 802d2e2:	f000 f9ed 	bl	802d6c0 <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 802d2e6:	466b      	mov	r3, sp
 802d2e8:	701d      	strb	r5, [r3, #0]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 802d2ea:	2201      	movs	r2, #1
 802d2ec:	4669      	mov	r1, sp
 802d2ee:	2010      	movs	r0, #16
 802d2f0:	f000 fa96 	bl	802d820 <LoRaMacCommandsAddCmd>
 802d2f4:	1e05      	subs	r5, r0, #0
 802d2f6:	d01b      	beq.n	802d330 <LoRaMacMlmeRequest+0x158>
                    status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802d2f8:	2513      	movs	r5, #19
 802d2fa:	e019      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 802d2fc:	2200      	movs	r2, #0
 802d2fe:	4669      	mov	r1, sp
 802d300:	2012      	movs	r0, #18
 802d302:	f000 fa8d 	bl	802d820 <LoRaMacCommandsAddCmd>
 802d306:	1e05      	subs	r5, r0, #0
 802d308:	d012      	beq.n	802d330 <LoRaMacMlmeRequest+0x158>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802d30a:	2513      	movs	r5, #19
 802d30c:	e010      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
            queueElement.RestrictCommonReadyToHandle = true;
 802d30e:	ab01      	add	r3, sp, #4
 802d310:	2201      	movs	r2, #1
 802d312:	70da      	strb	r2, [r3, #3]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 802d314:	f000 f9c5 	bl	802d6a2 <LoRaMacClassBIsAcquisitionInProgress>
 802d318:	2800      	cmp	r0, #0
 802d31a:	d001      	beq.n	802d320 <LoRaMacMlmeRequest+0x148>
                status = LORAMAC_STATUS_BUSY;
 802d31c:	2501      	movs	r5, #1
 802d31e:	e007      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 802d320:	f000 f9bc 	bl	802d69c <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 802d324:	2000      	movs	r0, #0
 802d326:	f000 f9be 	bl	802d6a6 <LoRaMacClassBBeaconTimerEvent>
                status = LORAMAC_STATUS_OK;
 802d32a:	2500      	movs	r5, #0
 802d32c:	e000      	b.n	802d330 <LoRaMacMlmeRequest+0x158>
    switch( mlmeRequest->Type )
 802d32e:	2502      	movs	r5, #2
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 802d330:	4a0d      	ldr	r2, [pc, #52]	; (802d368 <LoRaMacMlmeRequest+0x190>)
 802d332:	4b13      	ldr	r3, [pc, #76]	; (802d380 <LoRaMacMlmeRequest+0x1a8>)
 802d334:	58d3      	ldr	r3, [r2, r3]
 802d336:	6123      	str	r3, [r4, #16]
    if( status != LORAMAC_STATUS_OK )
 802d338:	2d00      	cmp	r5, #0
 802d33a:	d00e      	beq.n	802d35a <LoRaMacMlmeRequest+0x182>
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 802d33c:	f000 fc7a 	bl	802dc34 <LoRaMacConfirmQueueGetCnt>
 802d340:	2800      	cmp	r0, #0
 802d342:	d000      	beq.n	802d346 <LoRaMacMlmeRequest+0x16e>
 802d344:	e756      	b.n	802d1f4 <LoRaMacMlmeRequest+0x1c>
            MacCtx.NodeAckRequested = false;
 802d346:	4b08      	ldr	r3, [pc, #32]	; (802d368 <LoRaMacMlmeRequest+0x190>)
 802d348:	4a0e      	ldr	r2, [pc, #56]	; (802d384 <LoRaMacMlmeRequest+0x1ac>)
 802d34a:	2100      	movs	r1, #0
 802d34c:	5499      	strb	r1, [r3, r2]
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 802d34e:	4908      	ldr	r1, [pc, #32]	; (802d370 <LoRaMacMlmeRequest+0x198>)
 802d350:	5c5a      	ldrb	r2, [r3, r1]
 802d352:	3004      	adds	r0, #4
 802d354:	4382      	bics	r2, r0
 802d356:	545a      	strb	r2, [r3, r1]
 802d358:	e74c      	b.n	802d1f4 <LoRaMacMlmeRequest+0x1c>
        LoRaMacConfirmQueueAdd( &queueElement );
 802d35a:	a801      	add	r0, sp, #4
 802d35c:	f000 fba2 	bl	802daa4 <LoRaMacConfirmQueueAdd>
 802d360:	e748      	b.n	802d1f4 <LoRaMacMlmeRequest+0x1c>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d362:	2503      	movs	r5, #3
 802d364:	e746      	b.n	802d1f4 <LoRaMacMlmeRequest+0x1c>
 802d366:	46c0      	nop			; (mov r8, r8)
 802d368:	2000a534 	.word	0x2000a534
 802d36c:	0000044d 	.word	0x0000044d
 802d370:	00000481 	.word	0x00000481
 802d374:	08035064 	.word	0x08035064
 802d378:	2000a980 	.word	0x2000a980
 802d37c:	2000aa3c 	.word	0x2000aa3c
 802d380:	00000484 	.word	0x00000484
 802d384:	00000414 	.word	0x00000414

0802d388 <LoRaMacMcpsRequest>:

/* ST_WORKAROUND_BEGIN: Update MCPS request with new input parameter to allow delayed tx */
LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest, bool allowDelayedTx )
{
 802d388:	b5f0      	push	{r4, r5, r6, r7, lr}
 802d38a:	46d6      	mov	lr, sl
 802d38c:	4647      	mov	r7, r8
 802d38e:	b580      	push	{r7, lr}
 802d390:	b08b      	sub	sp, #44	; 0x2c
 802d392:	0004      	movs	r4, r0
 802d394:	9103      	str	r1, [sp, #12]
 802d396:	2600      	movs	r6, #0
    /* ST_WORKAROUND_END */
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 802d398:	2800      	cmp	r0, #0
 802d39a:	d100      	bne.n	802d39e <LoRaMacMcpsRequest+0x16>
 802d39c:	e0b3      	b.n	802d506 <LoRaMacMcpsRequest+0x17e>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( LoRaMacIsBusy( ) == true )
 802d39e:	f7ff f937 	bl	802c610 <LoRaMacIsBusy>
 802d3a2:	1e05      	subs	r5, r0, #0
 802d3a4:	d005      	beq.n	802d3b2 <LoRaMacMcpsRequest+0x2a>
    {
        return LORAMAC_STATUS_BUSY;
 802d3a6:	2001      	movs	r0, #1

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 802d3a8:	b00b      	add	sp, #44	; 0x2c
 802d3aa:	bcc0      	pop	{r6, r7}
 802d3ac:	46ba      	mov	sl, r7
 802d3ae:	46b0      	mov	r8, r6
 802d3b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    macHdr.Value = 0;
 802d3b2:	ab06      	add	r3, sp, #24
 802d3b4:	2200      	movs	r2, #0
 802d3b6:	701a      	strb	r2, [r3, #0]
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 802d3b8:	4f55      	ldr	r7, [pc, #340]	; (802d510 <LoRaMacMcpsRequest+0x188>)
 802d3ba:	3214      	adds	r2, #20
 802d3bc:	2100      	movs	r1, #0
 802d3be:	0038      	movs	r0, r7
 802d3c0:	f004 fa03 	bl	80317ca <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802d3c4:	4b53      	ldr	r3, [pc, #332]	; (802d514 <LoRaMacMcpsRequest+0x18c>)
 802d3c6:	469c      	mov	ip, r3
 802d3c8:	4467      	add	r7, ip
 802d3ca:	2301      	movs	r3, #1
 802d3cc:	4a52      	ldr	r2, [pc, #328]	; (802d518 <LoRaMacMcpsRequest+0x190>)
 802d3ce:	54bb      	strb	r3, [r7, r2]
    MacCtx.AckTimeoutRetriesCounter = 1;
 802d3d0:	4a52      	ldr	r2, [pc, #328]	; (802d51c <LoRaMacMcpsRequest+0x194>)
 802d3d2:	54bb      	strb	r3, [r7, r2]
    switch( mcpsRequest->Type )
 802d3d4:	7823      	ldrb	r3, [r4, #0]
 802d3d6:	2b01      	cmp	r3, #1
 802d3d8:	d05f      	beq.n	802d49a <LoRaMacMcpsRequest+0x112>
 802d3da:	2b03      	cmp	r3, #3
 802d3dc:	d075      	beq.n	802d4ca <LoRaMacMcpsRequest+0x142>
 802d3de:	2b00      	cmp	r3, #0
 802d3e0:	d047      	beq.n	802d472 <LoRaMacMcpsRequest+0xea>
 802d3e2:	2700      	movs	r7, #0
 802d3e4:	2300      	movs	r3, #0
 802d3e6:	469a      	mov	sl, r3
 802d3e8:	4698      	mov	r8, r3
    getPhy.Attribute = PHY_MIN_TX_DR;
 802d3ea:	2302      	movs	r3, #2
 802d3ec:	aa02      	add	r2, sp, #8
 802d3ee:	7613      	strb	r3, [r2, #24]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802d3f0:	4b4b      	ldr	r3, [pc, #300]	; (802d520 <LoRaMacMcpsRequest+0x198>)
 802d3f2:	2274      	movs	r2, #116	; 0x74
 802d3f4:	5c9a      	ldrb	r2, [r3, r2]
 802d3f6:	a902      	add	r1, sp, #8
 802d3f8:	768a      	strb	r2, [r1, #26]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802d3fa:	2240      	movs	r2, #64	; 0x40
 802d3fc:	5c98      	ldrb	r0, [r3, r2]
 802d3fe:	a908      	add	r1, sp, #32
 802d400:	f001 f978 	bl	802e6f4 <RegionGetPhyParam>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 802d404:	b240      	sxtb	r0, r0
 802d406:	1c03      	adds	r3, r0, #0
 802d408:	42b8      	cmp	r0, r7
 802d40a:	da00      	bge.n	802d40e <LoRaMacMcpsRequest+0x86>
 802d40c:	1c3b      	adds	r3, r7, #0
 802d40e:	b25b      	sxtb	r3, r3
    if( readyToSend == true )
 802d410:	2d00      	cmp	r5, #0
 802d412:	d072      	beq.n	802d4fa <LoRaMacMcpsRequest+0x172>
        if( Nvm.MacGroup2.AdrCtrlOn == false )
 802d414:	4942      	ldr	r1, [pc, #264]	; (802d520 <LoRaMacMcpsRequest+0x198>)
 802d416:	22fe      	movs	r2, #254	; 0xfe
 802d418:	5c8a      	ldrb	r2, [r1, r2]
 802d41a:	2a00      	cmp	r2, #0
 802d41c:	d114      	bne.n	802d448 <LoRaMacMcpsRequest+0xc0>
            verify.DatarateParams.Datarate = datarate;
 802d41e:	aa02      	add	r2, sp, #8
 802d420:	7313      	strb	r3, [r2, #12]
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802d422:	000b      	movs	r3, r1
 802d424:	2274      	movs	r2, #116	; 0x74
 802d426:	5c8a      	ldrb	r2, [r1, r2]
 802d428:	a902      	add	r1, sp, #8
 802d42a:	738a      	strb	r2, [r1, #14]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 802d42c:	2240      	movs	r2, #64	; 0x40
 802d42e:	5c98      	ldrb	r0, [r3, r2]
 802d430:	3a3b      	subs	r2, #59	; 0x3b
 802d432:	a905      	add	r1, sp, #20
 802d434:	f001 f991 	bl	802e75a <RegionVerify>
 802d438:	2800      	cmp	r0, #0
 802d43a:	d066      	beq.n	802d50a <LoRaMacMcpsRequest+0x182>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 802d43c:	ab05      	add	r3, sp, #20
 802d43e:	2100      	movs	r1, #0
 802d440:	5659      	ldrsb	r1, [r3, r1]
 802d442:	4a37      	ldr	r2, [pc, #220]	; (802d520 <LoRaMacMcpsRequest+0x198>)
 802d444:	2339      	movs	r3, #57	; 0x39
 802d446:	54d1      	strb	r1, [r2, r3]
        status = Send( &macHdr, fPort, fBuffer, fBufferSize, allowDelayedTx ); /* ST_WORKAROUND: Update Send request with new input parameter to allow delayed tx */
 802d448:	9b03      	ldr	r3, [sp, #12]
 802d44a:	9300      	str	r3, [sp, #0]
 802d44c:	0033      	movs	r3, r6
 802d44e:	4652      	mov	r2, sl
 802d450:	4641      	mov	r1, r8
 802d452:	a806      	add	r0, sp, #24
 802d454:	f7ff f83e 	bl	802c4d4 <Send>
        if( status == LORAMAC_STATUS_OK )
 802d458:	2800      	cmp	r0, #0
 802d45a:	d149      	bne.n	802d4f0 <LoRaMacMcpsRequest+0x168>
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 802d45c:	7821      	ldrb	r1, [r4, #0]
 802d45e:	4b31      	ldr	r3, [pc, #196]	; (802d524 <LoRaMacMcpsRequest+0x19c>)
 802d460:	2287      	movs	r2, #135	; 0x87
 802d462:	00d2      	lsls	r2, r2, #3
 802d464:	5499      	strb	r1, [r3, r2]
            MacCtx.MacFlags.Bits.McpsReq = 1;
 802d466:	4930      	ldr	r1, [pc, #192]	; (802d528 <LoRaMacMcpsRequest+0x1a0>)
 802d468:	5c5a      	ldrb	r2, [r3, r1]
 802d46a:	2501      	movs	r5, #1
 802d46c:	432a      	orrs	r2, r5
 802d46e:	545a      	strb	r2, [r3, r1]
 802d470:	e044      	b.n	802d4fc <LoRaMacMcpsRequest+0x174>
            MacCtx.AckTimeoutRetries = 1;
 802d472:	4a2c      	ldr	r2, [pc, #176]	; (802d524 <LoRaMacMcpsRequest+0x19c>)
 802d474:	4b2d      	ldr	r3, [pc, #180]	; (802d52c <LoRaMacMcpsRequest+0x1a4>)
 802d476:	2101      	movs	r1, #1
 802d478:	54d1      	strb	r1, [r2, r3]
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 802d47a:	aa06      	add	r2, sp, #24
 802d47c:	7811      	ldrb	r1, [r2, #0]
 802d47e:	231f      	movs	r3, #31
 802d480:	400b      	ands	r3, r1
 802d482:	2140      	movs	r1, #64	; 0x40
 802d484:	430b      	orrs	r3, r1
 802d486:	7013      	strb	r3, [r2, #0]
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 802d488:	7923      	ldrb	r3, [r4, #4]
 802d48a:	4698      	mov	r8, r3
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 802d48c:	68a3      	ldr	r3, [r4, #8]
 802d48e:	469a      	mov	sl, r3
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 802d490:	89a6      	ldrh	r6, [r4, #12]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 802d492:	270e      	movs	r7, #14
 802d494:	57e7      	ldrsb	r7, [r4, r7]
            readyToSend = true;
 802d496:	3501      	adds	r5, #1
            break;
 802d498:	e7a7      	b.n	802d3ea <LoRaMacMcpsRequest+0x62>
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 802d49a:	7be3      	ldrb	r3, [r4, #15]
 802d49c:	1c1a      	adds	r2, r3, #0
 802d49e:	2b08      	cmp	r3, #8
 802d4a0:	d900      	bls.n	802d4a4 <LoRaMacMcpsRequest+0x11c>
 802d4a2:	2208      	movs	r2, #8
 802d4a4:	491f      	ldr	r1, [pc, #124]	; (802d524 <LoRaMacMcpsRequest+0x19c>)
 802d4a6:	4b21      	ldr	r3, [pc, #132]	; (802d52c <LoRaMacMcpsRequest+0x1a4>)
 802d4a8:	54ca      	strb	r2, [r1, r3]
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 802d4aa:	a906      	add	r1, sp, #24
 802d4ac:	780a      	ldrb	r2, [r1, #0]
 802d4ae:	231f      	movs	r3, #31
 802d4b0:	401a      	ands	r2, r3
 802d4b2:	3b9f      	subs	r3, #159	; 0x9f
 802d4b4:	4313      	orrs	r3, r2
 802d4b6:	700b      	strb	r3, [r1, #0]
            fPort = mcpsRequest->Req.Confirmed.fPort;
 802d4b8:	7923      	ldrb	r3, [r4, #4]
 802d4ba:	4698      	mov	r8, r3
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 802d4bc:	68a3      	ldr	r3, [r4, #8]
 802d4be:	469a      	mov	sl, r3
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 802d4c0:	89a6      	ldrh	r6, [r4, #12]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 802d4c2:	270e      	movs	r7, #14
 802d4c4:	57e7      	ldrsb	r7, [r4, r7]
            readyToSend = true;
 802d4c6:	2501      	movs	r5, #1
            break;
 802d4c8:	e78f      	b.n	802d3ea <LoRaMacMcpsRequest+0x62>
            MacCtx.AckTimeoutRetries = 1;
 802d4ca:	4a16      	ldr	r2, [pc, #88]	; (802d524 <LoRaMacMcpsRequest+0x19c>)
 802d4cc:	4b17      	ldr	r3, [pc, #92]	; (802d52c <LoRaMacMcpsRequest+0x1a4>)
 802d4ce:	2101      	movs	r1, #1
 802d4d0:	54d1      	strb	r1, [r2, r3]
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 802d4d2:	aa06      	add	r2, sp, #24
 802d4d4:	7811      	ldrb	r1, [r2, #0]
 802d4d6:	2320      	movs	r3, #32
 802d4d8:	425b      	negs	r3, r3
 802d4da:	430b      	orrs	r3, r1
 802d4dc:	7013      	strb	r3, [r2, #0]
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 802d4de:	6863      	ldr	r3, [r4, #4]
 802d4e0:	469a      	mov	sl, r3
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 802d4e2:	8926      	ldrh	r6, [r4, #8]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 802d4e4:	270a      	movs	r7, #10
 802d4e6:	57e7      	ldrsb	r7, [r4, r7]
            readyToSend = true;
 802d4e8:	2501      	movs	r5, #1
    uint8_t fPort = 0;
 802d4ea:	2300      	movs	r3, #0
 802d4ec:	4698      	mov	r8, r3
            break;
 802d4ee:	e77c      	b.n	802d3ea <LoRaMacMcpsRequest+0x62>
            MacCtx.NodeAckRequested = false;
 802d4f0:	4a0c      	ldr	r2, [pc, #48]	; (802d524 <LoRaMacMcpsRequest+0x19c>)
 802d4f2:	4b0f      	ldr	r3, [pc, #60]	; (802d530 <LoRaMacMcpsRequest+0x1a8>)
 802d4f4:	2100      	movs	r1, #0
 802d4f6:	54d1      	strb	r1, [r2, r3]
 802d4f8:	e000      	b.n	802d4fc <LoRaMacMcpsRequest+0x174>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 802d4fa:	2002      	movs	r0, #2
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 802d4fc:	4a09      	ldr	r2, [pc, #36]	; (802d524 <LoRaMacMcpsRequest+0x19c>)
 802d4fe:	4b0d      	ldr	r3, [pc, #52]	; (802d534 <LoRaMacMcpsRequest+0x1ac>)
 802d500:	58d3      	ldr	r3, [r2, r3]
 802d502:	6123      	str	r3, [r4, #16]
    return status;
 802d504:	e750      	b.n	802d3a8 <LoRaMacMcpsRequest+0x20>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d506:	2003      	movs	r0, #3
 802d508:	e74e      	b.n	802d3a8 <LoRaMacMcpsRequest+0x20>
                return LORAMAC_STATUS_PARAMETER_INVALID;
 802d50a:	2003      	movs	r0, #3
 802d50c:	e74c      	b.n	802d3a8 <LoRaMacMcpsRequest+0x20>
 802d50e:	46c0      	nop			; (mov r8, r8)
 802d510:	2000a96c 	.word	0x2000a96c
 802d514:	fffffbc8 	.word	0xfffffbc8
 802d518:	00000439 	.word	0x00000439
 802d51c:	00000412 	.word	0x00000412
 802d520:	2000aa3c 	.word	0x2000aa3c
 802d524:	2000a534 	.word	0x2000a534
 802d528:	00000481 	.word	0x00000481
 802d52c:	00000411 	.word	0x00000411
 802d530:	00000414 	.word	0x00000414
 802d534:	00000484 	.word	0x00000484

0802d538 <LoRaMacTestSetDutyCycleOn>:
/* ST_WORKAROUND_END */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 802d538:	b510      	push	{r4, lr}
 802d53a:	b082      	sub	sp, #8
 802d53c:	0004      	movs	r4, r0
    VerifyParams_t verify;

    verify.DutyCycle = enable;
 802d53e:	a901      	add	r1, sp, #4
 802d540:	7008      	strb	r0, [r1, #0]

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 802d542:	4a07      	ldr	r2, [pc, #28]	; (802d560 <LoRaMacTestSetDutyCycleOn+0x28>)
 802d544:	2340      	movs	r3, #64	; 0x40
 802d546:	5cd0      	ldrb	r0, [r2, r3]
 802d548:	220f      	movs	r2, #15
 802d54a:	f001 f906 	bl	802e75a <RegionVerify>
 802d54e:	2800      	cmp	r0, #0
 802d550:	d003      	beq.n	802d55a <LoRaMacTestSetDutyCycleOn+0x22>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
 802d552:	4a03      	ldr	r2, [pc, #12]	; (802d560 <LoRaMacTestSetDutyCycleOn+0x28>)
 802d554:	2380      	movs	r3, #128	; 0x80
 802d556:	005b      	lsls	r3, r3, #1
 802d558:	54d4      	strb	r4, [r2, r3]
    }
}
 802d55a:	b002      	add	sp, #8
 802d55c:	bd10      	pop	{r4, pc}
 802d55e:	46c0      	nop			; (mov r8, r8)
 802d560:	2000aa3c 	.word	0x2000aa3c

0802d564 <LoRaMacDeInitialization>:

LoRaMacStatus_t LoRaMacDeInitialization( void )
{
 802d564:	b570      	push	{r4, r5, r6, lr}
    // Check the current state of the LoRaMac
    if ( LoRaMacStop( ) == LORAMAC_STATUS_OK )
 802d566:	f7ff fa8f 	bl	802ca88 <LoRaMacStop>
 802d56a:	1e04      	subs	r4, r0, #0
 802d56c:	d002      	beq.n	802d574 <LoRaMacDeInitialization+0x10>
        // Return success
        return LORAMAC_STATUS_OK;
    }
    else
    {
        return LORAMAC_STATUS_BUSY;
 802d56e:	2401      	movs	r4, #1
    }
}
 802d570:	0020      	movs	r0, r4
 802d572:	bd70      	pop	{r4, r5, r6, pc}
        TimerStop( &MacCtx.TxDelayedTimer );
 802d574:	4d0b      	ldr	r5, [pc, #44]	; (802d5a4 <LoRaMacDeInitialization+0x40>)
 802d576:	0028      	movs	r0, r5
 802d578:	f006 fe06 	bl	8034188 <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.RxWindowTimer1 );
 802d57c:	0028      	movs	r0, r5
 802d57e:	3018      	adds	r0, #24
 802d580:	f006 fe02 	bl	8034188 <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.RxWindowTimer2 );
 802d584:	0028      	movs	r0, r5
 802d586:	3030      	adds	r0, #48	; 0x30
 802d588:	f006 fdfe 	bl	8034188 <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.AckTimeoutTimer );
 802d58c:	0028      	movs	r0, r5
 802d58e:	3090      	adds	r0, #144	; 0x90
 802d590:	f006 fdfa 	bl	8034188 <UTIL_TIMER_Stop>
        LoRaMacClassBHaltBeaconing( );
 802d594:	f000 f895 	bl	802d6c2 <LoRaMacClassBHaltBeaconing>
        ResetMacParameters( );
 802d598:	f7fe fd10 	bl	802bfbc <ResetMacParameters>
        Radio.Sleep( );
 802d59c:	4b02      	ldr	r3, [pc, #8]	; (802d5a8 <LoRaMacDeInitialization+0x44>)
 802d59e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802d5a0:	4798      	blx	r3
        return LORAMAC_STATUS_OK;
 802d5a2:	e7e5      	b.n	802d570 <LoRaMacDeInitialization+0xc>
 802d5a4:	2000a89c 	.word	0x2000a89c
 802d5a8:	080356b4 	.word	0x080356b4

0802d5ac <CalcNextV10X>:

#include "Region.h"
#include "LoRaMacAdr.h"

static bool CalcNextV10X( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 802d5ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 802d5ae:	46de      	mov	lr, fp
 802d5b0:	4657      	mov	r7, sl
 802d5b2:	464e      	mov	r6, r9
 802d5b4:	4645      	mov	r5, r8
 802d5b6:	b5e0      	push	{r5, r6, r7, lr}
 802d5b8:	b089      	sub	sp, #36	; 0x24
 802d5ba:	0004      	movs	r4, r0
 802d5bc:	9101      	str	r1, [sp, #4]
 802d5be:	4691      	mov	r9, r2
 802d5c0:	001d      	movs	r5, r3
    bool adrAckReq = false;
    int8_t datarate = adrNext->Datarate;
 802d5c2:	2710      	movs	r7, #16
 802d5c4:	57c7      	ldrsb	r7, [r0, r7]
    int8_t txPower = adrNext->TxPower;
 802d5c6:	2311      	movs	r3, #17
 802d5c8:	56c3      	ldrsb	r3, [r0, r3]
 802d5ca:	469a      	mov	sl, r3
    int8_t minTxDatarate;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    // Report back the adr ack counter
    *adrAckCounter = adrNext->AdrAckCounter;
 802d5cc:	6883      	ldr	r3, [r0, #8]
 802d5ce:	602b      	str	r3, [r5, #0]

    if( adrNext->AdrEnabled == true )
 802d5d0:	7946      	ldrb	r6, [r0, #5]
 802d5d2:	2e00      	cmp	r6, #0
 802d5d4:	d10c      	bne.n	802d5f0 <CalcNextV10X+0x44>
                }
            }
        }
    }

    *drOut = datarate;
 802d5d6:	9b01      	ldr	r3, [sp, #4]
 802d5d8:	701f      	strb	r7, [r3, #0]
    *txPowOut = txPower;
 802d5da:	464b      	mov	r3, r9
 802d5dc:	4652      	mov	r2, sl
 802d5de:	701a      	strb	r2, [r3, #0]
    return adrAckReq;
}
 802d5e0:	0030      	movs	r0, r6
 802d5e2:	b009      	add	sp, #36	; 0x24
 802d5e4:	bcf0      	pop	{r4, r5, r6, r7}
 802d5e6:	46bb      	mov	fp, r7
 802d5e8:	46b2      	mov	sl, r6
 802d5ea:	46a9      	mov	r9, r5
 802d5ec:	46a0      	mov	r8, r4
 802d5ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
        getPhy.Attribute = PHY_MIN_TX_DR;
 802d5f0:	2302      	movs	r3, #2
 802d5f2:	aa02      	add	r2, sp, #8
 802d5f4:	7413      	strb	r3, [r2, #16]
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 802d5f6:	7c83      	ldrb	r3, [r0, #18]
 802d5f8:	7493      	strb	r3, [r2, #18]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 802d5fa:	7cc0      	ldrb	r0, [r0, #19]
 802d5fc:	a906      	add	r1, sp, #24
 802d5fe:	f001 f879 	bl	802e6f4 <RegionGetPhyParam>
        minTxDatarate = phyParam.Value;
 802d602:	b243      	sxtb	r3, r0
 802d604:	469b      	mov	fp, r3
        datarate = MAX( datarate, minTxDatarate );
 802d606:	1c3b      	adds	r3, r7, #0
 802d608:	455f      	cmp	r7, fp
 802d60a:	da00      	bge.n	802d60e <CalcNextV10X+0x62>
 802d60c:	465b      	mov	r3, fp
 802d60e:	b25b      	sxtb	r3, r3
 802d610:	4698      	mov	r8, r3
        if( datarate == minTxDatarate )
 802d612:	455f      	cmp	r7, fp
 802d614:	dc04      	bgt.n	802d620 <CalcNextV10X+0x74>
            *adrAckCounter = 0;
 802d616:	2300      	movs	r3, #0
 802d618:	602b      	str	r3, [r5, #0]
        datarate = MAX( datarate, minTxDatarate );
 802d61a:	4647      	mov	r7, r8
            adrAckReq = false;
 802d61c:	2600      	movs	r6, #0
 802d61e:	e7da      	b.n	802d5d6 <CalcNextV10X+0x2a>
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 802d620:	68a2      	ldr	r2, [r4, #8]
 802d622:	89a3      	ldrh	r3, [r4, #12]
 802d624:	429a      	cmp	r2, r3
 802d626:	d200      	bcs.n	802d62a <CalcNextV10X+0x7e>
                adrAckReq = false;
 802d628:	2600      	movs	r6, #0
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 802d62a:	89e1      	ldrh	r1, [r4, #14]
 802d62c:	185b      	adds	r3, r3, r1
 802d62e:	429a      	cmp	r2, r3
 802d630:	d201      	bcs.n	802d636 <CalcNextV10X+0x8a>
        datarate = MAX( datarate, minTxDatarate );
 802d632:	4647      	mov	r7, r8
 802d634:	e7cf      	b.n	802d5d6 <CalcNextV10X+0x2a>
                getPhy.Attribute = PHY_MAX_TX_POWER;
 802d636:	a906      	add	r1, sp, #24
 802d638:	2308      	movs	r3, #8
 802d63a:	700b      	strb	r3, [r1, #0]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 802d63c:	7ce0      	ldrb	r0, [r4, #19]
 802d63e:	f001 f859 	bl	802e6f4 <RegionGetPhyParam>
                txPower = phyParam.Value;
 802d642:	b243      	sxtb	r3, r0
 802d644:	469a      	mov	sl, r3
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 802d646:	89e1      	ldrh	r1, [r4, #14]
 802d648:	68a0      	ldr	r0, [r4, #8]
 802d64a:	f7f2 fdeb 	bl	8020224 <__aeabi_uidivmod>
 802d64e:	2901      	cmp	r1, #1
 802d650:	d001      	beq.n	802d656 <CalcNextV10X+0xaa>
        datarate = MAX( datarate, minTxDatarate );
 802d652:	4647      	mov	r7, r8
 802d654:	e7bf      	b.n	802d5d6 <CalcNextV10X+0x2a>
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 802d656:	a906      	add	r1, sp, #24
 802d658:	2322      	movs	r3, #34	; 0x22
 802d65a:	700b      	strb	r3, [r1, #0]
                    getPhy.Datarate = datarate;
 802d65c:	4643      	mov	r3, r8
 802d65e:	704b      	strb	r3, [r1, #1]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 802d660:	7ca3      	ldrb	r3, [r4, #18]
 802d662:	708b      	strb	r3, [r1, #2]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 802d664:	7ce0      	ldrb	r0, [r4, #19]
 802d666:	f001 f845 	bl	802e6f4 <RegionGetPhyParam>
                    datarate = phyParam.Value;
 802d66a:	b247      	sxtb	r7, r0
                    if( datarate == minTxDatarate )
 802d66c:	45bb      	cmp	fp, r7
 802d66e:	d1b2      	bne.n	802d5d6 <CalcNextV10X+0x2a>
                        if( adrNext->UpdateChanMask == true )
 802d670:	7926      	ldrb	r6, [r4, #4]
 802d672:	2e00      	cmp	r6, #0
 802d674:	d0af      	beq.n	802d5d6 <CalcNextV10X+0x2a>
                            params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 802d676:	2302      	movs	r3, #2
 802d678:	aa02      	add	r2, sp, #8
 802d67a:	7213      	strb	r3, [r2, #8]
                            RegionInitDefaults( adrNext->Region, &params );
 802d67c:	7ce0      	ldrb	r0, [r4, #19]
 802d67e:	0011      	movs	r1, r2
 802d680:	f001 f85d 	bl	802e73e <RegionInitDefaults>
                        adrAckReq = false;
 802d684:	2600      	movs	r6, #0
 802d686:	e7a6      	b.n	802d5d6 <CalcNextV10X+0x2a>

0802d688 <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 802d688:	b510      	push	{r4, lr}
    if( adrNext->Version.Fields.Minor == 0 )
 802d68a:	7884      	ldrb	r4, [r0, #2]
 802d68c:	2c00      	cmp	r4, #0
 802d68e:	d001      	beq.n	802d694 <LoRaMacAdrCalcNext+0xc>
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
    }
    return false;
 802d690:	2000      	movs	r0, #0
}
 802d692:	bd10      	pop	{r4, pc}
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
 802d694:	f7ff ff8a 	bl	802d5ac <CalcNextV10X>
 802d698:	e7fb      	b.n	802d692 <LoRaMacAdrCalcNext+0xa>

0802d69a <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d69a:	4770      	bx	lr

0802d69c <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d69c:	4770      	bx	lr

0802d69e <LoRaMacClassBSetPingSlotState>:
void LoRaMacClassBSetPingSlotState( PingSlotState_t pingSlotState )
{
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    Ctx.PingSlotState = pingSlotState;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d69e:	4770      	bx	lr

0802d6a0 <LoRaMacClassBSetMulticastSlotState>:
void LoRaMacClassBSetMulticastSlotState( PingSlotState_t multicastSlotState )
{
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    Ctx.MulticastSlotState = multicastSlotState;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6a0:	4770      	bx	lr

0802d6a2 <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6a2:	2000      	movs	r0, #0
 802d6a4:	4770      	bx	lr

0802d6a6 <LoRaMacClassBBeaconTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6a6:	4770      	bx	lr

0802d6a8 <LoRaMacClassBPingSlotTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6a8:	4770      	bx	lr

0802d6aa <LoRaMacClassBMulticastSlotTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6aa:	4770      	bx	lr

0802d6ac <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6ac:	2000      	movs	r0, #0
 802d6ae:	4770      	bx	lr

0802d6b0 <LoRaMacClassBIsBeaconExpected>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6b0:	2000      	movs	r0, #0
 802d6b2:	4770      	bx	lr

0802d6b4 <LoRaMacClassBIsPingExpected>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6b4:	2000      	movs	r0, #0
 802d6b6:	4770      	bx	lr

0802d6b8 <LoRaMacClassBIsMulticastExpected>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6b8:	2000      	movs	r0, #0
 802d6ba:	4770      	bx	lr

0802d6bc <LoRaMacClassBIsBeaconModeActive>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6bc:	2000      	movs	r0, #0
 802d6be:	4770      	bx	lr

0802d6c0 <LoRaMacClassBSetPingSlotInfo>:
{
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    ClassBNvm->PingSlotCtx.PingNb = CalcPingNb( periodicity );
    ClassBNvm->PingSlotCtx.PingPeriod = CalcPingPeriod( ClassBNvm->PingSlotCtx.PingNb );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6c0:	4770      	bx	lr

0802d6c2 <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6c2:	4770      	bx	lr

0802d6c4 <LoRaMacClassBResumeBeaconing>:
        }

        LoRaMacClassBBeaconTimerEvent( NULL );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6c4:	4770      	bx	lr

0802d6c6 <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6c6:	2002      	movs	r0, #2
 802d6c8:	4770      	bx	lr

0802d6ca <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6ca:	2002      	movs	r0, #2
 802d6cc:	4770      	bx	lr

0802d6ce <LoRaMacMibClassBSetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6ce:	2002      	movs	r0, #2
 802d6d0:	4770      	bx	lr

0802d6d2 <LoRaMacClassBPingSlotInfoAns>:
    {
        LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
        ClassBNvm->PingSlotCtx.Ctrl.Assigned = 1;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6d2:	4770      	bx	lr

0802d6d4 <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6d4:	2000      	movs	r0, #0
 802d6d6:	4770      	bx	lr

0802d6d8 <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6d8:	4770      	bx	lr

0802d6da <LoRaMacClassBDeviceTimeAns>:
            Ctx.BeaconCtx.BeaconTime.SubSeconds = 0;
            LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6da:	4770      	bx	lr

0802d6dc <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6dc:	2000      	movs	r0, #0
 802d6de:	4770      	bx	lr

0802d6e0 <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6e0:	2000      	movs	r0, #0
 802d6e2:	4770      	bx	lr

0802d6e4 <LoRaMacClassBStopRxSlots>:
    CRITICAL_SECTION_BEGIN( );
    LoRaMacClassBEvents.Events.PingSlot = 0;
    LoRaMacClassBEvents.Events.MulticastSlot = 0;
    CRITICAL_SECTION_END( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6e4:	4770      	bx	lr

0802d6e6 <LoRaMacClassBProcess>:
        {
            LoRaMacClassBProcessMulticastSlot( );
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802d6e6:	4770      	bx	lr

0802d6e8 <IsSlotFree>:
 */
static bool IsSlotFree( const MacCommand_t* slot )
{
    uint8_t* mem = ( uint8_t* )slot;

    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 802d6e8:	2300      	movs	r3, #0
 802d6ea:	2b0f      	cmp	r3, #15
 802d6ec:	d805      	bhi.n	802d6fa <IsSlotFree+0x12>
    {
        if( mem[size] != 0x00 )
 802d6ee:	5cc2      	ldrb	r2, [r0, r3]
 802d6f0:	2a00      	cmp	r2, #0
 802d6f2:	d104      	bne.n	802d6fe <IsSlotFree+0x16>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 802d6f4:	3301      	adds	r3, #1
 802d6f6:	b29b      	uxth	r3, r3
 802d6f8:	e7f7      	b.n	802d6ea <IsSlotFree+0x2>
        {
            return false;
        }
    }
    return true;
 802d6fa:	2001      	movs	r0, #1
}
 802d6fc:	4770      	bx	lr
            return false;
 802d6fe:	2000      	movs	r0, #0
 802d700:	e7fc      	b.n	802d6fc <IsSlotFree+0x14>
	...

0802d704 <MallocNewMacCommandSlot>:
 * \brief Allocates a new MAC command memory slot
 *
 * \retval                       - Pointer to slot
 */
static MacCommand_t* MallocNewMacCommandSlot( void )
{
 802d704:	b570      	push	{r4, r5, r6, lr}
    uint8_t itr = 0;
 802d706:	2500      	movs	r5, #0

    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 802d708:	012c      	lsls	r4, r5, #4
 802d70a:	3408      	adds	r4, #8
 802d70c:	4b06      	ldr	r3, [pc, #24]	; (802d728 <MallocNewMacCommandSlot+0x24>)
 802d70e:	18e4      	adds	r4, r4, r3
 802d710:	0020      	movs	r0, r4
 802d712:	f7ff ffe9 	bl	802d6e8 <IsSlotFree>
 802d716:	2800      	cmp	r0, #0
 802d718:	d104      	bne.n	802d724 <MallocNewMacCommandSlot+0x20>
    {
        itr++;
 802d71a:	3501      	adds	r5, #1
 802d71c:	b2ed      	uxtb	r5, r5
        if( itr == NUM_OF_MAC_COMMANDS )
 802d71e:	2d0f      	cmp	r5, #15
 802d720:	d1f2      	bne.n	802d708 <MallocNewMacCommandSlot+0x4>
        {
            return NULL;
 802d722:	2400      	movs	r4, #0
        }
    }

    return &CommandsCtx.MacCommandSlots[itr];
}
 802d724:	0020      	movs	r0, r4
 802d726:	bd70      	pop	{r4, r5, r6, pc}
 802d728:	2000b090 	.word	0x2000b090

0802d72c <LinkedListInit>:
 * \param[IN]     list           - List that shall be initialized
 * \retval                       - Status of the operation
 */
static bool LinkedListInit( MacCommandsList_t* list )
{
    if( list == NULL )
 802d72c:	2800      	cmp	r0, #0
 802d72e:	d004      	beq.n	802d73a <LinkedListInit+0xe>
    {
        return false;
    }

    list->First = NULL;
 802d730:	2300      	movs	r3, #0
 802d732:	6003      	str	r3, [r0, #0]
    list->Last = NULL;
 802d734:	6043      	str	r3, [r0, #4]

    return true;
 802d736:	2001      	movs	r0, #1
}
 802d738:	4770      	bx	lr
        return false;
 802d73a:	2000      	movs	r0, #0
 802d73c:	e7fc      	b.n	802d738 <LinkedListInit+0xc>

0802d73e <LinkedListAdd>:
 * \param[IN]     element        - Element to add
 * \retval                       - Status of the operation
 */
static bool LinkedListAdd( MacCommandsList_t* list, MacCommand_t* element )
{
    if( ( list == NULL ) || ( element == NULL ) )
 802d73e:	2800      	cmp	r0, #0
 802d740:	d00f      	beq.n	802d762 <LinkedListAdd+0x24>
 802d742:	2900      	cmp	r1, #0
 802d744:	d00f      	beq.n	802d766 <LinkedListAdd+0x28>
    {
        return false;
    }

    // Check if this is the first entry to enter the list.
    if( list->First == NULL )
 802d746:	6803      	ldr	r3, [r0, #0]
 802d748:	2b00      	cmp	r3, #0
 802d74a:	d008      	beq.n	802d75e <LinkedListAdd+0x20>
    {
        list->First = element;
    }

    // Check if the last entry exists and update its next point.
    if( list->Last )
 802d74c:	6843      	ldr	r3, [r0, #4]
 802d74e:	2b00      	cmp	r3, #0
 802d750:	d000      	beq.n	802d754 <LinkedListAdd+0x16>
    {
        list->Last->Next = element;
 802d752:	6019      	str	r1, [r3, #0]
    }

    // Update the next point of this entry.
    element->Next = NULL;
 802d754:	2300      	movs	r3, #0
 802d756:	600b      	str	r3, [r1, #0]

    // Update the last entry of the list.
    list->Last = element;
 802d758:	6041      	str	r1, [r0, #4]

    return true;
 802d75a:	2001      	movs	r0, #1
}
 802d75c:	4770      	bx	lr
        list->First = element;
 802d75e:	6001      	str	r1, [r0, #0]
 802d760:	e7f4      	b.n	802d74c <LinkedListAdd+0xe>
        return false;
 802d762:	2000      	movs	r0, #0
 802d764:	e7fa      	b.n	802d75c <LinkedListAdd+0x1e>
 802d766:	2000      	movs	r0, #0
 802d768:	e7f8      	b.n	802d75c <LinkedListAdd+0x1e>

0802d76a <LinkedListGetPrevious>:
 * \param[IN]     element        - Element where the previous element shall be searched
 * \retval                       - Status of the operation
 */
static MacCommand_t* LinkedListGetPrevious( MacCommandsList_t* list, MacCommand_t* element )
{
    if( ( list == NULL ) || ( element == NULL ) )
 802d76a:	2800      	cmp	r0, #0
 802d76c:	d00c      	beq.n	802d788 <LinkedListGetPrevious+0x1e>
 802d76e:	2900      	cmp	r1, #0
 802d770:	d00b      	beq.n	802d78a <LinkedListGetPrevious+0x20>
    }

    MacCommand_t* curElement;

    // Start at the head of the list
    curElement = list->First;
 802d772:	6800      	ldr	r0, [r0, #0]

    // When current element is the first of the list, there's no previous element so we can return NULL immediately.
    if( element != curElement )
 802d774:	4281      	cmp	r1, r0
 802d776:	d102      	bne.n	802d77e <LinkedListGetPrevious+0x14>
            curElement = curElement->Next;
        }
    }
    else
    {
        curElement = NULL;
 802d778:	2000      	movs	r0, #0
 802d77a:	e005      	b.n	802d788 <LinkedListGetPrevious+0x1e>
            curElement = curElement->Next;
 802d77c:	0018      	movs	r0, r3
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 802d77e:	2800      	cmp	r0, #0
 802d780:	d002      	beq.n	802d788 <LinkedListGetPrevious+0x1e>
 802d782:	6803      	ldr	r3, [r0, #0]
 802d784:	428b      	cmp	r3, r1
 802d786:	d1f9      	bne.n	802d77c <LinkedListGetPrevious+0x12>
    }

    return curElement;
}
 802d788:	4770      	bx	lr
        return NULL;
 802d78a:	0008      	movs	r0, r1
 802d78c:	e7fc      	b.n	802d788 <LinkedListGetPrevious+0x1e>

0802d78e <LinkedListRemove>:
 * \param[IN]     list           - List where the element shall be removed from.
 * \param[IN]     element        - Element to remove
 * \retval                       - Status of the operation
 */
static bool LinkedListRemove( MacCommandsList_t* list, MacCommand_t* element )
{
 802d78e:	b570      	push	{r4, r5, r6, lr}
 802d790:	0005      	movs	r5, r0
 802d792:	000c      	movs	r4, r1
    if( ( list == NULL ) || ( element == NULL ) )
 802d794:	2800      	cmp	r0, #0
 802d796:	d016      	beq.n	802d7c6 <LinkedListRemove+0x38>
 802d798:	2900      	cmp	r1, #0
 802d79a:	d016      	beq.n	802d7ca <LinkedListRemove+0x3c>
    {
        return false;
    }

    MacCommand_t* PrevElement = LinkedListGetPrevious( list, element );
 802d79c:	f7ff ffe5 	bl	802d76a <LinkedListGetPrevious>

    if( list->First == element )
 802d7a0:	682b      	ldr	r3, [r5, #0]
 802d7a2:	42a3      	cmp	r3, r4
 802d7a4:	d00a      	beq.n	802d7bc <LinkedListRemove+0x2e>
    {
        list->First = element->Next;
    }

    if( list->Last == element )
 802d7a6:	686b      	ldr	r3, [r5, #4]
 802d7a8:	42a3      	cmp	r3, r4
 802d7aa:	d00a      	beq.n	802d7c2 <LinkedListRemove+0x34>
    {
        list->Last = PrevElement;
    }

    if( PrevElement != NULL )
 802d7ac:	2800      	cmp	r0, #0
 802d7ae:	d001      	beq.n	802d7b4 <LinkedListRemove+0x26>
    {
        PrevElement->Next = element->Next;
 802d7b0:	6823      	ldr	r3, [r4, #0]
 802d7b2:	6003      	str	r3, [r0, #0]
    }

    element->Next = NULL;
 802d7b4:	2300      	movs	r3, #0
 802d7b6:	6023      	str	r3, [r4, #0]

    return true;
 802d7b8:	2001      	movs	r0, #1
}
 802d7ba:	bd70      	pop	{r4, r5, r6, pc}
        list->First = element->Next;
 802d7bc:	6823      	ldr	r3, [r4, #0]
 802d7be:	602b      	str	r3, [r5, #0]
 802d7c0:	e7f1      	b.n	802d7a6 <LinkedListRemove+0x18>
        list->Last = PrevElement;
 802d7c2:	6068      	str	r0, [r5, #4]
 802d7c4:	e7f2      	b.n	802d7ac <LinkedListRemove+0x1e>
        return false;
 802d7c6:	2000      	movs	r0, #0
 802d7c8:	e7f7      	b.n	802d7ba <LinkedListRemove+0x2c>
 802d7ca:	2000      	movs	r0, #0
 802d7cc:	e7f5      	b.n	802d7ba <LinkedListRemove+0x2c>

0802d7ce <IsSticky>:
 *
 * \retval                     - Status of the operation
 */
static bool IsSticky( uint8_t cid )
{
    switch( cid )
 802d7ce:	2805      	cmp	r0, #5
 802d7d0:	d006      	beq.n	802d7e0 <IsSticky+0x12>
 802d7d2:	d307      	bcc.n	802d7e4 <IsSticky+0x16>
 802d7d4:	3808      	subs	r0, #8
 802d7d6:	b2c0      	uxtb	r0, r0
 802d7d8:	2802      	cmp	r0, #2
 802d7da:	d905      	bls.n	802d7e8 <IsSticky+0x1a>
        case MOTE_MAC_RX_PARAM_SETUP_ANS:
        case MOTE_MAC_RX_TIMING_SETUP_ANS:
        case MOTE_MAC_TX_PARAM_SETUP_ANS:
            return true;
        default:
            return false;
 802d7dc:	2000      	movs	r0, #0
    }
}
 802d7de:	4770      	bx	lr
    switch( cid )
 802d7e0:	2001      	movs	r0, #1
 802d7e2:	e7fc      	b.n	802d7de <IsSticky+0x10>
            return false;
 802d7e4:	2000      	movs	r0, #0
 802d7e6:	e7fa      	b.n	802d7de <IsSticky+0x10>
    switch( cid )
 802d7e8:	2001      	movs	r0, #1
 802d7ea:	e7f8      	b.n	802d7de <IsSticky+0x10>

0802d7ec <FreeMacCommandSlot>:
{
 802d7ec:	b510      	push	{r4, lr}
    if( slot == NULL )
 802d7ee:	2800      	cmp	r0, #0
 802d7f0:	d005      	beq.n	802d7fe <FreeMacCommandSlot+0x12>
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 802d7f2:	2210      	movs	r2, #16
 802d7f4:	2100      	movs	r1, #0
 802d7f6:	f003 ffe8 	bl	80317ca <memset1>
    return true;
 802d7fa:	2001      	movs	r0, #1
}
 802d7fc:	bd10      	pop	{r4, pc}
        return false;
 802d7fe:	2000      	movs	r0, #0
 802d800:	e7fc      	b.n	802d7fc <FreeMacCommandSlot+0x10>
	...

0802d804 <LoRaMacCommandsInit>:

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 802d804:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 802d806:	4c05      	ldr	r4, [pc, #20]	; (802d81c <LoRaMacCommandsInit+0x18>)
 802d808:	22fc      	movs	r2, #252	; 0xfc
 802d80a:	2100      	movs	r1, #0
 802d80c:	0020      	movs	r0, r4
 802d80e:	f003 ffdc 	bl	80317ca <memset1>

    LinkedListInit( &CommandsCtx.MacCommandList );
 802d812:	0020      	movs	r0, r4
 802d814:	f7ff ff8a 	bl	802d72c <LinkedListInit>

    return LORAMAC_COMMANDS_SUCCESS;
}
 802d818:	2000      	movs	r0, #0
 802d81a:	bd10      	pop	{r4, pc}
 802d81c:	2000b090 	.word	0x2000b090

0802d820 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 802d820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802d822:	0007      	movs	r7, r0
 802d824:	000e      	movs	r6, r1
 802d826:	0014      	movs	r4, r2
    if( payload == NULL )
 802d828:	2900      	cmp	r1, #0
 802d82a:	d01d      	beq.n	802d868 <LoRaMacCommandsAddCmd+0x48>
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* newCmd;

    // Allocate a memory slot
    newCmd = MallocNewMacCommandSlot( );
 802d82c:	f7ff ff6a 	bl	802d704 <MallocNewMacCommandSlot>
 802d830:	1e05      	subs	r5, r0, #0

    if( newCmd == NULL )
 802d832:	d01b      	beq.n	802d86c <LoRaMacCommandsAddCmd+0x4c>
    {
        return LORAMAC_COMMANDS_ERROR_MEMORY;
    }

    // Add it to the list of Mac commands
    if( LinkedListAdd( &CommandsCtx.MacCommandList, newCmd ) == false )
 802d834:	0001      	movs	r1, r0
 802d836:	480f      	ldr	r0, [pc, #60]	; (802d874 <LoRaMacCommandsAddCmd+0x54>)
 802d838:	f7ff ff81 	bl	802d73e <LinkedListAdd>
 802d83c:	2800      	cmp	r0, #0
 802d83e:	d017      	beq.n	802d870 <LoRaMacCommandsAddCmd+0x50>
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
 802d840:	712f      	strb	r7, [r5, #4]
    newCmd->PayloadSize = payloadSize;
 802d842:	60ac      	str	r4, [r5, #8]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 802d844:	1d68      	adds	r0, r5, #5
 802d846:	b2a2      	uxth	r2, r4
 802d848:	0031      	movs	r1, r6
 802d84a:	f003 ffa6 	bl	803179a <memcpy1>
    newCmd->IsSticky = IsSticky( cid );
 802d84e:	0038      	movs	r0, r7
 802d850:	f7ff ffbd 	bl	802d7ce <IsSticky>
 802d854:	7328      	strb	r0, [r5, #12]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 802d856:	4a07      	ldr	r2, [pc, #28]	; (802d874 <LoRaMacCommandsAddCmd+0x54>)
 802d858:	23f8      	movs	r3, #248	; 0xf8
 802d85a:	58d1      	ldr	r1, [r2, r3]
 802d85c:	468c      	mov	ip, r1
 802d85e:	4464      	add	r4, ip
 802d860:	3401      	adds	r4, #1
 802d862:	50d4      	str	r4, [r2, r3]

    return LORAMAC_COMMANDS_SUCCESS;
 802d864:	2000      	movs	r0, #0
}
 802d866:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 802d868:	2001      	movs	r0, #1
 802d86a:	e7fc      	b.n	802d866 <LoRaMacCommandsAddCmd+0x46>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 802d86c:	2002      	movs	r0, #2
 802d86e:	e7fa      	b.n	802d866 <LoRaMacCommandsAddCmd+0x46>
        return LORAMAC_COMMANDS_ERROR;
 802d870:	2005      	movs	r0, #5
 802d872:	e7f8      	b.n	802d866 <LoRaMacCommandsAddCmd+0x46>
 802d874:	2000b090 	.word	0x2000b090

0802d878 <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 802d878:	b510      	push	{r4, lr}
 802d87a:	1e04      	subs	r4, r0, #0
    if( macCmd == NULL )
 802d87c:	d013      	beq.n	802d8a6 <LoRaMacCommandsRemoveCmd+0x2e>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Remove the Mac command element from MacCommandList
    if( LinkedListRemove( &CommandsCtx.MacCommandList, macCmd ) == false )
 802d87e:	0001      	movs	r1, r0
 802d880:	480c      	ldr	r0, [pc, #48]	; (802d8b4 <LoRaMacCommandsRemoveCmd+0x3c>)
 802d882:	f7ff ff84 	bl	802d78e <LinkedListRemove>
 802d886:	2800      	cmp	r0, #0
 802d888:	d00f      	beq.n	802d8aa <LoRaMacCommandsRemoveCmd+0x32>
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }

    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 802d88a:	490a      	ldr	r1, [pc, #40]	; (802d8b4 <LoRaMacCommandsRemoveCmd+0x3c>)
 802d88c:	22f8      	movs	r2, #248	; 0xf8
 802d88e:	588b      	ldr	r3, [r1, r2]
 802d890:	68a0      	ldr	r0, [r4, #8]
 802d892:	1a1b      	subs	r3, r3, r0
 802d894:	3b01      	subs	r3, #1
 802d896:	508b      	str	r3, [r1, r2]

    // Free the MacCommand Slot
    if( FreeMacCommandSlot( macCmd ) == false )
 802d898:	0020      	movs	r0, r4
 802d89a:	f7ff ffa7 	bl	802d7ec <FreeMacCommandSlot>
 802d89e:	2800      	cmp	r0, #0
 802d8a0:	d005      	beq.n	802d8ae <LoRaMacCommandsRemoveCmd+0x36>
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    return LORAMAC_COMMANDS_SUCCESS;
 802d8a2:	2000      	movs	r0, #0
}
 802d8a4:	bd10      	pop	{r4, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 802d8a6:	2001      	movs	r0, #1
 802d8a8:	e7fc      	b.n	802d8a4 <LoRaMacCommandsRemoveCmd+0x2c>
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
 802d8aa:	2003      	movs	r0, #3
 802d8ac:	e7fa      	b.n	802d8a4 <LoRaMacCommandsRemoveCmd+0x2c>
        return LORAMAC_COMMANDS_ERROR;
 802d8ae:	2005      	movs	r0, #5
 802d8b0:	e7f8      	b.n	802d8a4 <LoRaMacCommandsRemoveCmd+0x2c>
 802d8b2:	46c0      	nop			; (mov r8, r8)
 802d8b4:	2000b090 	.word	0x2000b090

0802d8b8 <LoRaMacCommandsRemoveNoneStickyCmds>:
    }
    return LORAMAC_COMMANDS_SUCCESS;
}

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 802d8b8:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 802d8ba:	4b07      	ldr	r3, [pc, #28]	; (802d8d8 <LoRaMacCommandsRemoveNoneStickyCmds+0x20>)
 802d8bc:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 802d8be:	e003      	b.n	802d8c8 <LoRaMacCommandsRemoveNoneStickyCmds+0x10>
    {
        if( curElement->IsSticky == false )
        {
            nexElement = curElement->Next;
 802d8c0:	6804      	ldr	r4, [r0, #0]
            LoRaMacCommandsRemoveCmd( curElement );
 802d8c2:	f7ff ffd9 	bl	802d878 <LoRaMacCommandsRemoveCmd>
            curElement = nexElement;
 802d8c6:	0020      	movs	r0, r4
    while( curElement != NULL )
 802d8c8:	2800      	cmp	r0, #0
 802d8ca:	d004      	beq.n	802d8d6 <LoRaMacCommandsRemoveNoneStickyCmds+0x1e>
        if( curElement->IsSticky == false )
 802d8cc:	7b03      	ldrb	r3, [r0, #12]
 802d8ce:	2b00      	cmp	r3, #0
 802d8d0:	d0f6      	beq.n	802d8c0 <LoRaMacCommandsRemoveNoneStickyCmds+0x8>
        }
        else
        {
            curElement = curElement->Next;
 802d8d2:	6800      	ldr	r0, [r0, #0]
 802d8d4:	e7f8      	b.n	802d8c8 <LoRaMacCommandsRemoveNoneStickyCmds+0x10>
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 802d8d6:	bd10      	pop	{r4, pc}
 802d8d8:	2000b090 	.word	0x2000b090

0802d8dc <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 802d8dc:	b570      	push	{r4, r5, r6, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 802d8de:	4b09      	ldr	r3, [pc, #36]	; (802d904 <LoRaMacCommandsRemoveStickyAnsCmds+0x28>)
 802d8e0:	681c      	ldr	r4, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 802d8e2:	e003      	b.n	802d8ec <LoRaMacCommandsRemoveStickyAnsCmds+0x10>
    {
        nexElement = curElement->Next;
        if( IsSticky( curElement->CID ) == true )
        {
            LoRaMacCommandsRemoveCmd( curElement );
 802d8e4:	0020      	movs	r0, r4
 802d8e6:	f7ff ffc7 	bl	802d878 <LoRaMacCommandsRemoveCmd>
{
 802d8ea:	002c      	movs	r4, r5
    while( curElement != NULL )
 802d8ec:	2c00      	cmp	r4, #0
 802d8ee:	d006      	beq.n	802d8fe <LoRaMacCommandsRemoveStickyAnsCmds+0x22>
        nexElement = curElement->Next;
 802d8f0:	6825      	ldr	r5, [r4, #0]
        if( IsSticky( curElement->CID ) == true )
 802d8f2:	7920      	ldrb	r0, [r4, #4]
 802d8f4:	f7ff ff6b 	bl	802d7ce <IsSticky>
 802d8f8:	2800      	cmp	r0, #0
 802d8fa:	d0f6      	beq.n	802d8ea <LoRaMacCommandsRemoveStickyAnsCmds+0xe>
 802d8fc:	e7f2      	b.n	802d8e4 <LoRaMacCommandsRemoveStickyAnsCmds+0x8>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 802d8fe:	2000      	movs	r0, #0
 802d900:	bd70      	pop	{r4, r5, r6, pc}
 802d902:	46c0      	nop			; (mov r8, r8)
 802d904:	2000b090 	.word	0x2000b090

0802d908 <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 802d908:	2800      	cmp	r0, #0
 802d90a:	d005      	beq.n	802d918 <LoRaMacCommandsGetSizeSerializedCmds+0x10>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 802d90c:	4a03      	ldr	r2, [pc, #12]	; (802d91c <LoRaMacCommandsGetSizeSerializedCmds+0x14>)
 802d90e:	23f8      	movs	r3, #248	; 0xf8
 802d910:	58d3      	ldr	r3, [r2, r3]
 802d912:	6003      	str	r3, [r0, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 802d914:	2000      	movs	r0, #0
}
 802d916:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 802d918:	2001      	movs	r0, #1
 802d91a:	e7fc      	b.n	802d916 <LoRaMacCommandsGetSizeSerializedCmds+0xe>
 802d91c:	2000b090 	.word	0x2000b090

0802d920 <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 802d920:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802d922:	46ce      	mov	lr, r9
 802d924:	4647      	mov	r7, r8
 802d926:	b580      	push	{r7, lr}
 802d928:	4680      	mov	r8, r0
 802d92a:	4689      	mov	r9, r1
 802d92c:	1e17      	subs	r7, r2, #0
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 802d92e:	4b18      	ldr	r3, [pc, #96]	; (802d990 <LoRaMacCommandsSerializeCmds+0x70>)
 802d930:	681c      	ldr	r4, [r3, #0]
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 802d932:	d029      	beq.n	802d988 <LoRaMacCommandsSerializeCmds+0x68>
 802d934:	2900      	cmp	r1, #0
 802d936:	d029      	beq.n	802d98c <LoRaMacCommandsSerializeCmds+0x6c>
    uint8_t itr = 0;
 802d938:	2200      	movs	r2, #0
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 802d93a:	2c00      	cmp	r4, #0
 802d93c:	d014      	beq.n	802d968 <LoRaMacCommandsSerializeCmds+0x48>
    {
        // If the next MAC command still fits into the buffer, add it.
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 802d93e:	4643      	mov	r3, r8
 802d940:	1a9e      	subs	r6, r3, r2
 802d942:	68a3      	ldr	r3, [r4, #8]
 802d944:	3301      	adds	r3, #1
 802d946:	429e      	cmp	r6, r3
 802d948:	d30e      	bcc.n	802d968 <LoRaMacCommandsSerializeCmds+0x48>
        {
            buffer[itr++] = curElement->CID;
 802d94a:	1c55      	adds	r5, r2, #1
 802d94c:	b2ed      	uxtb	r5, r5
 802d94e:	7923      	ldrb	r3, [r4, #4]
 802d950:	54bb      	strb	r3, [r7, r2]
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 802d952:	1d61      	adds	r1, r4, #5
 802d954:	8922      	ldrh	r2, [r4, #8]
 802d956:	1978      	adds	r0, r7, r5
 802d958:	f003 ff1f 	bl	803179a <memcpy1>
            itr += curElement->PayloadSize;
 802d95c:	68a3      	ldr	r3, [r4, #8]
 802d95e:	469c      	mov	ip, r3
 802d960:	4465      	add	r5, ip
 802d962:	b2ea      	uxtb	r2, r5
        }
        else
        {
            break;
        }
        curElement = curElement->Next;
 802d964:	6824      	ldr	r4, [r4, #0]
 802d966:	e7e8      	b.n	802d93a <LoRaMacCommandsSerializeCmds+0x1a>
    }

    // Remove all commands which do not fit into the buffer
    while( curElement != NULL )
 802d968:	2c00      	cmp	r4, #0
 802d96a:	d005      	beq.n	802d978 <LoRaMacCommandsSerializeCmds+0x58>
    {
        // Store the next element before removing the current one
        nextElement = curElement->Next;
 802d96c:	6825      	ldr	r5, [r4, #0]
        LoRaMacCommandsRemoveCmd( curElement );
 802d96e:	0020      	movs	r0, r4
 802d970:	f7ff ff82 	bl	802d878 <LoRaMacCommandsRemoveCmd>
        curElement = nextElement;
 802d974:	002c      	movs	r4, r5
 802d976:	e7f7      	b.n	802d968 <LoRaMacCommandsSerializeCmds+0x48>
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );
 802d978:	4648      	mov	r0, r9
 802d97a:	f7ff ffc5 	bl	802d908 <LoRaMacCommandsGetSizeSerializedCmds>

    return LORAMAC_COMMANDS_SUCCESS;
 802d97e:	2000      	movs	r0, #0
}
 802d980:	bcc0      	pop	{r6, r7}
 802d982:	46b9      	mov	r9, r7
 802d984:	46b0      	mov	r8, r6
 802d986:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 802d988:	2001      	movs	r0, #1
 802d98a:	e7f9      	b.n	802d980 <LoRaMacCommandsSerializeCmds+0x60>
 802d98c:	2001      	movs	r0, #1
 802d98e:	e7f7      	b.n	802d980 <LoRaMacCommandsSerializeCmds+0x60>
 802d990:	2000b090 	.word	0x2000b090

0802d994 <LoRaMacCommandsStickyCmdsPending>:

LoRaMacCommandStatus_t LoRaMacCommandsStickyCmdsPending( bool* cmdsPending )
{
    if( cmdsPending == NULL )
 802d994:	2800      	cmp	r0, #0
 802d996:	d010      	beq.n	802d9ba <LoRaMacCommandsStickyCmdsPending+0x26>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* curElement;
    curElement = CommandsCtx.MacCommandList.First;
 802d998:	4b09      	ldr	r3, [pc, #36]	; (802d9c0 <LoRaMacCommandsStickyCmdsPending+0x2c>)
 802d99a:	681b      	ldr	r3, [r3, #0]

    *cmdsPending = false;
 802d99c:	2200      	movs	r2, #0
 802d99e:	7002      	strb	r2, [r0, #0]

    // Loop through all elements
    while( curElement != NULL )
 802d9a0:	2b00      	cmp	r3, #0
 802d9a2:	d008      	beq.n	802d9b6 <LoRaMacCommandsStickyCmdsPending+0x22>
    {
        if( curElement->IsSticky == true )
 802d9a4:	7b1a      	ldrb	r2, [r3, #12]
 802d9a6:	2a00      	cmp	r2, #0
 802d9a8:	d101      	bne.n	802d9ae <LoRaMacCommandsStickyCmdsPending+0x1a>
        {
            // Found one sticky MAC command
            *cmdsPending = true;
            return LORAMAC_COMMANDS_SUCCESS;
        }
        curElement = curElement->Next;
 802d9aa:	681b      	ldr	r3, [r3, #0]
 802d9ac:	e7f8      	b.n	802d9a0 <LoRaMacCommandsStickyCmdsPending+0xc>
            *cmdsPending = true;
 802d9ae:	2301      	movs	r3, #1
 802d9b0:	7003      	strb	r3, [r0, #0]
            return LORAMAC_COMMANDS_SUCCESS;
 802d9b2:	2000      	movs	r0, #0
 802d9b4:	e000      	b.n	802d9b8 <LoRaMacCommandsStickyCmdsPending+0x24>
    }

    return LORAMAC_COMMANDS_SUCCESS;
 802d9b6:	2000      	movs	r0, #0
}
 802d9b8:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 802d9ba:	2001      	movs	r0, #1
 802d9bc:	e7fc      	b.n	802d9b8 <LoRaMacCommandsStickyCmdsPending+0x24>
 802d9be:	46c0      	nop			; (mov r8, r8)
 802d9c0:	2000b090 	.word	0x2000b090

0802d9c4 <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 802d9c4:	2813      	cmp	r0, #19
 802d9c6:	d803      	bhi.n	802d9d0 <LoRaMacCommandsGetCmdSize+0xc>
 802d9c8:	0083      	lsls	r3, r0, #2
 802d9ca:	4a0f      	ldr	r2, [pc, #60]	; (802da08 <LoRaMacCommandsGetCmdSize+0x44>)
 802d9cc:	58d3      	ldr	r3, [r2, r3]
 802d9ce:	469f      	mov	pc, r3
            break;
        }
        case SRV_MAC_BEACON_FREQ_REQ:
        {
            // cid + Frequency (3)
            cidSize = 4;
 802d9d0:	2000      	movs	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 802d9d2:	4770      	bx	lr
            cidSize = 5;
 802d9d4:	2005      	movs	r0, #5
            break;
 802d9d6:	e7fc      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 2;
 802d9d8:	2002      	movs	r0, #2
            break;
 802d9da:	e7fa      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 1;
 802d9dc:	2001      	movs	r0, #1
            break;
 802d9de:	e7f8      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 6;
 802d9e0:	2006      	movs	r0, #6
            break;
 802d9e2:	e7f6      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 2;
 802d9e4:	2002      	movs	r0, #2
            break;
 802d9e6:	e7f4      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 2;
 802d9e8:	2002      	movs	r0, #2
            break;
 802d9ea:	e7f2      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 5;
 802d9ec:	2005      	movs	r0, #5
            break;
 802d9ee:	e7f0      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 6;
 802d9f0:	2006      	movs	r0, #6
            break;
 802d9f2:	e7ee      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 1;
 802d9f4:	2001      	movs	r0, #1
            break;
 802d9f6:	e7ec      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 5;
 802d9f8:	2005      	movs	r0, #5
            break;
 802d9fa:	e7ea      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 4;
 802d9fc:	2004      	movs	r0, #4
            break;
 802d9fe:	e7e8      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 4;
 802da00:	2004      	movs	r0, #4
            break;
 802da02:	e7e6      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 3;
 802da04:	2003      	movs	r0, #3
 802da06:	e7e4      	b.n	802d9d2 <LoRaMacCommandsGetCmdSize+0xe>
 802da08:	080350b0 	.word	0x080350b0

0802da0c <IncreaseBufferPointer>:
 */
static LoRaMacConfirmQueueCtx_t ConfirmQueueCtx;

static MlmeConfirmQueue_t* IncreaseBufferPointer( MlmeConfirmQueue_t* bufferPointer )
{
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 802da0c:	4b04      	ldr	r3, [pc, #16]	; (802da20 <IncreaseBufferPointer+0x14>)
 802da0e:	331c      	adds	r3, #28
 802da10:	4298      	cmp	r0, r3
 802da12:	d001      	beq.n	802da18 <IncreaseBufferPointer+0xc>
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
    }
    else
    {
        // Increase
        bufferPointer++;
 802da14:	3004      	adds	r0, #4
    }
    return bufferPointer;
}
 802da16:	4770      	bx	lr
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 802da18:	4801      	ldr	r0, [pc, #4]	; (802da20 <IncreaseBufferPointer+0x14>)
 802da1a:	300c      	adds	r0, #12
    return bufferPointer;
 802da1c:	e7fb      	b.n	802da16 <IncreaseBufferPointer+0xa>
 802da1e:	46c0      	nop			; (mov r8, r8)
 802da20:	2000b18c 	.word	0x2000b18c

0802da24 <IsListEmpty>:
    return bufferPointer;
}

static bool IsListEmpty( uint8_t count )
{
    if( count == 0 )
 802da24:	2800      	cmp	r0, #0
 802da26:	d001      	beq.n	802da2c <IsListEmpty+0x8>
    {
        return true;
    }
    return false;
 802da28:	2000      	movs	r0, #0
}
 802da2a:	4770      	bx	lr
        return true;
 802da2c:	2001      	movs	r0, #1
 802da2e:	e7fc      	b.n	802da2a <IsListEmpty+0x6>

0802da30 <IsListFull>:

static bool IsListFull( uint8_t count )
{
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 802da30:	2804      	cmp	r0, #4
 802da32:	d801      	bhi.n	802da38 <IsListFull+0x8>
    {
        return true;
    }
    return false;
 802da34:	2000      	movs	r0, #0
}
 802da36:	4770      	bx	lr
        return true;
 802da38:	2001      	movs	r0, #1
 802da3a:	e7fc      	b.n	802da36 <IsListFull+0x6>

0802da3c <GetElement>:

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
{
 802da3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802da3e:	0006      	movs	r6, r0
 802da40:	000c      	movs	r4, r1
    MlmeConfirmQueue_t* element = bufferStart;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802da42:	4a0d      	ldr	r2, [pc, #52]	; (802da78 <GetElement+0x3c>)
 802da44:	2320      	movs	r3, #32
 802da46:	5cd7      	ldrb	r7, [r2, r3]
 802da48:	0038      	movs	r0, r7
 802da4a:	f7ff ffeb 	bl	802da24 <IsListEmpty>
 802da4e:	2800      	cmp	r0, #0
 802da50:	d10e      	bne.n	802da70 <GetElement+0x34>
    {
        return NULL;
    }

    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 802da52:	2500      	movs	r5, #0
 802da54:	42af      	cmp	r7, r5
 802da56:	d909      	bls.n	802da6c <GetElement+0x30>
    {
        if( element->Request == request )
 802da58:	7823      	ldrb	r3, [r4, #0]
 802da5a:	42b3      	cmp	r3, r6
 802da5c:	d00a      	beq.n	802da74 <GetElement+0x38>
        {
            // We have found the element
            return element;
        }
        element = IncreaseBufferPointer( element );
 802da5e:	0020      	movs	r0, r4
 802da60:	f7ff ffd4 	bl	802da0c <IncreaseBufferPointer>
 802da64:	0004      	movs	r4, r0
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 802da66:	3501      	adds	r5, #1
 802da68:	b2ed      	uxtb	r5, r5
 802da6a:	e7f3      	b.n	802da54 <GetElement+0x18>
    }

    return NULL;
 802da6c:	2000      	movs	r0, #0
}
 802da6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return NULL;
 802da70:	2000      	movs	r0, #0
 802da72:	e7fc      	b.n	802da6e <GetElement+0x32>
            return element;
 802da74:	0020      	movs	r0, r4
 802da76:	e7fa      	b.n	802da6e <GetElement+0x32>
 802da78:	2000b18c 	.word	0x2000b18c

0802da7c <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 802da7c:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 802da7e:	4c08      	ldr	r4, [pc, #32]	; (802daa0 <LoRaMacConfirmQueueInit+0x24>)
 802da80:	6020      	str	r0, [r4, #0]

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 802da82:	2320      	movs	r3, #32
 802da84:	2200      	movs	r2, #0
 802da86:	54e2      	strb	r2, [r4, r3]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 802da88:	0020      	movs	r0, r4
 802da8a:	300c      	adds	r0, #12
 802da8c:	6060      	str	r0, [r4, #4]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 802da8e:	60a0      	str	r0, [r4, #8]

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 802da90:	3214      	adds	r2, #20
 802da92:	21ff      	movs	r1, #255	; 0xff
 802da94:	f003 fe99 	bl	80317ca <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802da98:	2321      	movs	r3, #33	; 0x21
 802da9a:	2201      	movs	r2, #1
 802da9c:	54e2      	strb	r2, [r4, r3]
}
 802da9e:	bd10      	pop	{r4, pc}
 802daa0:	2000b18c 	.word	0x2000b18c

0802daa4 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
 802daa4:	b570      	push	{r4, r5, r6, lr}
 802daa6:	0005      	movs	r5, r0
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802daa8:	4a0f      	ldr	r2, [pc, #60]	; (802dae8 <LoRaMacConfirmQueueAdd+0x44>)
 802daaa:	2320      	movs	r3, #32
 802daac:	5cd0      	ldrb	r0, [r2, r3]
 802daae:	f7ff ffbf 	bl	802da30 <IsListFull>
 802dab2:	2800      	cmp	r0, #0
 802dab4:	d116      	bne.n	802dae4 <LoRaMacConfirmQueueAdd+0x40>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 802dab6:	4c0c      	ldr	r4, [pc, #48]	; (802dae8 <LoRaMacConfirmQueueAdd+0x44>)
 802dab8:	782b      	ldrb	r3, [r5, #0]
 802daba:	68a2      	ldr	r2, [r4, #8]
 802dabc:	7013      	strb	r3, [r2, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 802dabe:	786b      	ldrb	r3, [r5, #1]
 802dac0:	68a2      	ldr	r2, [r4, #8]
 802dac2:	7053      	strb	r3, [r2, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 802dac4:	78eb      	ldrb	r3, [r5, #3]
 802dac6:	68a2      	ldr	r2, [r4, #8]
 802dac8:	70d3      	strb	r3, [r2, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 802daca:	2300      	movs	r3, #0
 802dacc:	68a2      	ldr	r2, [r4, #8]
 802dace:	7093      	strb	r3, [r2, #2]
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 802dad0:	2220      	movs	r2, #32
 802dad2:	5ca3      	ldrb	r3, [r4, r2]
 802dad4:	3301      	adds	r3, #1
 802dad6:	54a3      	strb	r3, [r4, r2]
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 802dad8:	68a0      	ldr	r0, [r4, #8]
 802dada:	f7ff ff97 	bl	802da0c <IncreaseBufferPointer>
 802dade:	60a0      	str	r0, [r4, #8]

    return true;
 802dae0:	2001      	movs	r0, #1
}
 802dae2:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 802dae4:	2000      	movs	r0, #0
 802dae6:	e7fc      	b.n	802dae2 <LoRaMacConfirmQueueAdd+0x3e>
 802dae8:	2000b18c 	.word	0x2000b18c

0802daec <LoRaMacConfirmQueueRemoveFirst>:

    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
 802daec:	b570      	push	{r4, r5, r6, lr}
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802daee:	4a0a      	ldr	r2, [pc, #40]	; (802db18 <LoRaMacConfirmQueueRemoveFirst+0x2c>)
 802daf0:	2320      	movs	r3, #32
 802daf2:	5cd4      	ldrb	r4, [r2, r3]
 802daf4:	0020      	movs	r0, r4
 802daf6:	f7ff ff95 	bl	802da24 <IsListEmpty>
 802dafa:	2800      	cmp	r0, #0
 802dafc:	d109      	bne.n	802db12 <LoRaMacConfirmQueueRemoveFirst+0x26>
    {
        return false;
    }

    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 802dafe:	4d06      	ldr	r5, [pc, #24]	; (802db18 <LoRaMacConfirmQueueRemoveFirst+0x2c>)
 802db00:	3c01      	subs	r4, #1
 802db02:	2320      	movs	r3, #32
 802db04:	54ec      	strb	r4, [r5, r3]
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 802db06:	6868      	ldr	r0, [r5, #4]
 802db08:	f7ff ff80 	bl	802da0c <IncreaseBufferPointer>
 802db0c:	6068      	str	r0, [r5, #4]

    return true;
 802db0e:	2001      	movs	r0, #1
}
 802db10:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 802db12:	2000      	movs	r0, #0
 802db14:	e7fc      	b.n	802db10 <LoRaMacConfirmQueueRemoveFirst+0x24>
 802db16:	46c0      	nop			; (mov r8, r8)
 802db18:	2000b18c 	.word	0x2000b18c

0802db1c <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 802db1c:	b570      	push	{r4, r5, r6, lr}
 802db1e:	0005      	movs	r5, r0
 802db20:	000c      	movs	r4, r1
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 802db22:	4a09      	ldr	r2, [pc, #36]	; (802db48 <LoRaMacConfirmQueueSetStatus+0x2c>)
 802db24:	2320      	movs	r3, #32
 802db26:	5cd0      	ldrb	r0, [r2, r3]
 802db28:	f7ff ff7c 	bl	802da24 <IsListEmpty>
 802db2c:	2800      	cmp	r0, #0
 802db2e:	d10a      	bne.n	802db46 <LoRaMacConfirmQueueSetStatus+0x2a>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 802db30:	4b05      	ldr	r3, [pc, #20]	; (802db48 <LoRaMacConfirmQueueSetStatus+0x2c>)
 802db32:	689a      	ldr	r2, [r3, #8]
 802db34:	6859      	ldr	r1, [r3, #4]
 802db36:	0020      	movs	r0, r4
 802db38:	f7ff ff80 	bl	802da3c <GetElement>
        if( element != NULL )
 802db3c:	2800      	cmp	r0, #0
 802db3e:	d002      	beq.n	802db46 <LoRaMacConfirmQueueSetStatus+0x2a>
        {
            element->Status = status;
 802db40:	7045      	strb	r5, [r0, #1]
            element->ReadyToHandle = true;
 802db42:	2301      	movs	r3, #1
 802db44:	7083      	strb	r3, [r0, #2]
        }
    }
}
 802db46:	bd70      	pop	{r4, r5, r6, pc}
 802db48:	2000b18c 	.word	0x2000b18c

0802db4c <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 802db4c:	b510      	push	{r4, lr}
 802db4e:	0004      	movs	r4, r0
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 802db50:	4a0a      	ldr	r2, [pc, #40]	; (802db7c <LoRaMacConfirmQueueGetStatus+0x30>)
 802db52:	2320      	movs	r3, #32
 802db54:	5cd0      	ldrb	r0, [r2, r3]
 802db56:	f7ff ff65 	bl	802da24 <IsListEmpty>
 802db5a:	2800      	cmp	r0, #0
 802db5c:	d109      	bne.n	802db72 <LoRaMacConfirmQueueGetStatus+0x26>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 802db5e:	4b07      	ldr	r3, [pc, #28]	; (802db7c <LoRaMacConfirmQueueGetStatus+0x30>)
 802db60:	689a      	ldr	r2, [r3, #8]
 802db62:	6859      	ldr	r1, [r3, #4]
 802db64:	0020      	movs	r0, r4
 802db66:	f7ff ff69 	bl	802da3c <GetElement>
        if( element != NULL )
 802db6a:	2800      	cmp	r0, #0
 802db6c:	d003      	beq.n	802db76 <LoRaMacConfirmQueueGetStatus+0x2a>
        {
            return element->Status;
 802db6e:	7840      	ldrb	r0, [r0, #1]
 802db70:	e000      	b.n	802db74 <LoRaMacConfirmQueueGetStatus+0x28>
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 802db72:	2001      	movs	r0, #1
}
 802db74:	bd10      	pop	{r4, pc}
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 802db76:	2001      	movs	r0, #1
 802db78:	e7fc      	b.n	802db74 <LoRaMacConfirmQueueGetStatus+0x28>
 802db7a:	46c0      	nop			; (mov r8, r8)
 802db7c:	2000b18c 	.word	0x2000b18c

0802db80 <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 802db80:	b570      	push	{r4, r5, r6, lr}
 802db82:	0005      	movs	r5, r0
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 802db84:	4b0c      	ldr	r3, [pc, #48]	; (802dbb8 <LoRaMacConfirmQueueSetStatusCmn+0x38>)
 802db86:	685c      	ldr	r4, [r3, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 802db88:	2221      	movs	r2, #33	; 0x21
 802db8a:	5498      	strb	r0, [r3, r2]

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 802db8c:	3a01      	subs	r2, #1
 802db8e:	5c98      	ldrb	r0, [r3, r2]
 802db90:	f7ff ff48 	bl	802da24 <IsListEmpty>
 802db94:	2800      	cmp	r0, #0
 802db96:	d00a      	beq.n	802dbae <LoRaMacConfirmQueueSetStatusCmn+0x2e>
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
    }
}
 802db98:	bd70      	pop	{r4, r5, r6, pc}
                element->ReadyToHandle = true;
 802db9a:	3301      	adds	r3, #1
 802db9c:	70a3      	strb	r3, [r4, #2]
            element = IncreaseBufferPointer( element );
 802db9e:	0020      	movs	r0, r4
 802dba0:	f7ff ff34 	bl	802da0c <IncreaseBufferPointer>
 802dba4:	0004      	movs	r4, r0
        }while( element != ConfirmQueueCtx.BufferEnd );
 802dba6:	4b04      	ldr	r3, [pc, #16]	; (802dbb8 <LoRaMacConfirmQueueSetStatusCmn+0x38>)
 802dba8:	689b      	ldr	r3, [r3, #8]
 802dbaa:	4283      	cmp	r3, r0
 802dbac:	d0f4      	beq.n	802db98 <LoRaMacConfirmQueueSetStatusCmn+0x18>
            element->Status = status;
 802dbae:	7065      	strb	r5, [r4, #1]
            if( element->RestrictCommonReadyToHandle == false )
 802dbb0:	78e3      	ldrb	r3, [r4, #3]
 802dbb2:	2b00      	cmp	r3, #0
 802dbb4:	d1f3      	bne.n	802db9e <LoRaMacConfirmQueueSetStatusCmn+0x1e>
 802dbb6:	e7f0      	b.n	802db9a <LoRaMacConfirmQueueSetStatusCmn+0x1a>
 802dbb8:	2000b18c 	.word	0x2000b18c

0802dbbc <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 802dbbc:	b510      	push	{r4, lr}
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 802dbbe:	4b04      	ldr	r3, [pc, #16]	; (802dbd0 <LoRaMacConfirmQueueIsCmdActive+0x14>)
 802dbc0:	689a      	ldr	r2, [r3, #8]
 802dbc2:	6859      	ldr	r1, [r3, #4]
 802dbc4:	f7ff ff3a 	bl	802da3c <GetElement>
 802dbc8:	2800      	cmp	r0, #0
 802dbca:	d000      	beq.n	802dbce <LoRaMacConfirmQueueIsCmdActive+0x12>
    {
        return true;
 802dbcc:	2001      	movs	r0, #1
    }
    return false;
}
 802dbce:	bd10      	pop	{r4, pc}
 802dbd0:	2000b18c 	.word	0x2000b18c

0802dbd4 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 802dbd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 802dbd6:	b083      	sub	sp, #12
 802dbd8:	0006      	movs	r6, r0
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 802dbda:	4a15      	ldr	r2, [pc, #84]	; (802dc30 <LoRaMacConfirmQueueHandleCb+0x5c>)
 802dbdc:	2320      	movs	r3, #32
 802dbde:	5cd7      	ldrb	r7, [r2, r3]
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    for( uint8_t i = 0; i < nbElements; i++ )
 802dbe0:	2400      	movs	r4, #0
 802dbe2:	e00c      	b.n	802dbfe <LoRaMacConfirmQueueHandleCb+0x2a>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
        }
        else
        {
            // The request is not processed yet. Store the state.
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 802dbe4:	7819      	ldrb	r1, [r3, #0]
 802dbe6:	aa01      	add	r2, sp, #4
 802dbe8:	7011      	strb	r1, [r2, #0]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 802dbea:	7859      	ldrb	r1, [r3, #1]
 802dbec:	7051      	strb	r1, [r2, #1]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 802dbee:	78db      	ldrb	r3, [r3, #3]
 802dbf0:	70d3      	strb	r3, [r2, #3]
        }

        // Increase the pointer afterwards to prevent overwrites
        LoRaMacConfirmQueueRemoveFirst( );
 802dbf2:	f7ff ff7b 	bl	802daec <LoRaMacConfirmQueueRemoveFirst>

        if( readyToHandle == false )
 802dbf6:	2d00      	cmp	r5, #0
 802dbf8:	d014      	beq.n	802dc24 <LoRaMacConfirmQueueHandleCb+0x50>
    for( uint8_t i = 0; i < nbElements; i++ )
 802dbfa:	3401      	adds	r4, #1
 802dbfc:	b2e4      	uxtb	r4, r4
 802dbfe:	42bc      	cmp	r4, r7
 802dc00:	d214      	bcs.n	802dc2c <LoRaMacConfirmQueueHandleCb+0x58>
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 802dc02:	4b0b      	ldr	r3, [pc, #44]	; (802dc30 <LoRaMacConfirmQueueHandleCb+0x5c>)
 802dc04:	685a      	ldr	r2, [r3, #4]
 802dc06:	7812      	ldrb	r2, [r2, #0]
 802dc08:	7032      	strb	r2, [r6, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 802dc0a:	685a      	ldr	r2, [r3, #4]
 802dc0c:	7852      	ldrb	r2, [r2, #1]
 802dc0e:	7072      	strb	r2, [r6, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 802dc10:	685b      	ldr	r3, [r3, #4]
 802dc12:	789d      	ldrb	r5, [r3, #2]
        if( readyToHandle == true )
 802dc14:	2d00      	cmp	r5, #0
 802dc16:	d0e5      	beq.n	802dbe4 <LoRaMacConfirmQueueHandleCb+0x10>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 802dc18:	4b05      	ldr	r3, [pc, #20]	; (802dc30 <LoRaMacConfirmQueueHandleCb+0x5c>)
 802dc1a:	681b      	ldr	r3, [r3, #0]
 802dc1c:	689b      	ldr	r3, [r3, #8]
 802dc1e:	0030      	movs	r0, r6
 802dc20:	4798      	blx	r3
 802dc22:	e7e6      	b.n	802dbf2 <LoRaMacConfirmQueueHandleCb+0x1e>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 802dc24:	a801      	add	r0, sp, #4
 802dc26:	f7ff ff3d 	bl	802daa4 <LoRaMacConfirmQueueAdd>
 802dc2a:	e7e6      	b.n	802dbfa <LoRaMacConfirmQueueHandleCb+0x26>
        }
    }
}
 802dc2c:	b003      	add	sp, #12
 802dc2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802dc30:	2000b18c 	.word	0x2000b18c

0802dc34 <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 802dc34:	4a01      	ldr	r2, [pc, #4]	; (802dc3c <LoRaMacConfirmQueueGetCnt+0x8>)
 802dc36:	2320      	movs	r3, #32
 802dc38:	5cd0      	ldrb	r0, [r2, r3]
}
 802dc3a:	4770      	bx	lr
 802dc3c:	2000b18c 	.word	0x2000b18c

0802dc40 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
 802dc40:	b510      	push	{r4, lr}
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802dc42:	4a03      	ldr	r2, [pc, #12]	; (802dc50 <LoRaMacConfirmQueueIsFull+0x10>)
 802dc44:	2320      	movs	r3, #32
 802dc46:	5cd0      	ldrb	r0, [r2, r3]
 802dc48:	f7ff fef2 	bl	802da30 <IsListFull>
    }
    else
    {
        return false;
    }
}
 802dc4c:	bd10      	pop	{r4, pc}
 802dc4e:	46c0      	nop			; (mov r8, r8)
 802dc50:	2000b18c 	.word	0x2000b18c

0802dc54 <PrepareB0>:
 * \param[IN]  fCnt           - Frame counter
 * \param[IN/OUT]  b0         - B0 block
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t PrepareB0( uint16_t msgLen, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint8_t* b0 )
{
 802dc54:	b530      	push	{r4, r5, lr}
 802dc56:	9c03      	ldr	r4, [sp, #12]
 802dc58:	9904      	ldr	r1, [sp, #16]
 802dc5a:	9a05      	ldr	r2, [sp, #20]
    if( b0 == 0 )
 802dc5c:	2a00      	cmp	r2, #0
 802dc5e:	d019      	beq.n	802dc94 <PrepareB0+0x40>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    b0[0] = 0x49;
 802dc60:	2549      	movs	r5, #73	; 0x49
 802dc62:	7015      	strb	r5, [r2, #0]
    }
    else
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */
    /* ST_WORAROUND_END */
    {
        b0[1] = 0x00;
 802dc64:	2500      	movs	r5, #0
 802dc66:	7055      	strb	r5, [r2, #1]
        b0[2] = 0x00;
 802dc68:	7095      	strb	r5, [r2, #2]
    }

    b0[3] = 0x00;
 802dc6a:	70d5      	strb	r5, [r2, #3]
    b0[4] = 0x00;
 802dc6c:	7115      	strb	r5, [r2, #4]

    b0[5] = dir;
 802dc6e:	7153      	strb	r3, [r2, #5]

    b0[6] = devAddr & 0xFF;
 802dc70:	7194      	strb	r4, [r2, #6]
    b0[7] = ( devAddr >> 8 ) & 0xFF;
 802dc72:	0a23      	lsrs	r3, r4, #8
 802dc74:	71d3      	strb	r3, [r2, #7]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 802dc76:	0c23      	lsrs	r3, r4, #16
 802dc78:	7213      	strb	r3, [r2, #8]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 802dc7a:	0e24      	lsrs	r4, r4, #24
 802dc7c:	7254      	strb	r4, [r2, #9]

    b0[10] = fCnt & 0xFF;
 802dc7e:	7291      	strb	r1, [r2, #10]
    b0[11] = ( fCnt >> 8 ) & 0xFF;
 802dc80:	0a0b      	lsrs	r3, r1, #8
 802dc82:	72d3      	strb	r3, [r2, #11]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 802dc84:	0c0b      	lsrs	r3, r1, #16
 802dc86:	7313      	strb	r3, [r2, #12]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 802dc88:	0e09      	lsrs	r1, r1, #24
 802dc8a:	7351      	strb	r1, [r2, #13]

    b0[14] = 0x00;
 802dc8c:	7395      	strb	r5, [r2, #14]

    b0[15] = msgLen & 0xFF;
 802dc8e:	73d0      	strb	r0, [r2, #15]

    return LORAMAC_CRYPTO_SUCCESS;
 802dc90:	2000      	movs	r0, #0
}
 802dc92:	bd30      	pop	{r4, r5, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802dc94:	200a      	movs	r0, #10
 802dc96:	e7fc      	b.n	802dc92 <PrepareB0+0x3e>

0802dc98 <GetKeyAddrItem>:
 * \param[IN]  addrID          - Address identifier
 * \param[OUT] keyItem        - Key item reference
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t GetKeyAddrItem( AddressIdentifier_t addrID, KeyAddr_t** item )
{
 802dc98:	b530      	push	{r4, r5, lr}
    for( uint8_t i = 0; i < NUM_OF_SEC_CTX; i++ )
 802dc9a:	2300      	movs	r3, #0
 802dc9c:	2b01      	cmp	r3, #1
 802dc9e:	d80c      	bhi.n	802dcba <GetKeyAddrItem+0x22>
    {
        if( KeyAddrList[i].AddrID == addrID )
 802dca0:	009a      	lsls	r2, r3, #2
 802dca2:	4c07      	ldr	r4, [pc, #28]	; (802dcc0 <GetKeyAddrItem+0x28>)
 802dca4:	5d12      	ldrb	r2, [r2, r4]
 802dca6:	4282      	cmp	r2, r0
 802dca8:	d002      	beq.n	802dcb0 <GetKeyAddrItem+0x18>
    for( uint8_t i = 0; i < NUM_OF_SEC_CTX; i++ )
 802dcaa:	3301      	adds	r3, #1
 802dcac:	b2db      	uxtb	r3, r3
 802dcae:	e7f5      	b.n	802dc9c <GetKeyAddrItem+0x4>
        {
            *item = &( KeyAddrList[i] );
 802dcb0:	009d      	lsls	r5, r3, #2
 802dcb2:	1965      	adds	r5, r4, r5
 802dcb4:	600d      	str	r5, [r1, #0]
            return LORAMAC_CRYPTO_SUCCESS;
 802dcb6:	2000      	movs	r0, #0
 802dcb8:	e000      	b.n	802dcbc <GetKeyAddrItem+0x24>
        }
    }
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 802dcba:	200c      	movs	r0, #12
}
 802dcbc:	bd30      	pop	{r4, r5, pc}
 802dcbe:	46c0      	nop			; (mov r8, r8)
 802dcc0:	2000a0ac 	.word	0x2000a0ac

0802dcc4 <GetLastFcntDown>:
 *
 * \retval                     - Status of the operation
 */
static LoRaMacCryptoStatus_t GetLastFcntDown( FCntIdentifier_t fCntID, uint32_t* lastDown )
{
    if( lastDown == NULL )
 802dcc4:	2900      	cmp	r1, #0
 802dcc6:	d02a      	beq.n	802dd1e <GetLastFcntDown+0x5a>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    switch( fCntID )
 802dcc8:	2803      	cmp	r0, #3
 802dcca:	d020      	beq.n	802dd0e <GetLastFcntDown+0x4a>
 802dccc:	d80d      	bhi.n	802dcea <GetLastFcntDown+0x26>
 802dcce:	2801      	cmp	r0, #1
 802dcd0:	d015      	beq.n	802dcfe <GetLastFcntDown+0x3a>
 802dcd2:	2802      	cmp	r0, #2
 802dcd4:	d107      	bne.n	802dce6 <GetLastFcntDown+0x22>
        case N_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.NFCntDown;
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
            break;
        case A_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 802dcd6:	4b13      	ldr	r3, [pc, #76]	; (802dd24 <GetLastFcntDown+0x60>)
 802dcd8:	681b      	ldr	r3, [r3, #0]
 802dcda:	695a      	ldr	r2, [r3, #20]
 802dcdc:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 802dcde:	695a      	ldr	r2, [r3, #20]
 802dce0:	621a      	str	r2, [r3, #32]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
    }
    return LORAMAC_CRYPTO_SUCCESS;
 802dce2:	2000      	movs	r0, #0
            break;
 802dce4:	e00a      	b.n	802dcfc <GetLastFcntDown+0x38>
    switch( fCntID )
 802dce6:	2005      	movs	r0, #5
 802dce8:	e008      	b.n	802dcfc <GetLastFcntDown+0x38>
 802dcea:	2804      	cmp	r0, #4
 802dcec:	d105      	bne.n	802dcfa <GetLastFcntDown+0x36>
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 802dcee:	4b0d      	ldr	r3, [pc, #52]	; (802dd24 <GetLastFcntDown+0x60>)
 802dcf0:	681b      	ldr	r3, [r3, #0]
 802dcf2:	69db      	ldr	r3, [r3, #28]
 802dcf4:	600b      	str	r3, [r1, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 802dcf6:	2000      	movs	r0, #0
            break;
 802dcf8:	e000      	b.n	802dcfc <GetLastFcntDown+0x38>
    switch( fCntID )
 802dcfa:	2005      	movs	r0, #5
}
 802dcfc:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 802dcfe:	4b09      	ldr	r3, [pc, #36]	; (802dd24 <GetLastFcntDown+0x60>)
 802dd00:	681b      	ldr	r3, [r3, #0]
 802dd02:	691a      	ldr	r2, [r3, #16]
 802dd04:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 802dd06:	691a      	ldr	r2, [r3, #16]
 802dd08:	621a      	str	r2, [r3, #32]
    return LORAMAC_CRYPTO_SUCCESS;
 802dd0a:	2000      	movs	r0, #0
            break;
 802dd0c:	e7f6      	b.n	802dcfc <GetLastFcntDown+0x38>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 802dd0e:	4b05      	ldr	r3, [pc, #20]	; (802dd24 <GetLastFcntDown+0x60>)
 802dd10:	681b      	ldr	r3, [r3, #0]
 802dd12:	699a      	ldr	r2, [r3, #24]
 802dd14:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 802dd16:	699a      	ldr	r2, [r3, #24]
 802dd18:	621a      	str	r2, [r3, #32]
    return LORAMAC_CRYPTO_SUCCESS;
 802dd1a:	2000      	movs	r0, #0
            break;
 802dd1c:	e7ee      	b.n	802dcfc <GetLastFcntDown+0x38>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802dd1e:	200a      	movs	r0, #10
 802dd20:	e7ec      	b.n	802dcfc <GetLastFcntDown+0x38>
 802dd22:	46c0      	nop			; (mov r8, r8)
 802dd24:	2000b1b0 	.word	0x2000b1b0

0802dd28 <CheckFCntDown>:
 * \param[IN]     currentDown  - Current downlink counter value
 *
 * \retval                     - Status of the operation
 */
static bool CheckFCntDown( FCntIdentifier_t fCntID, uint32_t currentDown )
{
 802dd28:	b510      	push	{r4, lr}
 802dd2a:	b082      	sub	sp, #8
 802dd2c:	000c      	movs	r4, r1
    uint32_t lastDown = 0;
 802dd2e:	2300      	movs	r3, #0
 802dd30:	9301      	str	r3, [sp, #4]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 802dd32:	a901      	add	r1, sp, #4
 802dd34:	f7ff ffc6 	bl	802dcc4 <GetLastFcntDown>
 802dd38:	2800      	cmp	r0, #0
 802dd3a:	d108      	bne.n	802dd4e <CheckFCntDown+0x26>
    {
        return false;
    }
    if( ( currentDown > lastDown ) ||
 802dd3c:	9b01      	ldr	r3, [sp, #4]
 802dd3e:	42a3      	cmp	r3, r4
 802dd40:	d308      	bcc.n	802dd54 <CheckFCntDown+0x2c>
 802dd42:	3301      	adds	r3, #1
 802dd44:	d001      	beq.n	802dd4a <CheckFCntDown+0x22>
    {
        return true;
    }
    else
    {
        return false;
 802dd46:	2000      	movs	r0, #0
 802dd48:	e002      	b.n	802dd50 <CheckFCntDown+0x28>
        return true;
 802dd4a:	3001      	adds	r0, #1
 802dd4c:	e000      	b.n	802dd50 <CheckFCntDown+0x28>
        return false;
 802dd4e:	2000      	movs	r0, #0
    }
}
 802dd50:	b002      	add	sp, #8
 802dd52:	bd10      	pop	{r4, pc}
        return true;
 802dd54:	2001      	movs	r0, #1
 802dd56:	e7fb      	b.n	802dd50 <CheckFCntDown+0x28>

0802dd58 <UpdateFCntDown>:
 *
 * \retval                     - Status of the operation
 */
static void UpdateFCntDown( FCntIdentifier_t fCntID, uint32_t currentDown )
{
    switch( fCntID )
 802dd58:	2803      	cmp	r0, #3
 802dd5a:	d012      	beq.n	802dd82 <UpdateFCntDown+0x2a>
 802dd5c:	d807      	bhi.n	802dd6e <UpdateFCntDown+0x16>
 802dd5e:	2801      	cmp	r0, #1
 802dd60:	d00b      	beq.n	802dd7a <UpdateFCntDown+0x22>
 802dd62:	2802      	cmp	r0, #2
 802dd64:	d10c      	bne.n	802dd80 <UpdateFCntDown+0x28>
    {
        case N_FCNT_DOWN:
            CryptoNvm->FCntList.NFCntDown = currentDown;
            break;
        case A_FCNT_DOWN:
            CryptoNvm->FCntList.AFCntDown = currentDown;
 802dd66:	4b09      	ldr	r3, [pc, #36]	; (802dd8c <UpdateFCntDown+0x34>)
 802dd68:	681b      	ldr	r3, [r3, #0]
 802dd6a:	6159      	str	r1, [r3, #20]
            break;
 802dd6c:	e008      	b.n	802dd80 <UpdateFCntDown+0x28>
    switch( fCntID )
 802dd6e:	2804      	cmp	r0, #4
 802dd70:	d106      	bne.n	802dd80 <UpdateFCntDown+0x28>
        case FCNT_DOWN:
            CryptoNvm->FCntList.FCntDown = currentDown;
            break;
#if ( LORAMAC_MAX_MC_CTX > 0 )
        case MC_FCNT_DOWN_0:
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 802dd72:	4b06      	ldr	r3, [pc, #24]	; (802dd8c <UpdateFCntDown+0x34>)
 802dd74:	681b      	ldr	r3, [r3, #0]
 802dd76:	61d9      	str	r1, [r3, #28]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            break;
    }
}
 802dd78:	e002      	b.n	802dd80 <UpdateFCntDown+0x28>
            CryptoNvm->FCntList.NFCntDown = currentDown;
 802dd7a:	4b04      	ldr	r3, [pc, #16]	; (802dd8c <UpdateFCntDown+0x34>)
 802dd7c:	681b      	ldr	r3, [r3, #0]
 802dd7e:	6119      	str	r1, [r3, #16]
}
 802dd80:	4770      	bx	lr
            CryptoNvm->FCntList.FCntDown = currentDown;
 802dd82:	4b02      	ldr	r3, [pc, #8]	; (802dd8c <UpdateFCntDown+0x34>)
 802dd84:	681b      	ldr	r3, [r3, #0]
 802dd86:	6199      	str	r1, [r3, #24]
            break;
 802dd88:	e7fa      	b.n	802dd80 <UpdateFCntDown+0x28>
 802dd8a:	46c0      	nop			; (mov r8, r8)
 802dd8c:	2000b1b0 	.word	0x2000b1b0

0802dd90 <ResetFCnts>:
/*!
 * Resets the frame counters
 */
static void ResetFCnts( void )
{
    CryptoNvm->FCntList.FCntUp = 0;
 802dd90:	4b0a      	ldr	r3, [pc, #40]	; (802ddbc <ResetFCnts+0x2c>)
 802dd92:	681b      	ldr	r3, [r3, #0]
 802dd94:	2200      	movs	r2, #0
 802dd96:	60da      	str	r2, [r3, #12]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 802dd98:	3a01      	subs	r2, #1
 802dd9a:	611a      	str	r2, [r3, #16]
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 802dd9c:	615a      	str	r2, [r3, #20]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 802dd9e:	619a      	str	r2, [r3, #24]
    CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 802dda0:	621a      	str	r2, [r3, #32]

    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802dda2:	2200      	movs	r2, #0
 802dda4:	2a00      	cmp	r2, #0
 802dda6:	dd00      	ble.n	802ddaa <ResetFCnts+0x1a>
    {
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITAL_VALUE;
    }
}
 802dda8:	4770      	bx	lr
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITAL_VALUE;
 802ddaa:	1d91      	adds	r1, r2, #6
 802ddac:	0089      	lsls	r1, r1, #2
 802ddae:	1859      	adds	r1, r3, r1
 802ddb0:	2001      	movs	r0, #1
 802ddb2:	4240      	negs	r0, r0
 802ddb4:	6048      	str	r0, [r1, #4]
    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802ddb6:	3201      	adds	r2, #1
 802ddb8:	e7f4      	b.n	802dda4 <ResetFCnts+0x14>
 802ddba:	46c0      	nop			; (mov r8, r8)
 802ddbc:	2000b1b0 	.word	0x2000b1b0

0802ddc0 <ComputeCmacB0>:
{
 802ddc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ddc2:	b089      	sub	sp, #36	; 0x24
 802ddc4:	0006      	movs	r6, r0
 802ddc6:	000c      	movs	r4, r1
 802ddc8:	0015      	movs	r5, r2
 802ddca:	001a      	movs	r2, r3
 802ddcc:	a90e      	add	r1, sp, #56	; 0x38
 802ddce:	780b      	ldrb	r3, [r1, #0]
    if( ( msg == 0 ) || ( cmac == 0 ) )
 802ddd0:	2800      	cmp	r0, #0
 802ddd2:	d01c      	beq.n	802de0e <ComputeCmacB0+0x4e>
 802ddd4:	9911      	ldr	r1, [sp, #68]	; 0x44
 802ddd6:	2900      	cmp	r1, #0
 802ddd8:	d01b      	beq.n	802de12 <ComputeCmacB0+0x52>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 802ddda:	2180      	movs	r1, #128	; 0x80
 802dddc:	0049      	lsls	r1, r1, #1
 802ddde:	428c      	cmp	r4, r1
 802dde0:	d819      	bhi.n	802de16 <ComputeCmacB0+0x56>
    PrepareB0( len, keyID, isAck, dir, devAddr, fCnt, micBuff );
 802dde2:	af04      	add	r7, sp, #16
 802dde4:	9702      	str	r7, [sp, #8]
 802dde6:	9910      	ldr	r1, [sp, #64]	; 0x40
 802dde8:	9101      	str	r1, [sp, #4]
 802ddea:	990f      	ldr	r1, [sp, #60]	; 0x3c
 802ddec:	9100      	str	r1, [sp, #0]
 802ddee:	0029      	movs	r1, r5
 802ddf0:	0020      	movs	r0, r4
 802ddf2:	f7ff ff2f 	bl	802dc54 <PrepareB0>
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 802ddf6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802ddf8:	9300      	str	r3, [sp, #0]
 802ddfa:	002b      	movs	r3, r5
 802ddfc:	0022      	movs	r2, r4
 802ddfe:	0031      	movs	r1, r6
 802de00:	0038      	movs	r0, r7
 802de02:	f003 fa25 	bl	8031250 <SecureElementComputeAesCmac>
 802de06:	2800      	cmp	r0, #0
 802de08:	d107      	bne.n	802de1a <ComputeCmacB0+0x5a>
}
 802de0a:	b009      	add	sp, #36	; 0x24
 802de0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802de0e:	200a      	movs	r0, #10
 802de10:	e7fb      	b.n	802de0a <ComputeCmacB0+0x4a>
 802de12:	200a      	movs	r0, #10
 802de14:	e7f9      	b.n	802de0a <ComputeCmacB0+0x4a>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 802de16:	200e      	movs	r0, #14
 802de18:	e7f7      	b.n	802de0a <ComputeCmacB0+0x4a>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802de1a:	200f      	movs	r0, #15
 802de1c:	e7f5      	b.n	802de0a <ComputeCmacB0+0x4a>

0802de1e <DeriveSessionKey10x>:
{
 802de1e:	b5f0      	push	{r4, r5, r6, r7, lr}
 802de20:	b085      	sub	sp, #20
 802de22:	0006      	movs	r6, r0
 802de24:	000d      	movs	r5, r1
 802de26:	0014      	movs	r4, r2
 802de28:	001f      	movs	r7, r3
    uint8_t compBase[16] = { 0 };
 802de2a:	220c      	movs	r2, #12
 802de2c:	2100      	movs	r1, #0
 802de2e:	a801      	add	r0, sp, #4
 802de30:	f006 fc79 	bl	8034726 <memset>
    switch( keyID )
 802de34:	2e02      	cmp	r6, #2
 802de36:	d003      	beq.n	802de40 <DeriveSessionKey10x+0x22>
 802de38:	2e03      	cmp	r6, #3
 802de3a:	d01c      	beq.n	802de76 <DeriveSessionKey10x+0x58>
 802de3c:	200b      	movs	r0, #11
 802de3e:	e018      	b.n	802de72 <DeriveSessionKey10x+0x54>
            compBase[0] = 0x01;
 802de40:	2301      	movs	r3, #1
 802de42:	466a      	mov	r2, sp
 802de44:	7013      	strb	r3, [r2, #0]
    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 802de46:	466b      	mov	r3, sp
 802de48:	705d      	strb	r5, [r3, #1]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 802de4a:	0a2b      	lsrs	r3, r5, #8
 802de4c:	466a      	mov	r2, sp
 802de4e:	7093      	strb	r3, [r2, #2]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 802de50:	0c2d      	lsrs	r5, r5, #16
 802de52:	70d5      	strb	r5, [r2, #3]
    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 802de54:	7114      	strb	r4, [r2, #4]
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
 802de56:	0a23      	lsrs	r3, r4, #8
 802de58:	7153      	strb	r3, [r2, #5]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 802de5a:	0c24      	lsrs	r4, r4, #16
 802de5c:	7194      	strb	r4, [r2, #6]
    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 802de5e:	71d7      	strb	r7, [r2, #7]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 802de60:	0a3f      	lsrs	r7, r7, #8
 802de62:	7217      	strb	r7, [r2, #8]
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 802de64:	0032      	movs	r2, r6
 802de66:	2101      	movs	r1, #1
 802de68:	4668      	mov	r0, sp
 802de6a:	f003 fb8b 	bl	8031584 <SecureElementDeriveAndStoreKey>
 802de6e:	2800      	cmp	r0, #0
 802de70:	d105      	bne.n	802de7e <DeriveSessionKey10x+0x60>
}
 802de72:	b005      	add	sp, #20
 802de74:	bdf0      	pop	{r4, r5, r6, r7, pc}
            compBase[0] = 0x02;
 802de76:	2302      	movs	r3, #2
 802de78:	466a      	mov	r2, sp
 802de7a:	7013      	strb	r3, [r2, #0]
            break;
 802de7c:	e7e3      	b.n	802de46 <DeriveSessionKey10x+0x28>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802de7e:	200f      	movs	r0, #15
 802de80:	e7f7      	b.n	802de72 <DeriveSessionKey10x+0x54>

0802de82 <PayloadEncrypt>:
{
 802de82:	b5f0      	push	{r4, r5, r6, r7, lr}
 802de84:	46d6      	mov	lr, sl
 802de86:	464f      	mov	r7, r9
 802de88:	4646      	mov	r6, r8
 802de8a:	b5c0      	push	{r6, r7, lr}
 802de8c:	b088      	sub	sp, #32
 802de8e:	0005      	movs	r5, r0
 802de90:	000c      	movs	r4, r1
 802de92:	4690      	mov	r8, r2
 802de94:	001f      	movs	r7, r3
 802de96:	ab10      	add	r3, sp, #64	; 0x40
 802de98:	781b      	ldrb	r3, [r3, #0]
 802de9a:	469a      	mov	sl, r3
 802de9c:	9e11      	ldr	r6, [sp, #68]	; 0x44
    if( buffer == 0 )
 802de9e:	2800      	cmp	r0, #0
 802dea0:	d055      	beq.n	802df4e <PayloadEncrypt+0xcc>
    uint8_t sBlock[16] = { 0 };
 802dea2:	2300      	movs	r3, #0
 802dea4:	4699      	mov	r9, r3
 802dea6:	9304      	str	r3, [sp, #16]
 802dea8:	220c      	movs	r2, #12
 802deaa:	2100      	movs	r1, #0
 802deac:	a805      	add	r0, sp, #20
 802deae:	f006 fc3a 	bl	8034726 <memset>
    uint8_t aBlock[16] = { 0 };
 802deb2:	464b      	mov	r3, r9
 802deb4:	9300      	str	r3, [sp, #0]
 802deb6:	220c      	movs	r2, #12
 802deb8:	2100      	movs	r1, #0
 802deba:	a801      	add	r0, sp, #4
 802debc:	f006 fc33 	bl	8034726 <memset>
    aBlock[0] = 0x01;
 802dec0:	2301      	movs	r3, #1
 802dec2:	466a      	mov	r2, sp
 802dec4:	7013      	strb	r3, [r2, #0]
    aBlock[5] = dir;
 802dec6:	466b      	mov	r3, sp
 802dec8:	4652      	mov	r2, sl
 802deca:	715a      	strb	r2, [r3, #5]
    aBlock[6] = address & 0xFF;
 802decc:	719f      	strb	r7, [r3, #6]
    aBlock[7] = ( address >> 8 ) & 0xFF;
 802dece:	0a3b      	lsrs	r3, r7, #8
 802ded0:	466a      	mov	r2, sp
 802ded2:	71d3      	strb	r3, [r2, #7]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 802ded4:	0c3b      	lsrs	r3, r7, #16
 802ded6:	7213      	strb	r3, [r2, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 802ded8:	0e3f      	lsrs	r7, r7, #24
 802deda:	7257      	strb	r7, [r2, #9]
    aBlock[10] = frameCounter & 0xFF;
 802dedc:	7296      	strb	r6, [r2, #10]
    aBlock[11] = ( frameCounter >> 8 ) & 0xFF;
 802dede:	0a33      	lsrs	r3, r6, #8
 802dee0:	72d3      	strb	r3, [r2, #11]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 802dee2:	0c33      	lsrs	r3, r6, #16
 802dee4:	7313      	strb	r3, [r2, #12]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 802dee6:	0e36      	lsrs	r6, r6, #24
 802dee8:	7356      	strb	r6, [r2, #13]
    uint16_t ctr = 1;
 802deea:	2301      	movs	r3, #1
 802deec:	4699      	mov	r9, r3
    uint8_t bufferIndex = 0;
 802deee:	2600      	movs	r6, #0
    while( size > 0 )
 802def0:	e014      	b.n	802df1c <PayloadEncrypt+0x9a>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 802def2:	b21b      	sxth	r3, r3
 802def4:	429a      	cmp	r2, r3
 802def6:	da0d      	bge.n	802df14 <PayloadEncrypt+0x92>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 802def8:	18b1      	adds	r1, r6, r2
 802defa:	5c6b      	ldrb	r3, [r5, r1]
 802defc:	af04      	add	r7, sp, #16
 802defe:	5cba      	ldrb	r2, [r7, r2]
 802df00:	4053      	eors	r3, r2
 802df02:	546b      	strb	r3, [r5, r1]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 802df04:	3001      	adds	r0, #1
 802df06:	b2c0      	uxtb	r0, r0
 802df08:	0002      	movs	r2, r0
 802df0a:	1c23      	adds	r3, r4, #0
 802df0c:	2c10      	cmp	r4, #16
 802df0e:	ddf0      	ble.n	802def2 <PayloadEncrypt+0x70>
 802df10:	2310      	movs	r3, #16
 802df12:	e7ee      	b.n	802def2 <PayloadEncrypt+0x70>
        size -= 16;
 802df14:	3c10      	subs	r4, #16
 802df16:	b224      	sxth	r4, r4
        bufferIndex += 16;
 802df18:	3610      	adds	r6, #16
 802df1a:	b2f6      	uxtb	r6, r6
    while( size > 0 )
 802df1c:	2c00      	cmp	r4, #0
 802df1e:	dd0f      	ble.n	802df40 <PayloadEncrypt+0xbe>
        aBlock[15] = ctr & 0xFF;
 802df20:	466b      	mov	r3, sp
 802df22:	464a      	mov	r2, r9
 802df24:	73da      	strb	r2, [r3, #15]
        ctr++;
 802df26:	1c57      	adds	r7, r2, #1
 802df28:	b2bb      	uxth	r3, r7
 802df2a:	4699      	mov	r9, r3
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 802df2c:	ab04      	add	r3, sp, #16
 802df2e:	4642      	mov	r2, r8
 802df30:	2110      	movs	r1, #16
 802df32:	4668      	mov	r0, sp
 802df34:	f003 f9de 	bl	80312f4 <SecureElementAesEncrypt>
 802df38:	2800      	cmp	r0, #0
 802df3a:	d0e5      	beq.n	802df08 <PayloadEncrypt+0x86>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802df3c:	200f      	movs	r0, #15
 802df3e:	e000      	b.n	802df42 <PayloadEncrypt+0xc0>
    return LORAMAC_CRYPTO_SUCCESS;
 802df40:	2000      	movs	r0, #0
}
 802df42:	b008      	add	sp, #32
 802df44:	bce0      	pop	{r5, r6, r7}
 802df46:	46ba      	mov	sl, r7
 802df48:	46b1      	mov	r9, r6
 802df4a:	46a8      	mov	r8, r5
 802df4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802df4e:	200a      	movs	r0, #10
 802df50:	e7f7      	b.n	802df42 <PayloadEncrypt+0xc0>

0802df52 <VerifyCmacB0>:
{
 802df52:	b5f0      	push	{r4, r5, r6, r7, lr}
 802df54:	46ce      	mov	lr, r9
 802df56:	b500      	push	{lr}
 802df58:	b0ca      	sub	sp, #296	; 0x128
 802df5a:	0005      	movs	r5, r0
 802df5c:	000c      	movs	r4, r1
 802df5e:	0016      	movs	r6, r2
 802df60:	9305      	str	r3, [sp, #20]
 802df62:	ab50      	add	r3, sp, #320	; 0x140
 802df64:	7819      	ldrb	r1, [r3, #0]
 802df66:	4689      	mov	r9, r1
    if( msg == 0 )
 802df68:	2800      	cmp	r0, #0
 802df6a:	d028      	beq.n	802dfbe <VerifyCmacB0+0x6c>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 802df6c:	2380      	movs	r3, #128	; 0x80
 802df6e:	005b      	lsls	r3, r3, #1
 802df70:	429c      	cmp	r4, r3
 802df72:	d826      	bhi.n	802dfc2 <VerifyCmacB0+0x70>
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 802df74:	2288      	movs	r2, #136	; 0x88
 802df76:	af06      	add	r7, sp, #24
 802df78:	0052      	lsls	r2, r2, #1
 802df7a:	2100      	movs	r1, #0
 802df7c:	0038      	movs	r0, r7
 802df7e:	f003 fc24 	bl	80317ca <memset1>
    PrepareB0( len, keyID, isAck, dir, devAddr, fCnt, micBuff );
 802df82:	9702      	str	r7, [sp, #8]
 802df84:	9952      	ldr	r1, [sp, #328]	; 0x148
 802df86:	9101      	str	r1, [sp, #4]
 802df88:	9951      	ldr	r1, [sp, #324]	; 0x144
 802df8a:	9100      	str	r1, [sp, #0]
 802df8c:	464b      	mov	r3, r9
 802df8e:	9a05      	ldr	r2, [sp, #20]
 802df90:	0031      	movs	r1, r6
 802df92:	0020      	movs	r0, r4
 802df94:	f7ff fe5e 	bl	802dc54 <PrepareB0>
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 802df98:	0022      	movs	r2, r4
 802df9a:	0029      	movs	r1, r5
 802df9c:	a80a      	add	r0, sp, #40	; 0x28
 802df9e:	f003 fbfc 	bl	803179a <memcpy1>
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 802dfa2:	0021      	movs	r1, r4
 802dfa4:	3110      	adds	r1, #16
 802dfa6:	b289      	uxth	r1, r1
 802dfa8:	0033      	movs	r3, r6
 802dfaa:	9a53      	ldr	r2, [sp, #332]	; 0x14c
 802dfac:	0038      	movs	r0, r7
 802dfae:	f003 f95b 	bl	8031268 <SecureElementVerifyAesCmac>
    if( retval == SECURE_ELEMENT_SUCCESS )
 802dfb2:	2800      	cmp	r0, #0
 802dfb4:	d006      	beq.n	802dfc4 <VerifyCmacB0+0x72>
    else if( retval == SECURE_ELEMENT_FAIL_CMAC )
 802dfb6:	2801      	cmp	r0, #1
 802dfb8:	d004      	beq.n	802dfc4 <VerifyCmacB0+0x72>
    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802dfba:	200f      	movs	r0, #15
 802dfbc:	e002      	b.n	802dfc4 <VerifyCmacB0+0x72>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802dfbe:	200a      	movs	r0, #10
 802dfc0:	e000      	b.n	802dfc4 <VerifyCmacB0+0x72>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 802dfc2:	200e      	movs	r0, #14
}
 802dfc4:	b04a      	add	sp, #296	; 0x128
 802dfc6:	bc80      	pop	{r7}
 802dfc8:	46b9      	mov	r9, r7
 802dfca:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802dfcc <LoRaMacCryptoInit>:

/*
 *  API functions
 */
LoRaMacCryptoStatus_t LoRaMacCryptoInit( LoRaMacCryptoNvmData_t* nvm )
{
 802dfcc:	b510      	push	{r4, lr}
    if( nvm == NULL )
 802dfce:	2800      	cmp	r0, #0
 802dfd0:	d010      	beq.n	802dff4 <LoRaMacCryptoInit+0x28>
    {
        return LORAMAC_CRYPTO_FAIL_PARAM;
    }

    // Assign non volatile context
    CryptoNvm = nvm;
 802dfd2:	4c09      	ldr	r4, [pc, #36]	; (802dff8 <LoRaMacCryptoInit+0x2c>)
 802dfd4:	6020      	str	r0, [r4, #0]

    // Initialize with default
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 802dfd6:	2228      	movs	r2, #40	; 0x28
 802dfd8:	2100      	movs	r1, #0
 802dfda:	f003 fbf6 	bl	80317ca <memset1>

    // Set default LoRaWAN version
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 802dfde:	6823      	ldr	r3, [r4, #0]
 802dfe0:	2201      	movs	r2, #1
 802dfe2:	70da      	strb	r2, [r3, #3]
    CryptoNvm->LrWanVersion.Fields.Minor = 1;
 802dfe4:	709a      	strb	r2, [r3, #2]
    CryptoNvm->LrWanVersion.Fields.Patch = 1;
 802dfe6:	705a      	strb	r2, [r3, #1]
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 802dfe8:	2200      	movs	r2, #0
 802dfea:	701a      	strb	r2, [r3, #0]

    // Reset frame counters
    ResetFCnts( );
 802dfec:	f7ff fed0 	bl	802dd90 <ResetFCnts>

    return LORAMAC_CRYPTO_SUCCESS;
 802dff0:	2000      	movs	r0, #0
}
 802dff2:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 802dff4:	2009      	movs	r0, #9
 802dff6:	e7fc      	b.n	802dff2 <LoRaMacCryptoInit+0x26>
 802dff8:	2000b1b0 	.word	0x2000b1b0

0802dffc <LoRaMacCryptoSetLrWanVersion>:

LoRaMacCryptoStatus_t LoRaMacCryptoSetLrWanVersion( Version_t version )
{
    CryptoNvm->LrWanVersion = version;
 802dffc:	4b02      	ldr	r3, [pc, #8]	; (802e008 <LoRaMacCryptoSetLrWanVersion+0xc>)
 802dffe:	681b      	ldr	r3, [r3, #0]
 802e000:	6018      	str	r0, [r3, #0]
    return LORAMAC_CRYPTO_SUCCESS;
}
 802e002:	2000      	movs	r0, #0
 802e004:	4770      	bx	lr
 802e006:	46c0      	nop			; (mov r8, r8)
 802e008:	2000b1b0 	.word	0x2000b1b0

0802e00c <LoRaMacCryptoGetFCntUp>:

LoRaMacCryptoStatus_t LoRaMacCryptoGetFCntUp( uint32_t* currentUp )
{
    if( currentUp == NULL )
 802e00c:	2800      	cmp	r0, #0
 802e00e:	d006      	beq.n	802e01e <LoRaMacCryptoGetFCntUp+0x12>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 802e010:	4b04      	ldr	r3, [pc, #16]	; (802e024 <LoRaMacCryptoGetFCntUp+0x18>)
 802e012:	681b      	ldr	r3, [r3, #0]
 802e014:	68db      	ldr	r3, [r3, #12]
 802e016:	3301      	adds	r3, #1
 802e018:	6003      	str	r3, [r0, #0]

    return LORAMAC_CRYPTO_SUCCESS;
 802e01a:	2000      	movs	r0, #0
}
 802e01c:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e01e:	200a      	movs	r0, #10
 802e020:	e7fc      	b.n	802e01c <LoRaMacCryptoGetFCntUp+0x10>
 802e022:	46c0      	nop			; (mov r8, r8)
 802e024:	2000b1b0 	.word	0x2000b1b0

0802e028 <LoRaMacCryptoGetFCntDown>:

LoRaMacCryptoStatus_t LoRaMacCryptoGetFCntDown( FCntIdentifier_t fCntID, uint16_t maxFCntGap, uint32_t frameFcnt, uint32_t* currentDown )
{
 802e028:	b570      	push	{r4, r5, r6, lr}
 802e02a:	b082      	sub	sp, #8
 802e02c:	000e      	movs	r6, r1
 802e02e:	0015      	movs	r5, r2
 802e030:	001c      	movs	r4, r3
    uint32_t lastDown = 0;
 802e032:	2300      	movs	r3, #0
 802e034:	9301      	str	r3, [sp, #4]
    int32_t fCntDiff = 0;
    LoRaMacCryptoStatus_t cryptoStatus = LORAMAC_CRYPTO_ERROR;

    if( currentDown == NULL )
 802e036:	2c00      	cmp	r4, #0
 802e038:	d034      	beq.n	802e0a4 <LoRaMacCryptoGetFCntDown+0x7c>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 802e03a:	a901      	add	r1, sp, #4
 802e03c:	f7ff fe42 	bl	802dcc4 <GetLastFcntDown>
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 802e040:	2800      	cmp	r0, #0
 802e042:	d117      	bne.n	802e074 <LoRaMacCryptoGetFCntDown+0x4c>
    {
        return cryptoStatus;
    }

    // For LoRaWAN 1.0.X only, allow downlink frames of 0
    if( lastDown == FCNT_DOWN_INITAL_VALUE )
 802e044:	9a01      	ldr	r2, [sp, #4]
 802e046:	1c53      	adds	r3, r2, #1
 802e048:	d016      	beq.n	802e078 <LoRaMacCryptoGetFCntDown+0x50>
        *currentDown = frameFcnt;
    }
    else
    {
        // Add difference, consider roll-over
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 802e04a:	0413      	lsls	r3, r2, #16
 802e04c:	0c1b      	lsrs	r3, r3, #16
 802e04e:	1aeb      	subs	r3, r5, r3

        if( fCntDiff > 0 )
 802e050:	2b00      	cmp	r3, #0
 802e052:	dd13      	ble.n	802e07c <LoRaMacCryptoGetFCntDown+0x54>
        {  // Positive difference
            *currentDown = lastDown + fCntDiff;
 802e054:	18d2      	adds	r2, r2, r3
 802e056:	6022      	str	r2, [r4, #0]
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
        }
    }

    // For LoRaWAN 1.0.X only, check maxFCntGap
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 802e058:	4b13      	ldr	r3, [pc, #76]	; (802e0a8 <LoRaMacCryptoGetFCntDown+0x80>)
 802e05a:	681b      	ldr	r3, [r3, #0]
 802e05c:	789d      	ldrb	r5, [r3, #2]
 802e05e:	2d00      	cmp	r5, #0
 802e060:	d108      	bne.n	802e074 <LoRaMacCryptoGetFCntDown+0x4c>
    {
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 802e062:	6822      	ldr	r2, [r4, #0]
 802e064:	2300      	movs	r3, #0
 802e066:	9801      	ldr	r0, [sp, #4]
 802e068:	2100      	movs	r1, #0
 802e06a:	1a12      	subs	r2, r2, r0
 802e06c:	418b      	sbcs	r3, r1
 802e06e:	4299      	cmp	r1, r3
 802e070:	dd12      	ble.n	802e098 <LoRaMacCryptoGetFCntDown+0x70>
        {
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
        }
    }

    return LORAMAC_CRYPTO_SUCCESS;
 802e072:	0028      	movs	r0, r5
}
 802e074:	b002      	add	sp, #8
 802e076:	bd70      	pop	{r4, r5, r6, pc}
        *currentDown = frameFcnt;
 802e078:	6025      	str	r5, [r4, #0]
 802e07a:	e7ed      	b.n	802e058 <LoRaMacCryptoGetFCntDown+0x30>
        else if( fCntDiff == 0 )
 802e07c:	2b00      	cmp	r3, #0
 802e07e:	d008      	beq.n	802e092 <LoRaMacCryptoGetFCntDown+0x6a>
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 802e080:	0c12      	lsrs	r2, r2, #16
 802e082:	0412      	lsls	r2, r2, #16
 802e084:	1955      	adds	r5, r2, r5
 802e086:	2380      	movs	r3, #128	; 0x80
 802e088:	025b      	lsls	r3, r3, #9
 802e08a:	469c      	mov	ip, r3
 802e08c:	4465      	add	r5, ip
 802e08e:	6025      	str	r5, [r4, #0]
 802e090:	e7e2      	b.n	802e058 <LoRaMacCryptoGetFCntDown+0x30>
            *currentDown = lastDown;
 802e092:	6022      	str	r2, [r4, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 802e094:	2007      	movs	r0, #7
 802e096:	e7ed      	b.n	802e074 <LoRaMacCryptoGetFCntDown+0x4c>
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 802e098:	4299      	cmp	r1, r3
 802e09a:	d101      	bne.n	802e0a0 <LoRaMacCryptoGetFCntDown+0x78>
 802e09c:	4296      	cmp	r6, r2
 802e09e:	d8e8      	bhi.n	802e072 <LoRaMacCryptoGetFCntDown+0x4a>
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
 802e0a0:	2008      	movs	r0, #8
 802e0a2:	e7e7      	b.n	802e074 <LoRaMacCryptoGetFCntDown+0x4c>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e0a4:	200a      	movs	r0, #10
 802e0a6:	e7e5      	b.n	802e074 <LoRaMacCryptoGetFCntDown+0x4c>
 802e0a8:	2000b1b0 	.word	0x2000b1b0

0802e0ac <LoRaMacCryptoSetMulticastReference>:
    return LORAMAC_CRYPTO_SUCCESS;
}
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

LoRaMacCryptoStatus_t LoRaMacCryptoSetMulticastReference( MulticastCtx_t* multicastList )
{
 802e0ac:	b510      	push	{r4, lr}
    if( multicastList == NULL )
 802e0ae:	2800      	cmp	r0, #0
 802e0b0:	d101      	bne.n	802e0b6 <LoRaMacCryptoSetMulticastReference+0xa>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e0b2:	200a      	movs	r0, #10
    {
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802e0b4:	bd10      	pop	{r4, pc}
    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802e0b6:	2300      	movs	r3, #0
 802e0b8:	e00a      	b.n	802e0d0 <LoRaMacCryptoSetMulticastReference+0x24>
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 802e0ba:	4a07      	ldr	r2, [pc, #28]	; (802e0d8 <LoRaMacCryptoSetMulticastReference+0x2c>)
 802e0bc:	6811      	ldr	r1, [r2, #0]
 802e0be:	222c      	movs	r2, #44	; 0x2c
 802e0c0:	435a      	muls	r2, r3
 802e0c2:	1882      	adds	r2, r0, r2
 802e0c4:	1d9c      	adds	r4, r3, #6
 802e0c6:	00a4      	lsls	r4, r4, #2
 802e0c8:	1909      	adds	r1, r1, r4
 802e0ca:	3104      	adds	r1, #4
 802e0cc:	6211      	str	r1, [r2, #32]
    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802e0ce:	3301      	adds	r3, #1
 802e0d0:	2b00      	cmp	r3, #0
 802e0d2:	ddf2      	ble.n	802e0ba <LoRaMacCryptoSetMulticastReference+0xe>
    return LORAMAC_CRYPTO_SUCCESS;
 802e0d4:	2000      	movs	r0, #0
 802e0d6:	e7ed      	b.n	802e0b4 <LoRaMacCryptoSetMulticastReference+0x8>
 802e0d8:	2000b1b0 	.word	0x2000b1b0

0802e0dc <LoRaMacCryptoPrepareJoinRequest>:
    }
    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoPrepareJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 802e0dc:	b510      	push	{r4, lr}
 802e0de:	b084      	sub	sp, #16
 802e0e0:	1e04      	subs	r4, r0, #0
    if( macMsg == 0 )
 802e0e2:	d020      	beq.n	802e126 <LoRaMacCryptoPrepareJoinRequest+0x4a>
    }
    KeyIdentifier_t micComputationKeyID = NWK_KEY;

    // Add device nonce
#if ( USE_RANDOM_DEV_NONCE == 1 )
    uint32_t devNonce = 0;
 802e0e4:	2300      	movs	r3, #0
 802e0e6:	9303      	str	r3, [sp, #12]
    SecureElementRandomNumber( &devNonce );
 802e0e8:	a803      	add	r0, sp, #12
 802e0ea:	f003 faf7 	bl	80316dc <SecureElementRandomNumber>
    CryptoNvm->DevNonce = devNonce;
 802e0ee:	4b11      	ldr	r3, [pc, #68]	; (802e134 <LoRaMacCryptoPrepareJoinRequest+0x58>)
 802e0f0:	681a      	ldr	r2, [r3, #0]
 802e0f2:	9b03      	ldr	r3, [sp, #12]
 802e0f4:	b29b      	uxth	r3, r3
 802e0f6:	8093      	strh	r3, [r2, #4]
#else
    CryptoNvm->DevNonce++;
#endif /* USE_RANDOM_DEV_NONCE */
    macMsg->DevNonce = CryptoNvm->DevNonce;
 802e0f8:	82e3      	strh	r3, [r4, #22]
        return LORAMAC_CRYPTO_ERROR;
    }
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

    // Serialize message
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802e0fa:	0020      	movs	r0, r4
 802e0fc:	f000 fa43 	bl	802e586 <LoRaMacSerializerJoinRequest>
 802e100:	2800      	cmp	r0, #0
 802e102:	d112      	bne.n	802e12a <LoRaMacCryptoPrepareJoinRequest+0x4e>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
    }

    // Compute mic
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 802e104:	0023      	movs	r3, r4
 802e106:	3318      	adds	r3, #24
 802e108:	9300      	str	r3, [sp, #0]
 802e10a:	2301      	movs	r3, #1
 802e10c:	2213      	movs	r2, #19
 802e10e:	6821      	ldr	r1, [r4, #0]
 802e110:	f003 f89e 	bl	8031250 <SecureElementComputeAesCmac>
 802e114:	2800      	cmp	r0, #0
 802e116:	d10b      	bne.n	802e130 <LoRaMacCryptoPrepareJoinRequest+0x54>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    // Reserialize message to add the MIC
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802e118:	0020      	movs	r0, r4
 802e11a:	f000 fa34 	bl	802e586 <LoRaMacSerializerJoinRequest>
 802e11e:	2800      	cmp	r0, #0
 802e120:	d004      	beq.n	802e12c <LoRaMacCryptoPrepareJoinRequest+0x50>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802e122:	2011      	movs	r0, #17
 802e124:	e002      	b.n	802e12c <LoRaMacCryptoPrepareJoinRequest+0x50>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e126:	200a      	movs	r0, #10
 802e128:	e000      	b.n	802e12c <LoRaMacCryptoPrepareJoinRequest+0x50>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802e12a:	2011      	movs	r0, #17
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802e12c:	b004      	add	sp, #16
 802e12e:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e130:	200f      	movs	r0, #15
 802e132:	e7fb      	b.n	802e12c <LoRaMacCryptoPrepareJoinRequest+0x50>
 802e134:	2000b1b0 	.word	0x2000b1b0

0802e138 <LoRaMacCryptoSecureMessage>:

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoSecureMessage( uint32_t fCntUp, uint8_t txDr, uint8_t txCh, LoRaMacMessageData_t* macMsg )
{
 802e138:	b530      	push	{r4, r5, lr}
 802e13a:	b085      	sub	sp, #20
 802e13c:	0005      	movs	r5, r0
 802e13e:	1e1c      	subs	r4, r3, #0
    LoRaMacCryptoStatus_t retval = LORAMAC_CRYPTO_ERROR;
    KeyIdentifier_t payloadDecryptionKeyID = APP_S_KEY;

    if( macMsg == NULL )
 802e140:	d037      	beq.n	802e1b2 <LoRaMacCryptoSecureMessage+0x7a>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 802e142:	4b20      	ldr	r3, [pc, #128]	; (802e1c4 <LoRaMacCryptoSecureMessage+0x8c>)
 802e144:	681b      	ldr	r3, [r3, #0]
 802e146:	68db      	ldr	r3, [r3, #12]
 802e148:	4283      	cmp	r3, r0
 802e14a:	d834      	bhi.n	802e1b6 <LoRaMacCryptoSecureMessage+0x7e>
    {
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
    }

    // Encrypt payload
    if( macMsg->FPort == 0 )
 802e14c:	2220      	movs	r2, #32
 802e14e:	5ca2      	ldrb	r2, [r4, r2]
 802e150:	2a00      	cmp	r2, #0
 802e152:	d02c      	beq.n	802e1ae <LoRaMacCryptoSecureMessage+0x76>
    KeyIdentifier_t payloadDecryptionKeyID = APP_S_KEY;
 802e154:	2203      	movs	r2, #3
        payloadDecryptionKeyID = NWK_S_KEY;
#endif /* USE_LRWAN_1_1_X_CRYPTO */
        /* ST_WORKAROUND_END */
    }

    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 802e156:	42ab      	cmp	r3, r5
 802e158:	d20a      	bcs.n	802e170 <LoRaMacCryptoSecureMessage+0x38>
    {
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 802e15a:	2328      	movs	r3, #40	; 0x28
 802e15c:	5ce1      	ldrb	r1, [r4, r3]
 802e15e:	9501      	str	r5, [sp, #4]
 802e160:	2300      	movs	r3, #0
 802e162:	9300      	str	r3, [sp, #0]
 802e164:	68a3      	ldr	r3, [r4, #8]
 802e166:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802e168:	f7ff fe8b 	bl	802de82 <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e16c:	2800      	cmp	r0, #0
 802e16e:	d125      	bne.n	802e1bc <LoRaMacCryptoSecureMessage+0x84>
        }
#endif /* USE_LRWAN_1_1_X_CRYPTO */
    }

    // Serialize message
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802e170:	0020      	movs	r0, r4
 802e172:	f000 fa3e 	bl	802e5f2 <LoRaMacSerializerData>
 802e176:	2800      	cmp	r0, #0
 802e178:	d11f      	bne.n	802e1ba <LoRaMacCryptoSecureMessage+0x82>
        payloadDecryptionKeyID = NWK_S_KEY;
#endif /* USE_LRWAN_1_1_X_CRYPTO */
        /* ST_WORKAROUND_END */
        // MIC = cmacF[0..3]
        // The IsAck parameter is every time false since the ConfFCnt field is not used in legacy mode.
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 802e17a:	7921      	ldrb	r1, [r4, #4]
 802e17c:	3904      	subs	r1, #4
 802e17e:	b289      	uxth	r1, r1
 802e180:	0023      	movs	r3, r4
 802e182:	332c      	adds	r3, #44	; 0x2c
 802e184:	9303      	str	r3, [sp, #12]
 802e186:	9502      	str	r5, [sp, #8]
 802e188:	68a3      	ldr	r3, [r4, #8]
 802e18a:	9301      	str	r3, [sp, #4]
 802e18c:	2300      	movs	r3, #0
 802e18e:	9300      	str	r3, [sp, #0]
 802e190:	2202      	movs	r2, #2
 802e192:	6820      	ldr	r0, [r4, #0]
 802e194:	f7ff fe14 	bl	802ddc0 <ComputeCmacB0>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e198:	2800      	cmp	r0, #0
 802e19a:	d10f      	bne.n	802e1bc <LoRaMacCryptoSecureMessage+0x84>
            return retval;
        }
    }

    // Re-serialize message to add the MIC
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802e19c:	0020      	movs	r0, r4
 802e19e:	f000 fa28 	bl	802e5f2 <LoRaMacSerializerData>
 802e1a2:	2800      	cmp	r0, #0
 802e1a4:	d10c      	bne.n	802e1c0 <LoRaMacCryptoSecureMessage+0x88>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
    }

    CryptoNvm->FCntList.FCntUp = fCntUp;
 802e1a6:	4b07      	ldr	r3, [pc, #28]	; (802e1c4 <LoRaMacCryptoSecureMessage+0x8c>)
 802e1a8:	681b      	ldr	r3, [r3, #0]
 802e1aa:	60dd      	str	r5, [r3, #12]

    return LORAMAC_CRYPTO_SUCCESS;
 802e1ac:	e006      	b.n	802e1bc <LoRaMacCryptoSecureMessage+0x84>
        payloadDecryptionKeyID = NWK_S_KEY;
 802e1ae:	2202      	movs	r2, #2
 802e1b0:	e7d1      	b.n	802e156 <LoRaMacCryptoSecureMessage+0x1e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e1b2:	200a      	movs	r0, #10
 802e1b4:	e002      	b.n	802e1bc <LoRaMacCryptoSecureMessage+0x84>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 802e1b6:	2006      	movs	r0, #6
 802e1b8:	e000      	b.n	802e1bc <LoRaMacCryptoSecureMessage+0x84>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802e1ba:	2011      	movs	r0, #17
}
 802e1bc:	b005      	add	sp, #20
 802e1be:	bd30      	pop	{r4, r5, pc}
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802e1c0:	2011      	movs	r0, #17
 802e1c2:	e7fb      	b.n	802e1bc <LoRaMacCryptoSecureMessage+0x84>
 802e1c4:	2000b1b0 	.word	0x2000b1b0

0802e1c8 <LoRaMacCryptoUnsecureMessage>:

LoRaMacCryptoStatus_t LoRaMacCryptoUnsecureMessage( AddressIdentifier_t addrID, uint32_t address, FCntIdentifier_t fCntID, uint32_t fCntDown, LoRaMacMessageData_t* macMsg )
{
 802e1c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e1ca:	46ce      	mov	lr, r9
 802e1cc:	b500      	push	{lr}
 802e1ce:	b088      	sub	sp, #32
 802e1d0:	0005      	movs	r5, r0
 802e1d2:	9105      	str	r1, [sp, #20]
 802e1d4:	0017      	movs	r7, r2
 802e1d6:	001c      	movs	r4, r3
 802e1d8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    if( macMsg == 0 )
 802e1da:	2e00      	cmp	r6, #0
 802e1dc:	d047      	beq.n	802e26e <LoRaMacCryptoUnsecureMessage+0xa6>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    if( CheckFCntDown( fCntID, fCntDown ) == false )
 802e1de:	0019      	movs	r1, r3
 802e1e0:	0010      	movs	r0, r2
 802e1e2:	f7ff fda1 	bl	802dd28 <CheckFCntDown>
 802e1e6:	2800      	cmp	r0, #0
 802e1e8:	d043      	beq.n	802e272 <LoRaMacCryptoUnsecureMessage+0xaa>
#endif /* USE_LRWAN_1_1_X_CRYPTO */
    /* ST_WORKAROUND_END */
    KeyAddr_t* curItem;

    // Parse the message
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 802e1ea:	0030      	movs	r0, r6
 802e1ec:	f000 f96b 	bl	802e4c6 <LoRaMacParserData>
 802e1f0:	2800      	cmp	r0, #0
 802e1f2:	d144      	bne.n	802e27e <LoRaMacCryptoUnsecureMessage+0xb6>
    {
        return LORAMAC_CRYPTO_ERROR_PARSER;
    }

    // Determine current security context
    retval = GetKeyAddrItem( addrID, &curItem );
 802e1f4:	a907      	add	r1, sp, #28
 802e1f6:	0028      	movs	r0, r5
 802e1f8:	f7ff fd4e 	bl	802dc98 <GetKeyAddrItem>
 802e1fc:	1e05      	subs	r5, r0, #0
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e1fe:	d139      	bne.n	802e274 <LoRaMacCryptoUnsecureMessage+0xac>
    {
        return retval;
    }

    payloadDecryptionKeyID = curItem->AppSkey;
 802e200:	9b07      	ldr	r3, [sp, #28]
 802e202:	785a      	ldrb	r2, [r3, #1]
 802e204:	4691      	mov	r9, r2
    micComputationKeyID = curItem->NwkSkey;
 802e206:	789a      	ldrb	r2, [r3, #2]

    // Check if it is our address
    if( address != macMsg->FHDR.DevAddr )
 802e208:	68b0      	ldr	r0, [r6, #8]
 802e20a:	9b05      	ldr	r3, [sp, #20]
 802e20c:	4298      	cmp	r0, r3
 802e20e:	d138      	bne.n	802e282 <LoRaMacCryptoUnsecureMessage+0xba>
    {
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
    }

    // Compute mic
    bool isAck = macMsg->FHDR.FCtrl.Bits.Ack;
 802e210:	7b33      	ldrb	r3, [r6, #12]
 802e212:	069b      	lsls	r3, r3, #26
 802e214:	0fdb      	lsrs	r3, r3, #31
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 802e216:	491c      	ldr	r1, [pc, #112]	; (802e288 <LoRaMacCryptoUnsecureMessage+0xc0>)
 802e218:	6809      	ldr	r1, [r1, #0]
 802e21a:	7889      	ldrb	r1, [r1, #2]
 802e21c:	2900      	cmp	r1, #0
 802e21e:	d100      	bne.n	802e222 <LoRaMacCryptoUnsecureMessage+0x5a>
    {
        // In legacy mode the IsAck parameter is forced to be false since the ConfFCnt field is not used.
        isAck = false;
 802e220:	2300      	movs	r3, #0
    }

    // Verify mic
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 802e222:	7931      	ldrb	r1, [r6, #4]
 802e224:	3904      	subs	r1, #4
 802e226:	b289      	uxth	r1, r1
 802e228:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 802e22a:	9003      	str	r0, [sp, #12]
 802e22c:	9402      	str	r4, [sp, #8]
 802e22e:	9805      	ldr	r0, [sp, #20]
 802e230:	9001      	str	r0, [sp, #4]
 802e232:	2001      	movs	r0, #1
 802e234:	9000      	str	r0, [sp, #0]
 802e236:	6830      	ldr	r0, [r6, #0]
 802e238:	f7ff fe8b 	bl	802df52 <VerifyCmacB0>
 802e23c:	1e05      	subs	r5, r0, #0
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e23e:	d119      	bne.n	802e274 <LoRaMacCryptoUnsecureMessage+0xac>
    {
        return retval;
    }

    // Decrypt payload
    if( macMsg->FPort == 0 )
 802e240:	2320      	movs	r3, #32
 802e242:	5cf3      	ldrb	r3, [r6, r3]
 802e244:	2b00      	cmp	r3, #0
 802e246:	d101      	bne.n	802e24c <LoRaMacCryptoUnsecureMessage+0x84>
        // Use network session encryption key
        /* ST_WORKAROUND_BEGIN: integrate 1.1.x keys only if required */
#if ( USE_LRWAN_1_1_X_CRYPTO == 1 )
        payloadDecryptionKeyID = NWK_S_ENC_KEY;
#else /* USE_LRWAN_1_1_X_CRYPTO == 0 */
        payloadDecryptionKeyID = NWK_S_KEY;
 802e248:	3302      	adds	r3, #2
 802e24a:	4699      	mov	r9, r3
#endif /* USE_LRWAN_1_1_X_CRYPTO */
        /* ST_WORKAROUND_END */
    }
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 802e24c:	2328      	movs	r3, #40	; 0x28
 802e24e:	5cf1      	ldrb	r1, [r6, r3]
 802e250:	6a70      	ldr	r0, [r6, #36]	; 0x24
 802e252:	9401      	str	r4, [sp, #4]
 802e254:	3b27      	subs	r3, #39	; 0x27
 802e256:	9300      	str	r3, [sp, #0]
 802e258:	9b05      	ldr	r3, [sp, #20]
 802e25a:	464a      	mov	r2, r9
 802e25c:	f7ff fe11 	bl	802de82 <PayloadEncrypt>
 802e260:	1e05      	subs	r5, r0, #0
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e262:	d107      	bne.n	802e274 <LoRaMacCryptoUnsecureMessage+0xac>
            }
        } 
    }
#endif

    UpdateFCntDown( fCntID, fCntDown );
 802e264:	0021      	movs	r1, r4
 802e266:	0038      	movs	r0, r7
 802e268:	f7ff fd76 	bl	802dd58 <UpdateFCntDown>

    return LORAMAC_CRYPTO_SUCCESS;
 802e26c:	e002      	b.n	802e274 <LoRaMacCryptoUnsecureMessage+0xac>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e26e:	250a      	movs	r5, #10
 802e270:	e000      	b.n	802e274 <LoRaMacCryptoUnsecureMessage+0xac>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 802e272:	2506      	movs	r5, #6
}
 802e274:	0028      	movs	r0, r5
 802e276:	b008      	add	sp, #32
 802e278:	bc80      	pop	{r7}
 802e27a:	46b9      	mov	r9, r7
 802e27c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_PARSER;
 802e27e:	2510      	movs	r5, #16
 802e280:	e7f8      	b.n	802e274 <LoRaMacCryptoUnsecureMessage+0xac>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 802e282:	2502      	movs	r5, #2
 802e284:	e7f6      	b.n	802e274 <LoRaMacCryptoUnsecureMessage+0xac>
 802e286:	46c0      	nop			; (mov r8, r8)
 802e288:	2000b1b0 	.word	0x2000b1b0

0802e28c <LoRaMacCryptoDeriveMcRootKey>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcRootKey( uint8_t versionMinor, KeyIdentifier_t keyID )
{
 802e28c:	b530      	push	{r4, r5, lr}
 802e28e:	b085      	sub	sp, #20
 802e290:	0005      	movs	r5, r0
 802e292:	1e0c      	subs	r4, r1, #0
    // Prevent other keys than AppKey
    if( keyID != APP_KEY )
 802e294:	d115      	bne.n	802e2c2 <LoRaMacCryptoDeriveMcRootKey+0x36>
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
    uint8_t compBase[16] = { 0 };
 802e296:	2300      	movs	r3, #0
 802e298:	9300      	str	r3, [sp, #0]
 802e29a:	220c      	movs	r2, #12
 802e29c:	2100      	movs	r1, #0
 802e29e:	a801      	add	r0, sp, #4
 802e2a0:	f006 fa41 	bl	8034726 <memset>

    if( versionMinor == 1 )
 802e2a4:	2d01      	cmp	r5, #1
 802e2a6:	d008      	beq.n	802e2ba <LoRaMacCryptoDeriveMcRootKey+0x2e>
    {
        compBase[0] = 0x20;
    }
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 802e2a8:	2204      	movs	r2, #4
 802e2aa:	0021      	movs	r1, r4
 802e2ac:	4668      	mov	r0, sp
 802e2ae:	f003 f969 	bl	8031584 <SecureElementDeriveAndStoreKey>
 802e2b2:	2800      	cmp	r0, #0
 802e2b4:	d107      	bne.n	802e2c6 <LoRaMacCryptoDeriveMcRootKey+0x3a>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802e2b6:	b005      	add	sp, #20
 802e2b8:	bd30      	pop	{r4, r5, pc}
        compBase[0] = 0x20;
 802e2ba:	2320      	movs	r3, #32
 802e2bc:	466a      	mov	r2, sp
 802e2be:	7013      	strb	r3, [r2, #0]
 802e2c0:	e7f2      	b.n	802e2a8 <LoRaMacCryptoDeriveMcRootKey+0x1c>
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 802e2c2:	200b      	movs	r0, #11
 802e2c4:	e7f7      	b.n	802e2b6 <LoRaMacCryptoDeriveMcRootKey+0x2a>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e2c6:	200f      	movs	r0, #15
 802e2c8:	e7f5      	b.n	802e2b6 <LoRaMacCryptoDeriveMcRootKey+0x2a>

0802e2ca <LoRaMacCryptoDeriveMcKEKey>:

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcKEKey( KeyIdentifier_t keyID )
{
 802e2ca:	b510      	push	{r4, lr}
 802e2cc:	b084      	sub	sp, #16
 802e2ce:	0004      	movs	r4, r0
    // Prevent other keys than McRootKey
    if( keyID != MC_ROOT_KEY )
 802e2d0:	2804      	cmp	r0, #4
 802e2d2:	d002      	beq.n	802e2da <LoRaMacCryptoDeriveMcKEKey+0x10>
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 802e2d4:	200b      	movs	r0, #11
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802e2d6:	b004      	add	sp, #16
 802e2d8:	bd10      	pop	{r4, pc}
    uint8_t compBase[16] = { 0 };
 802e2da:	2300      	movs	r3, #0
 802e2dc:	9300      	str	r3, [sp, #0]
 802e2de:	220c      	movs	r2, #12
 802e2e0:	2100      	movs	r1, #0
 802e2e2:	a801      	add	r0, sp, #4
 802e2e4:	f006 fa1f 	bl	8034726 <memset>
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 802e2e8:	227f      	movs	r2, #127	; 0x7f
 802e2ea:	0021      	movs	r1, r4
 802e2ec:	4668      	mov	r0, sp
 802e2ee:	f003 f949 	bl	8031584 <SecureElementDeriveAndStoreKey>
 802e2f2:	2800      	cmp	r0, #0
 802e2f4:	d0ef      	beq.n	802e2d6 <LoRaMacCryptoDeriveMcKEKey+0xc>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e2f6:	200f      	movs	r0, #15
 802e2f8:	e7ed      	b.n	802e2d6 <LoRaMacCryptoDeriveMcKEKey+0xc>
	...

0802e2fc <LoRaMacCryptoSetKey>:
{
 802e2fc:	b510      	push	{r4, lr}
 802e2fe:	0004      	movs	r4, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 802e300:	f003 f86c 	bl	80313dc <SecureElementSetKey>
 802e304:	2800      	cmp	r0, #0
 802e306:	d111      	bne.n	802e32c <LoRaMacCryptoSetKey+0x30>
    if( keyID == APP_KEY )
 802e308:	2c00      	cmp	r4, #0
 802e30a:	d000      	beq.n	802e30e <LoRaMacCryptoSetKey+0x12>
}
 802e30c:	bd10      	pop	{r4, pc}
        if( LoRaMacCryptoDeriveMcRootKey( CryptoNvm->LrWanVersion.Fields.Minor, keyID ) != LORAMAC_CRYPTO_SUCCESS )
 802e30e:	4b09      	ldr	r3, [pc, #36]	; (802e334 <LoRaMacCryptoSetKey+0x38>)
 802e310:	681b      	ldr	r3, [r3, #0]
 802e312:	7898      	ldrb	r0, [r3, #2]
 802e314:	0021      	movs	r1, r4
 802e316:	f7ff ffb9 	bl	802e28c <LoRaMacCryptoDeriveMcRootKey>
 802e31a:	2800      	cmp	r0, #0
 802e31c:	d108      	bne.n	802e330 <LoRaMacCryptoSetKey+0x34>
        if( LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 802e31e:	3004      	adds	r0, #4
 802e320:	f7ff ffd3 	bl	802e2ca <LoRaMacCryptoDeriveMcKEKey>
 802e324:	2800      	cmp	r0, #0
 802e326:	d0f1      	beq.n	802e30c <LoRaMacCryptoSetKey+0x10>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e328:	200f      	movs	r0, #15
 802e32a:	e7ef      	b.n	802e30c <LoRaMacCryptoSetKey+0x10>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e32c:	200f      	movs	r0, #15
 802e32e:	e7ed      	b.n	802e30c <LoRaMacCryptoSetKey+0x10>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e330:	200f      	movs	r0, #15
 802e332:	e7eb      	b.n	802e30c <LoRaMacCryptoSetKey+0x10>
 802e334:	2000b1b0 	.word	0x2000b1b0

0802e338 <LoRaMacCryptoHandleJoinAccept>:
{
 802e338:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e33a:	b08f      	sub	sp, #60	; 0x3c
 802e33c:	0006      	movs	r6, r0
 802e33e:	000d      	movs	r5, r1
 802e340:	1e14      	subs	r4, r2, #0
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 802e342:	d063      	beq.n	802e40c <LoRaMacCryptoHandleJoinAccept+0xd4>
 802e344:	2900      	cmp	r1, #0
 802e346:	d063      	beq.n	802e410 <LoRaMacCryptoHandleJoinAccept+0xd8>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 802e348:	2700      	movs	r7, #0
 802e34a:	9705      	str	r7, [sp, #20]
 802e34c:	221d      	movs	r2, #29
 802e34e:	2100      	movs	r1, #0
 802e350:	a806      	add	r0, sp, #24
 802e352:	f006 f9e8 	bl	8034726 <memset>
    uint8_t versionMinor         = 0;
 802e356:	2313      	movs	r3, #19
 802e358:	446b      	add	r3, sp
 802e35a:	701f      	strb	r7, [r3, #0]
    uint16_t nonce               = CryptoNvm->DevNonce;
 802e35c:	4a31      	ldr	r2, [pc, #196]	; (802e424 <LoRaMacCryptoHandleJoinAccept+0xec>)
 802e35e:	6812      	ldr	r2, [r2, #0]
 802e360:	8897      	ldrh	r7, [r2, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 802e362:	9302      	str	r3, [sp, #8]
 802e364:	ab05      	add	r3, sp, #20
 802e366:	9301      	str	r3, [sp, #4]
 802e368:	7923      	ldrb	r3, [r4, #4]
 802e36a:	9300      	str	r3, [sp, #0]
 802e36c:	6823      	ldr	r3, [r4, #0]
 802e36e:	003a      	movs	r2, r7
 802e370:	0029      	movs	r1, r5
 802e372:	0030      	movs	r0, r6
 802e374:	f003 f96a 	bl	803164c <SecureElementProcessJoinAccept>
 802e378:	2800      	cmp	r0, #0
 802e37a:	d14b      	bne.n	802e414 <LoRaMacCryptoHandleJoinAccept+0xdc>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 802e37c:	7922      	ldrb	r2, [r4, #4]
 802e37e:	a905      	add	r1, sp, #20
 802e380:	6820      	ldr	r0, [r4, #0]
 802e382:	f003 fa0a 	bl	803179a <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 802e386:	0020      	movs	r0, r4
 802e388:	f000 f84e 	bl	802e428 <LoRaMacParserJoinAccept>
 802e38c:	2800      	cmp	r0, #0
 802e38e:	d144      	bne.n	802e41a <LoRaMacCryptoHandleJoinAccept+0xe2>
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 802e390:	79a3      	ldrb	r3, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 802e392:	79e5      	ldrb	r5, [r4, #7]
 802e394:	022d      	lsls	r5, r5, #8
 802e396:	432b      	orrs	r3, r5
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 802e398:	7a25      	ldrb	r5, [r4, #8]
 802e39a:	042d      	lsls	r5, r5, #16
 802e39c:	431d      	orrs	r5, r3
    if( currentJoinNonce != CryptoNvm->JoinNonce )
 802e39e:	4b21      	ldr	r3, [pc, #132]	; (802e424 <LoRaMacCryptoHandleJoinAccept+0xec>)
 802e3a0:	681b      	ldr	r3, [r3, #0]
 802e3a2:	689a      	ldr	r2, [r3, #8]
 802e3a4:	42aa      	cmp	r2, r5
 802e3a6:	d03a      	beq.n	802e41e <LoRaMacCryptoHandleJoinAccept+0xe6>
        CryptoNvm->JoinNonce = currentJoinNonce;
 802e3a8:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 802e3aa:	2313      	movs	r3, #19
 802e3ac:	446b      	add	r3, sp
 802e3ae:	7818      	ldrb	r0, [r3, #0]
 802e3b0:	2100      	movs	r1, #0
 802e3b2:	f7ff ff6b 	bl	802e28c <LoRaMacCryptoDeriveMcRootKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e3b6:	2800      	cmp	r0, #0
 802e3b8:	d12d      	bne.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
    retval = LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY );
 802e3ba:	3004      	adds	r0, #4
 802e3bc:	f7ff ff85 	bl	802e2ca <LoRaMacCryptoDeriveMcKEKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e3c0:	2800      	cmp	r0, #0
 802e3c2:	d128      	bne.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
        netID = ( uint32_t )macMsg->NetID[0];
 802e3c4:	7a62      	ldrb	r2, [r4, #9]
        netID |= ( ( uint32_t )macMsg->NetID[1] << 8 );
 802e3c6:	7aa3      	ldrb	r3, [r4, #10]
 802e3c8:	021b      	lsls	r3, r3, #8
 802e3ca:	4313      	orrs	r3, r2
        netID |= ( ( uint32_t )macMsg->NetID[2] << 16 );
 802e3cc:	7ae4      	ldrb	r4, [r4, #11]
 802e3ce:	0424      	lsls	r4, r4, #16
 802e3d0:	431c      	orrs	r4, r3
        retval = DeriveSessionKey10x( APP_S_KEY, currentJoinNonce, netID, nonce );
 802e3d2:	003b      	movs	r3, r7
 802e3d4:	0022      	movs	r2, r4
 802e3d6:	0029      	movs	r1, r5
 802e3d8:	3003      	adds	r0, #3
 802e3da:	f7ff fd20 	bl	802de1e <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e3de:	2800      	cmp	r0, #0
 802e3e0:	d119      	bne.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
        retval = DeriveSessionKey10x( NWK_S_KEY, currentJoinNonce, netID, nonce );
 802e3e2:	003b      	movs	r3, r7
 802e3e4:	0022      	movs	r2, r4
 802e3e6:	0029      	movs	r1, r5
 802e3e8:	3002      	adds	r0, #2
 802e3ea:	f7ff fd18 	bl	802de1e <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802e3ee:	2800      	cmp	r0, #0
 802e3f0:	d111      	bne.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 802e3f2:	4b0c      	ldr	r3, [pc, #48]	; (802e424 <LoRaMacCryptoHandleJoinAccept+0xec>)
 802e3f4:	681b      	ldr	r3, [r3, #0]
 802e3f6:	2213      	movs	r2, #19
 802e3f8:	446a      	add	r2, sp
 802e3fa:	7812      	ldrb	r2, [r2, #0]
 802e3fc:	709a      	strb	r2, [r3, #2]
    CryptoNvm->FCntList.FCntUp = 0;
 802e3fe:	2200      	movs	r2, #0
 802e400:	60da      	str	r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 802e402:	3a01      	subs	r2, #1
 802e404:	619a      	str	r2, [r3, #24]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 802e406:	611a      	str	r2, [r3, #16]
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 802e408:	615a      	str	r2, [r3, #20]
    return LORAMAC_CRYPTO_SUCCESS;
 802e40a:	e004      	b.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e40c:	200a      	movs	r0, #10
 802e40e:	e002      	b.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
 802e410:	200a      	movs	r0, #10
 802e412:	e000      	b.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e414:	200f      	movs	r0, #15
}
 802e416:	b00f      	add	sp, #60	; 0x3c
 802e418:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_PARSER;
 802e41a:	2010      	movs	r0, #16
 802e41c:	e7fb      	b.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 802e41e:	2003      	movs	r0, #3
 802e420:	e7f9      	b.n	802e416 <LoRaMacCryptoHandleJoinAccept+0xde>
 802e422:	46c0      	nop			; (mov r8, r8)
 802e424:	2000b1b0 	.word	0x2000b1b0

0802e428 <LoRaMacParserJoinAccept>:
 */
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 802e428:	b570      	push	{r4, r5, r6, lr}
 802e42a:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802e42c:	d045      	beq.n	802e4ba <LoRaMacParserJoinAccept+0x92>
 802e42e:	6801      	ldr	r1, [r0, #0]
 802e430:	2900      	cmp	r1, #0
 802e432:	d044      	beq.n	802e4be <LoRaMacParserJoinAccept+0x96>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 802e434:	780b      	ldrb	r3, [r1, #0]
 802e436:	7143      	strb	r3, [r0, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 802e438:	3006      	adds	r0, #6
 802e43a:	3101      	adds	r1, #1
 802e43c:	2203      	movs	r2, #3
 802e43e:	f003 f9ac 	bl	803179a <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 802e442:	6823      	ldr	r3, [r4, #0]
 802e444:	1d19      	adds	r1, r3, #4
 802e446:	2203      	movs	r2, #3
 802e448:	0020      	movs	r0, r4
 802e44a:	3009      	adds	r0, #9
 802e44c:	f003 f9a5 	bl	803179a <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 802e450:	6821      	ldr	r1, [r4, #0]
 802e452:	79cb      	ldrb	r3, [r1, #7]
 802e454:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 802e456:	7a0a      	ldrb	r2, [r1, #8]
 802e458:	0212      	lsls	r2, r2, #8
 802e45a:	4313      	orrs	r3, r2
 802e45c:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 802e45e:	7a4a      	ldrb	r2, [r1, #9]
 802e460:	0412      	lsls	r2, r2, #16
 802e462:	4313      	orrs	r3, r2
 802e464:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 802e466:	7a8a      	ldrb	r2, [r1, #10]
 802e468:	0612      	lsls	r2, r2, #24
 802e46a:	4313      	orrs	r3, r2
 802e46c:	60e3      	str	r3, [r4, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 802e46e:	7acb      	ldrb	r3, [r1, #11]
 802e470:	7423      	strb	r3, [r4, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 802e472:	7b0b      	ldrb	r3, [r1, #12]
 802e474:	7463      	strb	r3, [r4, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 802e476:	7923      	ldrb	r3, [r4, #4]
 802e478:	2b21      	cmp	r3, #33	; 0x21
 802e47a:	d016      	beq.n	802e4aa <LoRaMacParserJoinAccept+0x82>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
    }
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 802e47c:	2b11      	cmp	r3, #17
 802e47e:	dc20      	bgt.n	802e4c2 <LoRaMacParserJoinAccept+0x9a>
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 802e480:	220d      	movs	r2, #13
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 802e482:	6821      	ldr	r1, [r4, #0]
 802e484:	1c50      	adds	r0, r2, #1
 802e486:	5c8b      	ldrb	r3, [r1, r2]
 802e488:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 802e48a:	1c95      	adds	r5, r2, #2
 802e48c:	5c08      	ldrb	r0, [r1, r0]
 802e48e:	0200      	lsls	r0, r0, #8
 802e490:	4303      	orrs	r3, r0
 802e492:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 802e494:	3203      	adds	r2, #3
 802e496:	5d48      	ldrb	r0, [r1, r5]
 802e498:	0400      	lsls	r0, r0, #16
 802e49a:	4303      	orrs	r3, r0
 802e49c:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 802e49e:	5c8a      	ldrb	r2, [r1, r2]
 802e4a0:	0612      	lsls	r2, r2, #24
 802e4a2:	4313      	orrs	r3, r2
 802e4a4:	6263      	str	r3, [r4, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 802e4a6:	2000      	movs	r0, #0
}
 802e4a8:	bd70      	pop	{r4, r5, r6, pc}
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 802e4aa:	310d      	adds	r1, #13
 802e4ac:	2210      	movs	r2, #16
 802e4ae:	0020      	movs	r0, r4
 802e4b0:	3012      	adds	r0, #18
 802e4b2:	f003 f972 	bl	803179a <memcpy1>
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
 802e4b6:	221d      	movs	r2, #29
 802e4b8:	e7e3      	b.n	802e482 <LoRaMacParserJoinAccept+0x5a>
        return LORAMAC_PARSER_ERROR_NPE;
 802e4ba:	2002      	movs	r0, #2
 802e4bc:	e7f4      	b.n	802e4a8 <LoRaMacParserJoinAccept+0x80>
 802e4be:	2002      	movs	r0, #2
 802e4c0:	e7f2      	b.n	802e4a8 <LoRaMacParserJoinAccept+0x80>
        return LORAMAC_PARSER_FAIL;
 802e4c2:	2001      	movs	r0, #1
 802e4c4:	e7f0      	b.n	802e4a8 <LoRaMacParserJoinAccept+0x80>

0802e4c6 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 802e4c6:	b570      	push	{r4, r5, r6, lr}
 802e4c8:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802e4ca:	d058      	beq.n	802e57e <LoRaMacParserData+0xb8>
 802e4cc:	6801      	ldr	r1, [r0, #0]
 802e4ce:	2900      	cmp	r1, #0
 802e4d0:	d057      	beq.n	802e582 <LoRaMacParserData+0xbc>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 802e4d2:	780b      	ldrb	r3, [r1, #0]
 802e4d4:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 802e4d6:	784b      	ldrb	r3, [r1, #1]
 802e4d8:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 802e4da:	788a      	ldrb	r2, [r1, #2]
 802e4dc:	0212      	lsls	r2, r2, #8
 802e4de:	4313      	orrs	r3, r2
 802e4e0:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 802e4e2:	78ca      	ldrb	r2, [r1, #3]
 802e4e4:	0412      	lsls	r2, r2, #16
 802e4e6:	4313      	orrs	r3, r2
 802e4e8:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 802e4ea:	790a      	ldrb	r2, [r1, #4]
 802e4ec:	0612      	lsls	r2, r2, #24
 802e4ee:	4313      	orrs	r3, r2
 802e4f0:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 802e4f2:	794b      	ldrb	r3, [r1, #5]
 802e4f4:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 802e4f6:	798b      	ldrb	r3, [r1, #6]
 802e4f8:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 802e4fa:	79ca      	ldrb	r2, [r1, #7]
 802e4fc:	0212      	lsls	r2, r2, #8
 802e4fe:	4313      	orrs	r3, r2
 802e500:	81c3      	strh	r3, [r0, #14]

    if( macMsg->FHDR.FCtrl.Bits.FOptsLen <= 15 )
    {
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 802e502:	3010      	adds	r0, #16
 802e504:	3108      	adds	r1, #8
 802e506:	7b22      	ldrb	r2, [r4, #12]
 802e508:	0712      	lsls	r2, r2, #28
 802e50a:	0f12      	lsrs	r2, r2, #28
 802e50c:	f003 f945 	bl	803179a <memcpy1>
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 802e510:	7b23      	ldrb	r3, [r4, #12]
 802e512:	071b      	lsls	r3, r3, #28
 802e514:	0f1b      	lsrs	r3, r3, #28
 802e516:	0018      	movs	r0, r3
 802e518:	3008      	adds	r0, #8
    {
        return LORAMAC_PARSER_FAIL;
    }

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 802e51a:	2200      	movs	r2, #0
 802e51c:	2120      	movs	r1, #32
 802e51e:	5462      	strb	r2, [r4, r1]
    macMsg->FRMPayloadSize = 0;
 802e520:	3108      	adds	r1, #8
 802e522:	5462      	strb	r2, [r4, r1]

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 802e524:	7922      	ldrb	r2, [r4, #4]
 802e526:	1a11      	subs	r1, r2, r0
 802e528:	2904      	cmp	r1, #4
 802e52a:	dc17      	bgt.n	802e55c <LoRaMacParserData+0x96>
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 802e52c:	7922      	ldrb	r2, [r4, #4]
 802e52e:	6823      	ldr	r3, [r4, #0]
 802e530:	469c      	mov	ip, r3
 802e532:	4462      	add	r2, ip
 802e534:	1f13      	subs	r3, r2, #4
 802e536:	781b      	ldrb	r3, [r3, #0]
 802e538:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 802e53a:	1ed1      	subs	r1, r2, #3
 802e53c:	7809      	ldrb	r1, [r1, #0]
 802e53e:	0209      	lsls	r1, r1, #8
 802e540:	430b      	orrs	r3, r1
 802e542:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 802e544:	1e91      	subs	r1, r2, #2
 802e546:	7809      	ldrb	r1, [r1, #0]
 802e548:	0409      	lsls	r1, r1, #16
 802e54a:	430b      	orrs	r3, r1
 802e54c:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 802e54e:	3a01      	subs	r2, #1
 802e550:	7812      	ldrb	r2, [r2, #0]
 802e552:	0612      	lsls	r2, r2, #24
 802e554:	4313      	orrs	r3, r2
 802e556:	62e3      	str	r3, [r4, #44]	; 0x2c

    return LORAMAC_PARSER_SUCCESS;
 802e558:	2000      	movs	r0, #0
}
 802e55a:	bd70      	pop	{r4, r5, r6, pc}
        macMsg->FPort = macMsg->Buffer[bufItr++];
 802e55c:	6821      	ldr	r1, [r4, #0]
 802e55e:	3309      	adds	r3, #9
 802e560:	5c0d      	ldrb	r5, [r1, r0]
 802e562:	2020      	movs	r0, #32
 802e564:	5425      	strb	r5, [r4, r0]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 802e566:	1ad2      	subs	r2, r2, r3
 802e568:	b2d2      	uxtb	r2, r2
 802e56a:	3a04      	subs	r2, #4
 802e56c:	b2d2      	uxtb	r2, r2
 802e56e:	3008      	adds	r0, #8
 802e570:	5422      	strb	r2, [r4, r0]
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 802e572:	18c9      	adds	r1, r1, r3
 802e574:	b292      	uxth	r2, r2
 802e576:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802e578:	f003 f90f 	bl	803179a <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
 802e57c:	e7d6      	b.n	802e52c <LoRaMacParserData+0x66>
        return LORAMAC_PARSER_ERROR_NPE;
 802e57e:	2002      	movs	r0, #2
 802e580:	e7eb      	b.n	802e55a <LoRaMacParserData+0x94>
 802e582:	2002      	movs	r0, #2
 802e584:	e7e9      	b.n	802e55a <LoRaMacParserData+0x94>

0802e586 <LoRaMacSerializerJoinRequest>:
 */
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 802e586:	b510      	push	{r4, lr}
 802e588:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802e58a:	d02c      	beq.n	802e5e6 <LoRaMacSerializerJoinRequest+0x60>
 802e58c:	6803      	ldr	r3, [r0, #0]
 802e58e:	2b00      	cmp	r3, #0
 802e590:	d02b      	beq.n	802e5ea <LoRaMacSerializerJoinRequest+0x64>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 802e592:	7902      	ldrb	r2, [r0, #4]
 802e594:	2a16      	cmp	r2, #22
 802e596:	d92a      	bls.n	802e5ee <LoRaMacSerializerJoinRequest+0x68>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 802e598:	7942      	ldrb	r2, [r0, #5]
 802e59a:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 802e59c:	1d81      	adds	r1, r0, #6
 802e59e:	6803      	ldr	r3, [r0, #0]
 802e5a0:	1c58      	adds	r0, r3, #1
 802e5a2:	2208      	movs	r2, #8
 802e5a4:	f003 f904 	bl	80317b0 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 802e5a8:	0021      	movs	r1, r4
 802e5aa:	310e      	adds	r1, #14
 802e5ac:	6820      	ldr	r0, [r4, #0]
 802e5ae:	3009      	adds	r0, #9
 802e5b0:	2208      	movs	r2, #8
 802e5b2:	f003 f8fd 	bl	80317b0 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 802e5b6:	8ae3      	ldrh	r3, [r4, #22]
 802e5b8:	6822      	ldr	r2, [r4, #0]
 802e5ba:	7453      	strb	r3, [r2, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 802e5bc:	8ae3      	ldrh	r3, [r4, #22]
 802e5be:	0a1b      	lsrs	r3, r3, #8
 802e5c0:	6822      	ldr	r2, [r4, #0]
 802e5c2:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 802e5c4:	69a3      	ldr	r3, [r4, #24]
 802e5c6:	6822      	ldr	r2, [r4, #0]
 802e5c8:	74d3      	strb	r3, [r2, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 802e5ca:	69a3      	ldr	r3, [r4, #24]
 802e5cc:	0a1b      	lsrs	r3, r3, #8
 802e5ce:	6822      	ldr	r2, [r4, #0]
 802e5d0:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 802e5d2:	8b63      	ldrh	r3, [r4, #26]
 802e5d4:	6822      	ldr	r2, [r4, #0]
 802e5d6:	7553      	strb	r3, [r2, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 802e5d8:	7ee3      	ldrb	r3, [r4, #27]
 802e5da:	6822      	ldr	r2, [r4, #0]
 802e5dc:	7593      	strb	r3, [r2, #22]

    macMsg->BufSize = bufItr;
 802e5de:	2317      	movs	r3, #23
 802e5e0:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 802e5e2:	2000      	movs	r0, #0
}
 802e5e4:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 802e5e6:	2001      	movs	r0, #1
 802e5e8:	e7fc      	b.n	802e5e4 <LoRaMacSerializerJoinRequest+0x5e>
 802e5ea:	2001      	movs	r0, #1
 802e5ec:	e7fa      	b.n	802e5e4 <LoRaMacSerializerJoinRequest+0x5e>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 802e5ee:	2002      	movs	r0, #2
 802e5f0:	e7f8      	b.n	802e5e4 <LoRaMacSerializerJoinRequest+0x5e>

0802e5f2 <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 802e5f2:	b570      	push	{r4, r5, r6, lr}
 802e5f4:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802e5f6:	d100      	bne.n	802e5fa <LoRaMacSerializerData+0x8>
 802e5f8:	e067      	b.n	802e6ca <LoRaMacSerializerData+0xd8>
 802e5fa:	6801      	ldr	r1, [r0, #0]
 802e5fc:	2900      	cmp	r1, #0
 802e5fe:	d066      	beq.n	802e6ce <LoRaMacSerializerData+0xdc>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 802e600:	7b02      	ldrb	r2, [r0, #12]
 802e602:	0712      	lsls	r2, r2, #28
 802e604:	0f12      	lsrs	r2, r2, #28
 802e606:	0010      	movs	r0, r2
 802e608:	3008      	adds	r0, #8

    if( macMsg->FRMPayloadSize > 0 )
 802e60a:	2328      	movs	r3, #40	; 0x28
 802e60c:	5ce3      	ldrb	r3, [r4, r3]
 802e60e:	2b00      	cmp	r3, #0
 802e610:	d001      	beq.n	802e616 <LoRaMacSerializerData+0x24>
    {
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 802e612:	3209      	adds	r2, #9
 802e614:	0010      	movs	r0, r2
    }

    computedBufSize += macMsg->FRMPayloadSize;
 802e616:	181b      	adds	r3, r3, r0
 802e618:	b29b      	uxth	r3, r3
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 802e61a:	3304      	adds	r3, #4
 802e61c:	b29b      	uxth	r3, r3

    if( macMsg->BufSize < computedBufSize )
 802e61e:	7922      	ldrb	r2, [r4, #4]
 802e620:	429a      	cmp	r2, r3
 802e622:	d356      	bcc.n	802e6d2 <LoRaMacSerializerData+0xe0>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 802e624:	7963      	ldrb	r3, [r4, #5]
 802e626:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 802e628:	68a3      	ldr	r3, [r4, #8]
 802e62a:	6822      	ldr	r2, [r4, #0]
 802e62c:	7053      	strb	r3, [r2, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 802e62e:	68a3      	ldr	r3, [r4, #8]
 802e630:	0a1b      	lsrs	r3, r3, #8
 802e632:	6822      	ldr	r2, [r4, #0]
 802e634:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 802e636:	8963      	ldrh	r3, [r4, #10]
 802e638:	6822      	ldr	r2, [r4, #0]
 802e63a:	70d3      	strb	r3, [r2, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 802e63c:	7ae3      	ldrb	r3, [r4, #11]
 802e63e:	6822      	ldr	r2, [r4, #0]
 802e640:	7113      	strb	r3, [r2, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 802e642:	7b23      	ldrb	r3, [r4, #12]
 802e644:	6822      	ldr	r2, [r4, #0]
 802e646:	7153      	strb	r3, [r2, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 802e648:	89e3      	ldrh	r3, [r4, #14]
 802e64a:	6822      	ldr	r2, [r4, #0]
 802e64c:	7193      	strb	r3, [r2, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 802e64e:	89e3      	ldrh	r3, [r4, #14]
 802e650:	0a1b      	lsrs	r3, r3, #8
 802e652:	6822      	ldr	r2, [r4, #0]
 802e654:	71d3      	strb	r3, [r2, #7]

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 802e656:	0021      	movs	r1, r4
 802e658:	3110      	adds	r1, #16
 802e65a:	7b22      	ldrb	r2, [r4, #12]
 802e65c:	0712      	lsls	r2, r2, #28
 802e65e:	0f12      	lsrs	r2, r2, #28
 802e660:	6820      	ldr	r0, [r4, #0]
 802e662:	3008      	adds	r0, #8
 802e664:	f003 f899 	bl	803179a <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 802e668:	7b23      	ldrb	r3, [r4, #12]
 802e66a:	071b      	lsls	r3, r3, #28
 802e66c:	0f1b      	lsrs	r3, r3, #28
 802e66e:	001d      	movs	r5, r3
 802e670:	3508      	adds	r5, #8

    if( macMsg->FRMPayloadSize > 0 )
 802e672:	2228      	movs	r2, #40	; 0x28
 802e674:	5ca2      	ldrb	r2, [r4, r2]
 802e676:	2a00      	cmp	r2, #0
 802e678:	d005      	beq.n	802e686 <LoRaMacSerializerData+0x94>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 802e67a:	2220      	movs	r2, #32
 802e67c:	5ca2      	ldrb	r2, [r4, r2]
 802e67e:	6821      	ldr	r1, [r4, #0]
 802e680:	554a      	strb	r2, [r1, r5]
 802e682:	3309      	adds	r3, #9
 802e684:	001d      	movs	r5, r3
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 802e686:	2628      	movs	r6, #40	; 0x28
 802e688:	5da2      	ldrb	r2, [r4, r6]
 802e68a:	6823      	ldr	r3, [r4, #0]
 802e68c:	1958      	adds	r0, r3, r5
 802e68e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 802e690:	f003 f883 	bl	803179a <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 802e694:	5da3      	ldrb	r3, [r4, r6]
 802e696:	195b      	adds	r3, r3, r5
 802e698:	b29b      	uxth	r3, r3

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 802e69a:	1c5a      	adds	r2, r3, #1
 802e69c:	b292      	uxth	r2, r2
 802e69e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802e6a0:	6820      	ldr	r0, [r4, #0]
 802e6a2:	54c1      	strb	r1, [r0, r3]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 802e6a4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802e6a6:	0a08      	lsrs	r0, r1, #8
 802e6a8:	1c99      	adds	r1, r3, #2
 802e6aa:	b289      	uxth	r1, r1
 802e6ac:	6825      	ldr	r5, [r4, #0]
 802e6ae:	54a8      	strb	r0, [r5, r2]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 802e6b0:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 802e6b2:	1cda      	adds	r2, r3, #3
 802e6b4:	b292      	uxth	r2, r2
 802e6b6:	6825      	ldr	r5, [r4, #0]
 802e6b8:	5468      	strb	r0, [r5, r1]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 802e6ba:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802e6bc:	0e09      	lsrs	r1, r1, #24
 802e6be:	3304      	adds	r3, #4
 802e6c0:	6820      	ldr	r0, [r4, #0]
 802e6c2:	5481      	strb	r1, [r0, r2]

    macMsg->BufSize = bufItr;
 802e6c4:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 802e6c6:	2000      	movs	r0, #0
}
 802e6c8:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 802e6ca:	2001      	movs	r0, #1
 802e6cc:	e7fc      	b.n	802e6c8 <LoRaMacSerializerData+0xd6>
 802e6ce:	2001      	movs	r0, #1
 802e6d0:	e7fa      	b.n	802e6c8 <LoRaMacSerializerData+0xd6>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 802e6d2:	2002      	movs	r0, #2
 802e6d4:	e7f8      	b.n	802e6c8 <LoRaMacSerializerData+0xd6>

0802e6d6 <NvmDataMgmtEvent>:
void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags = notifyFlags;
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 802e6d6:	4770      	bx	lr

0802e6d8 <NvmDataMgmtStore>:
    LoRaMacStart( );
    return dataSize;
#else
    return 0;
#endif
}
 802e6d8:	2000      	movs	r0, #0
 802e6da:	4770      	bx	lr

0802e6dc <NvmDataMgmtRestore>:
    {
        return sizeof( LoRaMacNvmData_t );
    }
#endif
    return 0;
}
 802e6dc:	2000      	movs	r0, #0
 802e6de:	4770      	bx	lr

0802e6e0 <RegionIsActive>:
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
    switch( region )
 802e6e0:	2805      	cmp	r0, #5
 802e6e2:	d005      	beq.n	802e6f0 <RegionIsActive+0x10>
 802e6e4:	2808      	cmp	r0, #8
 802e6e6:	d001      	beq.n	802e6ec <RegionIsActive+0xc>
        IN865_IS_ACTIVE( );
        US915_IS_ACTIVE( );
        RU864_IS_ACTIVE( );
        default:
        {
            return false;
 802e6e8:	2000      	movs	r0, #0
        }
    }
}
 802e6ea:	4770      	bx	lr
    switch( region )
 802e6ec:	3807      	subs	r0, #7
 802e6ee:	e7fc      	b.n	802e6ea <RegionIsActive+0xa>
 802e6f0:	2001      	movs	r0, #1
 802e6f2:	e7fa      	b.n	802e6ea <RegionIsActive+0xa>

0802e6f4 <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 802e6f4:	b500      	push	{lr}
 802e6f6:	b083      	sub	sp, #12
 802e6f8:	0003      	movs	r3, r0
 802e6fa:	0008      	movs	r0, r1
    PhyParam_t phyParam = { 0 };
 802e6fc:	2200      	movs	r2, #0
 802e6fe:	9200      	str	r2, [sp, #0]
    switch( region )
 802e700:	2b05      	cmp	r3, #5
 802e702:	d004      	beq.n	802e70e <RegionGetPhyParam+0x1a>
 802e704:	2b08      	cmp	r3, #8
 802e706:	d008      	beq.n	802e71a <RegionGetPhyParam+0x26>
        IN865_GET_PHY_PARAM( );
        US915_GET_PHY_PARAM( );
        RU864_GET_PHY_PARAM( );
        default:
        {
            return phyParam;
 802e708:	9b00      	ldr	r3, [sp, #0]
 802e70a:	9301      	str	r3, [sp, #4]
 802e70c:	e002      	b.n	802e714 <RegionGetPhyParam+0x20>
        EU868_GET_PHY_PARAM( );
 802e70e:	f000 fe27 	bl	802f360 <RegionEU868GetPhyParam>
 802e712:	9001      	str	r0, [sp, #4]
        }
    }
}
 802e714:	9801      	ldr	r0, [sp, #4]
 802e716:	b003      	add	sp, #12
 802e718:	bd00      	pop	{pc}
        US915_GET_PHY_PARAM( );
 802e71a:	f001 fc5d 	bl	802ffd8 <RegionUS915GetPhyParam>
 802e71e:	9001      	str	r0, [sp, #4]
 802e720:	e7f8      	b.n	802e714 <RegionGetPhyParam+0x20>

0802e722 <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 802e722:	b510      	push	{r4, lr}
 802e724:	0003      	movs	r3, r0
 802e726:	0008      	movs	r0, r1
    switch( region )
 802e728:	2b05      	cmp	r3, #5
 802e72a:	d002      	beq.n	802e732 <RegionSetBandTxDone+0x10>
 802e72c:	2b08      	cmp	r3, #8
 802e72e:	d003      	beq.n	802e738 <RegionSetBandTxDone+0x16>
        default:
        {
            return;
        }
    }
}
 802e730:	bd10      	pop	{r4, pc}
        EU868_SET_BAND_TX_DONE( );
 802e732:	f000 fec9 	bl	802f4c8 <RegionEU868SetBandTxDone>
 802e736:	e7fb      	b.n	802e730 <RegionSetBandTxDone+0xe>
        US915_SET_BAND_TX_DONE( );
 802e738:	f001 fd12 	bl	8030160 <RegionUS915SetBandTxDone>
 802e73c:	e7f8      	b.n	802e730 <RegionSetBandTxDone+0xe>

0802e73e <RegionInitDefaults>:

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 802e73e:	b510      	push	{r4, lr}
 802e740:	0003      	movs	r3, r0
 802e742:	0008      	movs	r0, r1
    switch( region )
 802e744:	2b05      	cmp	r3, #5
 802e746:	d002      	beq.n	802e74e <RegionInitDefaults+0x10>
 802e748:	2b08      	cmp	r3, #8
 802e74a:	d003      	beq.n	802e754 <RegionInitDefaults+0x16>
        default:
        {
            break;
        }
    }
}
 802e74c:	bd10      	pop	{r4, pc}
        EU868_INIT_DEFAULTS( );
 802e74e:	f000 fed9 	bl	802f504 <RegionEU868InitDefaults>
 802e752:	e7fb      	b.n	802e74c <RegionInitDefaults+0xe>
        US915_INIT_DEFAULTS( );
 802e754:	f001 fd22 	bl	803019c <RegionUS915InitDefaults>
}
 802e758:	e7f8      	b.n	802e74c <RegionInitDefaults+0xe>

0802e75a <RegionVerify>:

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 802e75a:	b510      	push	{r4, lr}
 802e75c:	0003      	movs	r3, r0
 802e75e:	0008      	movs	r0, r1
 802e760:	0011      	movs	r1, r2
    switch( region )
 802e762:	2b05      	cmp	r3, #5
 802e764:	d003      	beq.n	802e76e <RegionVerify+0x14>
 802e766:	2b08      	cmp	r3, #8
 802e768:	d004      	beq.n	802e774 <RegionVerify+0x1a>
 802e76a:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802e76c:	bd10      	pop	{r4, pc}
        EU868_VERIFY( );
 802e76e:	f000 ff33 	bl	802f5d8 <RegionEU868Verify>
 802e772:	e7fb      	b.n	802e76c <RegionVerify+0x12>
        US915_VERIFY( );
 802e774:	f001 fdc4 	bl	8030300 <RegionUS915Verify>
 802e778:	e7f8      	b.n	802e76c <RegionVerify+0x12>

0802e77a <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 802e77a:	b510      	push	{r4, lr}
 802e77c:	0003      	movs	r3, r0
 802e77e:	0008      	movs	r0, r1
    switch( region )
 802e780:	2b05      	cmp	r3, #5
 802e782:	d002      	beq.n	802e78a <RegionApplyCFList+0x10>
 802e784:	2b08      	cmp	r3, #8
 802e786:	d003      	beq.n	802e790 <RegionApplyCFList+0x16>
        default:
        {
            break;
        }
    }
}
 802e788:	bd10      	pop	{r4, pc}
        EU868_APPLY_CF_LIST( );
 802e78a:	f001 fb1d 	bl	802fdc8 <RegionEU868ApplyCFList>
 802e78e:	e7fb      	b.n	802e788 <RegionApplyCFList+0xe>
        US915_APPLY_CF_LIST( );
 802e790:	f001 fdea 	bl	8030368 <RegionUS915ApplyCFList>
}
 802e794:	e7f8      	b.n	802e788 <RegionApplyCFList+0xe>

0802e796 <RegionChanMaskSet>:

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 802e796:	b510      	push	{r4, lr}
 802e798:	0003      	movs	r3, r0
 802e79a:	0008      	movs	r0, r1
    switch( region )
 802e79c:	2b05      	cmp	r3, #5
 802e79e:	d003      	beq.n	802e7a8 <RegionChanMaskSet+0x12>
 802e7a0:	2b08      	cmp	r3, #8
 802e7a2:	d004      	beq.n	802e7ae <RegionChanMaskSet+0x18>
 802e7a4:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802e7a6:	bd10      	pop	{r4, pc}
        EU868_CHAN_MASK_SET( );
 802e7a8:	f000 ff56 	bl	802f658 <RegionEU868ChanMaskSet>
 802e7ac:	e7fb      	b.n	802e7a6 <RegionChanMaskSet+0x10>
        US915_CHAN_MASK_SET( );
 802e7ae:	f001 fe15 	bl	80303dc <RegionUS915ChanMaskSet>
 802e7b2:	e7f8      	b.n	802e7a6 <RegionChanMaskSet+0x10>

0802e7b4 <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 802e7b4:	b510      	push	{r4, lr}
 802e7b6:	0004      	movs	r4, r0
 802e7b8:	0008      	movs	r0, r1
 802e7ba:	0011      	movs	r1, r2
 802e7bc:	001a      	movs	r2, r3
    switch( region )
 802e7be:	2c05      	cmp	r4, #5
 802e7c0:	d002      	beq.n	802e7c8 <RegionComputeRxWindowParameters+0x14>
 802e7c2:	2c08      	cmp	r4, #8
 802e7c4:	d004      	beq.n	802e7d0 <RegionComputeRxWindowParameters+0x1c>
        default:
        {
            break;
        }
    }
}
 802e7c6:	bd10      	pop	{r4, pc}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 802e7c8:	9b02      	ldr	r3, [sp, #8]
 802e7ca:	f000 ff69 	bl	802f6a0 <RegionEU868ComputeRxWindowParameters>
 802e7ce:	e7fa      	b.n	802e7c6 <RegionComputeRxWindowParameters+0x12>
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
 802e7d0:	9b02      	ldr	r3, [sp, #8]
 802e7d2:	f001 fe51 	bl	8030478 <RegionUS915ComputeRxWindowParameters>
}
 802e7d6:	e7f6      	b.n	802e7c6 <RegionComputeRxWindowParameters+0x12>

0802e7d8 <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 802e7d8:	b510      	push	{r4, lr}
 802e7da:	0003      	movs	r3, r0
 802e7dc:	0008      	movs	r0, r1
 802e7de:	0011      	movs	r1, r2
    switch( region )
 802e7e0:	2b05      	cmp	r3, #5
 802e7e2:	d003      	beq.n	802e7ec <RegionRxConfig+0x14>
 802e7e4:	2b08      	cmp	r3, #8
 802e7e6:	d004      	beq.n	802e7f2 <RegionRxConfig+0x1a>
 802e7e8:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802e7ea:	bd10      	pop	{r4, pc}
        EU868_RX_CONFIG( );
 802e7ec:	f000 ff90 	bl	802f710 <RegionEU868RxConfig>
 802e7f0:	e7fb      	b.n	802e7ea <RegionRxConfig+0x12>
        US915_RX_CONFIG( );
 802e7f2:	f001 fe71 	bl	80304d8 <RegionUS915RxConfig>
 802e7f6:	e7f8      	b.n	802e7ea <RegionRxConfig+0x12>

0802e7f8 <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 802e7f8:	b510      	push	{r4, lr}
 802e7fa:	0004      	movs	r4, r0
 802e7fc:	0008      	movs	r0, r1
 802e7fe:	0011      	movs	r1, r2
 802e800:	001a      	movs	r2, r3
    switch( region )
 802e802:	2c05      	cmp	r4, #5
 802e804:	d003      	beq.n	802e80e <RegionTxConfig+0x16>
 802e806:	2c08      	cmp	r4, #8
 802e808:	d004      	beq.n	802e814 <RegionTxConfig+0x1c>
 802e80a:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802e80c:	bd10      	pop	{r4, pc}
        EU868_TX_CONFIG( );
 802e80e:	f001 f809 	bl	802f824 <RegionEU868TxConfig>
 802e812:	e7fb      	b.n	802e80c <RegionTxConfig+0x14>
        US915_TX_CONFIG( );
 802e814:	f001 fec0 	bl	8030598 <RegionUS915TxConfig>
 802e818:	e7f8      	b.n	802e80c <RegionTxConfig+0x14>

0802e81a <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 802e81a:	b510      	push	{r4, lr}
 802e81c:	b082      	sub	sp, #8
 802e81e:	0004      	movs	r4, r0
 802e820:	0008      	movs	r0, r1
 802e822:	0011      	movs	r1, r2
 802e824:	001a      	movs	r2, r3
    switch( region )
 802e826:	2c05      	cmp	r4, #5
 802e828:	d004      	beq.n	802e834 <RegionLinkAdrReq+0x1a>
 802e82a:	2c08      	cmp	r4, #8
 802e82c:	d008      	beq.n	802e840 <RegionLinkAdrReq+0x26>
 802e82e:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802e830:	b002      	add	sp, #8
 802e832:	bd10      	pop	{r4, pc}
        EU868_LINK_ADR_REQ( );
 802e834:	9b05      	ldr	r3, [sp, #20]
 802e836:	9300      	str	r3, [sp, #0]
 802e838:	9b04      	ldr	r3, [sp, #16]
 802e83a:	f001 f895 	bl	802f968 <RegionEU868LinkAdrReq>
 802e83e:	e7f7      	b.n	802e830 <RegionLinkAdrReq+0x16>
        US915_LINK_ADR_REQ( );
 802e840:	9b05      	ldr	r3, [sp, #20]
 802e842:	9300      	str	r3, [sp, #0]
 802e844:	9b04      	ldr	r3, [sp, #16]
 802e846:	f001 ff27 	bl	8030698 <RegionUS915LinkAdrReq>
 802e84a:	e7f1      	b.n	802e830 <RegionLinkAdrReq+0x16>

0802e84c <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 802e84c:	b510      	push	{r4, lr}
 802e84e:	0003      	movs	r3, r0
 802e850:	0008      	movs	r0, r1
    switch( region )
 802e852:	2b05      	cmp	r3, #5
 802e854:	d003      	beq.n	802e85e <RegionRxParamSetupReq+0x12>
 802e856:	2b08      	cmp	r3, #8
 802e858:	d004      	beq.n	802e864 <RegionRxParamSetupReq+0x18>
 802e85a:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802e85c:	bd10      	pop	{r4, pc}
        EU868_RX_PARAM_SETUP_REQ( );
 802e85e:	f001 f94b 	bl	802faf8 <RegionEU868RxParamSetupReq>
 802e862:	e7fb      	b.n	802e85c <RegionRxParamSetupReq+0x10>
        US915_RX_PARAM_SETUP_REQ( );
 802e864:	f002 f866 	bl	8030934 <RegionUS915RxParamSetupReq>
 802e868:	e7f8      	b.n	802e85c <RegionRxParamSetupReq+0x10>

0802e86a <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 802e86a:	b510      	push	{r4, lr}
 802e86c:	0003      	movs	r3, r0
 802e86e:	0008      	movs	r0, r1
    switch( region )
 802e870:	2b05      	cmp	r3, #5
 802e872:	d003      	beq.n	802e87c <RegionNewChannelReq+0x12>
 802e874:	2b08      	cmp	r3, #8
 802e876:	d004      	beq.n	802e882 <RegionNewChannelReq+0x18>
 802e878:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802e87a:	bd10      	pop	{r4, pc}
        EU868_NEW_CHANNEL_REQ( );
 802e87c:	f001 fae2 	bl	802fe44 <RegionEU868NewChannelReq>
 802e880:	e7fb      	b.n	802e87a <RegionNewChannelReq+0x10>
        US915_NEW_CHANNEL_REQ( );
 802e882:	f002 f885 	bl	8030990 <RegionUS915NewChannelReq>
 802e886:	e7f8      	b.n	802e87a <RegionNewChannelReq+0x10>

0802e888 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 802e888:	b510      	push	{r4, lr}
 802e88a:	0003      	movs	r3, r0
 802e88c:	0008      	movs	r0, r1
    switch( region )
 802e88e:	2b05      	cmp	r3, #5
 802e890:	d003      	beq.n	802e89a <RegionTxParamSetupReq+0x12>
 802e892:	2b08      	cmp	r3, #8
 802e894:	d004      	beq.n	802e8a0 <RegionTxParamSetupReq+0x18>
 802e896:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802e898:	bd10      	pop	{r4, pc}
        EU868_TX_PARAM_SETUP_REQ( );
 802e89a:	f001 f953 	bl	802fb44 <RegionEU868TxParamSetupReq>
 802e89e:	e7fb      	b.n	802e898 <RegionTxParamSetupReq+0x10>
        US915_TX_PARAM_SETUP_REQ( );
 802e8a0:	f002 f879 	bl	8030996 <RegionUS915TxParamSetupReq>
 802e8a4:	e7f8      	b.n	802e898 <RegionTxParamSetupReq+0x10>

0802e8a6 <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 802e8a6:	b510      	push	{r4, lr}
 802e8a8:	0003      	movs	r3, r0
 802e8aa:	0008      	movs	r0, r1
    switch( region )
 802e8ac:	2b05      	cmp	r3, #5
 802e8ae:	d003      	beq.n	802e8b8 <RegionDlChannelReq+0x12>
 802e8b0:	2b08      	cmp	r3, #8
 802e8b2:	d004      	beq.n	802e8be <RegionDlChannelReq+0x18>
 802e8b4:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802e8b6:	bd10      	pop	{r4, pc}
        EU868_DL_CHANNEL_REQ( );
 802e8b8:	f001 f948 	bl	802fb4c <RegionEU868DlChannelReq>
 802e8bc:	e7fb      	b.n	802e8b6 <RegionDlChannelReq+0x10>
        US915_DL_CHANNEL_REQ( );
 802e8be:	f002 f86d 	bl	803099c <RegionUS915DlChannelReq>
 802e8c2:	e7f8      	b.n	802e8b6 <RegionDlChannelReq+0x10>

0802e8c4 <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 802e8c4:	b510      	push	{r4, lr}
 802e8c6:	0003      	movs	r3, r0
 802e8c8:	0008      	movs	r0, r1
 802e8ca:	0011      	movs	r1, r2
    switch( region )
 802e8cc:	2b05      	cmp	r3, #5
 802e8ce:	d003      	beq.n	802e8d8 <RegionAlternateDr+0x14>
 802e8d0:	2b08      	cmp	r3, #8
 802e8d2:	d004      	beq.n	802e8de <RegionAlternateDr+0x1a>
 802e8d4:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802e8d6:	bd10      	pop	{r4, pc}
        EU868_ALTERNATE_DR( );
 802e8d8:	f001 f960 	bl	802fb9c <RegionEU868AlternateDr>
 802e8dc:	e7fb      	b.n	802e8d6 <RegionAlternateDr+0x12>
        US915_ALTERNATE_DR( );
 802e8de:	f002 f861 	bl	80309a4 <RegionUS915AlternateDr>
 802e8e2:	e7f8      	b.n	802e8d6 <RegionAlternateDr+0x12>

0802e8e4 <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 802e8e4:	b510      	push	{r4, lr}
 802e8e6:	0004      	movs	r4, r0
 802e8e8:	0008      	movs	r0, r1
 802e8ea:	0011      	movs	r1, r2
 802e8ec:	001a      	movs	r2, r3
    switch( region )
 802e8ee:	2c05      	cmp	r4, #5
 802e8f0:	d003      	beq.n	802e8fa <RegionNextChannel+0x16>
 802e8f2:	2c08      	cmp	r4, #8
 802e8f4:	d005      	beq.n	802e902 <RegionNextChannel+0x1e>
 802e8f6:	2009      	movs	r0, #9
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 802e8f8:	bd10      	pop	{r4, pc}
        EU868_NEXT_CHANNEL( );
 802e8fa:	9b02      	ldr	r3, [sp, #8]
 802e8fc:	f001 f950 	bl	802fba0 <RegionEU868NextChannel>
 802e900:	e7fa      	b.n	802e8f8 <RegionNextChannel+0x14>
        US915_NEXT_CHANNEL( );
 802e902:	9b02      	ldr	r3, [sp, #8]
 802e904:	f002 f86e 	bl	80309e4 <RegionUS915NextChannel>
 802e908:	e7f6      	b.n	802e8f8 <RegionNextChannel+0x14>

0802e90a <RegionSetContinuousWave>:
        }
    }
}

void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
 802e90a:	b510      	push	{r4, lr}
 802e90c:	0003      	movs	r3, r0
 802e90e:	0008      	movs	r0, r1
    switch( region )
 802e910:	2b05      	cmp	r3, #5
 802e912:	d002      	beq.n	802e91a <RegionSetContinuousWave+0x10>
 802e914:	2b08      	cmp	r3, #8
 802e916:	d003      	beq.n	802e920 <RegionSetContinuousWave+0x16>
        default:
        {
            break;
        }
    }
}
 802e918:	bd10      	pop	{r4, pc}
        EU868_SET_CONTINUOUS_WAVE( );
 802e91a:	f001 fabf 	bl	802fe9c <RegionEU868SetContinuousWave>
 802e91e:	e7fb      	b.n	802e918 <RegionSetContinuousWave+0xe>
        US915_SET_CONTINUOUS_WAVE( );
 802e920:	f002 f916 	bl	8030b50 <RegionUS915SetContinuousWave>
}
 802e924:	e7f8      	b.n	802e918 <RegionSetContinuousWave+0xe>

0802e926 <RegionApplyDrOffset>:

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 802e926:	b510      	push	{r4, lr}
 802e928:	0004      	movs	r4, r0
 802e92a:	0008      	movs	r0, r1
 802e92c:	0011      	movs	r1, r2
 802e92e:	001a      	movs	r2, r3
    switch( region )
 802e930:	2c05      	cmp	r4, #5
 802e932:	d003      	beq.n	802e93c <RegionApplyDrOffset+0x16>
 802e934:	2c08      	cmp	r4, #8
 802e936:	d004      	beq.n	802e942 <RegionApplyDrOffset+0x1c>
        IN865_APPLY_DR_OFFSET( );
        US915_APPLY_DR_OFFSET( );
        RU864_APPLY_DR_OFFSET( );
        default:
        {
            return dr;
 802e938:	b2c8      	uxtb	r0, r1
 802e93a:	e001      	b.n	802e940 <RegionApplyDrOffset+0x1a>
        EU868_APPLY_DR_OFFSET( );
 802e93c:	f001 fadc 	bl	802fef8 <RegionEU868ApplyDrOffset>
        }
    }
}
 802e940:	bd10      	pop	{r4, pc}
        US915_APPLY_DR_OFFSET( );
 802e942:	f002 f93b 	bl	8030bbc <RegionUS915ApplyDrOffset>
 802e946:	e7fb      	b.n	802e940 <RegionApplyDrOffset+0x1a>

0802e948 <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 802e948:	4800      	ldr	r0, [pc, #0]	; (802e94c <RegionGetVersion+0x4>)
 802e94a:	4770      	bx	lr
 802e94c:	01000300 	.word	0x01000300

0802e950 <FindAvailable125kHzChannels>:
 *
 * \retval Status
 */
static LoRaMacStatus_t FindAvailable125kHzChannels( uint16_t currentChannelMaskLeft,
                                                    uint8_t* findAvailableChannelsIndex, uint8_t* availableChannels )
{
 802e950:	b510      	push	{r4, lr}
    // Nullpointer check
    if( findAvailableChannelsIndex == NULL || availableChannels == NULL )
 802e952:	2900      	cmp	r1, #0
 802e954:	d014      	beq.n	802e980 <FindAvailable125kHzChannels+0x30>
 802e956:	2a00      	cmp	r2, #0
 802e958:	d014      	beq.n	802e984 <FindAvailable125kHzChannels+0x34>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // Initialize counter
    *availableChannels = 0;
 802e95a:	2300      	movs	r3, #0
 802e95c:	7013      	strb	r3, [r2, #0]
    for( uint8_t i = 0; i < 8; i++ )
 802e95e:	e001      	b.n	802e964 <FindAvailable125kHzChannels+0x14>
 802e960:	3301      	adds	r3, #1
 802e962:	b2db      	uxtb	r3, r3
 802e964:	2b07      	cmp	r3, #7
 802e966:	d809      	bhi.n	802e97c <FindAvailable125kHzChannels+0x2c>
    {
        // Find available channels
        if( ( currentChannelMaskLeft & ( 1 << i ) ) != 0 )
 802e968:	0004      	movs	r4, r0
 802e96a:	411c      	asrs	r4, r3
 802e96c:	07e4      	lsls	r4, r4, #31
 802e96e:	d5f7      	bpl.n	802e960 <FindAvailable125kHzChannels+0x10>
        {
            // Save available channel index
            findAvailableChannelsIndex[*availableChannels] = i;
 802e970:	7814      	ldrb	r4, [r2, #0]
 802e972:	550b      	strb	r3, [r1, r4]
            // Increment counter of available channels if the current channel is available
            ( *availableChannels )++;
 802e974:	7814      	ldrb	r4, [r2, #0]
 802e976:	3401      	adds	r4, #1
 802e978:	7014      	strb	r4, [r2, #0]
 802e97a:	e7f1      	b.n	802e960 <FindAvailable125kHzChannels+0x10>
        }
    }

    return LORAMAC_STATUS_OK;
 802e97c:	2000      	movs	r0, #0
}
 802e97e:	bd10      	pop	{r4, pc}
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802e980:	2003      	movs	r0, #3
 802e982:	e7fc      	b.n	802e97e <FindAvailable125kHzChannels+0x2e>
 802e984:	2003      	movs	r0, #3
 802e986:	e7fa      	b.n	802e97e <FindAvailable125kHzChannels+0x2e>

0802e988 <RegionBaseUSComputeNext125kHzJoinChannel>:

LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                          uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
{
 802e988:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e98a:	b085      	sub	sp, #20
 802e98c:	0006      	movs	r6, r0
 802e98e:	000d      	movs	r5, r1
 802e990:	0017      	movs	r7, r2
    uint8_t currentChannelMaskLeftIndex;
    uint16_t currentChannelMaskLeft;
    uint8_t findAvailableChannelsIndex[8] = { 0 };
 802e992:	2300      	movs	r3, #0
 802e994:	9302      	str	r3, [sp, #8]
 802e996:	9303      	str	r3, [sp, #12]
    uint8_t availableChannels = 0;
 802e998:	466a      	mov	r2, sp
 802e99a:	71d3      	strb	r3, [r2, #7]
    uint8_t startIndex;

    // Null pointer check
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 802e99c:	2800      	cmp	r0, #0
 802e99e:	d03b      	beq.n	802ea18 <RegionBaseUSComputeNext125kHzJoinChannel+0x90>
 802e9a0:	2900      	cmp	r1, #0
 802e9a2:	d03b      	beq.n	802ea1c <RegionBaseUSComputeNext125kHzJoinChannel+0x94>
 802e9a4:	2f00      	cmp	r7, #0
 802e9a6:	d03b      	beq.n	802ea20 <RegionBaseUSComputeNext125kHzJoinChannel+0x98>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // copy the current index.
    startIndex = *groupsCurrentIndex;
 802e9a8:	780c      	ldrb	r4, [r1, #0]
 802e9aa:	e015      	b.n	802e9d8 <RegionBaseUSComputeNext125kHzJoinChannel+0x50>
        {
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
        }
        else
        {
            currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
 802e9ac:	005b      	lsls	r3, r3, #1
 802e9ae:	5b98      	ldrh	r0, [r3, r6]
 802e9b0:	0a00      	lsrs	r0, r0, #8
 802e9b2:	e018      	b.n	802e9e6 <RegionBaseUSComputeNext125kHzJoinChannel+0x5e>
        }

        if ( availableChannels > 0 )
        {
            // Choose randomly a free channel 125kHz
            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
 802e9b4:	3901      	subs	r1, #1
 802e9b6:	2000      	movs	r0, #0
 802e9b8:	f002 fee4 	bl	8031784 <randr>
 802e9bc:	ab02      	add	r3, sp, #8
 802e9be:	5c1b      	ldrb	r3, [r3, r0]
 802e9c0:	00e2      	lsls	r2, r4, #3
 802e9c2:	189b      	adds	r3, r3, r2
 802e9c4:	703b      	strb	r3, [r7, #0]
 802e9c6:	e019      	b.n	802e9fc <RegionBaseUSComputeNext125kHzJoinChannel+0x74>
        startIndex++;
        if ( startIndex > 7 )
        {
            startIndex = 0;
        }
    } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 802e9c8:	466b      	mov	r3, sp
 802e9ca:	3307      	adds	r3, #7
 802e9cc:	781b      	ldrb	r3, [r3, #0]
 802e9ce:	2b00      	cmp	r3, #0
 802e9d0:	d11a      	bne.n	802ea08 <RegionBaseUSComputeNext125kHzJoinChannel+0x80>
 802e9d2:	782a      	ldrb	r2, [r5, #0]
 802e9d4:	42a2      	cmp	r2, r4
 802e9d6:	d017      	beq.n	802ea08 <RegionBaseUSComputeNext125kHzJoinChannel+0x80>
        currentChannelMaskLeftIndex = (uint8_t) startIndex / 2;
 802e9d8:	0863      	lsrs	r3, r4, #1
        if( ( startIndex % 2 ) == 0 )
 802e9da:	07e2      	lsls	r2, r4, #31
 802e9dc:	d4e6      	bmi.n	802e9ac <RegionBaseUSComputeNext125kHzJoinChannel+0x24>
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 802e9de:	005b      	lsls	r3, r3, #1
 802e9e0:	5b9b      	ldrh	r3, [r3, r6]
 802e9e2:	20ff      	movs	r0, #255	; 0xff
 802e9e4:	4018      	ands	r0, r3
        if( FindAvailable125kHzChannels( currentChannelMaskLeft, findAvailableChannelsIndex, &availableChannels ) == LORAMAC_STATUS_PARAMETER_INVALID )
 802e9e6:	466b      	mov	r3, sp
 802e9e8:	1dda      	adds	r2, r3, #7
 802e9ea:	a902      	add	r1, sp, #8
 802e9ec:	f7ff ffb0 	bl	802e950 <FindAvailable125kHzChannels>
 802e9f0:	2803      	cmp	r0, #3
 802e9f2:	d00c      	beq.n	802ea0e <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
        if ( availableChannels > 0 )
 802e9f4:	466b      	mov	r3, sp
 802e9f6:	79d9      	ldrb	r1, [r3, #7]
 802e9f8:	2900      	cmp	r1, #0
 802e9fa:	d1db      	bne.n	802e9b4 <RegionBaseUSComputeNext125kHzJoinChannel+0x2c>
        startIndex++;
 802e9fc:	3401      	adds	r4, #1
 802e9fe:	b2e4      	uxtb	r4, r4
        if ( startIndex > 7 )
 802ea00:	2c07      	cmp	r4, #7
 802ea02:	d9e1      	bls.n	802e9c8 <RegionBaseUSComputeNext125kHzJoinChannel+0x40>
            startIndex = 0;
 802ea04:	2400      	movs	r4, #0
 802ea06:	e7df      	b.n	802e9c8 <RegionBaseUSComputeNext125kHzJoinChannel+0x40>

    if ( availableChannels > 0 )
 802ea08:	2b00      	cmp	r3, #0
 802ea0a:	d102      	bne.n	802ea12 <RegionBaseUSComputeNext125kHzJoinChannel+0x8a>
    {
        *groupsCurrentIndex = startIndex;
        return LORAMAC_STATUS_OK;
    }

    return LORAMAC_STATUS_PARAMETER_INVALID;
 802ea0c:	2003      	movs	r0, #3
}
 802ea0e:	b005      	add	sp, #20
 802ea10:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *groupsCurrentIndex = startIndex;
 802ea12:	702c      	strb	r4, [r5, #0]
        return LORAMAC_STATUS_OK;
 802ea14:	2000      	movs	r0, #0
 802ea16:	e7fa      	b.n	802ea0e <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802ea18:	2003      	movs	r0, #3
 802ea1a:	e7f8      	b.n	802ea0e <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
 802ea1c:	2003      	movs	r0, #3
 802ea1e:	e7f6      	b.n	802ea0e <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
 802ea20:	2003      	movs	r0, #3
 802ea22:	e7f4      	b.n	802ea0e <RegionBaseUSComputeNext125kHzJoinChannel+0x86>

0802ea24 <RegionBaseUSCalcDownlinkFrequency>:

uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                            uint32_t stepwidth )
{
    // Calculate the frequency
    return frequency + ( channel * stepwidth );
 802ea24:	4350      	muls	r0, r2
 802ea26:	1840      	adds	r0, r0, r1
}
 802ea28:	4770      	bx	lr
	...

0802ea2c <GetDutyCycle>:
        ( ( ( N ) + ( D ) - 1 ) / ( D ) ) :                                    \
        ( ( N ) / ( D ) )                                                      \
    )

static uint16_t GetDutyCycle( Band_t* band, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 802ea2c:	b082      	sub	sp, #8
 802ea2e:	9200      	str	r2, [sp, #0]
    uint16_t dutyCycle = band->DCycle;
 802ea30:	8800      	ldrh	r0, [r0, #0]

    if( joined == false )
 802ea32:	2900      	cmp	r1, #0
 802ea34:	d110      	bne.n	802ea58 <GetDutyCycle+0x2c>
    {
        uint16_t joinDutyCycle = BACKOFF_DC_24_HOURS;

        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 802ea36:	0013      	movs	r3, r2
 802ea38:	22e1      	movs	r2, #225	; 0xe1
 802ea3a:	0112      	lsls	r2, r2, #4
 802ea3c:	4293      	cmp	r3, r2
 802ea3e:	d305      	bcc.n	802ea4c <GetDutyCycle+0x20>
        {
            joinDutyCycle = BACKOFF_DC_1_HOUR;
        }
        else if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_10_HOURS_IN_S )
 802ea40:	4a09      	ldr	r2, [pc, #36]	; (802ea68 <GetDutyCycle+0x3c>)
 802ea42:	4293      	cmp	r3, r2
 802ea44:	d80d      	bhi.n	802ea62 <GetDutyCycle+0x36>
        {
            joinDutyCycle = BACKOFF_DC_10_HOURS;
 802ea46:	23fa      	movs	r3, #250	; 0xfa
 802ea48:	009b      	lsls	r3, r3, #2
 802ea4a:	e000      	b.n	802ea4e <GetDutyCycle+0x22>
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 802ea4c:	2364      	movs	r3, #100	; 0x64
        else
        {
            joinDutyCycle = BACKOFF_DC_24_HOURS;
        }
        // Take the most restrictive duty cycle
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 802ea4e:	1c1a      	adds	r2, r3, #0
 802ea50:	4283      	cmp	r3, r0
 802ea52:	d200      	bcs.n	802ea56 <GetDutyCycle+0x2a>
 802ea54:	1c02      	adds	r2, r0, #0
 802ea56:	b290      	uxth	r0, r2
    }

    // Prevent value of 0
    if( dutyCycle == 0 )
 802ea58:	2800      	cmp	r0, #0
 802ea5a:	d100      	bne.n	802ea5e <GetDutyCycle+0x32>
    {
        dutyCycle = 1;
 802ea5c:	3001      	adds	r0, #1
    }

    return dutyCycle;
}
 802ea5e:	b002      	add	sp, #8
 802ea60:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 802ea62:	4b02      	ldr	r3, [pc, #8]	; (802ea6c <GetDutyCycle+0x40>)
 802ea64:	e7f3      	b.n	802ea4e <GetDutyCycle+0x22>
 802ea66:	46c0      	nop			; (mov r8, r8)
 802ea68:	00009aaf 	.word	0x00009aaf
 802ea6c:	00002710 	.word	0x00002710

0802ea70 <CountChannels>:

    return dutyCycle;
}

static uint8_t CountChannels( uint16_t mask, uint8_t nbBits )
{
 802ea70:	b530      	push	{r4, r5, lr}
 802ea72:	0005      	movs	r5, r0
    uint8_t nbActiveBits = 0;

    for( uint8_t j = 0; j < nbBits; j++ )
 802ea74:	2300      	movs	r3, #0
    uint8_t nbActiveBits = 0;
 802ea76:	2000      	movs	r0, #0
    for( uint8_t j = 0; j < nbBits; j++ )
 802ea78:	e001      	b.n	802ea7e <CountChannels+0xe>
 802ea7a:	3301      	adds	r3, #1
 802ea7c:	b2db      	uxtb	r3, r3
 802ea7e:	428b      	cmp	r3, r1
 802ea80:	d208      	bcs.n	802ea94 <CountChannels+0x24>
    {
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 802ea82:	2201      	movs	r2, #1
 802ea84:	409a      	lsls	r2, r3
 802ea86:	0014      	movs	r4, r2
 802ea88:	402c      	ands	r4, r5
 802ea8a:	42a2      	cmp	r2, r4
 802ea8c:	d1f5      	bne.n	802ea7a <CountChannels+0xa>
        {
            nbActiveBits++;
 802ea8e:	3001      	adds	r0, #1
 802ea90:	b2c0      	uxtb	r0, r0
 802ea92:	e7f2      	b.n	802ea7a <CountChannels+0xa>
        }
    }
    return nbActiveBits;
}
 802ea94:	bd30      	pop	{r4, r5, pc}
	...

0802ea98 <SetMaxTimeCredits>:
{
 802ea98:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ea9a:	46ce      	mov	lr, r9
 802ea9c:	b500      	push	{lr}
 802ea9e:	b08a      	sub	sp, #40	; 0x28
 802eaa0:	0004      	movs	r4, r0
 802eaa2:	000e      	movs	r6, r1
 802eaa4:	0010      	movs	r0, r2
 802eaa6:	9204      	str	r2, [sp, #16]
 802eaa8:	0019      	movs	r1, r3
 802eaaa:	9305      	str	r3, [sp, #20]
 802eaac:	ab10      	add	r3, sp, #64	; 0x40
 802eaae:	781f      	ldrb	r7, [r3, #0]
 802eab0:	ab11      	add	r3, sp, #68	; 0x44
 802eab2:	781b      	ldrb	r3, [r3, #0]
 802eab4:	4699      	mov	r9, r3
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 802eab6:	f005 fab3 	bl	8034020 <SysTimeToMs>
 802eaba:	9003      	str	r0, [sp, #12]
    dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 802eabc:	9a04      	ldr	r2, [sp, #16]
 802eabe:	9b05      	ldr	r3, [sp, #20]
 802eac0:	0031      	movs	r1, r6
 802eac2:	0020      	movs	r0, r4
 802eac4:	f7ff ffb2 	bl	802ea2c <GetDutyCycle>
 802eac8:	0005      	movs	r5, r0
    if( joined == false )
 802eaca:	2e00      	cmp	r6, #0
 802eacc:	d14f      	bne.n	802eb6e <SetMaxTimeCredits+0xd6>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 802eace:	2864      	cmp	r0, #100	; 0x64
 802ead0:	d027      	beq.n	802eb22 <SetMaxTimeCredits+0x8a>
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 802ead2:	22fa      	movs	r2, #250	; 0xfa
 802ead4:	0092      	lsls	r2, r2, #2
 802ead6:	4290      	cmp	r0, r2
 802ead8:	d027      	beq.n	802eb2a <SetMaxTimeCredits+0x92>
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 802eada:	4e28      	ldr	r6, [pc, #160]	; (802eb7c <SetMaxTimeCredits+0xe4>)
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 802eadc:	68a1      	ldr	r1, [r4, #8]
 802eade:	a808      	add	r0, sp, #32
 802eae0:	f005 fac0 	bl	8034064 <SysTimeFromMs>
 802eae4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802eae6:	9300      	str	r3, [sp, #0]
 802eae8:	9b08      	ldr	r3, [sp, #32]
 802eaea:	9904      	ldr	r1, [sp, #16]
 802eaec:	9a05      	ldr	r2, [sp, #20]
 802eaee:	a806      	add	r0, sp, #24
 802eaf0:	f005 fa26 	bl	8033f40 <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 802eaf4:	2f00      	cmp	r7, #0
 802eaf6:	d102      	bne.n	802eafe <SetMaxTimeCredits+0x66>
 802eaf8:	464b      	mov	r3, r9
 802eafa:	2b00      	cmp	r3, #0
 802eafc:	d002      	beq.n	802eb04 <SetMaxTimeCredits+0x6c>
 802eafe:	6923      	ldr	r3, [r4, #16]
 802eb00:	42b3      	cmp	r3, r6
 802eb02:	d016      	beq.n	802eb32 <SetMaxTimeCredits+0x9a>
            band->TimeCredits = maxCredits;
 802eb04:	60e6      	str	r6, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 802eb06:	9804      	ldr	r0, [sp, #16]
 802eb08:	4b1d      	ldr	r3, [pc, #116]	; (802eb80 <SetMaxTimeCredits+0xe8>)
 802eb0a:	4298      	cmp	r0, r3
 802eb0c:	d816      	bhi.n	802eb3c <SetMaxTimeCredits+0xa4>
    if( band->LastBandUpdateTime == 0 )
 802eb0e:	6863      	ldr	r3, [r4, #4]
 802eb10:	2b00      	cmp	r3, #0
 802eb12:	d100      	bne.n	802eb16 <SetMaxTimeCredits+0x7e>
        band->TimeCredits = maxCredits;
 802eb14:	60e6      	str	r6, [r4, #12]
    band->MaxTimeCredits = maxCredits;
 802eb16:	6126      	str	r6, [r4, #16]
}
 802eb18:	0028      	movs	r0, r5
 802eb1a:	b00a      	add	sp, #40	; 0x28
 802eb1c:	bc80      	pop	{r7}
 802eb1e:	46b9      	mov	r9, r7
 802eb20:	bdf0      	pop	{r4, r5, r6, r7, pc}
            band->LastMaxCreditAssignTime = elapsedTime;
 802eb22:	9b03      	ldr	r3, [sp, #12]
 802eb24:	60a3      	str	r3, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 802eb26:	4e17      	ldr	r6, [pc, #92]	; (802eb84 <SetMaxTimeCredits+0xec>)
 802eb28:	e7d8      	b.n	802eadc <SetMaxTimeCredits+0x44>
            band->LastMaxCreditAssignTime = elapsedTime;
 802eb2a:	9b03      	ldr	r3, [sp, #12]
 802eb2c:	60a3      	str	r3, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 802eb2e:	4e16      	ldr	r6, [pc, #88]	; (802eb88 <SetMaxTimeCredits+0xf0>)
 802eb30:	e7d4      	b.n	802eadc <SetMaxTimeCredits+0x44>
            ( band->MaxTimeCredits != maxCredits ) ||
 802eb32:	4b16      	ldr	r3, [pc, #88]	; (802eb8c <SetMaxTimeCredits+0xf4>)
 802eb34:	9a06      	ldr	r2, [sp, #24]
 802eb36:	429a      	cmp	r2, r3
 802eb38:	d9e9      	bls.n	802eb0e <SetMaxTimeCredits+0x76>
 802eb3a:	e7e3      	b.n	802eb04 <SetMaxTimeCredits+0x6c>
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 802eb3c:	4b14      	ldr	r3, [pc, #80]	; (802eb90 <SetMaxTimeCredits+0xf8>)
 802eb3e:	469c      	mov	ip, r3
 802eb40:	4460      	add	r0, ip
 802eb42:	4914      	ldr	r1, [pc, #80]	; (802eb94 <SetMaxTimeCredits+0xfc>)
 802eb44:	f7f1 fae8 	bl	8020118 <__udivsi3>
 802eb48:	0003      	movs	r3, r0
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 802eb4a:	0040      	lsls	r0, r0, #1
 802eb4c:	18c0      	adds	r0, r0, r3
 802eb4e:	0103      	lsls	r3, r0, #4
 802eb50:	1a1b      	subs	r3, r3, r0
 802eb52:	0118      	lsls	r0, r3, #4
 802eb54:	1ac0      	subs	r0, r0, r3
 802eb56:	01c0      	lsls	r0, r0, #7
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 802eb58:	ab06      	add	r3, sp, #24
 802eb5a:	4a0f      	ldr	r2, [pc, #60]	; (802eb98 <SetMaxTimeCredits+0x100>)
 802eb5c:	4694      	mov	ip, r2
 802eb5e:	4460      	add	r0, ip
                timeDiff.SubSeconds = 0;
 802eb60:	2200      	movs	r2, #0
 802eb62:	809a      	strh	r2, [r3, #4]
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 802eb64:	9907      	ldr	r1, [sp, #28]
 802eb66:	f005 fa5b 	bl	8034020 <SysTimeToMs>
 802eb6a:	60a0      	str	r0, [r4, #8]
 802eb6c:	e7cf      	b.n	802eb0e <SetMaxTimeCredits+0x76>
        if( dutyCycleEnabled == false )
 802eb6e:	2f00      	cmp	r7, #0
 802eb70:	d102      	bne.n	802eb78 <SetMaxTimeCredits+0xe0>
            band->TimeCredits = maxCredits;
 802eb72:	4e04      	ldr	r6, [pc, #16]	; (802eb84 <SetMaxTimeCredits+0xec>)
 802eb74:	60e6      	str	r6, [r4, #12]
 802eb76:	e7ca      	b.n	802eb0e <SetMaxTimeCredits+0x76>
    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
 802eb78:	4e02      	ldr	r6, [pc, #8]	; (802eb84 <SetMaxTimeCredits+0xec>)
 802eb7a:	e7c8      	b.n	802eb0e <SetMaxTimeCredits+0x76>
 802eb7c:	02932e00 	.word	0x02932e00
 802eb80:	0001ec2f 	.word	0x0001ec2f
 802eb84:	001b7740 	.word	0x001b7740
 802eb88:	0112a880 	.word	0x0112a880
 802eb8c:	0001517f 	.word	0x0001517f
 802eb90:	fffe13d0 	.word	0xfffe13d0
 802eb94:	00015180 	.word	0x00015180
 802eb98:	0001ec30 	.word	0x0001ec30

0802eb9c <UpdateTimeCredits>:
{
 802eb9c:	b570      	push	{r4, r5, r6, lr}
 802eb9e:	b082      	sub	sp, #8
 802eba0:	0004      	movs	r4, r0
 802eba2:	000d      	movs	r5, r1
    uint16_t dutyCycle = SetMaxTimeCredits( band, joined, elapsedTimeSinceStartup,
 802eba4:	9301      	str	r3, [sp, #4]
 802eba6:	9200      	str	r2, [sp, #0]
 802eba8:	9a06      	ldr	r2, [sp, #24]
 802ebaa:	9b07      	ldr	r3, [sp, #28]
 802ebac:	f7ff ff74 	bl	802ea98 <SetMaxTimeCredits>
 802ebb0:	0006      	movs	r6, r0
    if( joined == true )
 802ebb2:	2d00      	cmp	r5, #0
 802ebb4:	d109      	bne.n	802ebca <UpdateTimeCredits+0x2e>
    if( band->TimeCredits > band->MaxTimeCredits )
 802ebb6:	6923      	ldr	r3, [r4, #16]
 802ebb8:	68e2      	ldr	r2, [r4, #12]
 802ebba:	429a      	cmp	r2, r3
 802ebbc:	d900      	bls.n	802ebc0 <UpdateTimeCredits+0x24>
        band->TimeCredits = band->MaxTimeCredits;
 802ebbe:	60e3      	str	r3, [r4, #12]
    band->LastBandUpdateTime = currentTime;
 802ebc0:	9b08      	ldr	r3, [sp, #32]
 802ebc2:	6063      	str	r3, [r4, #4]
}
 802ebc4:	0030      	movs	r0, r6
 802ebc6:	b002      	add	sp, #8
 802ebc8:	bd70      	pop	{r4, r5, r6, pc}
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 802ebca:	6860      	ldr	r0, [r4, #4]
 802ebcc:	f005 faa6 	bl	803411c <UTIL_TIMER_GetElapsedTime>
 802ebd0:	68e3      	ldr	r3, [r4, #12]
 802ebd2:	469c      	mov	ip, r3
 802ebd4:	4460      	add	r0, ip
 802ebd6:	60e0      	str	r0, [r4, #12]
 802ebd8:	e7ed      	b.n	802ebb6 <UpdateTimeCredits+0x1a>

0802ebda <RegionCommonValueInRange>:
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 802ebda:	4288      	cmp	r0, r1
 802ebdc:	db03      	blt.n	802ebe6 <RegionCommonValueInRange+0xc>
 802ebde:	4290      	cmp	r0, r2
 802ebe0:	dd03      	ble.n	802ebea <RegionCommonValueInRange+0x10>
    {
        return 1;
    }
    return 0;
 802ebe2:	2000      	movs	r0, #0
 802ebe4:	e000      	b.n	802ebe8 <RegionCommonValueInRange+0xe>
 802ebe6:	2000      	movs	r0, #0
}
 802ebe8:	4770      	bx	lr
        return 1;
 802ebea:	2001      	movs	r0, #1
 802ebec:	e7fc      	b.n	802ebe8 <RegionCommonValueInRange+0xe>

0802ebee <RegionCommonChanVerifyDr>:
{
 802ebee:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ebf0:	46d6      	mov	lr, sl
 802ebf2:	464f      	mov	r7, r9
 802ebf4:	4646      	mov	r6, r8
 802ebf6:	b5c0      	push	{r6, r7, lr}
 802ebf8:	4682      	mov	sl, r0
 802ebfa:	000e      	movs	r6, r1
 802ebfc:	4690      	mov	r8, r2
 802ebfe:	0019      	movs	r1, r3
 802ec00:	ab08      	add	r3, sp, #32
 802ec02:	2200      	movs	r2, #0
 802ec04:	569a      	ldrsb	r2, [r3, r2]
 802ec06:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802ec08:	4699      	mov	r9, r3
    if( RegionCommonValueInRange( dr, minDr, maxDr ) == 0 )
 802ec0a:	4640      	mov	r0, r8
 802ec0c:	f7ff ffe5 	bl	802ebda <RegionCommonValueInRange>
 802ec10:	2800      	cmp	r0, #0
 802ec12:	d02e      	beq.n	802ec72 <RegionCommonChanVerifyDr+0x84>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 802ec14:	2500      	movs	r5, #0
 802ec16:	2700      	movs	r7, #0
 802ec18:	e025      	b.n	802ec66 <RegionCommonChanVerifyDr+0x78>
        for( uint8_t j = 0; j < 16; j++ )
 802ec1a:	3401      	adds	r4, #1
 802ec1c:	b2e4      	uxtb	r4, r4
 802ec1e:	2c0f      	cmp	r4, #15
 802ec20:	d81d      	bhi.n	802ec5e <RegionCommonChanVerifyDr+0x70>
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 802ec22:	006b      	lsls	r3, r5, #1
 802ec24:	5b9b      	ldrh	r3, [r3, r6]
 802ec26:	4123      	asrs	r3, r4
 802ec28:	07db      	lsls	r3, r3, #31
 802ec2a:	d5f6      	bpl.n	802ec1a <RegionCommonChanVerifyDr+0x2c>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 802ec2c:	193a      	adds	r2, r7, r4
 802ec2e:	0053      	lsls	r3, r2, #1
 802ec30:	189b      	adds	r3, r3, r2
 802ec32:	009b      	lsls	r3, r3, #2
 802ec34:	444b      	add	r3, r9
 802ec36:	7a1a      	ldrb	r2, [r3, #8]
 802ec38:	0111      	lsls	r1, r2, #4
 802ec3a:	b249      	sxtb	r1, r1
 802ec3c:	1109      	asrs	r1, r1, #4
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 802ec3e:	b252      	sxtb	r2, r2
 802ec40:	1112      	asrs	r2, r2, #4
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 802ec42:	230f      	movs	r3, #15
 802ec44:	401a      	ands	r2, r3
 802ec46:	4019      	ands	r1, r3
 802ec48:	4640      	mov	r0, r8
 802ec4a:	f7ff ffc6 	bl	802ebda <RegionCommonValueInRange>
 802ec4e:	2801      	cmp	r0, #1
 802ec50:	d1e3      	bne.n	802ec1a <RegionCommonChanVerifyDr+0x2c>
                    return true;
 802ec52:	2001      	movs	r0, #1
}
 802ec54:	bce0      	pop	{r5, r6, r7}
 802ec56:	46ba      	mov	sl, r7
 802ec58:	46b1      	mov	r9, r6
 802ec5a:	46a8      	mov	r8, r5
 802ec5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 802ec5e:	3710      	adds	r7, #16
 802ec60:	b2ff      	uxtb	r7, r7
 802ec62:	3501      	adds	r5, #1
 802ec64:	b2ed      	uxtb	r5, r5
 802ec66:	4557      	cmp	r7, sl
 802ec68:	d201      	bcs.n	802ec6e <RegionCommonChanVerifyDr+0x80>
        for( uint8_t j = 0; j < 16; j++ )
 802ec6a:	2400      	movs	r4, #0
 802ec6c:	e7d7      	b.n	802ec1e <RegionCommonChanVerifyDr+0x30>
    return false;
 802ec6e:	2000      	movs	r0, #0
 802ec70:	e7f0      	b.n	802ec54 <RegionCommonChanVerifyDr+0x66>
        return false;
 802ec72:	2000      	movs	r0, #0
 802ec74:	e7ee      	b.n	802ec54 <RegionCommonChanVerifyDr+0x66>

0802ec76 <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 802ec76:	b510      	push	{r4, lr}
    uint8_t index = id / 16;
 802ec78:	090b      	lsrs	r3, r1, #4

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 802ec7a:	0914      	lsrs	r4, r2, #4
 802ec7c:	429c      	cmp	r4, r3
 802ec7e:	d30b      	bcc.n	802ec98 <RegionCommonChanDisable+0x22>
 802ec80:	4291      	cmp	r1, r2
 802ec82:	d20b      	bcs.n	802ec9c <RegionCommonChanDisable+0x26>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 802ec84:	005b      	lsls	r3, r3, #1
 802ec86:	220f      	movs	r2, #15
 802ec88:	400a      	ands	r2, r1
 802ec8a:	2101      	movs	r1, #1
 802ec8c:	4091      	lsls	r1, r2
 802ec8e:	5ac2      	ldrh	r2, [r0, r3]
 802ec90:	438a      	bics	r2, r1
 802ec92:	52c2      	strh	r2, [r0, r3]

    return true;
 802ec94:	2001      	movs	r0, #1
}
 802ec96:	bd10      	pop	{r4, pc}
        return false;
 802ec98:	2000      	movs	r0, #0
 802ec9a:	e7fc      	b.n	802ec96 <RegionCommonChanDisable+0x20>
 802ec9c:	2000      	movs	r0, #0
 802ec9e:	e7fa      	b.n	802ec96 <RegionCommonChanDisable+0x20>

0802eca0 <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 802eca0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802eca2:	0006      	movs	r6, r0
 802eca4:	000c      	movs	r4, r1
 802eca6:	0017      	movs	r7, r2
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 802eca8:	2800      	cmp	r0, #0
 802ecaa:	d00e      	beq.n	802ecca <RegionCommonCountChannels+0x2a>
    uint8_t nbChannels = 0;
 802ecac:	2500      	movs	r5, #0
 802ecae:	e008      	b.n	802ecc2 <RegionCommonCountChannels+0x22>
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
 802ecb0:	0063      	lsls	r3, r4, #1
 802ecb2:	5af0      	ldrh	r0, [r6, r3]
 802ecb4:	2110      	movs	r1, #16
 802ecb6:	f7ff fedb 	bl	802ea70 <CountChannels>
 802ecba:	182d      	adds	r5, r5, r0
 802ecbc:	b2ed      	uxtb	r5, r5
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 802ecbe:	3401      	adds	r4, #1
 802ecc0:	b2e4      	uxtb	r4, r4
 802ecc2:	42bc      	cmp	r4, r7
 802ecc4:	d3f4      	bcc.n	802ecb0 <RegionCommonCountChannels+0x10>
    }

    return nbChannels;
}
 802ecc6:	0028      	movs	r0, r5
 802ecc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
 802ecca:	2500      	movs	r5, #0
 802eccc:	e7fb      	b.n	802ecc6 <RegionCommonCountChannels+0x26>

0802ecce <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 802ecce:	b530      	push	{r4, r5, lr}
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 802ecd0:	2800      	cmp	r0, #0
 802ecd2:	d00a      	beq.n	802ecea <RegionCommonChanMaskCopy+0x1c>
 802ecd4:	2900      	cmp	r1, #0
 802ecd6:	d008      	beq.n	802ecea <RegionCommonChanMaskCopy+0x1c>
    {
        for( uint8_t i = 0; i < len; i++ )
 802ecd8:	2300      	movs	r3, #0
 802ecda:	4293      	cmp	r3, r2
 802ecdc:	d205      	bcs.n	802ecea <RegionCommonChanMaskCopy+0x1c>
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
 802ecde:	005c      	lsls	r4, r3, #1
 802ece0:	5b0d      	ldrh	r5, [r1, r4]
 802ece2:	5305      	strh	r5, [r0, r4]
        for( uint8_t i = 0; i < len; i++ )
 802ece4:	3301      	adds	r3, #1
 802ece6:	b2db      	uxtb	r3, r3
 802ece8:	e7f7      	b.n	802ecda <RegionCommonChanMaskCopy+0xc>
        }
    }
}
 802ecea:	bd30      	pop	{r4, r5, pc}

0802ecec <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 802ecec:	b082      	sub	sp, #8
 802ecee:	b570      	push	{r4, r5, r6, lr}
 802ecf0:	0005      	movs	r5, r0
 802ecf2:	000c      	movs	r4, r1
 802ecf4:	0011      	movs	r1, r2
 802ecf6:	001a      	movs	r2, r3
 802ecf8:	9305      	str	r3, [sp, #20]
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 802ecfa:	9b06      	ldr	r3, [sp, #24]
 802ecfc:	f7ff fe96 	bl	802ea2c <GetDutyCycle>

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 802ed00:	68eb      	ldr	r3, [r5, #12]
 802ed02:	4360      	muls	r0, r4
 802ed04:	4283      	cmp	r3, r0
 802ed06:	d905      	bls.n	802ed14 <RegionCommonSetBandTxDone+0x28>
    {
        // Reduce time credits by the time of air
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 802ed08:	1a18      	subs	r0, r3, r0
 802ed0a:	60e8      	str	r0, [r5, #12]
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 802ed0c:	bc70      	pop	{r4, r5, r6}
 802ed0e:	bc08      	pop	{r3}
 802ed10:	b002      	add	sp, #8
 802ed12:	4718      	bx	r3
        band->TimeCredits = 0;
 802ed14:	2300      	movs	r3, #0
 802ed16:	60eb      	str	r3, [r5, #12]
}
 802ed18:	e7f8      	b.n	802ed0c <RegionCommonSetBandTxDone+0x20>
	...

0802ed1c <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 802ed1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ed1e:	46de      	mov	lr, fp
 802ed20:	4657      	mov	r7, sl
 802ed22:	464e      	mov	r6, r9
 802ed24:	4645      	mov	r5, r8
 802ed26:	b5e0      	push	{r5, r6, r7, lr}
 802ed28:	b089      	sub	sp, #36	; 0x24
 802ed2a:	0007      	movs	r7, r0
 802ed2c:	468b      	mov	fp, r1
 802ed2e:	4691      	mov	r9, r2
 802ed30:	4698      	mov	r8, r3
 802ed32:	ab12      	add	r3, sp, #72	; 0x48
 802ed34:	781b      	ldrb	r3, [r3, #0]
 802ed36:	469a      	mov	sl, r3
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 802ed38:	f005 f9e6 	bl	8034108 <UTIL_TIMER_GetCurrentTime>
 802ed3c:	9004      	str	r0, [sp, #16]
    TimerTime_t creditCosts = 0;
    uint16_t dutyCycle = 1;
    uint8_t validBands = 0;

    for( uint8_t i = 0; i < nbBands; i++ )
 802ed3e:	2500      	movs	r5, #0
    uint8_t validBands = 0;
 802ed40:	2600      	movs	r6, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 802ed42:	2301      	movs	r3, #1
 802ed44:	425b      	negs	r3, r3
 802ed46:	9305      	str	r3, [sp, #20]
    for( uint8_t i = 0; i < nbBands; i++ )
 802ed48:	e005      	b.n	802ed56 <RegionCommonUpdateBandTimeOff+0x3a>
        // when the duty cycle is off, or the TimeCredits of the band
        // is higher than the credit costs for the transmission.
        if( ( bands[i].TimeCredits > creditCosts ) ||
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
        {
            bands[i].ReadyForTransmission = true;
 802ed4a:	2301      	movs	r3, #1
 802ed4c:	7523      	strb	r3, [r4, #20]
            // This band is a potential candidate for an
            // upcoming transmission, so increase the counter.
            validBands++;
 802ed4e:	3601      	adds	r6, #1
 802ed50:	b2f6      	uxtb	r6, r6
    for( uint8_t i = 0; i < nbBands; i++ )
 802ed52:	3501      	adds	r5, #1
 802ed54:	b2ed      	uxtb	r5, r5
 802ed56:	454d      	cmp	r5, r9
 802ed58:	d25e      	bcs.n	802ee18 <RegionCommonUpdateBandTimeOff+0xfc>
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 802ed5a:	006c      	lsls	r4, r5, #1
 802ed5c:	1964      	adds	r4, r4, r5
 802ed5e:	00e4      	lsls	r4, r4, #3
 802ed60:	445c      	add	r4, fp
 802ed62:	9b04      	ldr	r3, [sp, #16]
 802ed64:	9302      	str	r3, [sp, #8]
 802ed66:	ab13      	add	r3, sp, #76	; 0x4c
 802ed68:	466a      	mov	r2, sp
 802ed6a:	cb03      	ldmia	r3!, {r0, r1}
 802ed6c:	c203      	stmia	r2!, {r0, r1}
 802ed6e:	4653      	mov	r3, sl
 802ed70:	4642      	mov	r2, r8
 802ed72:	0039      	movs	r1, r7
 802ed74:	0020      	movs	r0, r4
 802ed76:	f7ff ff11 	bl	802eb9c <UpdateTimeCredits>
 802ed7a:	0003      	movs	r3, r0
        creditCosts = expectedTimeOnAir * dutyCycle;
 802ed7c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 802ed7e:	4350      	muls	r0, r2
        if( ( bands[i].TimeCredits > creditCosts ) ||
 802ed80:	68e2      	ldr	r2, [r4, #12]
 802ed82:	4282      	cmp	r2, r0
 802ed84:	d8e1      	bhi.n	802ed4a <RegionCommonUpdateBandTimeOff+0x2e>
 802ed86:	4641      	mov	r1, r8
 802ed88:	2900      	cmp	r1, #0
 802ed8a:	d101      	bne.n	802ed90 <RegionCommonUpdateBandTimeOff+0x74>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 802ed8c:	2f00      	cmp	r7, #0
 802ed8e:	d1dc      	bne.n	802ed4a <RegionCommonUpdateBandTimeOff+0x2e>
        }
        else
        {
            // In this case, the band has not enough credits
            // for the next transmission.
            bands[i].ReadyForTransmission = false;
 802ed90:	2100      	movs	r1, #0
 802ed92:	7521      	strb	r1, [r4, #20]

            if( bands[i].MaxTimeCredits > creditCosts )
 802ed94:	6921      	ldr	r1, [r4, #16]
 802ed96:	4281      	cmp	r1, r0
 802ed98:	d906      	bls.n	802eda8 <RegionCommonUpdateBandTimeOff+0x8c>
                // The band can only be taken into account, if the maximum credits
                // of the band are higher than the credit costs.
                // We calculate the minTimeToWait among the bands which are not
                // ready for transmission and which are potentially available
                // for a transmission in the future.
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 802ed9a:	1a80      	subs	r0, r0, r2
 802ed9c:	9a05      	ldr	r2, [sp, #20]
 802ed9e:	4282      	cmp	r2, r0
 802eda0:	d900      	bls.n	802eda4 <RegionCommonUpdateBandTimeOff+0x88>
 802eda2:	9005      	str	r0, [sp, #20]
                // This band is a potential candidate for an
                // upcoming transmission (even if its time credits are not enough
                // at the moment), so increase the counter.
                validBands++;
 802eda4:	3601      	adds	r6, #1
 802eda6:	b2f6      	uxtb	r6, r6
            }

            // Apply a special calculation if the device is not joined.
            if( joined == false )
 802eda8:	2f00      	cmp	r7, #0
 802edaa:	d1d2      	bne.n	802ed52 <RegionCommonUpdateBandTimeOff+0x36>
            {
                SysTime_t backoffTimeRange = {
 802edac:	aa06      	add	r2, sp, #24
 802edae:	2100      	movs	r1, #0
 802edb0:	8091      	strh	r1, [r2, #4]
                    .Seconds    = 0,
                    .SubSeconds = 0,
                };
                // Get the backoff time range based on the duty cycle definition
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 802edb2:	2b64      	cmp	r3, #100	; 0x64
 802edb4:	d029      	beq.n	802ee0a <RegionCommonUpdateBandTimeOff+0xee>
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
                }
                else if( dutyCycle == BACKOFF_DC_10_HOURS )
 802edb6:	22fa      	movs	r2, #250	; 0xfa
 802edb8:	0092      	lsls	r2, r2, #2
 802edba:	4293      	cmp	r3, r2
 802edbc:	d029      	beq.n	802ee12 <RegionCommonUpdateBandTimeOff+0xf6>
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_10_HOURS_IN_S;
                }
                else
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 802edbe:	4b1d      	ldr	r3, [pc, #116]	; (802ee34 <RegionCommonUpdateBandTimeOff+0x118>)
 802edc0:	9306      	str	r3, [sp, #24]
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 802edc2:	9813      	ldr	r0, [sp, #76]	; 0x4c
 802edc4:	4b1b      	ldr	r3, [pc, #108]	; (802ee34 <RegionCommonUpdateBandTimeOff+0x118>)
 802edc6:	4298      	cmp	r0, r3
 802edc8:	d911      	bls.n	802edee <RegionCommonUpdateBandTimeOff+0xd2>
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 802edca:	4b1b      	ldr	r3, [pc, #108]	; (802ee38 <RegionCommonUpdateBandTimeOff+0x11c>)
 802edcc:	469c      	mov	ip, r3
 802edce:	4460      	add	r0, ip
 802edd0:	491a      	ldr	r1, [pc, #104]	; (802ee3c <RegionCommonUpdateBandTimeOff+0x120>)
 802edd2:	f7f1 f9a1 	bl	8020118 <__udivsi3>
 802edd6:	3001      	adds	r0, #1
 802edd8:	0042      	lsls	r2, r0, #1
 802edda:	1812      	adds	r2, r2, r0
 802eddc:	0113      	lsls	r3, r2, #4
 802edde:	1a9a      	subs	r2, r3, r2
 802ede0:	0113      	lsls	r3, r2, #4
 802ede2:	1a9b      	subs	r3, r3, r2
 802ede4:	01db      	lsls	r3, r3, #7
 802ede6:	9a06      	ldr	r2, [sp, #24]
 802ede8:	4694      	mov	ip, r2
 802edea:	4463      	add	r3, ip
 802edec:	9306      	str	r3, [sp, #24]
                }
                // Calculate the time difference between now and the next range
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 802edee:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802edf0:	9300      	str	r3, [sp, #0]
 802edf2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802edf4:	9906      	ldr	r1, [sp, #24]
 802edf6:	9a07      	ldr	r2, [sp, #28]
 802edf8:	a806      	add	r0, sp, #24
 802edfa:	f005 f8a1 	bl	8033f40 <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 802edfe:	9806      	ldr	r0, [sp, #24]
 802ee00:	9907      	ldr	r1, [sp, #28]
 802ee02:	f005 f90d 	bl	8034020 <SysTimeToMs>
 802ee06:	9005      	str	r0, [sp, #20]
 802ee08:	e7a3      	b.n	802ed52 <RegionCommonUpdateBandTimeOff+0x36>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 802ee0a:	23e1      	movs	r3, #225	; 0xe1
 802ee0c:	011b      	lsls	r3, r3, #4
 802ee0e:	9306      	str	r3, [sp, #24]
 802ee10:	e7d7      	b.n	802edc2 <RegionCommonUpdateBandTimeOff+0xa6>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_10_HOURS_IN_S;
 802ee12:	4b0b      	ldr	r3, [pc, #44]	; (802ee40 <RegionCommonUpdateBandTimeOff+0x124>)
 802ee14:	9306      	str	r3, [sp, #24]
 802ee16:	e7d4      	b.n	802edc2 <RegionCommonUpdateBandTimeOff+0xa6>
            }
        }
    }


    if( validBands == 0 )
 802ee18:	2e00      	cmp	r6, #0
 802ee1a:	d007      	beq.n	802ee2c <RegionCommonUpdateBandTimeOff+0x110>
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
    }
    return minTimeToWait;
}
 802ee1c:	9805      	ldr	r0, [sp, #20]
 802ee1e:	b009      	add	sp, #36	; 0x24
 802ee20:	bcf0      	pop	{r4, r5, r6, r7}
 802ee22:	46bb      	mov	fp, r7
 802ee24:	46b2      	mov	sl, r6
 802ee26:	46a9      	mov	r9, r5
 802ee28:	46a0      	mov	r8, r4
 802ee2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return TIMERTIME_T_MAX;
 802ee2c:	2301      	movs	r3, #1
 802ee2e:	425b      	negs	r3, r3
 802ee30:	9305      	str	r3, [sp, #20]
 802ee32:	e7f3      	b.n	802ee1c <RegionCommonUpdateBandTimeOff+0x100>
 802ee34:	0001ec30 	.word	0x0001ec30
 802ee38:	fffe13d0 	.word	0xfffe13d0
 802ee3c:	00015180 	.word	0x00015180
 802ee40:	00009ab0 	.word	0x00009ab0

0802ee44 <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
 802ee44:	b510      	push	{r4, lr}
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 802ee46:	7803      	ldrb	r3, [r0, #0]
 802ee48:	2b03      	cmp	r3, #3
 802ee4a:	d001      	beq.n	802ee50 <RegionCommonParseLinkAdrReq+0xc>
    uint8_t retIndex = 0;
 802ee4c:	2000      	movs	r0, #0

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
    }
    return retIndex;
}
 802ee4e:	bd10      	pop	{r4, pc}
        linkAdrParams->Datarate = payload[1];
 802ee50:	7842      	ldrb	r2, [r0, #1]
 802ee52:	2401      	movs	r4, #1
 802ee54:	5704      	ldrsb	r4, [r0, r4]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 802ee56:	330c      	adds	r3, #12
 802ee58:	401c      	ands	r4, r3
 802ee5a:	708c      	strb	r4, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 802ee5c:	0912      	lsrs	r2, r2, #4
 802ee5e:	704a      	strb	r2, [r1, #1]
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 802ee60:	7882      	ldrb	r2, [r0, #2]
 802ee62:	808a      	strh	r2, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 802ee64:	78c4      	ldrb	r4, [r0, #3]
 802ee66:	0224      	lsls	r4, r4, #8
 802ee68:	4322      	orrs	r2, r4
 802ee6a:	808a      	strh	r2, [r1, #4]
        linkAdrParams->NbRep = payload[4];
 802ee6c:	7900      	ldrb	r0, [r0, #4]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 802ee6e:	0904      	lsrs	r4, r0, #4
 802ee70:	2207      	movs	r2, #7
 802ee72:	4022      	ands	r2, r4
 802ee74:	70ca      	strb	r2, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 802ee76:	4003      	ands	r3, r0
 802ee78:	700b      	strb	r3, [r1, #0]
        retIndex = 5;
 802ee7a:	2005      	movs	r0, #5
 802ee7c:	e7e7      	b.n	802ee4e <RegionCommonParseLinkAdrReq+0xa>

0802ee7e <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 802ee7e:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ee80:	46de      	mov	lr, fp
 802ee82:	4657      	mov	r7, sl
 802ee84:	464e      	mov	r6, r9
 802ee86:	4645      	mov	r5, r8
 802ee88:	b5e0      	push	{r5, r6, r7, lr}
 802ee8a:	b085      	sub	sp, #20
 802ee8c:	0004      	movs	r4, r0
 802ee8e:	4688      	mov	r8, r1
 802ee90:	9203      	str	r2, [sp, #12]
 802ee92:	469a      	mov	sl, r3
    uint8_t status = verifyParams->Status;
 802ee94:	7905      	ldrb	r5, [r0, #4]
    int8_t datarate = verifyParams->Datarate;
 802ee96:	2306      	movs	r3, #6
 802ee98:	56c3      	ldrsb	r3, [r0, r3]
 802ee9a:	469b      	mov	fp, r3
    int8_t txPower = verifyParams->TxPower;
 802ee9c:	2707      	movs	r7, #7
 802ee9e:	57c7      	ldrsb	r7, [r0, r7]
    int8_t nbRepetitions = verifyParams->NbRep;
 802eea0:	2608      	movs	r6, #8
 802eea2:	5786      	ldrsb	r6, [r0, r6]

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 802eea4:	7943      	ldrb	r3, [r0, #5]
 802eea6:	2b00      	cmp	r3, #0
 802eea8:	d106      	bne.n	802eeb8 <RegionCommonLinkAdrReqVerifyParams+0x3a>
    {
        // When ADR is off, we are allowed to change the channels mask
        nbRepetitions = verifyParams->CurrentNbRep;
 802eeaa:	260b      	movs	r6, #11
 802eeac:	5786      	ldrsb	r6, [r0, r6]
        datarate =  verifyParams->CurrentDatarate;
 802eeae:	2309      	movs	r3, #9
 802eeb0:	56c3      	ldrsb	r3, [r0, r3]
 802eeb2:	469b      	mov	fp, r3
        txPower =  verifyParams->CurrentTxPower;
 802eeb4:	270a      	movs	r7, #10
 802eeb6:	57c7      	ldrsb	r7, [r0, r7]
    }

    if( status != 0 )
 802eeb8:	2d00      	cmp	r5, #0
 802eeba:	d110      	bne.n	802eede <RegionCommonLinkAdrReqVerifyParams+0x60>
            }
        }
    }

    // If the status is ok, verify the NbRep
    if( status == 0x07 )
 802eebc:	2d07      	cmp	r5, #7
 802eebe:	d030      	beq.n	802ef22 <RegionCommonLinkAdrReqVerifyParams+0xa4>
            nbRepetitions = 1;
        }
    }

    // Apply changes
    *dr = datarate;
 802eec0:	4643      	mov	r3, r8
 802eec2:	465a      	mov	r2, fp
 802eec4:	701a      	strb	r2, [r3, #0]
    *txPow = txPower;
 802eec6:	9b03      	ldr	r3, [sp, #12]
 802eec8:	701f      	strb	r7, [r3, #0]
    *nbRep = nbRepetitions;
 802eeca:	4653      	mov	r3, sl
 802eecc:	701e      	strb	r6, [r3, #0]

    return status;
}
 802eece:	0028      	movs	r0, r5
 802eed0:	b005      	add	sp, #20
 802eed2:	bcf0      	pop	{r4, r5, r6, r7}
 802eed4:	46bb      	mov	fp, r7
 802eed6:	46b2      	mov	sl, r6
 802eed8:	46a9      	mov	r9, r5
 802eeda:	46a0      	mov	r8, r4
 802eedc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 802eede:	2314      	movs	r3, #20
 802eee0:	56e3      	ldrsb	r3, [r4, r3]
 802eee2:	7b20      	ldrb	r0, [r4, #12]
 802eee4:	69a2      	ldr	r2, [r4, #24]
 802eee6:	9201      	str	r2, [sp, #4]
 802eee8:	2215      	movs	r2, #21
 802eeea:	56a2      	ldrsb	r2, [r4, r2]
 802eeec:	9200      	str	r2, [sp, #0]
 802eeee:	465a      	mov	r2, fp
 802eef0:	6921      	ldr	r1, [r4, #16]
 802eef2:	f7ff fe7c 	bl	802ebee <RegionCommonChanVerifyDr>
 802eef6:	2800      	cmp	r0, #0
 802eef8:	d101      	bne.n	802eefe <RegionCommonLinkAdrReqVerifyParams+0x80>
            status &= 0xFD; // Datarate KO
 802eefa:	2302      	movs	r3, #2
 802eefc:	439d      	bics	r5, r3
        if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 802eefe:	231d      	movs	r3, #29
 802ef00:	56e3      	ldrsb	r3, [r4, r3]
 802ef02:	4699      	mov	r9, r3
 802ef04:	221c      	movs	r2, #28
 802ef06:	56a2      	ldrsb	r2, [r4, r2]
 802ef08:	0019      	movs	r1, r3
 802ef0a:	0038      	movs	r0, r7
 802ef0c:	f7ff fe65 	bl	802ebda <RegionCommonValueInRange>
 802ef10:	2800      	cmp	r0, #0
 802ef12:	d1d3      	bne.n	802eebc <RegionCommonLinkAdrReqVerifyParams+0x3e>
            if( verifyParams->MaxTxPower > txPower )
 802ef14:	45b9      	cmp	r9, r7
 802ef16:	dc02      	bgt.n	802ef1e <RegionCommonLinkAdrReqVerifyParams+0xa0>
                status &= 0xFB; // TxPower KO
 802ef18:	2304      	movs	r3, #4
 802ef1a:	439d      	bics	r5, r3
 802ef1c:	e7ce      	b.n	802eebc <RegionCommonLinkAdrReqVerifyParams+0x3e>
                txPower = verifyParams->MaxTxPower;
 802ef1e:	464f      	mov	r7, r9
 802ef20:	e7cc      	b.n	802eebc <RegionCommonLinkAdrReqVerifyParams+0x3e>
        if( nbRepetitions == 0 )
 802ef22:	2e00      	cmp	r6, #0
 802ef24:	d1cc      	bne.n	802eec0 <RegionCommonLinkAdrReqVerifyParams+0x42>
            nbRepetitions = 1;
 802ef26:	3601      	adds	r6, #1
 802ef28:	e7ca      	b.n	802eec0 <RegionCommonLinkAdrReqVerifyParams+0x42>
	...

0802ef2c <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
 802ef2c:	b510      	push	{r4, lr}
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 802ef2e:	4b03      	ldr	r3, [pc, #12]	; (802ef3c <RegionCommonComputeSymbolTimeLoRa+0x10>)
 802ef30:	4083      	lsls	r3, r0
 802ef32:	0018      	movs	r0, r3
 802ef34:	f7f1 f8f0 	bl	8020118 <__udivsi3>
}
 802ef38:	bd10      	pop	{r4, pc}
 802ef3a:	46c0      	nop			; (mov r8, r8)
 802ef3c:	000f4240 	.word	0x000f4240

0802ef40 <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
 802ef40:	b510      	push	{r4, lr}
 802ef42:	0001      	movs	r1, r0
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
 802ef44:	20fa      	movs	r0, #250	; 0xfa
 802ef46:	0140      	lsls	r0, r0, #5
 802ef48:	f7f1 f8e6 	bl	8020118 <__udivsi3>
}
 802ef4c:	bd10      	pop	{r4, pc}
	...

0802ef50 <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
 802ef50:	b570      	push	{r4, r5, r6, lr}
 802ef52:	0005      	movs	r5, r0
 802ef54:	000c      	movs	r4, r1
 802ef56:	001e      	movs	r6, r3
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 802ef58:	3904      	subs	r1, #4
 802ef5a:	4341      	muls	r1, r0
 802ef5c:	0150      	lsls	r0, r2, #5
 802ef5e:	1a80      	subs	r0, r0, r2
 802ef60:	0080      	lsls	r0, r0, #2
 802ef62:	1880      	adds	r0, r0, r2
 802ef64:	00c0      	lsls	r0, r0, #3
 802ef66:	1840      	adds	r0, r0, r1
 802ef68:	0040      	lsls	r0, r0, #1
 802ef6a:	d022      	beq.n	802efb2 <RegionCommonComputeRxWindowParameters+0x62>
 802ef6c:	1940      	adds	r0, r0, r5
 802ef6e:	3801      	subs	r0, #1
 802ef70:	0029      	movs	r1, r5
 802ef72:	f7f1 f8d1 	bl	8020118 <__udivsi3>
 802ef76:	4284      	cmp	r4, r0
 802ef78:	d200      	bcs.n	802ef7c <RegionCommonComputeRxWindowParameters+0x2c>
 802ef7a:	0004      	movs	r4, r0
 802ef7c:	9b04      	ldr	r3, [sp, #16]
 802ef7e:	601c      	str	r4, [r3, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 802ef80:	00a8      	lsls	r0, r5, #2
 802ef82:	4365      	muls	r5, r4
 802ef84:	2d00      	cmp	r5, #0
 802ef86:	d018      	beq.n	802efba <RegionCommonComputeRxWindowParameters+0x6a>
 802ef88:	3501      	adds	r5, #1
 802ef8a:	086d      	lsrs	r5, r5, #1
 802ef8c:	1b40      	subs	r0, r0, r5
 802ef8e:	0173      	lsls	r3, r6, #5
 802ef90:	1b9b      	subs	r3, r3, r6
 802ef92:	009b      	lsls	r3, r3, #2
 802ef94:	199e      	adds	r6, r3, r6
 802ef96:	00f6      	lsls	r6, r6, #3
 802ef98:	1b80      	subs	r0, r0, r6
 802ef9a:	2800      	cmp	r0, #0
 802ef9c:	dd0f      	ble.n	802efbe <RegionCommonComputeRxWindowParameters+0x6e>
 802ef9e:	4b0a      	ldr	r3, [pc, #40]	; (802efc8 <RegionCommonComputeRxWindowParameters+0x78>)
 802efa0:	469c      	mov	ip, r3
 802efa2:	4460      	add	r0, ip
 802efa4:	21fa      	movs	r1, #250	; 0xfa
 802efa6:	0089      	lsls	r1, r1, #2
 802efa8:	f7f1 f940 	bl	802022c <__divsi3>
 802efac:	9b05      	ldr	r3, [sp, #20]
 802efae:	6018      	str	r0, [r3, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 802efb0:	bd70      	pop	{r4, r5, r6, pc}
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 802efb2:	0029      	movs	r1, r5
 802efb4:	f7f1 f8b0 	bl	8020118 <__udivsi3>
 802efb8:	e7dd      	b.n	802ef76 <RegionCommonComputeRxWindowParameters+0x26>
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 802efba:	086d      	lsrs	r5, r5, #1
 802efbc:	e7e6      	b.n	802ef8c <RegionCommonComputeRxWindowParameters+0x3c>
 802efbe:	21fa      	movs	r1, #250	; 0xfa
 802efc0:	0089      	lsls	r1, r1, #2
 802efc2:	f7f1 f933 	bl	802022c <__divsi3>
 802efc6:	e7f1      	b.n	802efac <RegionCommonComputeRxWindowParameters+0x5c>
 802efc8:	000003e7 	.word	0x000003e7

0802efcc <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 802efcc:	b570      	push	{r4, r5, r6, lr}
 802efce:	1c0d      	adds	r5, r1, #0
 802efd0:	1c14      	adds	r4, r2, #0
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 802efd2:	0040      	lsls	r0, r0, #1
 802efd4:	f7f1 fd30 	bl	8020a38 <__aeabi_ui2f>
 802efd8:	1c01      	adds	r1, r0, #0
 802efda:	1c28      	adds	r0, r5, #0
 802efdc:	f7f1 fb64 	bl	80206a8 <__aeabi_fsub>
 802efe0:	1c21      	adds	r1, r4, #0
 802efe2:	f7f1 fb61 	bl	80206a8 <__aeabi_fsub>
 802efe6:	f7f2 fa21 	bl	802142c <__aeabi_f2d>
 802efea:	f005 fba5 	bl	8034738 <floor>
 802efee:	f7f2 f9e7 	bl	80213c0 <__aeabi_d2iz>
 802eff2:	b240      	sxtb	r0, r0

    return phyTxPower;
}
 802eff4:	bd70      	pop	{r4, r5, r6, pc}

0802eff6 <RegionCommonCountNbOfEnabledChannels>:
    /* ST_WORKAROUND_END */
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 802eff6:	b5f0      	push	{r4, r5, r6, r7, lr}
 802eff8:	46de      	mov	lr, fp
 802effa:	4657      	mov	r7, sl
 802effc:	464e      	mov	r6, r9
 802effe:	4645      	mov	r5, r8
 802f000:	b5e0      	push	{r5, r6, r7, lr}
 802f002:	b083      	sub	sp, #12
 802f004:	0005      	movs	r5, r0
 802f006:	468b      	mov	fp, r1
 802f008:	9200      	str	r2, [sp, #0]
 802f00a:	9301      	str	r3, [sp, #4]
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 802f00c:	2700      	movs	r7, #0
 802f00e:	2300      	movs	r3, #0
 802f010:	4698      	mov	r8, r3
    uint8_t nbRestrictedChannelsCount = 0;
 802f012:	469a      	mov	sl, r3
    uint8_t nbChannelCount = 0;
 802f014:	4699      	mov	r9, r3
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 802f016:	e048      	b.n	802f0aa <RegionCommonCountNbOfEnabledChannels+0xb4>
                    {
                        continue;
                    }
                }
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 802f018:	7a32      	ldrb	r2, [r6, #8]
 802f01a:	0111      	lsls	r1, r2, #4
 802f01c:	b249      	sxtb	r1, r1
 802f01e:	1109      	asrs	r1, r1, #4
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 802f020:	b252      	sxtb	r2, r2
 802f022:	1112      	asrs	r2, r2, #4
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 802f024:	2001      	movs	r0, #1
 802f026:	5628      	ldrsb	r0, [r5, r0]
 802f028:	f7ff fdd7 	bl	802ebda <RegionCommonValueInRange>
 802f02c:	2800      	cmp	r0, #0
 802f02e:	d012      	beq.n	802f056 <RegionCommonCountNbOfEnabledChannels+0x60>
                { // Check if the current channel selection supports the given datarate
                    continue;
                }
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 802f030:	7a72      	ldrb	r2, [r6, #9]
 802f032:	0053      	lsls	r3, r2, #1
 802f034:	189b      	adds	r3, r3, r2
 802f036:	00db      	lsls	r3, r3, #3
 802f038:	68ea      	ldr	r2, [r5, #12]
 802f03a:	4694      	mov	ip, r2
 802f03c:	4463      	add	r3, ip
 802f03e:	7d1b      	ldrb	r3, [r3, #20]
 802f040:	2b00      	cmp	r3, #0
 802f042:	d027      	beq.n	802f094 <RegionCommonCountNbOfEnabledChannels+0x9e>
                { // Check if the band is available for transmission
                    nbRestrictedChannelsCount++;
                    continue;
                }
                enabledChannels[nbChannelCount++] = i + j;
 802f044:	464b      	mov	r3, r9
 802f046:	3301      	adds	r3, #1
 802f048:	4642      	mov	r2, r8
 802f04a:	1912      	adds	r2, r2, r4
 802f04c:	4659      	mov	r1, fp
 802f04e:	4648      	mov	r0, r9
 802f050:	540a      	strb	r2, [r1, r0]
 802f052:	b2db      	uxtb	r3, r3
 802f054:	4699      	mov	r9, r3
        for( uint8_t j = 0; j < 16; j++ )
 802f056:	3401      	adds	r4, #1
 802f058:	b2e4      	uxtb	r4, r4
 802f05a:	2c0f      	cmp	r4, #15
 802f05c:	d81f      	bhi.n	802f09e <RegionCommonCountNbOfEnabledChannels+0xa8>
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 802f05e:	0079      	lsls	r1, r7, #1
 802f060:	686b      	ldr	r3, [r5, #4]
 802f062:	5a5b      	ldrh	r3, [r3, r1]
 802f064:	4123      	asrs	r3, r4
 802f066:	07db      	lsls	r3, r3, #31
 802f068:	d5f5      	bpl.n	802f056 <RegionCommonCountNbOfEnabledChannels+0x60>
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 802f06a:	4643      	mov	r3, r8
 802f06c:	1918      	adds	r0, r3, r4
 802f06e:	0043      	lsls	r3, r0, #1
 802f070:	181b      	adds	r3, r3, r0
 802f072:	009b      	lsls	r3, r3, #2
 802f074:	68a8      	ldr	r0, [r5, #8]
 802f076:	18c6      	adds	r6, r0, r3
 802f078:	6833      	ldr	r3, [r6, #0]
 802f07a:	2b00      	cmp	r3, #0
 802f07c:	d0eb      	beq.n	802f056 <RegionCommonCountNbOfEnabledChannels+0x60>
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 802f07e:	782b      	ldrb	r3, [r5, #0]
 802f080:	2b00      	cmp	r3, #0
 802f082:	d1c9      	bne.n	802f018 <RegionCommonCountNbOfEnabledChannels+0x22>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 802f084:	696b      	ldr	r3, [r5, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 802f086:	2b00      	cmp	r3, #0
 802f088:	d0c6      	beq.n	802f018 <RegionCommonCountNbOfEnabledChannels+0x22>
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 802f08a:	5a5b      	ldrh	r3, [r3, r1]
 802f08c:	4123      	asrs	r3, r4
 802f08e:	07db      	lsls	r3, r3, #31
 802f090:	d4c2      	bmi.n	802f018 <RegionCommonCountNbOfEnabledChannels+0x22>
 802f092:	e7e0      	b.n	802f056 <RegionCommonCountNbOfEnabledChannels+0x60>
                    nbRestrictedChannelsCount++;
 802f094:	4653      	mov	r3, sl
 802f096:	3301      	adds	r3, #1
 802f098:	b2db      	uxtb	r3, r3
 802f09a:	469a      	mov	sl, r3
                    continue;
 802f09c:	e7db      	b.n	802f056 <RegionCommonCountNbOfEnabledChannels+0x60>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 802f09e:	4646      	mov	r6, r8
 802f0a0:	3610      	adds	r6, #16
 802f0a2:	b2f3      	uxtb	r3, r6
 802f0a4:	4698      	mov	r8, r3
 802f0a6:	3701      	adds	r7, #1
 802f0a8:	b2ff      	uxtb	r7, r7
 802f0aa:	4643      	mov	r3, r8
 802f0ac:	b29b      	uxth	r3, r3
 802f0ae:	8a2a      	ldrh	r2, [r5, #16]
 802f0b0:	4293      	cmp	r3, r2
 802f0b2:	d201      	bcs.n	802f0b8 <RegionCommonCountNbOfEnabledChannels+0xc2>
        for( uint8_t j = 0; j < 16; j++ )
 802f0b4:	2400      	movs	r4, #0
 802f0b6:	e7d0      	b.n	802f05a <RegionCommonCountNbOfEnabledChannels+0x64>
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 802f0b8:	9b00      	ldr	r3, [sp, #0]
 802f0ba:	464a      	mov	r2, r9
 802f0bc:	701a      	strb	r2, [r3, #0]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 802f0be:	9b01      	ldr	r3, [sp, #4]
 802f0c0:	4652      	mov	r2, sl
 802f0c2:	701a      	strb	r2, [r3, #0]
}
 802f0c4:	b003      	add	sp, #12
 802f0c6:	bcf0      	pop	{r4, r5, r6, r7}
 802f0c8:	46bb      	mov	fp, r7
 802f0ca:	46b2      	mov	sl, r6
 802f0cc:	46a9      	mov	r9, r5
 802f0ce:	46a0      	mov	r8, r4
 802f0d0:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802f0d2 <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 802f0d2:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f0d4:	46d6      	mov	lr, sl
 802f0d6:	4647      	mov	r7, r8
 802f0d8:	b580      	push	{r7, lr}
 802f0da:	b087      	sub	sp, #28
 802f0dc:	0004      	movs	r4, r0
 802f0de:	000e      	movs	r6, r1
 802f0e0:	9205      	str	r2, [sp, #20]
 802f0e2:	001d      	movs	r5, r3
 802f0e4:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 802f0e6:	6840      	ldr	r0, [r0, #4]
 802f0e8:	f005 f818 	bl	803411c <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 802f0ec:	6823      	ldr	r3, [r4, #0]
 802f0ee:	1a1b      	subs	r3, r3, r0
 802f0f0:	603b      	str	r3, [r7, #0]
    *nbRestrictedChannels = 1;
 802f0f2:	2301      	movs	r3, #1
 802f0f4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802f0f6:	7013      	strb	r3, [r2, #0]
    *nbEnabledChannels = 0;
 802f0f8:	2300      	movs	r3, #0
 802f0fa:	702b      	strb	r3, [r5, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 802f0fc:	6863      	ldr	r3, [r4, #4]
 802f0fe:	2b00      	cmp	r3, #0
 802f100:	d002      	beq.n	802f108 <RegionCommonIdentifyChannels+0x36>
 802f102:	6823      	ldr	r3, [r4, #0]
 802f104:	4283      	cmp	r3, r0
 802f106:	d81e      	bhi.n	802f146 <RegionCommonIdentifyChannels+0x74>
        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 802f108:	2300      	movs	r3, #0
 802f10a:	6033      	str	r3, [r6, #0]

        // Update bands Time OFF
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 802f10c:	69e0      	ldr	r0, [r4, #28]
 802f10e:	7a23      	ldrb	r3, [r4, #8]
 802f110:	4698      	mov	r8, r3
 802f112:	7a63      	ldrb	r3, [r4, #9]
 802f114:	469c      	mov	ip, r3
 802f116:	68c3      	ldr	r3, [r0, #12]
 802f118:	469a      	mov	sl, r3
 802f11a:	7800      	ldrb	r0, [r0, #0]
 802f11c:	69a3      	ldr	r3, [r4, #24]
 802f11e:	9303      	str	r3, [sp, #12]
 802f120:	aa01      	add	r2, sp, #4
 802f122:	0023      	movs	r3, r4
 802f124:	330c      	adds	r3, #12
 802f126:	cb42      	ldmia	r3!, {r1, r6}
 802f128:	c242      	stmia	r2!, {r1, r6}
 802f12a:	7d23      	ldrb	r3, [r4, #20]
 802f12c:	9300      	str	r3, [sp, #0]
 802f12e:	4643      	mov	r3, r8
 802f130:	4662      	mov	r2, ip
 802f132:	4651      	mov	r1, sl
 802f134:	f7ff fdf2 	bl	802ed1c <RegionCommonUpdateBandTimeOff>
 802f138:	6038      	str	r0, [r7, #0]
                                                      identifyChannelsParam->DutyCycleEnabled,
                                                      identifyChannelsParam->LastTxIsJoinRequest,
                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
                                                      identifyChannelsParam->ExpectedTimeOnAir );

        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 802f13a:	69e0      	ldr	r0, [r4, #28]
 802f13c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802f13e:	002a      	movs	r2, r5
 802f140:	9905      	ldr	r1, [sp, #20]
 802f142:	f7ff ff58 	bl	802eff6 <RegionCommonCountNbOfEnabledChannels>
                                              nbEnabledChannels, nbRestrictedChannels );
    }

    if( *nbEnabledChannels > 0 )
 802f146:	782b      	ldrb	r3, [r5, #0]
 802f148:	2b00      	cmp	r3, #0
 802f14a:	d105      	bne.n	802f158 <RegionCommonIdentifyChannels+0x86>
    {
        *nextTxDelay = 0;
        return LORAMAC_STATUS_OK;
    }
    else if( *nbRestrictedChannels > 0 )
 802f14c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802f14e:	781b      	ldrb	r3, [r3, #0]
 802f150:	2b00      	cmp	r3, #0
 802f152:	d009      	beq.n	802f168 <RegionCommonIdentifyChannels+0x96>
    {
        return LORAMAC_STATUS_DUTYCYCLE_RESTRICTED;
 802f154:	200b      	movs	r0, #11
 802f156:	e002      	b.n	802f15e <RegionCommonIdentifyChannels+0x8c>
        *nextTxDelay = 0;
 802f158:	2300      	movs	r3, #0
 802f15a:	603b      	str	r3, [r7, #0]
        return LORAMAC_STATUS_OK;
 802f15c:	2000      	movs	r0, #0
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 802f15e:	b007      	add	sp, #28
 802f160:	bcc0      	pop	{r6, r7}
 802f162:	46ba      	mov	sl, r7
 802f164:	46b0      	mov	r8, r6
 802f166:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 802f168:	200c      	movs	r0, #12
 802f16a:	e7f8      	b.n	802f15e <RegionCommonIdentifyChannels+0x8c>

0802f16c <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 802f16c:	b570      	push	{r4, r5, r6, lr}
 802f16e:	b082      	sub	sp, #8
 802f170:	0005      	movs	r5, r0
    int8_t drLocal = params->CurrentDr;
 802f172:	2400      	movs	r4, #0
 802f174:	5704      	ldrsb	r4, [r0, r4]

    if( params->CurrentDr == params->MinDr )
 802f176:	2602      	movs	r6, #2
 802f178:	5786      	ldrsb	r6, [r0, r6]
 802f17a:	42a6      	cmp	r6, r4
 802f17c:	d011      	beq.n	802f1a2 <RegionCommonGetNextLowerTxDr+0x36>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 802f17e:	3c01      	subs	r4, #1
 802f180:	b264      	sxtb	r4, r4
        } while( ( drLocal != params->MinDr ) &&
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 802f182:	42a6      	cmp	r6, r4
 802f184:	d00e      	beq.n	802f1a4 <RegionCommonGetNextLowerTxDr+0x38>
 802f186:	78e8      	ldrb	r0, [r5, #3]
 802f188:	68ab      	ldr	r3, [r5, #8]
 802f18a:	9301      	str	r3, [sp, #4]
 802f18c:	2301      	movs	r3, #1
 802f18e:	56eb      	ldrsb	r3, [r5, r3]
 802f190:	9300      	str	r3, [sp, #0]
 802f192:	0033      	movs	r3, r6
 802f194:	0022      	movs	r2, r4
 802f196:	6869      	ldr	r1, [r5, #4]
 802f198:	f7ff fd29 	bl	802ebee <RegionCommonChanVerifyDr>
        } while( ( drLocal != params->MinDr ) &&
 802f19c:	2800      	cmp	r0, #0
 802f19e:	d0ee      	beq.n	802f17e <RegionCommonGetNextLowerTxDr+0x12>
 802f1a0:	e000      	b.n	802f1a4 <RegionCommonGetNextLowerTxDr+0x38>
        return params->MinDr;
 802f1a2:	0034      	movs	r4, r6

        return drLocal;
    }
}
 802f1a4:	0020      	movs	r0, r4
 802f1a6:	b002      	add	sp, #8
 802f1a8:	bd70      	pop	{r4, r5, r6, pc}

0802f1aa <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
 802f1aa:	1c0b      	adds	r3, r1, #0
 802f1ac:	4281      	cmp	r1, r0
 802f1ae:	da00      	bge.n	802f1b2 <RegionCommonLimitTxPower+0x8>
 802f1b0:	1c03      	adds	r3, r0, #0
 802f1b2:	b258      	sxtb	r0, r3
}
 802f1b4:	4770      	bx	lr
	...

0802f1b8 <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 802f1b8:	0080      	lsls	r0, r0, #2
 802f1ba:	5843      	ldr	r3, [r0, r1]
 802f1bc:	4a05      	ldr	r2, [pc, #20]	; (802f1d4 <RegionCommonGetBandwidth+0x1c>)
 802f1be:	4293      	cmp	r3, r2
 802f1c0:	d004      	beq.n	802f1cc <RegionCommonGetBandwidth+0x14>
 802f1c2:	4a05      	ldr	r2, [pc, #20]	; (802f1d8 <RegionCommonGetBandwidth+0x20>)
 802f1c4:	4293      	cmp	r3, r2
 802f1c6:	d103      	bne.n	802f1d0 <RegionCommonGetBandwidth+0x18>
        case 125000:
            return 0;
        case 250000:
            return 1;
        case 500000:
            return 2;
 802f1c8:	2002      	movs	r0, #2
    }
}
 802f1ca:	4770      	bx	lr
            return 1;
 802f1cc:	2001      	movs	r0, #1
 802f1ce:	e7fc      	b.n	802f1ca <RegionCommonGetBandwidth+0x12>
    switch( bandwidths[drIndex] )
 802f1d0:	2000      	movs	r0, #0
 802f1d2:	e7fa      	b.n	802f1ca <RegionCommonGetBandwidth+0x12>
 802f1d4:	0003d090 	.word	0x0003d090
 802f1d8:	0007a120 	.word	0x0007a120

0802f1dc <RegionCommonRxConfigPrint>:

/* ST_WORKAROUND_BEGIN: Print Tx/Rx config */
void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 802f1dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f1de:	b08b      	sub	sp, #44	; 0x2c
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 802f1e0:	ad04      	add	r5, sp, #16
 802f1e2:	4b0f      	ldr	r3, [pc, #60]	; (802f220 <RegionCommonRxConfigPrint+0x44>)
 802f1e4:	002c      	movs	r4, r5
 802f1e6:	cbe0      	ldmia	r3!, {r5, r6, r7}
 802f1e8:	c4e0      	stmia	r4!, {r5, r6, r7}
 802f1ea:	cbe0      	ldmia	r3!, {r5, r6, r7}
 802f1ec:	c4e0      	stmia	r4!, {r5, r6, r7}

    if ( rxSlot < RX_SLOT_NONE )
 802f1ee:	2805      	cmp	r0, #5
 802f1f0:	d80d      	bhi.n	802f20e <RegionCommonRxConfigPrint+0x32>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", slotStrings[rxSlot], frequency, dr );
 802f1f2:	9202      	str	r2, [sp, #8]
 802f1f4:	9101      	str	r1, [sp, #4]
 802f1f6:	0080      	lsls	r0, r0, #2
 802f1f8:	ab04      	add	r3, sp, #16
 802f1fa:	58c3      	ldr	r3, [r0, r3]
 802f1fc:	9300      	str	r3, [sp, #0]
 802f1fe:	4b09      	ldr	r3, [pc, #36]	; (802f224 <RegionCommonRxConfigPrint+0x48>)
 802f200:	2201      	movs	r2, #1
 802f202:	2100      	movs	r1, #0
 802f204:	2002      	movs	r0, #2
 802f206:	f004 fc57 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 802f20a:	b00b      	add	sp, #44	; 0x2c
 802f20c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 802f20e:	9201      	str	r2, [sp, #4]
 802f210:	9100      	str	r1, [sp, #0]
 802f212:	4b05      	ldr	r3, [pc, #20]	; (802f228 <RegionCommonRxConfigPrint+0x4c>)
 802f214:	2201      	movs	r2, #1
 802f216:	2100      	movs	r1, #0
 802f218:	2002      	movs	r0, #2
 802f21a:	f004 fc4d 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 802f21e:	e7f4      	b.n	802f20a <RegionCommonRxConfigPrint+0x2e>
 802f220:	080348b0 	.word	0x080348b0
 802f224:	08035120 	.word	0x08035120
 802f228:	08035140 	.word	0x08035140

0802f22c <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 802f22c:	b500      	push	{lr}
 802f22e:	b083      	sub	sp, #12
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 802f230:	9101      	str	r1, [sp, #4]
 802f232:	9000      	str	r0, [sp, #0]
 802f234:	4b03      	ldr	r3, [pc, #12]	; (802f244 <RegionCommonTxConfigPrint+0x18>)
 802f236:	2201      	movs	r2, #1
 802f238:	2100      	movs	r1, #0
 802f23a:	2002      	movs	r0, #2
 802f23c:	f004 fc3c 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 802f240:	b003      	add	sp, #12
 802f242:	bd00      	pop	{pc}
 802f244:	0803515c 	.word	0x0803515c

0802f248 <VerifyRfFreq>:
static RegionNvmDataGroup1_t* RegionNvmGroup1;
static RegionNvmDataGroup2_t* RegionNvmGroup2;

// Static functions
static bool VerifyRfFreq( uint32_t freq, uint8_t *band )
{
 802f248:	b570      	push	{r4, r5, r6, lr}
 802f24a:	0004      	movs	r4, r0
 802f24c:	000d      	movs	r5, r1
    // Check radio driver support
    if( Radio.CheckRfFrequency( freq ) == false )
 802f24e:	4b1c      	ldr	r3, [pc, #112]	; (802f2c0 <VerifyRfFreq+0x78>)
 802f250:	6a1b      	ldr	r3, [r3, #32]
 802f252:	4798      	blx	r3
 802f254:	2800      	cmp	r0, #0
 802f256:	d006      	beq.n	802f266 <VerifyRfFreq+0x1e>
    {
        return false;
    }

    // Check frequency bands
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 802f258:	4a1a      	ldr	r2, [pc, #104]	; (802f2c4 <VerifyRfFreq+0x7c>)
 802f25a:	4b1b      	ldr	r3, [pc, #108]	; (802f2c8 <VerifyRfFreq+0x80>)
 802f25c:	18e3      	adds	r3, r4, r3
 802f25e:	4293      	cmp	r3, r2
 802f260:	d802      	bhi.n	802f268 <VerifyRfFreq+0x20>
    {
        *band = 2;
 802f262:	2302      	movs	r3, #2
 802f264:	702b      	strb	r3, [r5, #0]
    else
    {
        return false;
    }
    return true;
}
 802f266:	bd70      	pop	{r4, r5, r6, pc}
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 802f268:	4a18      	ldr	r2, [pc, #96]	; (802f2cc <VerifyRfFreq+0x84>)
 802f26a:	4b19      	ldr	r3, [pc, #100]	; (802f2d0 <VerifyRfFreq+0x88>)
 802f26c:	18e3      	adds	r3, r4, r3
 802f26e:	4293      	cmp	r3, r2
 802f270:	d802      	bhi.n	802f278 <VerifyRfFreq+0x30>
        *band = 0;
 802f272:	2300      	movs	r3, #0
 802f274:	702b      	strb	r3, [r5, #0]
 802f276:	e7f6      	b.n	802f266 <VerifyRfFreq+0x1e>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 802f278:	4a16      	ldr	r2, [pc, #88]	; (802f2d4 <VerifyRfFreq+0x8c>)
 802f27a:	4b17      	ldr	r3, [pc, #92]	; (802f2d8 <VerifyRfFreq+0x90>)
 802f27c:	18e3      	adds	r3, r4, r3
 802f27e:	4293      	cmp	r3, r2
 802f280:	d802      	bhi.n	802f288 <VerifyRfFreq+0x40>
        *band = 1;
 802f282:	2301      	movs	r3, #1
 802f284:	702b      	strb	r3, [r5, #0]
 802f286:	e7ee      	b.n	802f266 <VerifyRfFreq+0x1e>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 802f288:	4a14      	ldr	r2, [pc, #80]	; (802f2dc <VerifyRfFreq+0x94>)
 802f28a:	4b15      	ldr	r3, [pc, #84]	; (802f2e0 <VerifyRfFreq+0x98>)
 802f28c:	18e3      	adds	r3, r4, r3
 802f28e:	4293      	cmp	r3, r2
 802f290:	d802      	bhi.n	802f298 <VerifyRfFreq+0x50>
        *band = 5;
 802f292:	2305      	movs	r3, #5
 802f294:	702b      	strb	r3, [r5, #0]
 802f296:	e7e6      	b.n	802f266 <VerifyRfFreq+0x1e>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 802f298:	4a12      	ldr	r2, [pc, #72]	; (802f2e4 <VerifyRfFreq+0x9c>)
 802f29a:	4b13      	ldr	r3, [pc, #76]	; (802f2e8 <VerifyRfFreq+0xa0>)
 802f29c:	18e3      	adds	r3, r4, r3
 802f29e:	4293      	cmp	r3, r2
 802f2a0:	d802      	bhi.n	802f2a8 <VerifyRfFreq+0x60>
        *band = 3;
 802f2a2:	2303      	movs	r3, #3
 802f2a4:	702b      	strb	r3, [r5, #0]
 802f2a6:	e7de      	b.n	802f266 <VerifyRfFreq+0x1e>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 802f2a8:	4b10      	ldr	r3, [pc, #64]	; (802f2ec <VerifyRfFreq+0xa4>)
 802f2aa:	469c      	mov	ip, r3
 802f2ac:	4464      	add	r4, ip
 802f2ae:	4b10      	ldr	r3, [pc, #64]	; (802f2f0 <VerifyRfFreq+0xa8>)
 802f2b0:	429c      	cmp	r4, r3
 802f2b2:	d802      	bhi.n	802f2ba <VerifyRfFreq+0x72>
        *band = 4;
 802f2b4:	2304      	movs	r3, #4
 802f2b6:	702b      	strb	r3, [r5, #0]
 802f2b8:	e7d5      	b.n	802f266 <VerifyRfFreq+0x1e>
        return false;
 802f2ba:	2000      	movs	r0, #0
 802f2bc:	e7d3      	b.n	802f266 <VerifyRfFreq+0x1e>
 802f2be:	46c0      	nop			; (mov r8, r8)
 802f2c0:	080356b4 	.word	0x080356b4
 802f2c4:	001e847f 	.word	0x001e847f
 802f2c8:	cc8faa40 	.word	0xcc8faa40
 802f2cc:	002dc6c0 	.word	0x002dc6c0
 802f2d0:	cc7125c0 	.word	0xcc7125c0
 802f2d4:	000927bf 	.word	0x000927bf
 802f2d8:	cc435eff 	.word	0xcc435eff
 802f2dc:	0007a120 	.word	0x0007a120
 802f2e0:	cc38b0a0 	.word	0xcc38b0a0
 802f2e4:	0003d090 	.word	0x0003d090
 802f2e8:	cc2e0240 	.word	0xcc2e0240
 802f2ec:	cc296e60 	.word	0xcc296e60
 802f2f0:	000493e0 	.word	0x000493e0

0802f2f4 <GetTimeOnAir>:

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 802f2f4:	b570      	push	{r4, r5, r6, lr}
 802f2f6:	b084      	sub	sp, #16
 802f2f8:	0005      	movs	r5, r0
 802f2fa:	000c      	movs	r4, r1
    int8_t phyDr = DataratesEU868[datarate];
 802f2fc:	4b15      	ldr	r3, [pc, #84]	; (802f354 <GetTimeOnAir+0x60>)
 802f2fe:	561e      	ldrsb	r6, [r3, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 802f300:	4915      	ldr	r1, [pc, #84]	; (802f358 <GetTimeOnAir+0x64>)
 802f302:	f7ff ff59 	bl	802f1b8 <RegionCommonGetBandwidth>
 802f306:	0001      	movs	r1, r0
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
 802f308:	2d07      	cmp	r5, #7
 802f30a:	d00f      	beq.n	802f32c <GetTimeOnAir+0x38>
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 802f30c:	4b13      	ldr	r3, [pc, #76]	; (802f35c <GetTimeOnAir+0x68>)
 802f30e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 802f310:	2301      	movs	r3, #1
 802f312:	9303      	str	r3, [sp, #12]
 802f314:	b2e4      	uxtb	r4, r4
 802f316:	9402      	str	r4, [sp, #8]
 802f318:	2300      	movs	r3, #0
 802f31a:	9301      	str	r3, [sp, #4]
 802f31c:	3308      	adds	r3, #8
 802f31e:	9300      	str	r3, [sp, #0]
 802f320:	3b07      	subs	r3, #7
 802f322:	0032      	movs	r2, r6
 802f324:	2001      	movs	r0, #1
 802f326:	47a8      	blx	r5
    }
    return timeOnAir;
}
 802f328:	b004      	add	sp, #16
 802f32a:	bd70      	pop	{r4, r5, r6, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 802f32c:	4b0b      	ldr	r3, [pc, #44]	; (802f35c <GetTimeOnAir+0x68>)
 802f32e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 802f330:	0172      	lsls	r2, r6, #5
 802f332:	1b92      	subs	r2, r2, r6
 802f334:	0092      	lsls	r2, r2, #2
 802f336:	1992      	adds	r2, r2, r6
 802f338:	00d2      	lsls	r2, r2, #3
 802f33a:	2301      	movs	r3, #1
 802f33c:	9303      	str	r3, [sp, #12]
 802f33e:	b2e4      	uxtb	r4, r4
 802f340:	9402      	str	r4, [sp, #8]
 802f342:	2300      	movs	r3, #0
 802f344:	9301      	str	r3, [sp, #4]
 802f346:	3305      	adds	r3, #5
 802f348:	9300      	str	r3, [sp, #0]
 802f34a:	2300      	movs	r3, #0
 802f34c:	2000      	movs	r0, #0
 802f34e:	47a8      	blx	r5
 802f350:	e7ea      	b.n	802f328 <GetTimeOnAir+0x34>
 802f352:	46c0      	nop			; (mov r8, r8)
 802f354:	08035294 	.word	0x08035294
 802f358:	08035274 	.word	0x08035274
 802f35c:	080356b4 	.word	0x080356b4

0802f360 <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 802f360:	b500      	push	{lr}
 802f362:	b087      	sub	sp, #28
    PhyParam_t phyParam = { 0 };
 802f364:	2300      	movs	r3, #0
 802f366:	9304      	str	r3, [sp, #16]

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 802f368:	7803      	ldrb	r3, [r0, #0]
 802f36a:	3b0b      	subs	r3, #11
 802f36c:	b2da      	uxtb	r2, r3
 802f36e:	2a2e      	cmp	r2, #46	; 0x2e
 802f370:	d817      	bhi.n	802f3a2 <RegionEU868GetPhyParam+0x42>
 802f372:	0093      	lsls	r3, r2, #2
 802f374:	4a48      	ldr	r2, [pc, #288]	; (802f498 <RegionEU868GetPhyParam+0x138>)
 802f376:	58d3      	ldr	r3, [r2, r3]
 802f378:	469f      	mov	pc, r3
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
            {
                .CurrentDr = getPhy->Datarate,
 802f37a:	2301      	movs	r3, #1
 802f37c:	56c3      	ldrsb	r3, [r0, r3]
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 802f37e:	a801      	add	r0, sp, #4
 802f380:	7003      	strb	r3, [r0, #0]
 802f382:	2307      	movs	r3, #7
 802f384:	7043      	strb	r3, [r0, #1]
 802f386:	2300      	movs	r3, #0
 802f388:	7083      	strb	r3, [r0, #2]
 802f38a:	3310      	adds	r3, #16
 802f38c:	70c3      	strb	r3, [r0, #3]
                .MaxDr = ( int8_t )EU868_TX_MAX_DATARATE,
                .MinDr = ( int8_t )EU868_TX_MIN_DATARATE,
                .NbChannels = EU868_MAX_NB_CHANNELS,
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 802f38e:	4b43      	ldr	r3, [pc, #268]	; (802f49c <RegionEU868GetPhyParam+0x13c>)
 802f390:	681b      	ldr	r3, [r3, #0]
 802f392:	22d8      	movs	r2, #216	; 0xd8
 802f394:	0092      	lsls	r2, r2, #2
 802f396:	189a      	adds	r2, r3, r2
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 802f398:	6042      	str	r2, [r0, #4]
 802f39a:	6083      	str	r3, [r0, #8]
                .Channels = RegionNvmGroup2->Channels,
            };
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 802f39c:	f7ff fee6 	bl	802f16c <RegionCommonGetNextLowerTxDr>
 802f3a0:	9004      	str	r0, [sp, #16]
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
}
 802f3a2:	9804      	ldr	r0, [sp, #16]
 802f3a4:	b007      	add	sp, #28
 802f3a6:	bd00      	pop	{pc}
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 802f3a8:	2340      	movs	r3, #64	; 0x40
 802f3aa:	9304      	str	r3, [sp, #16]
            break;
 802f3ac:	e7f9      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 802f3ae:	2320      	movs	r3, #32
 802f3b0:	9304      	str	r3, [sp, #16]
            break;
 802f3b2:	e7f6      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 802f3b4:	2301      	movs	r3, #1
 802f3b6:	56c3      	ldrsb	r3, [r0, r3]
 802f3b8:	4a39      	ldr	r2, [pc, #228]	; (802f4a0 <RegionEU868GetPhyParam+0x140>)
 802f3ba:	5cd3      	ldrb	r3, [r2, r3]
 802f3bc:	9304      	str	r3, [sp, #16]
            break;
 802f3be:	e7f0      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 802f3c0:	2301      	movs	r3, #1
 802f3c2:	56c3      	ldrsb	r3, [r0, r3]
 802f3c4:	4a37      	ldr	r2, [pc, #220]	; (802f4a4 <RegionEU868GetPhyParam+0x144>)
 802f3c6:	5cd3      	ldrb	r3, [r2, r3]
 802f3c8:	9304      	str	r3, [sp, #16]
            break;
 802f3ca:	e7ea      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 802f3cc:	2301      	movs	r3, #1
 802f3ce:	9304      	str	r3, [sp, #16]
            break;
 802f3d0:	e7e7      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 802f3d2:	4b35      	ldr	r3, [pc, #212]	; (802f4a8 <RegionEU868GetPhyParam+0x148>)
 802f3d4:	9304      	str	r3, [sp, #16]
            break;
 802f3d6:	e7e4      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 802f3d8:	23fa      	movs	r3, #250	; 0xfa
 802f3da:	009b      	lsls	r3, r3, #2
 802f3dc:	9304      	str	r3, [sp, #16]
            break;
 802f3de:	e7e0      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 802f3e0:	23fa      	movs	r3, #250	; 0xfa
 802f3e2:	00db      	lsls	r3, r3, #3
 802f3e4:	9304      	str	r3, [sp, #16]
            break;
 802f3e6:	e7dc      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 802f3e8:	4b30      	ldr	r3, [pc, #192]	; (802f4ac <RegionEU868GetPhyParam+0x14c>)
 802f3ea:	9304      	str	r3, [sp, #16]
            break;
 802f3ec:	e7d9      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 802f3ee:	4b30      	ldr	r3, [pc, #192]	; (802f4b0 <RegionEU868GetPhyParam+0x150>)
 802f3f0:	9304      	str	r3, [sp, #16]
            break;
 802f3f2:	e7d6      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 802f3f4:	2380      	movs	r3, #128	; 0x80
 802f3f6:	01db      	lsls	r3, r3, #7
 802f3f8:	9304      	str	r3, [sp, #16]
            break;
 802f3fa:	e7d2      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 802f3fc:	21fa      	movs	r1, #250	; 0xfa
 802f3fe:	0089      	lsls	r1, r1, #2
 802f400:	482c      	ldr	r0, [pc, #176]	; (802f4b4 <RegionEU868GetPhyParam+0x154>)
 802f402:	f002 f9bf 	bl	8031784 <randr>
 802f406:	23fa      	movs	r3, #250	; 0xfa
 802f408:	00db      	lsls	r3, r3, #3
 802f40a:	469c      	mov	ip, r3
 802f40c:	4460      	add	r0, ip
 802f40e:	9004      	str	r0, [sp, #16]
            break;
 802f410:	e7c7      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_RX_WND_2_FREQ;
 802f412:	4b29      	ldr	r3, [pc, #164]	; (802f4b8 <RegionEU868GetPhyParam+0x158>)
 802f414:	9304      	str	r3, [sp, #16]
            break;
 802f416:	e7c4      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 802f418:	4b20      	ldr	r3, [pc, #128]	; (802f49c <RegionEU868GetPhyParam+0x13c>)
 802f41a:	681b      	ldr	r3, [r3, #0]
 802f41c:	22d8      	movs	r2, #216	; 0xd8
 802f41e:	0092      	lsls	r2, r2, #2
 802f420:	4694      	mov	ip, r2
 802f422:	4463      	add	r3, ip
 802f424:	9304      	str	r3, [sp, #16]
            break;
 802f426:	e7bc      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 802f428:	4b1c      	ldr	r3, [pc, #112]	; (802f49c <RegionEU868GetPhyParam+0x13c>)
 802f42a:	681b      	ldr	r3, [r3, #0]
 802f42c:	22db      	movs	r2, #219	; 0xdb
 802f42e:	0092      	lsls	r2, r2, #2
 802f430:	4694      	mov	ip, r2
 802f432:	4463      	add	r3, ip
 802f434:	9304      	str	r3, [sp, #16]
            break;
 802f436:	e7b4      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 802f438:	2310      	movs	r3, #16
 802f43a:	9304      	str	r3, [sp, #16]
            break;
 802f43c:	e7b1      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Channels = RegionNvmGroup2->Channels;
 802f43e:	4b17      	ldr	r3, [pc, #92]	; (802f49c <RegionEU868GetPhyParam+0x13c>)
 802f440:	681b      	ldr	r3, [r3, #0]
 802f442:	9304      	str	r3, [sp, #16]
            break;
 802f444:	e7ad      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 802f446:	2383      	movs	r3, #131	; 0x83
 802f448:	05db      	lsls	r3, r3, #23
 802f44a:	9304      	str	r3, [sp, #16]
            break;
 802f44c:	e7a9      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 802f44e:	4b1b      	ldr	r3, [pc, #108]	; (802f4bc <RegionEU868GetPhyParam+0x15c>)
 802f450:	9304      	str	r3, [sp, #16]
            break;
 802f452:	e7a6      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_BEACON_CHANNEL_FREQ;
 802f454:	4b18      	ldr	r3, [pc, #96]	; (802f4b8 <RegionEU868GetPhyParam+0x158>)
 802f456:	9304      	str	r3, [sp, #16]
            break;
 802f458:	e7a3      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 802f45a:	ab04      	add	r3, sp, #16
 802f45c:	2211      	movs	r2, #17
 802f45e:	701a      	strb	r2, [r3, #0]
            phyParam.BeaconFormat.Rfu1Size = EU868_RFU1_SIZE;
 802f460:	3a0f      	subs	r2, #15
 802f462:	705a      	strb	r2, [r3, #1]
            phyParam.BeaconFormat.Rfu2Size = EU868_RFU2_SIZE;
 802f464:	2200      	movs	r2, #0
 802f466:	709a      	strb	r2, [r3, #2]
            break;
 802f468:	e79b      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 802f46a:	2303      	movs	r3, #3
 802f46c:	9304      	str	r3, [sp, #16]
            break;
 802f46e:	e798      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_PING_SLOT_CHANNEL_FREQ;
 802f470:	4b11      	ldr	r3, [pc, #68]	; (802f4b8 <RegionEU868GetPhyParam+0x158>)
 802f472:	9304      	str	r3, [sp, #16]
            break;
 802f474:	e795      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_PING_SLOT_CHANNEL_DR;
 802f476:	2303      	movs	r3, #3
 802f478:	9304      	str	r3, [sp, #16]
            break;
 802f47a:	e792      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 802f47c:	2301      	movs	r3, #1
 802f47e:	56c3      	ldrsb	r3, [r0, r3]
 802f480:	4a0f      	ldr	r2, [pc, #60]	; (802f4c0 <RegionEU868GetPhyParam+0x160>)
 802f482:	5cd3      	ldrb	r3, [r2, r3]
 802f484:	9304      	str	r3, [sp, #16]
            break;
 802f486:	e78c      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 802f488:	7840      	ldrb	r0, [r0, #1]
 802f48a:	b240      	sxtb	r0, r0
 802f48c:	490d      	ldr	r1, [pc, #52]	; (802f4c4 <RegionEU868GetPhyParam+0x164>)
 802f48e:	f7ff fe93 	bl	802f1b8 <RegionCommonGetBandwidth>
 802f492:	9004      	str	r0, [sp, #16]
            break;
 802f494:	e785      	b.n	802f3a2 <RegionEU868GetPhyParam+0x42>
 802f496:	46c0      	nop			; (mov r8, r8)
 802f498:	08035178 	.word	0x08035178
 802f49c:	2000b1b8 	.word	0x2000b1b8
 802f4a0:	0803529c 	.word	0x0803529c
 802f4a4:	080352a4 	.word	0x080352a4
 802f4a8:	00000bb8 	.word	0x00000bb8
 802f4ac:	00001388 	.word	0x00001388
 802f4b0:	00001770 	.word	0x00001770
 802f4b4:	fffffc18 	.word	0xfffffc18
 802f4b8:	33d3e608 	.word	0x33d3e608
 802f4bc:	4009999a 	.word	0x4009999a
 802f4c0:	08035294 	.word	0x08035294
 802f4c4:	08035274 	.word	0x08035274

0802f4c8 <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 802f4c8:	b530      	push	{r4, r5, lr}
 802f4ca:	b083      	sub	sp, #12
 802f4cc:	0003      	movs	r3, r0
#if defined( REGION_EU868 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 802f4ce:	4a0b      	ldr	r2, [pc, #44]	; (802f4fc <RegionEU868SetBandTxDone+0x34>)
 802f4d0:	6814      	ldr	r4, [r2, #0]
 802f4d2:	4a0b      	ldr	r2, [pc, #44]	; (802f500 <RegionEU868SetBandTxDone+0x38>)
 802f4d4:	6811      	ldr	r1, [r2, #0]
 802f4d6:	7800      	ldrb	r0, [r0, #0]
 802f4d8:	0042      	lsls	r2, r0, #1
 802f4da:	1812      	adds	r2, r2, r0
 802f4dc:	0092      	lsls	r2, r2, #2
 802f4de:	188a      	adds	r2, r1, r2
 802f4e0:	7a55      	ldrb	r5, [r2, #9]
 802f4e2:	785a      	ldrb	r2, [r3, #1]
 802f4e4:	6899      	ldr	r1, [r3, #8]
 802f4e6:	0068      	lsls	r0, r5, #1
 802f4e8:	1940      	adds	r0, r0, r5
 802f4ea:	00c0      	lsls	r0, r0, #3
 802f4ec:	1820      	adds	r0, r4, r0
 802f4ee:	691c      	ldr	r4, [r3, #16]
 802f4f0:	9400      	str	r4, [sp, #0]
 802f4f2:	68db      	ldr	r3, [r3, #12]
 802f4f4:	f7ff fbfa 	bl	802ecec <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_EU868 */
}
 802f4f8:	b003      	add	sp, #12
 802f4fa:	bd30      	pop	{r4, r5, pc}
 802f4fc:	2000b1b4 	.word	0x2000b1b4
 802f500:	2000b1b8 	.word	0x2000b1b8

0802f504 <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 802f504:	b570      	push	{r4, r5, r6, lr}
 802f506:	b0a4      	sub	sp, #144	; 0x90
 802f508:	0004      	movs	r4, r0
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 802f50a:	2290      	movs	r2, #144	; 0x90
 802f50c:	2100      	movs	r1, #0
 802f50e:	4668      	mov	r0, sp
 802f510:	f005 f909 	bl	8034726 <memset>
 802f514:	2364      	movs	r3, #100	; 0x64
 802f516:	466a      	mov	r2, sp
 802f518:	8013      	strh	r3, [r2, #0]
 802f51a:	8313      	strh	r3, [r2, #24]
 802f51c:	22fa      	movs	r2, #250	; 0xfa
 802f51e:	0092      	lsls	r2, r2, #2
 802f520:	4669      	mov	r1, sp
 802f522:	860a      	strh	r2, [r1, #48]	; 0x30
 802f524:	2148      	movs	r1, #72	; 0x48
 802f526:	200a      	movs	r0, #10
 802f528:	466d      	mov	r5, sp
 802f52a:	5268      	strh	r0, [r5, r1]
 802f52c:	3118      	adds	r1, #24
 802f52e:	526b      	strh	r3, [r5, r1]
 802f530:	3314      	adds	r3, #20
 802f532:	4669      	mov	r1, sp
 802f534:	52ea      	strh	r2, [r5, r3]
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 802f536:	7a23      	ldrb	r3, [r4, #8]
 802f538:	2b01      	cmp	r3, #1
 802f53a:	d02c      	beq.n	802f596 <RegionEU868InitDefaults+0x92>
 802f53c:	2b02      	cmp	r3, #2
 802f53e:	d03a      	beq.n	802f5b6 <RegionEU868InitDefaults+0xb2>
 802f540:	2b00      	cmp	r3, #0
 802f542:	d001      	beq.n	802f548 <RegionEU868InitDefaults+0x44>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 802f544:	b024      	add	sp, #144	; 0x90
 802f546:	bd70      	pop	{r4, r5, r6, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 802f548:	6820      	ldr	r0, [r4, #0]
 802f54a:	2800      	cmp	r0, #0
 802f54c:	d0fa      	beq.n	802f544 <RegionEU868InitDefaults+0x40>
 802f54e:	6863      	ldr	r3, [r4, #4]
 802f550:	2b00      	cmp	r3, #0
 802f552:	d0f7      	beq.n	802f544 <RegionEU868InitDefaults+0x40>
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 802f554:	4a1d      	ldr	r2, [pc, #116]	; (802f5cc <RegionEU868InitDefaults+0xc8>)
 802f556:	6010      	str	r0, [r2, #0]
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 802f558:	4c1d      	ldr	r4, [pc, #116]	; (802f5d0 <RegionEU868InitDefaults+0xcc>)
 802f55a:	6023      	str	r3, [r4, #0]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 802f55c:	2290      	movs	r2, #144	; 0x90
 802f55e:	f002 f91c 	bl	803179a <memcpy1>
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 802f562:	6821      	ldr	r1, [r4, #0]
 802f564:	4b1b      	ldr	r3, [pc, #108]	; (802f5d4 <RegionEU868InitDefaults+0xd0>)
 802f566:	0008      	movs	r0, r1
 802f568:	001a      	movs	r2, r3
 802f56a:	ca70      	ldmia	r2!, {r4, r5, r6}
 802f56c:	c070      	stmia	r0!, {r4, r5, r6}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 802f56e:	ca70      	ldmia	r2!, {r4, r5, r6}
 802f570:	c070      	stmia	r0!, {r4, r5, r6}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 802f572:	000a      	movs	r2, r1
 802f574:	3218      	adds	r2, #24
 802f576:	3318      	adds	r3, #24
 802f578:	cb31      	ldmia	r3!, {r0, r4, r5}
 802f57a:	c231      	stmia	r2!, {r0, r4, r5}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 802f57c:	23db      	movs	r3, #219	; 0xdb
 802f57e:	009b      	lsls	r3, r3, #2
 802f580:	2207      	movs	r2, #7
 802f582:	52ca      	strh	r2, [r1, r3]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 802f584:	3b0c      	subs	r3, #12
 802f586:	18c8      	adds	r0, r1, r3
 802f588:	330c      	adds	r3, #12
 802f58a:	469c      	mov	ip, r3
 802f58c:	4461      	add	r1, ip
 802f58e:	3a06      	subs	r2, #6
 802f590:	f7ff fb9d 	bl	802ecce <RegionCommonChanMaskCopy>
            break;
 802f594:	e7d6      	b.n	802f544 <RegionEU868InitDefaults+0x40>
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 802f596:	4b0e      	ldr	r3, [pc, #56]	; (802f5d0 <RegionEU868InitDefaults+0xcc>)
 802f598:	6819      	ldr	r1, [r3, #0]
 802f59a:	2300      	movs	r3, #0
 802f59c:	604b      	str	r3, [r1, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 802f59e:	610b      	str	r3, [r1, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 802f5a0:	61cb      	str	r3, [r1, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 802f5a2:	23d8      	movs	r3, #216	; 0xd8
 802f5a4:	009b      	lsls	r3, r3, #2
 802f5a6:	18c8      	adds	r0, r1, r3
 802f5a8:	330c      	adds	r3, #12
 802f5aa:	469c      	mov	ip, r3
 802f5ac:	4461      	add	r1, ip
 802f5ae:	2201      	movs	r2, #1
 802f5b0:	f7ff fb8d 	bl	802ecce <RegionCommonChanMaskCopy>
            break;
 802f5b4:	e7c6      	b.n	802f544 <RegionEU868InitDefaults+0x40>
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 802f5b6:	4b06      	ldr	r3, [pc, #24]	; (802f5d0 <RegionEU868InitDefaults+0xcc>)
 802f5b8:	681b      	ldr	r3, [r3, #0]
 802f5ba:	22db      	movs	r2, #219	; 0xdb
 802f5bc:	0092      	lsls	r2, r2, #2
 802f5be:	5a9a      	ldrh	r2, [r3, r2]
 802f5c0:	21d8      	movs	r1, #216	; 0xd8
 802f5c2:	0089      	lsls	r1, r1, #2
 802f5c4:	5a58      	ldrh	r0, [r3, r1]
 802f5c6:	4302      	orrs	r2, r0
 802f5c8:	525a      	strh	r2, [r3, r1]
            break;
 802f5ca:	e7bb      	b.n	802f544 <RegionEU868InitDefaults+0x40>
 802f5cc:	2000b1b4 	.word	0x2000b1b4
 802f5d0:	2000b1b8 	.word	0x2000b1b8
 802f5d4:	080348c8 	.word	0x080348c8

0802f5d8 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 802f5d8:	b500      	push	{lr}
 802f5da:	b083      	sub	sp, #12
#if defined( REGION_EU868 )
    switch( phyAttribute )
 802f5dc:	290f      	cmp	r1, #15
 802f5de:	d835      	bhi.n	802f64c <RegionEU868Verify+0x74>
 802f5e0:	0089      	lsls	r1, r1, #2
 802f5e2:	4b1c      	ldr	r3, [pc, #112]	; (802f654 <RegionEU868Verify+0x7c>)
 802f5e4:	585b      	ldr	r3, [r3, r1]
 802f5e6:	469f      	mov	pc, r3
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
        }
        default:
            return false;
 802f5e8:	2001      	movs	r0, #1
 802f5ea:	e030      	b.n	802f64e <RegionEU868Verify+0x76>
            uint8_t band = 0;
 802f5ec:	466b      	mov	r3, sp
 802f5ee:	1dd9      	adds	r1, r3, #7
 802f5f0:	2300      	movs	r3, #0
 802f5f2:	700b      	strb	r3, [r1, #0]
            return VerifyRfFreq( verify->Frequency, &band );
 802f5f4:	6800      	ldr	r0, [r0, #0]
 802f5f6:	f7ff fe27 	bl	802f248 <VerifyRfFreq>
 802f5fa:	e028      	b.n	802f64e <RegionEU868Verify+0x76>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE );
 802f5fc:	7800      	ldrb	r0, [r0, #0]
 802f5fe:	b240      	sxtb	r0, r0
 802f600:	2207      	movs	r2, #7
 802f602:	2100      	movs	r1, #0
 802f604:	f7ff fae9 	bl	802ebda <RegionCommonValueInRange>
 802f608:	1e43      	subs	r3, r0, #1
 802f60a:	4198      	sbcs	r0, r3
 802f60c:	b2c0      	uxtb	r0, r0
 802f60e:	e01e      	b.n	802f64e <RegionEU868Verify+0x76>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 802f610:	7800      	ldrb	r0, [r0, #0]
 802f612:	b240      	sxtb	r0, r0
 802f614:	2205      	movs	r2, #5
 802f616:	2100      	movs	r1, #0
 802f618:	f7ff fadf 	bl	802ebda <RegionCommonValueInRange>
 802f61c:	1e43      	subs	r3, r0, #1
 802f61e:	4198      	sbcs	r0, r3
 802f620:	b2c0      	uxtb	r0, r0
 802f622:	e014      	b.n	802f64e <RegionEU868Verify+0x76>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE );
 802f624:	7800      	ldrb	r0, [r0, #0]
 802f626:	b240      	sxtb	r0, r0
 802f628:	2207      	movs	r2, #7
 802f62a:	2100      	movs	r1, #0
 802f62c:	f7ff fad5 	bl	802ebda <RegionCommonValueInRange>
 802f630:	1e43      	subs	r3, r0, #1
 802f632:	4198      	sbcs	r0, r3
 802f634:	b2c0      	uxtb	r0, r0
 802f636:	e00a      	b.n	802f64e <RegionEU868Verify+0x76>
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 802f638:	7800      	ldrb	r0, [r0, #0]
 802f63a:	b240      	sxtb	r0, r0
 802f63c:	2207      	movs	r2, #7
 802f63e:	2100      	movs	r1, #0
 802f640:	f7ff facb 	bl	802ebda <RegionCommonValueInRange>
 802f644:	1e43      	subs	r3, r0, #1
 802f646:	4198      	sbcs	r0, r3
 802f648:	b2c0      	uxtb	r0, r0
 802f64a:	e000      	b.n	802f64e <RegionEU868Verify+0x76>
            return false;
 802f64c:	2000      	movs	r0, #0
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 802f64e:	b003      	add	sp, #12
 802f650:	bd00      	pop	{pc}
 802f652:	46c0      	nop			; (mov r8, r8)
 802f654:	08035234 	.word	0x08035234

0802f658 <RegionEU868ChanMaskSet>:
    }
#endif /* REGION_EU868 */
}

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 802f658:	b510      	push	{r4, lr}
 802f65a:	0003      	movs	r3, r0
#if defined( REGION_EU868 )
    switch( chanMaskSet->ChannelsMaskType )
 802f65c:	7902      	ldrb	r2, [r0, #4]
 802f65e:	2a00      	cmp	r2, #0
 802f660:	d003      	beq.n	802f66a <RegionEU868ChanMaskSet+0x12>
 802f662:	2a01      	cmp	r2, #1
 802f664:	d00d      	beq.n	802f682 <RegionEU868ChanMaskSet+0x2a>
 802f666:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 802f668:	bd10      	pop	{r4, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 802f66a:	4a0c      	ldr	r2, [pc, #48]	; (802f69c <RegionEU868ChanMaskSet+0x44>)
 802f66c:	6810      	ldr	r0, [r2, #0]
 802f66e:	22d8      	movs	r2, #216	; 0xd8
 802f670:	0092      	lsls	r2, r2, #2
 802f672:	4694      	mov	ip, r2
 802f674:	4460      	add	r0, ip
 802f676:	6819      	ldr	r1, [r3, #0]
 802f678:	2201      	movs	r2, #1
 802f67a:	f7ff fb28 	bl	802ecce <RegionCommonChanMaskCopy>
    return true;
 802f67e:	2001      	movs	r0, #1
            break;
 802f680:	e7f2      	b.n	802f668 <RegionEU868ChanMaskSet+0x10>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 802f682:	4a06      	ldr	r2, [pc, #24]	; (802f69c <RegionEU868ChanMaskSet+0x44>)
 802f684:	6810      	ldr	r0, [r2, #0]
 802f686:	22db      	movs	r2, #219	; 0xdb
 802f688:	0092      	lsls	r2, r2, #2
 802f68a:	4694      	mov	ip, r2
 802f68c:	4460      	add	r0, ip
 802f68e:	6819      	ldr	r1, [r3, #0]
 802f690:	2201      	movs	r2, #1
 802f692:	f7ff fb1c 	bl	802ecce <RegionCommonChanMaskCopy>
    return true;
 802f696:	2001      	movs	r0, #1
            break;
 802f698:	e7e6      	b.n	802f668 <RegionEU868ChanMaskSet+0x10>
 802f69a:	46c0      	nop			; (mov r8, r8)
 802f69c:	2000b1b8 	.word	0x2000b1b8

0802f6a0 <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 802f6a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f6a2:	b083      	sub	sp, #12
 802f6a4:	000e      	movs	r6, r1
 802f6a6:	0017      	movs	r7, r2
 802f6a8:	001c      	movs	r4, r3
#if defined( REGION_EU868 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 802f6aa:	1c03      	adds	r3, r0, #0
 802f6ac:	2807      	cmp	r0, #7
 802f6ae:	dd00      	ble.n	802f6b2 <RegionEU868ComputeRxWindowParameters+0x12>
 802f6b0:	2307      	movs	r3, #7
 802f6b2:	b258      	sxtb	r0, r3
 802f6b4:	7063      	strb	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 802f6b6:	4913      	ldr	r1, [pc, #76]	; (802f704 <RegionEU868ComputeRxWindowParameters+0x64>)
 802f6b8:	f7ff fd7e 	bl	802f1b8 <RegionCommonGetBandwidth>
 802f6bc:	70a0      	strb	r0, [r4, #2]

    if( rxConfigParams->Datarate == DR_7 )
 802f6be:	2301      	movs	r3, #1
 802f6c0:	56e3      	ldrsb	r3, [r4, r3]
 802f6c2:	2b07      	cmp	r3, #7
 802f6c4:	d017      	beq.n	802f6f6 <RegionEU868ComputeRxWindowParameters+0x56>
    { // FSK
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
    }
    else
    { // LoRa
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 802f6c6:	0099      	lsls	r1, r3, #2
 802f6c8:	4a0e      	ldr	r2, [pc, #56]	; (802f704 <RegionEU868ComputeRxWindowParameters+0x64>)
 802f6ca:	5889      	ldr	r1, [r1, r2]
 802f6cc:	4a0e      	ldr	r2, [pc, #56]	; (802f708 <RegionEU868ComputeRxWindowParameters+0x68>)
 802f6ce:	5cd0      	ldrb	r0, [r2, r3]
 802f6d0:	f7ff fc2c 	bl	802ef2c <RegionCommonComputeSymbolTimeLoRa>
 802f6d4:	0005      	movs	r5, r0
    }

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 802f6d6:	4b0d      	ldr	r3, [pc, #52]	; (802f70c <RegionEU868ComputeRxWindowParameters+0x6c>)
 802f6d8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802f6da:	4798      	blx	r3
 802f6dc:	0003      	movs	r3, r0
 802f6de:	0022      	movs	r2, r4
 802f6e0:	320c      	adds	r2, #12
 802f6e2:	9201      	str	r2, [sp, #4]
 802f6e4:	3408      	adds	r4, #8
 802f6e6:	9400      	str	r4, [sp, #0]
 802f6e8:	003a      	movs	r2, r7
 802f6ea:	0031      	movs	r1, r6
 802f6ec:	0028      	movs	r0, r5
 802f6ee:	f7ff fc2f 	bl	802ef50 <RegionCommonComputeRxWindowParameters>
#endif /* REGION_EU868 */
}
 802f6f2:	b003      	add	sp, #12
 802f6f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 802f6f6:	4a04      	ldr	r2, [pc, #16]	; (802f708 <RegionEU868ComputeRxWindowParameters+0x68>)
 802f6f8:	5cd0      	ldrb	r0, [r2, r3]
 802f6fa:	f7ff fc21 	bl	802ef40 <RegionCommonComputeSymbolTimeFsk>
 802f6fe:	0005      	movs	r5, r0
 802f700:	e7e9      	b.n	802f6d6 <RegionEU868ComputeRxWindowParameters+0x36>
 802f702:	46c0      	nop			; (mov r8, r8)
 802f704:	08035274 	.word	0x08035274
 802f708:	08035294 	.word	0x08035294
 802f70c:	080356b4 	.word	0x080356b4

0802f710 <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 802f710:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f712:	46d6      	mov	lr, sl
 802f714:	464f      	mov	r7, r9
 802f716:	b580      	push	{r7, lr}
 802f718:	b08d      	sub	sp, #52	; 0x34
 802f71a:	0004      	movs	r4, r0
 802f71c:	910b      	str	r1, [sp, #44]	; 0x2c
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t dr = rxConfig->Datarate;
 802f71e:	2601      	movs	r6, #1
 802f720:	5786      	ldrsb	r6, [r0, r6]
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;
 802f722:	6847      	ldr	r7, [r0, #4]

    if( Radio.GetStatus( ) != RF_IDLE )
 802f724:	4b38      	ldr	r3, [pc, #224]	; (802f808 <RegionEU868RxConfig+0xf8>)
 802f726:	685b      	ldr	r3, [r3, #4]
 802f728:	4798      	blx	r3
 802f72a:	1e05      	subs	r5, r0, #0
 802f72c:	d169      	bne.n	802f802 <RegionEU868RxConfig+0xf2>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 802f72e:	7ce3      	ldrb	r3, [r4, #19]
 802f730:	2b00      	cmp	r3, #0
 802f732:	d10d      	bne.n	802f750 <RegionEU868RxConfig+0x40>
    {
        // Apply window 1 frequency
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 802f734:	4b35      	ldr	r3, [pc, #212]	; (802f80c <RegionEU868RxConfig+0xfc>)
 802f736:	681a      	ldr	r2, [r3, #0]
 802f738:	7821      	ldrb	r1, [r4, #0]
 802f73a:	004b      	lsls	r3, r1, #1
 802f73c:	1858      	adds	r0, r3, r1
 802f73e:	0080      	lsls	r0, r0, #2
 802f740:	5880      	ldr	r0, [r0, r2]
        // Apply the alternative RX 1 window frequency, if it is available
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 802f742:	185b      	adds	r3, r3, r1
 802f744:	009b      	lsls	r3, r3, #2
 802f746:	18d3      	adds	r3, r2, r3
 802f748:	685f      	ldr	r7, [r3, #4]
 802f74a:	2f00      	cmp	r7, #0
 802f74c:	d100      	bne.n	802f750 <RegionEU868RxConfig+0x40>
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 802f74e:	0007      	movs	r7, r0
            frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency;
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 802f750:	4b2f      	ldr	r3, [pc, #188]	; (802f810 <RegionEU868RxConfig+0x100>)
 802f752:	579b      	ldrsb	r3, [r3, r6]
 802f754:	469a      	mov	sl, r3

    Radio.SetChannel( frequency );
 802f756:	4b2c      	ldr	r3, [pc, #176]	; (802f808 <RegionEU868RxConfig+0xf8>)
 802f758:	68db      	ldr	r3, [r3, #12]
 802f75a:	0038      	movs	r0, r7
 802f75c:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 802f75e:	2e07      	cmp	r6, #7
 802f760:	d02e      	beq.n	802f7c0 <RegionEU868RxConfig+0xb0>
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 802f762:	4b29      	ldr	r3, [pc, #164]	; (802f808 <RegionEU868RxConfig+0xf8>)
 802f764:	699d      	ldr	r5, [r3, #24]
 802f766:	78a1      	ldrb	r1, [r4, #2]
 802f768:	7ca3      	ldrb	r3, [r4, #18]
 802f76a:	9309      	str	r3, [sp, #36]	; 0x24
 802f76c:	2301      	movs	r3, #1
 802f76e:	9308      	str	r3, [sp, #32]
 802f770:	2300      	movs	r3, #0
 802f772:	9307      	str	r3, [sp, #28]
 802f774:	9306      	str	r3, [sp, #24]
 802f776:	9305      	str	r3, [sp, #20]
 802f778:	9304      	str	r3, [sp, #16]
 802f77a:	9303      	str	r3, [sp, #12]
 802f77c:	8922      	ldrh	r2, [r4, #8]
 802f77e:	9202      	str	r2, [sp, #8]
 802f780:	2208      	movs	r2, #8
 802f782:	9201      	str	r2, [sp, #4]
 802f784:	9300      	str	r3, [sp, #0]
 802f786:	3301      	adds	r3, #1
 802f788:	4652      	mov	r2, sl
 802f78a:	2001      	movs	r0, #1
 802f78c:	47a8      	blx	r5
        modem = MODEM_LORA;
 802f78e:	2501      	movs	r5, #1
    }

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 802f790:	7c63      	ldrb	r3, [r4, #17]
 802f792:	2b00      	cmp	r3, #0
 802f794:	d032      	beq.n	802f7fc <RegionEU868RxConfig+0xec>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 802f796:	4b1f      	ldr	r3, [pc, #124]	; (802f814 <RegionEU868RxConfig+0x104>)
 802f798:	5d99      	ldrb	r1, [r3, r6]
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 802f79a:	4b1b      	ldr	r3, [pc, #108]	; (802f808 <RegionEU868RxConfig+0xf8>)
 802f79c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802f79e:	310d      	adds	r1, #13
 802f7a0:	b2c9      	uxtb	r1, r1
 802f7a2:	0028      	movs	r0, r5
 802f7a4:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 802f7a6:	7ce0      	ldrb	r0, [r4, #19]
 802f7a8:	0032      	movs	r2, r6
 802f7aa:	0039      	movs	r1, r7
 802f7ac:	f7ff fd16 	bl	802f1dc <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 802f7b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802f7b2:	701e      	strb	r6, [r3, #0]
    return true;
 802f7b4:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_EU868 */
}
 802f7b6:	b00d      	add	sp, #52	; 0x34
 802f7b8:	bcc0      	pop	{r6, r7}
 802f7ba:	46ba      	mov	sl, r7
 802f7bc:	46b1      	mov	r9, r6
 802f7be:	bdf0      	pop	{r4, r5, r6, r7, pc}
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 802f7c0:	4b11      	ldr	r3, [pc, #68]	; (802f808 <RegionEU868RxConfig+0xf8>)
 802f7c2:	699b      	ldr	r3, [r3, #24]
 802f7c4:	4699      	mov	r9, r3
 802f7c6:	4653      	mov	r3, sl
 802f7c8:	015a      	lsls	r2, r3, #5
 802f7ca:	1ad2      	subs	r2, r2, r3
 802f7cc:	0092      	lsls	r2, r2, #2
 802f7ce:	4452      	add	r2, sl
 802f7d0:	00d2      	lsls	r2, r2, #3
 802f7d2:	7ca3      	ldrb	r3, [r4, #18]
 802f7d4:	9309      	str	r3, [sp, #36]	; 0x24
 802f7d6:	2300      	movs	r3, #0
 802f7d8:	9308      	str	r3, [sp, #32]
 802f7da:	9307      	str	r3, [sp, #28]
 802f7dc:	9306      	str	r3, [sp, #24]
 802f7de:	2101      	movs	r1, #1
 802f7e0:	9105      	str	r1, [sp, #20]
 802f7e2:	9304      	str	r3, [sp, #16]
 802f7e4:	9303      	str	r3, [sp, #12]
 802f7e6:	8923      	ldrh	r3, [r4, #8]
 802f7e8:	9302      	str	r3, [sp, #8]
 802f7ea:	2305      	movs	r3, #5
 802f7ec:	9301      	str	r3, [sp, #4]
 802f7ee:	4b0a      	ldr	r3, [pc, #40]	; (802f818 <RegionEU868RxConfig+0x108>)
 802f7f0:	9300      	str	r3, [sp, #0]
 802f7f2:	2300      	movs	r3, #0
 802f7f4:	4909      	ldr	r1, [pc, #36]	; (802f81c <RegionEU868RxConfig+0x10c>)
 802f7f6:	2000      	movs	r0, #0
 802f7f8:	47c8      	blx	r9
 802f7fa:	e7c9      	b.n	802f790 <RegionEU868RxConfig+0x80>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 802f7fc:	4b08      	ldr	r3, [pc, #32]	; (802f820 <RegionEU868RxConfig+0x110>)
 802f7fe:	5d99      	ldrb	r1, [r3, r6]
 802f800:	e7cb      	b.n	802f79a <RegionEU868RxConfig+0x8a>
        return false;
 802f802:	2000      	movs	r0, #0
 802f804:	e7d7      	b.n	802f7b6 <RegionEU868RxConfig+0xa6>
 802f806:	46c0      	nop			; (mov r8, r8)
 802f808:	080356b4 	.word	0x080356b4
 802f80c:	2000b1b8 	.word	0x2000b1b8
 802f810:	08035294 	.word	0x08035294
 802f814:	080352a4 	.word	0x080352a4
 802f818:	00014585 	.word	0x00014585
 802f81c:	0000c350 	.word	0x0000c350
 802f820:	0803529c 	.word	0x0803529c

0802f824 <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 802f824:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f826:	46de      	mov	lr, fp
 802f828:	4657      	mov	r7, sl
 802f82a:	464e      	mov	r6, r9
 802f82c:	4645      	mov	r5, r8
 802f82e:	b5e0      	push	{r5, r6, r7, lr}
 802f830:	b08d      	sub	sp, #52	; 0x34
 802f832:	0004      	movs	r4, r0
 802f834:	468a      	mov	sl, r1
 802f836:	0017      	movs	r7, r2
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 802f838:	2301      	movs	r3, #1
 802f83a:	56c3      	ldrsb	r3, [r0, r3]
 802f83c:	4a44      	ldr	r2, [pc, #272]	; (802f950 <RegionEU868TxConfig+0x12c>)
 802f83e:	56d6      	ldrsb	r6, [r2, r3]
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 802f840:	4b44      	ldr	r3, [pc, #272]	; (802f954 <RegionEU868TxConfig+0x130>)
 802f842:	6819      	ldr	r1, [r3, #0]
 802f844:	4d44      	ldr	r5, [pc, #272]	; (802f958 <RegionEU868TxConfig+0x134>)
 802f846:	7803      	ldrb	r3, [r0, #0]
 802f848:	005a      	lsls	r2, r3, #1
 802f84a:	18d2      	adds	r2, r2, r3
 802f84c:	0092      	lsls	r2, r2, #2
 802f84e:	682b      	ldr	r3, [r5, #0]
 802f850:	469c      	mov	ip, r3
 802f852:	4462      	add	r2, ip
 802f854:	7a52      	ldrb	r2, [r2, #9]
 802f856:	0053      	lsls	r3, r2, #1
 802f858:	189b      	adds	r3, r3, r2
 802f85a:	00db      	lsls	r3, r3, #3
 802f85c:	18cb      	adds	r3, r1, r3
 802f85e:	2102      	movs	r1, #2
 802f860:	5659      	ldrsb	r1, [r3, r1]
 802f862:	2002      	movs	r0, #2
 802f864:	5620      	ldrsb	r0, [r4, r0]
 802f866:	f7ff fca0 	bl	802f1aa <RegionCommonLimitTxPower>
 802f86a:	4680      	mov	r8, r0
 802f86c:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 802f86e:	2001      	movs	r0, #1
 802f870:	5620      	ldrsb	r0, [r4, r0]
 802f872:	493a      	ldr	r1, [pc, #232]	; (802f95c <RegionEU868TxConfig+0x138>)
 802f874:	f7ff fca0 	bl	802f1b8 <RegionCommonGetBandwidth>
 802f878:	4681      	mov	r9, r0
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 802f87a:	68a2      	ldr	r2, [r4, #8]
 802f87c:	6861      	ldr	r1, [r4, #4]
 802f87e:	4640      	mov	r0, r8
 802f880:	f7ff fba4 	bl	802efcc <RegionCommonComputeTxPower>
 802f884:	4680      	mov	r8, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 802f886:	4b36      	ldr	r3, [pc, #216]	; (802f960 <RegionEU868TxConfig+0x13c>)
 802f888:	68da      	ldr	r2, [r3, #12]
 802f88a:	6828      	ldr	r0, [r5, #0]
 802f88c:	7821      	ldrb	r1, [r4, #0]
 802f88e:	004b      	lsls	r3, r1, #1
 802f890:	185b      	adds	r3, r3, r1
 802f892:	009b      	lsls	r3, r3, #2
 802f894:	5818      	ldr	r0, [r3, r0]
 802f896:	4790      	blx	r2

    if( txConfig->Datarate == DR_7 )
 802f898:	2301      	movs	r3, #1
 802f89a:	56e3      	ldrsb	r3, [r4, r3]
 802f89c:	2b07      	cmp	r3, #7
 802f89e:	d038      	beq.n	802f912 <RegionEU868TxConfig+0xee>
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 802f8a0:	4b2f      	ldr	r3, [pc, #188]	; (802f960 <RegionEU868TxConfig+0x13c>)
 802f8a2:	69db      	ldr	r3, [r3, #28]
 802f8a4:	469b      	mov	fp, r3
 802f8a6:	23fa      	movs	r3, #250	; 0xfa
 802f8a8:	011b      	lsls	r3, r3, #4
 802f8aa:	9308      	str	r3, [sp, #32]
 802f8ac:	2300      	movs	r3, #0
 802f8ae:	9307      	str	r3, [sp, #28]
 802f8b0:	9306      	str	r3, [sp, #24]
 802f8b2:	9305      	str	r3, [sp, #20]
 802f8b4:	2201      	movs	r2, #1
 802f8b6:	9204      	str	r2, [sp, #16]
 802f8b8:	9303      	str	r3, [sp, #12]
 802f8ba:	3308      	adds	r3, #8
 802f8bc:	9302      	str	r3, [sp, #8]
 802f8be:	9201      	str	r2, [sp, #4]
 802f8c0:	9600      	str	r6, [sp, #0]
 802f8c2:	464b      	mov	r3, r9
 802f8c4:	2200      	movs	r2, #0
 802f8c6:	4641      	mov	r1, r8
 802f8c8:	2001      	movs	r0, #1
 802f8ca:	47d8      	blx	fp
        modem = MODEM_LORA;
 802f8cc:	2301      	movs	r3, #1
 802f8ce:	4698      	mov	r8, r3
    }
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 802f8d0:	4b21      	ldr	r3, [pc, #132]	; (802f958 <RegionEU868TxConfig+0x134>)
 802f8d2:	6818      	ldr	r0, [r3, #0]
 802f8d4:	7822      	ldrb	r2, [r4, #0]
 802f8d6:	2101      	movs	r1, #1
 802f8d8:	5661      	ldrsb	r1, [r4, r1]
 802f8da:	0053      	lsls	r3, r2, #1
 802f8dc:	189b      	adds	r3, r3, r2
 802f8de:	009b      	lsls	r3, r3, #2
 802f8e0:	5818      	ldr	r0, [r3, r0]
 802f8e2:	f7ff fca3 	bl	802f22c <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 802f8e6:	89a1      	ldrh	r1, [r4, #12]
 802f8e8:	2001      	movs	r0, #1
 802f8ea:	5620      	ldrsb	r0, [r4, r0]
 802f8ec:	f7ff fd02 	bl	802f2f4 <GetTimeOnAir>
 802f8f0:	6038      	str	r0, [r7, #0]

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 802f8f2:	4b1b      	ldr	r3, [pc, #108]	; (802f960 <RegionEU868TxConfig+0x13c>)
 802f8f4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802f8f6:	7b21      	ldrb	r1, [r4, #12]
 802f8f8:	4640      	mov	r0, r8
 802f8fa:	4798      	blx	r3

    *txPower = txPowerLimited;
 802f8fc:	4653      	mov	r3, sl
 802f8fe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802f900:	701a      	strb	r2, [r3, #0]
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 802f902:	2001      	movs	r0, #1
 802f904:	b00d      	add	sp, #52	; 0x34
 802f906:	bcf0      	pop	{r4, r5, r6, r7}
 802f908:	46bb      	mov	fp, r7
 802f90a:	46b2      	mov	sl, r6
 802f90c:	46a9      	mov	r9, r5
 802f90e:	46a0      	mov	r8, r4
 802f910:	bdf0      	pop	{r4, r5, r6, r7, pc}
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 802f912:	4b13      	ldr	r3, [pc, #76]	; (802f960 <RegionEU868TxConfig+0x13c>)
 802f914:	69db      	ldr	r3, [r3, #28]
 802f916:	469b      	mov	fp, r3
 802f918:	0173      	lsls	r3, r6, #5
 802f91a:	1b9b      	subs	r3, r3, r6
 802f91c:	009b      	lsls	r3, r3, #2
 802f91e:	199b      	adds	r3, r3, r6
 802f920:	00db      	lsls	r3, r3, #3
 802f922:	22fa      	movs	r2, #250	; 0xfa
 802f924:	0112      	lsls	r2, r2, #4
 802f926:	9208      	str	r2, [sp, #32]
 802f928:	2200      	movs	r2, #0
 802f92a:	9207      	str	r2, [sp, #28]
 802f92c:	9206      	str	r2, [sp, #24]
 802f92e:	9205      	str	r2, [sp, #20]
 802f930:	2101      	movs	r1, #1
 802f932:	9104      	str	r1, [sp, #16]
 802f934:	9203      	str	r2, [sp, #12]
 802f936:	3104      	adds	r1, #4
 802f938:	9102      	str	r1, [sp, #8]
 802f93a:	9201      	str	r2, [sp, #4]
 802f93c:	9300      	str	r3, [sp, #0]
 802f93e:	464b      	mov	r3, r9
 802f940:	4a08      	ldr	r2, [pc, #32]	; (802f964 <RegionEU868TxConfig+0x140>)
 802f942:	4641      	mov	r1, r8
 802f944:	2000      	movs	r0, #0
 802f946:	47d8      	blx	fp
        modem = MODEM_FSK;
 802f948:	2300      	movs	r3, #0
 802f94a:	4698      	mov	r8, r3
 802f94c:	e7c0      	b.n	802f8d0 <RegionEU868TxConfig+0xac>
 802f94e:	46c0      	nop			; (mov r8, r8)
 802f950:	08035294 	.word	0x08035294
 802f954:	2000b1b4 	.word	0x2000b1b4
 802f958:	2000b1b8 	.word	0x2000b1b8
 802f95c:	08035274 	.word	0x08035274
 802f960:	080356b4 	.word	0x080356b4
 802f964:	000061a8 	.word	0x000061a8

0802f968 <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 802f968:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f96a:	46d6      	mov	lr, sl
 802f96c:	464f      	mov	r7, r9
 802f96e:	4646      	mov	r6, r8
 802f970:	b5c0      	push	{r6, r7, lr}
 802f972:	b08e      	sub	sp, #56	; 0x38
 802f974:	0006      	movs	r6, r0
 802f976:	468a      	mov	sl, r1
 802f978:	4691      	mov	r9, r2
 802f97a:	4698      	mov	r8, r3
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 802f97c:	2206      	movs	r2, #6
 802f97e:	2100      	movs	r1, #0
 802f980:	a80c      	add	r0, sp, #48	; 0x30
 802f982:	f004 fed0 	bl	8034726 <memset>
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t chMask = 0;
 802f986:	232e      	movs	r3, #46	; 0x2e
 802f988:	446b      	add	r3, sp
 802f98a:	2200      	movs	r2, #0
 802f98c:	801a      	strh	r2, [r3, #0]
    uint8_t bytesProcessed = 0;
 802f98e:	2500      	movs	r5, #0
    uint8_t status = 0x07;
 802f990:	2707      	movs	r7, #7
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    while( bytesProcessed < linkAdrReq->PayloadSize )
 802f992:	e02b      	b.n	802f9ec <RegionEU868LinkAdrReq+0x84>
            // RFU
            status &= 0xFE; // Channel mask KO
        }
        else
        {
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 802f994:	2400      	movs	r4, #0
        status = 0x07;
 802f996:	2707      	movs	r7, #7
 802f998:	e010      	b.n	802f9bc <RegionEU868LinkAdrReq+0x54>
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
                {
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 802f99a:	4a56      	ldr	r2, [pc, #344]	; (802faf4 <RegionEU868LinkAdrReq+0x18c>)
 802f99c:	6811      	ldr	r1, [r2, #0]
 802f99e:	0062      	lsls	r2, r4, #1
 802f9a0:	1912      	adds	r2, r2, r4
 802f9a2:	0092      	lsls	r2, r2, #2
 802f9a4:	5852      	ldr	r2, [r2, r1]
 802f9a6:	2a00      	cmp	r2, #0
 802f9a8:	d006      	beq.n	802f9b8 <RegionEU868LinkAdrReq+0x50>
                    {
                        chMask |= 1 << i;
 802f9aa:	2001      	movs	r0, #1
 802f9ac:	40a0      	lsls	r0, r4
 802f9ae:	212e      	movs	r1, #46	; 0x2e
 802f9b0:	4469      	add	r1, sp
 802f9b2:	880a      	ldrh	r2, [r1, #0]
 802f9b4:	4302      	orrs	r2, r0
 802f9b6:	800a      	strh	r2, [r1, #0]
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 802f9b8:	3401      	adds	r4, #1
 802f9ba:	b2e4      	uxtb	r4, r4
 802f9bc:	2c0f      	cmp	r4, #15
 802f9be:	d815      	bhi.n	802f9ec <RegionEU868LinkAdrReq+0x84>
                if( linkAdrParams.ChMaskCtrl == 6 )
 802f9c0:	2b06      	cmp	r3, #6
 802f9c2:	d0ea      	beq.n	802f99a <RegionEU868LinkAdrReq+0x32>
                    }
                }
                else
                {
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 802f9c4:	222e      	movs	r2, #46	; 0x2e
 802f9c6:	446a      	add	r2, sp
 802f9c8:	8812      	ldrh	r2, [r2, #0]
 802f9ca:	4122      	asrs	r2, r4
 802f9cc:	07d2      	lsls	r2, r2, #31
 802f9ce:	d5f3      	bpl.n	802f9b8 <RegionEU868LinkAdrReq+0x50>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 802f9d0:	4a48      	ldr	r2, [pc, #288]	; (802faf4 <RegionEU868LinkAdrReq+0x18c>)
 802f9d2:	6811      	ldr	r1, [r2, #0]
 802f9d4:	0062      	lsls	r2, r4, #1
 802f9d6:	1912      	adds	r2, r2, r4
 802f9d8:	0092      	lsls	r2, r2, #2
 802f9da:	5852      	ldr	r2, [r2, r1]
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 802f9dc:	2a00      	cmp	r2, #0
 802f9de:	d1eb      	bne.n	802f9b8 <RegionEU868LinkAdrReq+0x50>
                    {// Trying to enable an undefined channel
                        status &= 0xFE; // Channel mask KO
 802f9e0:	3201      	adds	r2, #1
 802f9e2:	4397      	bics	r7, r2
 802f9e4:	e7e8      	b.n	802f9b8 <RegionEU868LinkAdrReq+0x50>
            status &= 0xFE; // Channel mask KO
 802f9e6:	2706      	movs	r7, #6
 802f9e8:	e000      	b.n	802f9ec <RegionEU868LinkAdrReq+0x84>
            status &= 0xFE; // Channel mask KO
 802f9ea:	2706      	movs	r7, #6
    while( bytesProcessed < linkAdrReq->PayloadSize )
 802f9ec:	7a33      	ldrb	r3, [r6, #8]
 802f9ee:	42ab      	cmp	r3, r5
 802f9f0:	d91a      	bls.n	802fa28 <RegionEU868LinkAdrReq+0xc0>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 802f9f2:	6873      	ldr	r3, [r6, #4]
 802f9f4:	1958      	adds	r0, r3, r5
 802f9f6:	a90c      	add	r1, sp, #48	; 0x30
 802f9f8:	f7ff fa24 	bl	802ee44 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 802f9fc:	2800      	cmp	r0, #0
 802f9fe:	d013      	beq.n	802fa28 <RegionEU868LinkAdrReq+0xc0>
        bytesProcessed += nextIndex;
 802fa00:	182d      	adds	r5, r5, r0
 802fa02:	b2ed      	uxtb	r5, r5
        chMask = linkAdrParams.ChMask;
 802fa04:	ab0c      	add	r3, sp, #48	; 0x30
 802fa06:	889a      	ldrh	r2, [r3, #4]
 802fa08:	212e      	movs	r1, #46	; 0x2e
 802fa0a:	4469      	add	r1, sp
 802fa0c:	800a      	strh	r2, [r1, #0]
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 802fa0e:	78db      	ldrb	r3, [r3, #3]
 802fa10:	2b00      	cmp	r3, #0
 802fa12:	d101      	bne.n	802fa18 <RegionEU868LinkAdrReq+0xb0>
 802fa14:	2a00      	cmp	r2, #0
 802fa16:	d0e6      	beq.n	802f9e6 <RegionEU868LinkAdrReq+0x7e>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 802fa18:	1e5a      	subs	r2, r3, #1
 802fa1a:	b2d2      	uxtb	r2, r2
 802fa1c:	2a04      	cmp	r2, #4
 802fa1e:	d9e4      	bls.n	802f9ea <RegionEU868LinkAdrReq+0x82>
 802fa20:	2b06      	cmp	r3, #6
 802fa22:	d9b7      	bls.n	802f994 <RegionEU868LinkAdrReq+0x2c>
            status &= 0xFE; // Channel mask KO
 802fa24:	2706      	movs	r7, #6
 802fa26:	e7e1      	b.n	802f9ec <RegionEU868LinkAdrReq+0x84>
            }
        }
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 802fa28:	2302      	movs	r3, #2
 802fa2a:	466a      	mov	r2, sp
 802fa2c:	2128      	movs	r1, #40	; 0x28
 802fa2e:	1852      	adds	r2, r2, r1
 802fa30:	7013      	strb	r3, [r2, #0]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 802fa32:	7a73      	ldrb	r3, [r6, #9]
 802fa34:	466a      	mov	r2, sp
 802fa36:	3102      	adds	r1, #2
 802fa38:	1852      	adds	r2, r2, r1
 802fa3a:	7013      	strb	r3, [r2, #0]
    phyParam = RegionEU868GetPhyParam( &getPhy );
 802fa3c:	a80a      	add	r0, sp, #40	; 0x28
 802fa3e:	f7ff fc8f 	bl	802f360 <RegionEU868GetPhyParam>

    linkAdrVerifyParams.Status = status;
 802fa42:	ac01      	add	r4, sp, #4
 802fa44:	7127      	strb	r7, [r4, #4]
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 802fa46:	7ab3      	ldrb	r3, [r6, #10]
 802fa48:	7163      	strb	r3, [r4, #5]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 802fa4a:	ab0c      	add	r3, sp, #48	; 0x30
 802fa4c:	2201      	movs	r2, #1
 802fa4e:	569a      	ldrsb	r2, [r3, r2]
 802fa50:	71a2      	strb	r2, [r4, #6]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 802fa52:	2202      	movs	r2, #2
 802fa54:	569a      	ldrsb	r2, [r3, r2]
 802fa56:	71e2      	strb	r2, [r4, #7]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 802fa58:	781a      	ldrb	r2, [r3, #0]
 802fa5a:	7222      	strb	r2, [r4, #8]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 802fa5c:	220b      	movs	r2, #11
 802fa5e:	56b2      	ldrsb	r2, [r6, r2]
 802fa60:	7262      	strb	r2, [r4, #9]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 802fa62:	220c      	movs	r2, #12
 802fa64:	56b2      	ldrsb	r2, [r6, r2]
 802fa66:	72a2      	strb	r2, [r4, #10]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 802fa68:	220d      	movs	r2, #13
 802fa6a:	56b2      	ldrsb	r2, [r6, r2]
 802fa6c:	72e2      	strb	r2, [r4, #11]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 802fa6e:	2210      	movs	r2, #16
 802fa70:	7322      	strb	r2, [r4, #12]
    linkAdrVerifyParams.ChannelsMask = &chMask;
 802fa72:	321e      	adds	r2, #30
 802fa74:	446a      	add	r2, sp
 802fa76:	9205      	str	r2, [sp, #20]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 802fa78:	7520      	strb	r0, [r4, #20]
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
 802fa7a:	2207      	movs	r2, #7
 802fa7c:	7562      	strb	r2, [r4, #21]
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 802fa7e:	491d      	ldr	r1, [pc, #116]	; (802faf4 <RegionEU868LinkAdrReq+0x18c>)
 802fa80:	6809      	ldr	r1, [r1, #0]
 802fa82:	9107      	str	r1, [sp, #28]
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 802fa84:	7722      	strb	r2, [r4, #28]
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
 802fa86:	2200      	movs	r2, #0
 802fa88:	7762      	strb	r2, [r4, #29]
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 802fa8a:	6832      	ldr	r2, [r6, #0]
 802fa8c:	9201      	str	r2, [sp, #4]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 802fa8e:	2232      	movs	r2, #50	; 0x32
 802fa90:	446a      	add	r2, sp
 802fa92:	2131      	movs	r1, #49	; 0x31
 802fa94:	4469      	add	r1, sp
 802fa96:	0020      	movs	r0, r4
 802fa98:	f7ff f9f1 	bl	802ee7e <RegionCommonLinkAdrReqVerifyParams>
 802fa9c:	0004      	movs	r4, r0

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 802fa9e:	2807      	cmp	r0, #7
 802faa0:	d014      	beq.n	802facc <RegionEU868LinkAdrReq+0x164>
        // Update the channels mask
        RegionNvmGroup2->ChannelsMask[0] = chMask;
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 802faa2:	ab0c      	add	r3, sp, #48	; 0x30
 802faa4:	2201      	movs	r2, #1
 802faa6:	569a      	ldrsb	r2, [r3, r2]
 802faa8:	4651      	mov	r1, sl
 802faaa:	700a      	strb	r2, [r1, #0]
    *txPowOut = linkAdrParams.TxPower;
 802faac:	2202      	movs	r2, #2
 802faae:	569a      	ldrsb	r2, [r3, r2]
 802fab0:	4649      	mov	r1, r9
 802fab2:	700a      	strb	r2, [r1, #0]
    *nbRepOut = linkAdrParams.NbRep;
 802fab4:	781b      	ldrb	r3, [r3, #0]
 802fab6:	4642      	mov	r2, r8
 802fab8:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 802faba:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802fabc:	701d      	strb	r5, [r3, #0]

#endif /* REGION_EU868 */
    return status;
}
 802fabe:	0020      	movs	r0, r4
 802fac0:	b00e      	add	sp, #56	; 0x38
 802fac2:	bce0      	pop	{r5, r6, r7}
 802fac4:	46ba      	mov	sl, r7
 802fac6:	46b1      	mov	r9, r6
 802fac8:	46a8      	mov	r8, r5
 802faca:	bdf0      	pop	{r4, r5, r6, r7, pc}
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 802facc:	4e09      	ldr	r6, [pc, #36]	; (802faf4 <RegionEU868LinkAdrReq+0x18c>)
 802face:	6833      	ldr	r3, [r6, #0]
 802fad0:	22d8      	movs	r2, #216	; 0xd8
 802fad2:	0092      	lsls	r2, r2, #2
 802fad4:	4694      	mov	ip, r2
 802fad6:	4463      	add	r3, ip
 802fad8:	0018      	movs	r0, r3
 802fada:	220c      	movs	r2, #12
 802fadc:	2100      	movs	r1, #0
 802fade:	f001 fe74 	bl	80317ca <memset1>
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 802fae2:	6832      	ldr	r2, [r6, #0]
 802fae4:	232e      	movs	r3, #46	; 0x2e
 802fae6:	446b      	add	r3, sp
 802fae8:	8819      	ldrh	r1, [r3, #0]
 802faea:	23d8      	movs	r3, #216	; 0xd8
 802faec:	009b      	lsls	r3, r3, #2
 802faee:	52d1      	strh	r1, [r2, r3]
 802faf0:	e7d7      	b.n	802faa2 <RegionEU868LinkAdrReq+0x13a>
 802faf2:	46c0      	nop			; (mov r8, r8)
 802faf4:	2000b1b8 	.word	0x2000b1b8

0802faf8 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 802faf8:	b530      	push	{r4, r5, lr}
 802fafa:	b083      	sub	sp, #12
 802fafc:	0004      	movs	r4, r0
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 802fafe:	466b      	mov	r3, sp
 802fb00:	1dd9      	adds	r1, r3, #7
 802fb02:	2300      	movs	r3, #0
 802fb04:	700b      	strb	r3, [r1, #0]

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 802fb06:	6840      	ldr	r0, [r0, #4]
 802fb08:	f7ff fb9e 	bl	802f248 <VerifyRfFreq>
 802fb0c:	2800      	cmp	r0, #0
 802fb0e:	d017      	beq.n	802fb40 <RegionEU868RxParamSetupReq+0x48>
    uint8_t status = 0x07;
 802fb10:	2507      	movs	r5, #7
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 802fb12:	2000      	movs	r0, #0
 802fb14:	5620      	ldrsb	r0, [r4, r0]
 802fb16:	2207      	movs	r2, #7
 802fb18:	2100      	movs	r1, #0
 802fb1a:	f7ff f85e 	bl	802ebda <RegionCommonValueInRange>
 802fb1e:	2800      	cmp	r0, #0
 802fb20:	d101      	bne.n	802fb26 <RegionEU868RxParamSetupReq+0x2e>
    {
        status &= 0xFD; // Datarate KO
 802fb22:	2302      	movs	r3, #2
 802fb24:	439d      	bics	r5, r3
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 802fb26:	2001      	movs	r0, #1
 802fb28:	5620      	ldrsb	r0, [r4, r0]
 802fb2a:	2205      	movs	r2, #5
 802fb2c:	2100      	movs	r1, #0
 802fb2e:	f7ff f854 	bl	802ebda <RegionCommonValueInRange>
 802fb32:	2800      	cmp	r0, #0
 802fb34:	d101      	bne.n	802fb3a <RegionEU868RxParamSetupReq+0x42>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 802fb36:	2304      	movs	r3, #4
 802fb38:	439d      	bics	r5, r3
    }

#endif /* REGION_EU868 */
    return status;
}
 802fb3a:	0028      	movs	r0, r5
 802fb3c:	b003      	add	sp, #12
 802fb3e:	bd30      	pop	{r4, r5, pc}
        status &= 0xFE; // Channel frequency KO
 802fb40:	2506      	movs	r5, #6
 802fb42:	e7e6      	b.n	802fb12 <RegionEU868RxParamSetupReq+0x1a>

0802fb44 <RegionEU868TxParamSetupReq>:
}

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
 802fb44:	2001      	movs	r0, #1
}
 802fb46:	4240      	negs	r0, r0
 802fb48:	4770      	bx	lr
	...

0802fb4c <RegionEU868DlChannelReq>:

int8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 802fb4c:	b510      	push	{r4, lr}
 802fb4e:	b082      	sub	sp, #8
 802fb50:	0004      	movs	r4, r0
    uint8_t status = 0x03;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 802fb52:	466b      	mov	r3, sp
 802fb54:	1dd9      	adds	r1, r3, #7
 802fb56:	2300      	movs	r3, #0
 802fb58:	700b      	strb	r3, [r1, #0]

    // Verify if the frequency is supported
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 802fb5a:	6840      	ldr	r0, [r0, #4]
 802fb5c:	f7ff fb74 	bl	802f248 <VerifyRfFreq>
 802fb60:	2800      	cmp	r0, #0
 802fb62:	d010      	beq.n	802fb86 <RegionEU868DlChannelReq+0x3a>
    uint8_t status = 0x03;
 802fb64:	2303      	movs	r3, #3
    {
        status &= 0xFE;
    }

    // Verify if an uplink frequency exists
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 802fb66:	4a0c      	ldr	r2, [pc, #48]	; (802fb98 <RegionEU868DlChannelReq+0x4c>)
 802fb68:	6810      	ldr	r0, [r2, #0]
 802fb6a:	7821      	ldrb	r1, [r4, #0]
 802fb6c:	004a      	lsls	r2, r1, #1
 802fb6e:	1852      	adds	r2, r2, r1
 802fb70:	0092      	lsls	r2, r2, #2
 802fb72:	5812      	ldr	r2, [r2, r0]
 802fb74:	2a00      	cmp	r2, #0
 802fb76:	d101      	bne.n	802fb7c <RegionEU868DlChannelReq+0x30>
    {
        status &= 0xFD;
 802fb78:	3202      	adds	r2, #2
 802fb7a:	4393      	bics	r3, r2
    }

    // Apply Rx1 frequency, if the status is OK
    if( status == 0x03 )
 802fb7c:	2b03      	cmp	r3, #3
 802fb7e:	d004      	beq.n	802fb8a <RegionEU868DlChannelReq+0x3e>
    {
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
    }

#endif /* REGION_EU868 */
    return status;
 802fb80:	b258      	sxtb	r0, r3
}
 802fb82:	b002      	add	sp, #8
 802fb84:	bd10      	pop	{r4, pc}
        status &= 0xFE;
 802fb86:	2302      	movs	r3, #2
 802fb88:	e7ed      	b.n	802fb66 <RegionEU868DlChannelReq+0x1a>
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 802fb8a:	6864      	ldr	r4, [r4, #4]
 802fb8c:	004a      	lsls	r2, r1, #1
 802fb8e:	1851      	adds	r1, r2, r1
 802fb90:	0089      	lsls	r1, r1, #2
 802fb92:	1840      	adds	r0, r0, r1
 802fb94:	6044      	str	r4, [r0, #4]
 802fb96:	e7f3      	b.n	802fb80 <RegionEU868DlChannelReq+0x34>
 802fb98:	2000b1b8 	.word	0x2000b1b8

0802fb9c <RegionEU868AlternateDr>:
#if defined( REGION_EU868 )
    return currentDr;
#else
    return -1;
#endif /* REGION_EU868 */
}
 802fb9c:	4770      	bx	lr
	...

0802fba0 <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 802fba0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802fba2:	46c6      	mov	lr, r8
 802fba4:	b500      	push	{lr}
 802fba6:	b098      	sub	sp, #96	; 0x60
 802fba8:	0004      	movs	r4, r0
 802fbaa:	9103      	str	r1, [sp, #12]
 802fbac:	0017      	movs	r7, r2
 802fbae:	4698      	mov	r8, r3
#if defined( REGION_EU868 )
    uint8_t nbEnabledChannels = 0;
 802fbb0:	2300      	movs	r3, #0
 802fbb2:	2257      	movs	r2, #87	; 0x57
 802fbb4:	a902      	add	r1, sp, #8
 802fbb6:	468c      	mov	ip, r1
 802fbb8:	4462      	add	r2, ip
 802fbba:	7013      	strb	r3, [r2, #0]
    uint8_t nbRestrictedChannels = 0;
 802fbbc:	2256      	movs	r2, #86	; 0x56
 802fbbe:	4462      	add	r2, ip
 802fbc0:	7013      	strb	r3, [r2, #0]
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 802fbc2:	9313      	str	r3, [sp, #76]	; 0x4c
 802fbc4:	220c      	movs	r2, #12
 802fbc6:	2100      	movs	r1, #0
 802fbc8:	a814      	add	r0, sp, #80	; 0x50
 802fbca:	f004 fdac 	bl	8034726 <memset>
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 802fbce:	230a      	movs	r3, #10
 802fbd0:	aa02      	add	r2, sp, #8
 802fbd2:	4694      	mov	ip, r2
 802fbd4:	4463      	add	r3, ip
 802fbd6:	2207      	movs	r2, #7
 802fbd8:	801a      	strh	r2, [r3, #0]

    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 802fbda:	4b37      	ldr	r3, [pc, #220]	; (802fcb8 <RegionEU868NextChannel+0x118>)
 802fbdc:	6818      	ldr	r0, [r3, #0]
 802fbde:	23d8      	movs	r3, #216	; 0xd8
 802fbe0:	009b      	lsls	r3, r3, #2
 802fbe2:	469c      	mov	ip, r3
 802fbe4:	4460      	add	r0, ip
 802fbe6:	3a06      	subs	r2, #6
 802fbe8:	2100      	movs	r1, #0
 802fbea:	f7ff f859 	bl	802eca0 <RegionCommonCountChannels>
 802fbee:	2800      	cmp	r0, #0
 802fbf0:	d107      	bne.n	802fc02 <RegionEU868NextChannel+0x62>
    { // Reactivate default channels
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 802fbf2:	4b31      	ldr	r3, [pc, #196]	; (802fcb8 <RegionEU868NextChannel+0x118>)
 802fbf4:	6819      	ldr	r1, [r3, #0]
 802fbf6:	22d8      	movs	r2, #216	; 0xd8
 802fbf8:	0092      	lsls	r2, r2, #2
 802fbfa:	5a8b      	ldrh	r3, [r1, r2]
 802fbfc:	2007      	movs	r0, #7
 802fbfe:	4303      	orrs	r3, r0
 802fc00:	528b      	strh	r3, [r1, r2]
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 802fc02:	7a63      	ldrb	r3, [r4, #9]
 802fc04:	ad05      	add	r5, sp, #20
 802fc06:	702b      	strb	r3, [r5, #0]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 802fc08:	7a23      	ldrb	r3, [r4, #8]
 802fc0a:	706b      	strb	r3, [r5, #1]
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 802fc0c:	4b2a      	ldr	r3, [pc, #168]	; (802fcb8 <RegionEU868NextChannel+0x118>)
 802fc0e:	681b      	ldr	r3, [r3, #0]
 802fc10:	22d8      	movs	r2, #216	; 0xd8
 802fc12:	0092      	lsls	r2, r2, #2
 802fc14:	189a      	adds	r2, r3, r2
 802fc16:	9206      	str	r2, [sp, #24]
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 802fc18:	9307      	str	r3, [sp, #28]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 802fc1a:	4b28      	ldr	r3, [pc, #160]	; (802fcbc <RegionEU868NextChannel+0x11c>)
 802fc1c:	681b      	ldr	r3, [r3, #0]
 802fc1e:	9308      	str	r3, [sp, #32]
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 802fc20:	2310      	movs	r3, #16
 802fc22:	822b      	strh	r3, [r5, #16]
    countChannelsParams.JoinChannels = &joinChannels;
 802fc24:	3b06      	subs	r3, #6
 802fc26:	aa02      	add	r2, sp, #8
 802fc28:	4694      	mov	ip, r2
 802fc2a:	4463      	add	r3, ip
 802fc2c:	930a      	str	r3, [sp, #40]	; 0x28

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 802fc2e:	ae0b      	add	r6, sp, #44	; 0x2c
 802fc30:	6823      	ldr	r3, [r4, #0]
 802fc32:	930b      	str	r3, [sp, #44]	; 0x2c
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 802fc34:	6863      	ldr	r3, [r4, #4]
 802fc36:	930c      	str	r3, [sp, #48]	; 0x30
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 802fc38:	7aa3      	ldrb	r3, [r4, #10]
 802fc3a:	7233      	strb	r3, [r6, #8]
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 802fc3c:	2306      	movs	r3, #6
 802fc3e:	7273      	strb	r3, [r6, #9]

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 802fc40:	a90e      	add	r1, sp, #56	; 0x38
 802fc42:	0020      	movs	r0, r4
 802fc44:	300c      	adds	r0, #12
 802fc46:	c80c      	ldmia	r0!, {r2, r3}
 802fc48:	c10c      	stmia	r1!, {r2, r3}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 802fc4a:	7d23      	ldrb	r3, [r4, #20]
 802fc4c:	7533      	strb	r3, [r6, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 802fc4e:	8ae1      	ldrh	r1, [r4, #22]
 802fc50:	2008      	movs	r0, #8
 802fc52:	5620      	ldrsb	r0, [r4, r0]
 802fc54:	f7ff fb4e 	bl	802f2f4 <GetTimeOnAir>
 802fc58:	61b0      	str	r0, [r6, #24]

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 802fc5a:	61f5      	str	r5, [r6, #28]

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 802fc5c:	9701      	str	r7, [sp, #4]
 802fc5e:	2356      	movs	r3, #86	; 0x56
 802fc60:	aa02      	add	r2, sp, #8
 802fc62:	4694      	mov	ip, r2
 802fc64:	4463      	add	r3, ip
 802fc66:	9300      	str	r3, [sp, #0]
 802fc68:	2357      	movs	r3, #87	; 0x57
 802fc6a:	4463      	add	r3, ip
 802fc6c:	aa13      	add	r2, sp, #76	; 0x4c
 802fc6e:	4641      	mov	r1, r8
 802fc70:	0030      	movs	r0, r6
 802fc72:	f7ff fa2e 	bl	802f0d2 <RegionCommonIdentifyChannels>
 802fc76:	0004      	movs	r4, r0
 802fc78:	1e03      	subs	r3, r0, #0
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 802fc7a:	d006      	beq.n	802fc8a <RegionEU868NextChannel+0xea>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
    }
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 802fc7c:	280c      	cmp	r0, #12
 802fc7e:	d012      	beq.n	802fca6 <RegionEU868NextChannel+0x106>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 802fc80:	0020      	movs	r0, r4
 802fc82:	b018      	add	sp, #96	; 0x60
 802fc84:	bc80      	pop	{r7}
 802fc86:	46b8      	mov	r8, r7
 802fc88:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 802fc8a:	3357      	adds	r3, #87	; 0x57
 802fc8c:	aa02      	add	r2, sp, #8
 802fc8e:	4694      	mov	ip, r2
 802fc90:	4463      	add	r3, ip
 802fc92:	7819      	ldrb	r1, [r3, #0]
 802fc94:	3901      	subs	r1, #1
 802fc96:	2000      	movs	r0, #0
 802fc98:	f001 fd74 	bl	8031784 <randr>
 802fc9c:	ab13      	add	r3, sp, #76	; 0x4c
 802fc9e:	5c1b      	ldrb	r3, [r3, r0]
 802fca0:	9a03      	ldr	r2, [sp, #12]
 802fca2:	7013      	strb	r3, [r2, #0]
 802fca4:	e7ec      	b.n	802fc80 <RegionEU868NextChannel+0xe0>
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 802fca6:	4b04      	ldr	r3, [pc, #16]	; (802fcb8 <RegionEU868NextChannel+0x118>)
 802fca8:	6819      	ldr	r1, [r3, #0]
 802fcaa:	22d8      	movs	r2, #216	; 0xd8
 802fcac:	0092      	lsls	r2, r2, #2
 802fcae:	5a8b      	ldrh	r3, [r1, r2]
 802fcb0:	2007      	movs	r0, #7
 802fcb2:	4303      	orrs	r3, r0
 802fcb4:	528b      	strh	r3, [r1, r2]
 802fcb6:	e7e3      	b.n	802fc80 <RegionEU868NextChannel+0xe0>
 802fcb8:	2000b1b8 	.word	0x2000b1b8
 802fcbc:	2000b1b4 	.word	0x2000b1b4

0802fcc0 <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 802fcc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802fcc2:	b083      	sub	sp, #12
 802fcc4:	0004      	movs	r4, r0
#if defined( REGION_EU868 )
    uint8_t band = 0;
 802fcc6:	466b      	mov	r3, sp
 802fcc8:	2200      	movs	r2, #0
 802fcca:	71da      	strb	r2, [r3, #7]
    bool drInvalid = false;
    bool freqInvalid = false;
    uint8_t id = channelAdd->ChannelId;
 802fccc:	7905      	ldrb	r5, [r0, #4]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 802fcce:	2d02      	cmp	r5, #2
 802fcd0:	d952      	bls.n	802fd78 <RegionEU868ChannelAdd+0xb8>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
    }

    if( id >= EU868_MAX_NB_CHANNELS )
 802fcd2:	2d0f      	cmp	r5, #15
 802fcd4:	d852      	bhi.n	802fd7c <RegionEU868ChannelAdd+0xbc>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // Validate the datarate range
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 802fcd6:	6803      	ldr	r3, [r0, #0]
 802fcd8:	7a18      	ldrb	r0, [r3, #8]
 802fcda:	0100      	lsls	r0, r0, #4
 802fcdc:	b240      	sxtb	r0, r0
 802fcde:	1100      	asrs	r0, r0, #4
 802fce0:	3207      	adds	r2, #7
 802fce2:	2100      	movs	r1, #0
 802fce4:	f7fe ff79 	bl	802ebda <RegionCommonValueInRange>
 802fce8:	2800      	cmp	r0, #0
 802fcea:	d041      	beq.n	802fd70 <RegionEU868ChannelAdd+0xb0>
    bool drInvalid = false;
 802fcec:	2600      	movs	r6, #0
    {
        drInvalid = true;
    }
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 802fcee:	6823      	ldr	r3, [r4, #0]
 802fcf0:	2008      	movs	r0, #8
 802fcf2:	5618      	ldrsb	r0, [r3, r0]
 802fcf4:	1100      	asrs	r0, r0, #4
 802fcf6:	2207      	movs	r2, #7
 802fcf8:	2100      	movs	r1, #0
 802fcfa:	f7fe ff6e 	bl	802ebda <RegionCommonValueInRange>
 802fcfe:	2800      	cmp	r0, #0
 802fd00:	d100      	bne.n	802fd04 <RegionEU868ChannelAdd+0x44>
    {
        drInvalid = true;
 802fd02:	2601      	movs	r6, #1
    }
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 802fd04:	6821      	ldr	r1, [r4, #0]
 802fd06:	7a0b      	ldrb	r3, [r1, #8]
 802fd08:	011a      	lsls	r2, r3, #4
 802fd0a:	b252      	sxtb	r2, r2
 802fd0c:	1112      	asrs	r2, r2, #4
 802fd0e:	b25b      	sxtb	r3, r3
 802fd10:	111b      	asrs	r3, r3, #4
 802fd12:	429a      	cmp	r2, r3
 802fd14:	dd00      	ble.n	802fd18 <RegionEU868ChannelAdd+0x58>
    {
        drInvalid = true;
 802fd16:	2601      	movs	r6, #1
    }

    // Check frequency
    if( freqInvalid == false )
    {
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 802fd18:	6808      	ldr	r0, [r1, #0]
 802fd1a:	466b      	mov	r3, sp
 802fd1c:	1dd9      	adds	r1, r3, #7
 802fd1e:	f7ff fa93 	bl	802f248 <VerifyRfFreq>
 802fd22:	2800      	cmp	r0, #0
 802fd24:	d026      	beq.n	802fd74 <RegionEU868ChannelAdd+0xb4>
    bool freqInvalid = false;
 802fd26:	2300      	movs	r3, #0
            freqInvalid = true;
        }
    }

    // Check status
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 802fd28:	2e00      	cmp	r6, #0
 802fd2a:	d001      	beq.n	802fd30 <RegionEU868ChannelAdd+0x70>
 802fd2c:	2b00      	cmp	r3, #0
 802fd2e:	d128      	bne.n	802fd82 <RegionEU868ChannelAdd+0xc2>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
    }
    if( drInvalid == true )
 802fd30:	2e00      	cmp	r6, #0
 802fd32:	d128      	bne.n	802fd86 <RegionEU868ChannelAdd+0xc6>
    {
        return LORAMAC_STATUS_DATARATE_INVALID;
    }
    if( freqInvalid == true )
 802fd34:	2b00      	cmp	r3, #0
 802fd36:	d128      	bne.n	802fd8a <RegionEU868ChannelAdd+0xca>
    {
        return LORAMAC_STATUS_FREQUENCY_INVALID;
    }

    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 802fd38:	4f15      	ldr	r7, [pc, #84]	; (802fd90 <RegionEU868ChannelAdd+0xd0>)
 802fd3a:	006e      	lsls	r6, r5, #1
 802fd3c:	1970      	adds	r0, r6, r5
 802fd3e:	0080      	lsls	r0, r0, #2
 802fd40:	683b      	ldr	r3, [r7, #0]
 802fd42:	469c      	mov	ip, r3
 802fd44:	4460      	add	r0, ip
 802fd46:	6821      	ldr	r1, [r4, #0]
 802fd48:	220c      	movs	r2, #12
 802fd4a:	f001 fd26 	bl	803179a <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 802fd4e:	683b      	ldr	r3, [r7, #0]
 802fd50:	1976      	adds	r6, r6, r5
 802fd52:	00b6      	lsls	r6, r6, #2
 802fd54:	199e      	adds	r6, r3, r6
 802fd56:	466a      	mov	r2, sp
 802fd58:	3207      	adds	r2, #7
 802fd5a:	7812      	ldrb	r2, [r2, #0]
 802fd5c:	7272      	strb	r2, [r6, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 802fd5e:	2101      	movs	r1, #1
 802fd60:	40a9      	lsls	r1, r5
 802fd62:	20d8      	movs	r0, #216	; 0xd8
 802fd64:	0080      	lsls	r0, r0, #2
 802fd66:	5a1a      	ldrh	r2, [r3, r0]
 802fd68:	430a      	orrs	r2, r1
 802fd6a:	521a      	strh	r2, [r3, r0]
    return LORAMAC_STATUS_OK;
 802fd6c:	2000      	movs	r0, #0
 802fd6e:	e006      	b.n	802fd7e <RegionEU868ChannelAdd+0xbe>
        drInvalid = true;
 802fd70:	2601      	movs	r6, #1
 802fd72:	e7bc      	b.n	802fcee <RegionEU868ChannelAdd+0x2e>
            freqInvalid = true;
 802fd74:	2301      	movs	r3, #1
 802fd76:	e7d7      	b.n	802fd28 <RegionEU868ChannelAdd+0x68>
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 802fd78:	2006      	movs	r0, #6
 802fd7a:	e000      	b.n	802fd7e <RegionEU868ChannelAdd+0xbe>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802fd7c:	2003      	movs	r0, #3
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 802fd7e:	b003      	add	sp, #12
 802fd80:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 802fd82:	2006      	movs	r0, #6
 802fd84:	e7fb      	b.n	802fd7e <RegionEU868ChannelAdd+0xbe>
        return LORAMAC_STATUS_DATARATE_INVALID;
 802fd86:	2005      	movs	r0, #5
 802fd88:	e7f9      	b.n	802fd7e <RegionEU868ChannelAdd+0xbe>
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 802fd8a:	2004      	movs	r0, #4
 802fd8c:	e7f7      	b.n	802fd7e <RegionEU868ChannelAdd+0xbe>
 802fd8e:	46c0      	nop			; (mov r8, r8)
 802fd90:	2000b1b8 	.word	0x2000b1b8

0802fd94 <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 802fd94:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    uint8_t id = channelRemove->ChannelId;
 802fd96:	7804      	ldrb	r4, [r0, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 802fd98:	2c02      	cmp	r4, #2
 802fd9a:	d801      	bhi.n	802fda0 <RegionEU868ChannelsRemove+0xc>
    {
        return false;
 802fd9c:	2000      	movs	r0, #0

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
#else
    return false;
#endif /* REGION_EU868 */
}
 802fd9e:	bd70      	pop	{r4, r5, r6, pc}
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 802fda0:	4b08      	ldr	r3, [pc, #32]	; (802fdc4 <RegionEU868ChannelsRemove+0x30>)
 802fda2:	681d      	ldr	r5, [r3, #0]
 802fda4:	0060      	lsls	r0, r4, #1
 802fda6:	1900      	adds	r0, r0, r4
 802fda8:	0080      	lsls	r0, r0, #2
 802fdaa:	1828      	adds	r0, r5, r0
 802fdac:	220c      	movs	r2, #12
 802fdae:	2100      	movs	r1, #0
 802fdb0:	f004 fcb9 	bl	8034726 <memset>
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 802fdb4:	23d8      	movs	r3, #216	; 0xd8
 802fdb6:	009b      	lsls	r3, r3, #2
 802fdb8:	18e8      	adds	r0, r5, r3
 802fdba:	2210      	movs	r2, #16
 802fdbc:	0021      	movs	r1, r4
 802fdbe:	f7fe ff5a 	bl	802ec76 <RegionCommonChanDisable>
 802fdc2:	e7ec      	b.n	802fd9e <RegionEU868ChannelsRemove+0xa>
 802fdc4:	2000b1b8 	.word	0x2000b1b8

0802fdc8 <RegionEU868ApplyCFList>:
{
 802fdc8:	b570      	push	{r4, r5, r6, lr}
 802fdca:	b086      	sub	sp, #24
 802fdcc:	0006      	movs	r6, r0
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 802fdce:	ab03      	add	r3, sp, #12
 802fdd0:	2250      	movs	r2, #80	; 0x50
 802fdd2:	721a      	strb	r2, [r3, #8]
    if( applyCFList->Size != 16 )
 802fdd4:	7903      	ldrb	r3, [r0, #4]
 802fdd6:	2b10      	cmp	r3, #16
 802fdd8:	d132      	bne.n	802fe40 <RegionEU868ApplyCFList+0x78>
    if( applyCFList->Payload[15] != 0 )
 802fdda:	6803      	ldr	r3, [r0, #0]
 802fddc:	7bdd      	ldrb	r5, [r3, #15]
 802fdde:	2d00      	cmp	r5, #0
 802fde0:	d12e      	bne.n	802fe40 <RegionEU868ApplyCFList+0x78>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 802fde2:	2403      	movs	r4, #3
 802fde4:	e019      	b.n	802fe1a <RegionEU868ApplyCFList+0x52>
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 802fde6:	6832      	ldr	r2, [r6, #0]
 802fde8:	5d53      	ldrb	r3, [r2, r5]
 802fdea:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 802fdec:	1952      	adds	r2, r2, r5
 802fdee:	7851      	ldrb	r1, [r2, #1]
 802fdf0:	0209      	lsls	r1, r1, #8
 802fdf2:	430b      	orrs	r3, r1
 802fdf4:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 802fdf6:	7892      	ldrb	r2, [r2, #2]
 802fdf8:	0412      	lsls	r2, r2, #16
 802fdfa:	4313      	orrs	r3, r2
            newChannel.Frequency *= 100;
 802fdfc:	2264      	movs	r2, #100	; 0x64
 802fdfe:	4353      	muls	r3, r2
 802fe00:	9303      	str	r3, [sp, #12]
            newChannel.Rx1Frequency = 0;
 802fe02:	2300      	movs	r3, #0
 802fe04:	9304      	str	r3, [sp, #16]
 802fe06:	e011      	b.n	802fe2c <RegionEU868ApplyCFList+0x64>
            channelRemove.ChannelId = chanIdx;
 802fe08:	466b      	mov	r3, sp
 802fe0a:	701c      	strb	r4, [r3, #0]
            RegionEU868ChannelsRemove( &channelRemove );
 802fe0c:	4668      	mov	r0, sp
 802fe0e:	f7ff ffc1 	bl	802fd94 <RegionEU868ChannelsRemove>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 802fe12:	3503      	adds	r5, #3
 802fe14:	b2ed      	uxtb	r5, r5
 802fe16:	3401      	adds	r4, #1
 802fe18:	b2e4      	uxtb	r4, r4
 802fe1a:	2c0f      	cmp	r4, #15
 802fe1c:	d810      	bhi.n	802fe40 <RegionEU868ApplyCFList+0x78>
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 802fe1e:	2c07      	cmp	r4, #7
 802fe20:	d9e1      	bls.n	802fde6 <RegionEU868ApplyCFList+0x1e>
            newChannel.Frequency = 0;
 802fe22:	aa03      	add	r2, sp, #12
 802fe24:	2300      	movs	r3, #0
 802fe26:	9303      	str	r3, [sp, #12]
            newChannel.DrRange.Value = 0;
 802fe28:	7213      	strb	r3, [r2, #8]
            newChannel.Rx1Frequency = 0;
 802fe2a:	9304      	str	r3, [sp, #16]
        if( newChannel.Frequency != 0 )
 802fe2c:	9b03      	ldr	r3, [sp, #12]
 802fe2e:	2b00      	cmp	r3, #0
 802fe30:	d0ea      	beq.n	802fe08 <RegionEU868ApplyCFList+0x40>
            channelAdd.NewChannel = &newChannel;
 802fe32:	a801      	add	r0, sp, #4
 802fe34:	ab03      	add	r3, sp, #12
 802fe36:	9301      	str	r3, [sp, #4]
            channelAdd.ChannelId = chanIdx;
 802fe38:	7104      	strb	r4, [r0, #4]
            RegionEU868ChannelAdd( &channelAdd );
 802fe3a:	f7ff ff41 	bl	802fcc0 <RegionEU868ChannelAdd>
 802fe3e:	e7e8      	b.n	802fe12 <RegionEU868ApplyCFList+0x4a>
}
 802fe40:	b006      	add	sp, #24
 802fe42:	bd70      	pop	{r4, r5, r6, pc}

0802fe44 <RegionEU868NewChannelReq>:
{
 802fe44:	b500      	push	{lr}
 802fe46:	b085      	sub	sp, #20
 802fe48:	0003      	movs	r3, r0
    if( newChannelReq->NewChannel->Frequency == 0 )
 802fe4a:	6802      	ldr	r2, [r0, #0]
 802fe4c:	6811      	ldr	r1, [r2, #0]
 802fe4e:	2900      	cmp	r1, #0
 802fe50:	d108      	bne.n	802fe64 <RegionEU868NewChannelReq+0x20>
        channelRemove.ChannelId = newChannelReq->ChannelId;
 802fe52:	7903      	ldrb	r3, [r0, #4]
 802fe54:	a801      	add	r0, sp, #4
 802fe56:	7003      	strb	r3, [r0, #0]
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 802fe58:	f7ff ff9c 	bl	802fd94 <RegionEU868ChannelsRemove>
 802fe5c:	2800      	cmp	r0, #0
 802fe5e:	d012      	beq.n	802fe86 <RegionEU868NewChannelReq+0x42>
    uint8_t status = 0x03;
 802fe60:	2003      	movs	r0, #3
 802fe62:	e00d      	b.n	802fe80 <RegionEU868NewChannelReq+0x3c>
        channelAdd.NewChannel = newChannelReq->NewChannel;
 802fe64:	a802      	add	r0, sp, #8
 802fe66:	9202      	str	r2, [sp, #8]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 802fe68:	791b      	ldrb	r3, [r3, #4]
 802fe6a:	7103      	strb	r3, [r0, #4]
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 802fe6c:	f7ff ff28 	bl	802fcc0 <RegionEU868ChannelAdd>
 802fe70:	2805      	cmp	r0, #5
 802fe72:	d00a      	beq.n	802fe8a <RegionEU868NewChannelReq+0x46>
 802fe74:	d80b      	bhi.n	802fe8e <RegionEU868NewChannelReq+0x4a>
 802fe76:	2800      	cmp	r0, #0
 802fe78:	d00b      	beq.n	802fe92 <RegionEU868NewChannelReq+0x4e>
 802fe7a:	2804      	cmp	r0, #4
 802fe7c:	d10b      	bne.n	802fe96 <RegionEU868NewChannelReq+0x52>
                status &= 0xFE;
 802fe7e:	3802      	subs	r0, #2
    return status;
 802fe80:	b240      	sxtb	r0, r0
}
 802fe82:	b005      	add	sp, #20
 802fe84:	bd00      	pop	{pc}
            status &= 0xFC;
 802fe86:	2000      	movs	r0, #0
 802fe88:	e7fa      	b.n	802fe80 <RegionEU868NewChannelReq+0x3c>
                status &= 0xFD;
 802fe8a:	2001      	movs	r0, #1
 802fe8c:	e7f8      	b.n	802fe80 <RegionEU868NewChannelReq+0x3c>
                status &= 0xFC;
 802fe8e:	2000      	movs	r0, #0
 802fe90:	e7f6      	b.n	802fe80 <RegionEU868NewChannelReq+0x3c>
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 802fe92:	2003      	movs	r0, #3
 802fe94:	e7f4      	b.n	802fe80 <RegionEU868NewChannelReq+0x3c>
                status &= 0xFC;
 802fe96:	2000      	movs	r0, #0
 802fe98:	e7f2      	b.n	802fe80 <RegionEU868NewChannelReq+0x3c>
	...

0802fe9c <RegionEU868SetContinuousWave>:

void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 802fe9c:	b570      	push	{r4, r5, r6, lr}
 802fe9e:	0004      	movs	r4, r0
#if defined( REGION_EU868 )
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 802fea0:	4b12      	ldr	r3, [pc, #72]	; (802feec <RegionEU868SetContinuousWave+0x50>)
 802fea2:	6819      	ldr	r1, [r3, #0]
 802fea4:	4d12      	ldr	r5, [pc, #72]	; (802fef0 <RegionEU868SetContinuousWave+0x54>)
 802fea6:	7803      	ldrb	r3, [r0, #0]
 802fea8:	005a      	lsls	r2, r3, #1
 802feaa:	18d2      	adds	r2, r2, r3
 802feac:	0092      	lsls	r2, r2, #2
 802feae:	682b      	ldr	r3, [r5, #0]
 802feb0:	469c      	mov	ip, r3
 802feb2:	4462      	add	r2, ip
 802feb4:	7a52      	ldrb	r2, [r2, #9]
 802feb6:	0053      	lsls	r3, r2, #1
 802feb8:	189b      	adds	r3, r3, r2
 802feba:	00db      	lsls	r3, r3, #3
 802febc:	18cb      	adds	r3, r1, r3
 802febe:	2102      	movs	r1, #2
 802fec0:	5659      	ldrsb	r1, [r3, r1]
 802fec2:	2002      	movs	r0, #2
 802fec4:	5620      	ldrsb	r0, [r4, r0]
 802fec6:	f7ff f970 	bl	802f1aa <RegionCommonLimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 802feca:	6829      	ldr	r1, [r5, #0]
 802fecc:	7822      	ldrb	r2, [r4, #0]
 802fece:	0053      	lsls	r3, r2, #1
 802fed0:	189b      	adds	r3, r3, r2
 802fed2:	009b      	lsls	r3, r3, #2
 802fed4:	585d      	ldr	r5, [r3, r1]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 802fed6:	68a2      	ldr	r2, [r4, #8]
 802fed8:	6861      	ldr	r1, [r4, #4]
 802feda:	f7ff f877 	bl	802efcc <RegionCommonComputeTxPower>
 802fede:	0001      	movs	r1, r0

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 802fee0:	4b04      	ldr	r3, [pc, #16]	; (802fef4 <RegionEU868SetContinuousWave+0x58>)
 802fee2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802fee4:	89a2      	ldrh	r2, [r4, #12]
 802fee6:	0028      	movs	r0, r5
 802fee8:	4798      	blx	r3
#endif /* REGION_EU868 */
}
 802feea:	bd70      	pop	{r4, r5, r6, pc}
 802feec:	2000b1b4 	.word	0x2000b1b4
 802fef0:	2000b1b8 	.word	0x2000b1b8
 802fef4:	080356b4 	.word	0x080356b4

0802fef8 <RegionEU868ApplyDrOffset>:

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 802fef8:	1a8a      	subs	r2, r1, r2
 802fefa:	b250      	sxtb	r0, r2

    if( datarate < 0 )
 802fefc:	0613      	lsls	r3, r2, #24
 802fefe:	d401      	bmi.n	802ff04 <RegionEU868ApplyDrOffset+0xc>
    {
        datarate = DR_0;
    }
    return datarate;
 802ff00:	b2c0      	uxtb	r0, r0
#else
    return 0;
#endif /* REGION_EU868 */
}
 802ff02:	4770      	bx	lr
        datarate = DR_0;
 802ff04:	2000      	movs	r0, #0
 802ff06:	e7fb      	b.n	802ff00 <RegionEU868ApplyDrOffset+0x8>

0802ff08 <VerifyRfFreq>:
    }
    return txPowerResult;
}

static bool VerifyRfFreq( uint32_t freq )
{
 802ff08:	b570      	push	{r4, r5, r6, lr}
 802ff0a:	0004      	movs	r4, r0
    // Check radio driver support
    if( Radio.CheckRfFrequency( freq ) == false )
 802ff0c:	4b0d      	ldr	r3, [pc, #52]	; (802ff44 <VerifyRfFreq+0x3c>)
 802ff0e:	6a1b      	ldr	r3, [r3, #32]
 802ff10:	4798      	blx	r3
 802ff12:	1e05      	subs	r5, r0, #0
 802ff14:	d012      	beq.n	802ff3c <VerifyRfFreq+0x34>
    {
        return false;
    }

    // Rx frequencies
    if( ( freq < US915_FIRST_RX1_CHANNEL ) ||
 802ff16:	4b0c      	ldr	r3, [pc, #48]	; (802ff48 <VerifyRfFreq+0x40>)
 802ff18:	18e0      	adds	r0, r4, r3
 802ff1a:	4b0c      	ldr	r3, [pc, #48]	; (802ff4c <VerifyRfFreq+0x44>)
 802ff1c:	4298      	cmp	r0, r3
 802ff1e:	d80c      	bhi.n	802ff3a <VerifyRfFreq+0x32>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
        ( ( ( freq - ( uint32_t ) US915_FIRST_RX1_CHANNEL ) % ( uint32_t ) US915_STEPWIDTH_RX1_CHANNEL ) != 0 ) )
 802ff20:	490b      	ldr	r1, [pc, #44]	; (802ff50 <VerifyRfFreq+0x48>)
 802ff22:	f7f0 f97f 	bl	8020224 <__aeabi_uidivmod>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
 802ff26:	2900      	cmp	r1, #0
 802ff28:	d10a      	bne.n	802ff40 <VerifyRfFreq+0x38>
    {
        return false;
    }

    // Test for frequency range - take RX and TX frequencies into account
    if( ( freq < 902300000 ) ||  ( freq > 927500000 ) )
 802ff2a:	4b0a      	ldr	r3, [pc, #40]	; (802ff54 <VerifyRfFreq+0x4c>)
 802ff2c:	469c      	mov	ip, r3
 802ff2e:	4464      	add	r4, ip
 802ff30:	4b09      	ldr	r3, [pc, #36]	; (802ff58 <VerifyRfFreq+0x50>)
 802ff32:	429c      	cmp	r4, r3
 802ff34:	d902      	bls.n	802ff3c <VerifyRfFreq+0x34>
    {
        return false;
 802ff36:	2500      	movs	r5, #0
 802ff38:	e000      	b.n	802ff3c <VerifyRfFreq+0x34>
        return false;
 802ff3a:	2500      	movs	r5, #0
    }
    return true;
}
 802ff3c:	0028      	movs	r0, r5
 802ff3e:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 802ff40:	2500      	movs	r5, #0
 802ff42:	e7fb      	b.n	802ff3c <VerifyRfFreq+0x34>
 802ff44:	080356b4 	.word	0x080356b4
 802ff48:	c8f78f60 	.word	0xc8f78f60
 802ff4c:	00401640 	.word	0x00401640
 802ff50:	000927c0 	.word	0x000927c0
 802ff54:	ca37fea0 	.word	0xca37fea0
 802ff58:	01808580 	.word	0x01808580

0802ff5c <GetTimeOnAir>:

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 802ff5c:	b570      	push	{r4, r5, r6, lr}
 802ff5e:	b084      	sub	sp, #16
 802ff60:	000c      	movs	r4, r1
    int8_t phyDr = DataratesUS915[datarate];
 802ff62:	4b0b      	ldr	r3, [pc, #44]	; (802ff90 <GetTimeOnAir+0x34>)
 802ff64:	561e      	ldrsb	r6, [r3, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 802ff66:	490b      	ldr	r1, [pc, #44]	; (802ff94 <GetTimeOnAir+0x38>)
 802ff68:	f7ff f926 	bl	802f1b8 <RegionCommonGetBandwidth>
 802ff6c:	0001      	movs	r1, r0

    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 802ff6e:	4b0a      	ldr	r3, [pc, #40]	; (802ff98 <GetTimeOnAir+0x3c>)
 802ff70:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 802ff72:	2301      	movs	r3, #1
 802ff74:	9303      	str	r3, [sp, #12]
 802ff76:	b2e4      	uxtb	r4, r4
 802ff78:	9402      	str	r4, [sp, #8]
 802ff7a:	2300      	movs	r3, #0
 802ff7c:	9301      	str	r3, [sp, #4]
 802ff7e:	3308      	adds	r3, #8
 802ff80:	9300      	str	r3, [sp, #0]
 802ff82:	3b07      	subs	r3, #7
 802ff84:	0032      	movs	r2, r6
 802ff86:	2001      	movs	r0, #1
 802ff88:	47a8      	blx	r5
}
 802ff8a:	b004      	add	sp, #16
 802ff8c:	bd70      	pop	{r4, r5, r6, pc}
 802ff8e:	46c0      	nop			; (mov r8, r8)
 802ff90:	080353e8 	.word	0x080353e8
 802ff94:	08035394 	.word	0x08035394
 802ff98:	080356b4 	.word	0x080356b4

0802ff9c <LimitTxPower>:
{
 802ff9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802ff9e:	0005      	movs	r5, r0
 802ffa0:	0017      	movs	r7, r2
 802ffa2:	001e      	movs	r6, r3
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 802ffa4:	f7ff f901 	bl	802f1aa <RegionCommonLimitTxPower>
 802ffa8:	0004      	movs	r4, r0
    if( datarate == DR_4 )
 802ffaa:	2f04      	cmp	r7, #4
 802ffac:	d107      	bne.n	802ffbe <LimitTxPower+0x22>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 802ffae:	1c2c      	adds	r4, r5, #0
 802ffb0:	2d01      	cmp	r5, #1
 802ffb2:	dd02      	ble.n	802ffba <LimitTxPower+0x1e>
 802ffb4:	b264      	sxtb	r4, r4
}
 802ffb6:	0020      	movs	r0, r4
 802ffb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        txPowerResult = MAX( txPower, TX_POWER_2 );
 802ffba:	2402      	movs	r4, #2
 802ffbc:	e7fa      	b.n	802ffb4 <LimitTxPower+0x18>
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 802ffbe:	2204      	movs	r2, #4
 802ffc0:	2100      	movs	r1, #0
 802ffc2:	0030      	movs	r0, r6
 802ffc4:	f7fe fe6c 	bl	802eca0 <RegionCommonCountChannels>
 802ffc8:	2831      	cmp	r0, #49	; 0x31
 802ffca:	d8f4      	bhi.n	802ffb6 <LimitTxPower+0x1a>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 802ffcc:	1c2c      	adds	r4, r5, #0
 802ffce:	2d04      	cmp	r5, #4
 802ffd0:	dc00      	bgt.n	802ffd4 <LimitTxPower+0x38>
 802ffd2:	2405      	movs	r4, #5
 802ffd4:	b264      	sxtb	r4, r4
 802ffd6:	e7ee      	b.n	802ffb6 <LimitTxPower+0x1a>

0802ffd8 <RegionUS915GetPhyParam>:
#endif /* REGION_US915 */

PhyParam_t RegionUS915GetPhyParam( GetPhyParams_t* getPhy )
{
 802ffd8:	b500      	push	{lr}
 802ffda:	b087      	sub	sp, #28
    PhyParam_t phyParam = { 0 };
 802ffdc:	2300      	movs	r3, #0
 802ffde:	9304      	str	r3, [sp, #16]

#if defined( REGION_US915 )
    switch( getPhy->Attribute )
 802ffe0:	7803      	ldrb	r3, [r0, #0]
 802ffe2:	2b39      	cmp	r3, #57	; 0x39
 802ffe4:	d805      	bhi.n	802fff2 <RegionUS915GetPhyParam+0x1a>
 802ffe6:	009b      	lsls	r3, r3, #2
 802ffe8:	4a50      	ldr	r2, [pc, #320]	; (803012c <RegionUS915GetPhyParam+0x154>)
 802ffea:	58d3      	ldr	r3, [r2, r3]
 802ffec:	469f      	mov	pc, r3
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = US915_RX_MIN_DATARATE;
 802ffee:	2308      	movs	r3, #8
 802fff0:	9304      	str	r3, [sp, #16]
        }
    }

#endif /* REGION_US915 */
    return phyParam;
}
 802fff2:	9804      	ldr	r0, [sp, #16]
 802fff4:	b007      	add	sp, #28
 802fff6:	bd00      	pop	{pc}
                .CurrentDr = getPhy->Datarate,
 802fff8:	2301      	movs	r3, #1
 802fffa:	56c3      	ldrsb	r3, [r0, r3]
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 802fffc:	a801      	add	r0, sp, #4
 802fffe:	7003      	strb	r3, [r0, #0]
 8030000:	2304      	movs	r3, #4
 8030002:	7043      	strb	r3, [r0, #1]
 8030004:	2300      	movs	r3, #0
 8030006:	7083      	strb	r3, [r0, #2]
 8030008:	3348      	adds	r3, #72	; 0x48
 803000a:	70c3      	strb	r3, [r0, #3]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 803000c:	4b48      	ldr	r3, [pc, #288]	; (8030130 <RegionUS915GetPhyParam+0x158>)
 803000e:	681b      	ldr	r3, [r3, #0]
 8030010:	22d8      	movs	r2, #216	; 0xd8
 8030012:	0092      	lsls	r2, r2, #2
 8030014:	189a      	adds	r2, r3, r2
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 8030016:	6042      	str	r2, [r0, #4]
 8030018:	6083      	str	r3, [r0, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 803001a:	f7ff f8a7 	bl	802f16c <RegionCommonGetNextLowerTxDr>
 803001e:	9004      	str	r0, [sp, #16]
            break;
 8030020:	e7e7      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 8030022:	2340      	movs	r3, #64	; 0x40
 8030024:	9304      	str	r3, [sp, #16]
            break;
 8030026:	e7e4      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 8030028:	2320      	movs	r3, #32
 803002a:	9304      	str	r3, [sp, #16]
            break;
 803002c:	e7e1      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = MaxPayloadOfDatarateUS915[getPhy->Datarate];
 803002e:	2301      	movs	r3, #1
 8030030:	56c3      	ldrsb	r3, [r0, r3]
 8030032:	4a40      	ldr	r2, [pc, #256]	; (8030134 <RegionUS915GetPhyParam+0x15c>)
 8030034:	5cd3      	ldrb	r3, [r2, r3]
 8030036:	9304      	str	r3, [sp, #16]
            break;
 8030038:	e7db      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = MaxPayloadOfDatarateRepeaterUS915[getPhy->Datarate];
 803003a:	2301      	movs	r3, #1
 803003c:	56c3      	ldrsb	r3, [r0, r3]
 803003e:	4a3e      	ldr	r2, [pc, #248]	; (8030138 <RegionUS915GetPhyParam+0x160>)
 8030040:	5cd3      	ldrb	r3, [r2, r3]
 8030042:	9304      	str	r3, [sp, #16]
            break;
 8030044:	e7d5      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_MAX_RX_WINDOW;
 8030046:	4b3d      	ldr	r3, [pc, #244]	; (803013c <RegionUS915GetPhyParam+0x164>)
 8030048:	9304      	str	r3, [sp, #16]
            break;
 803004a:	e7d2      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 803004c:	23fa      	movs	r3, #250	; 0xfa
 803004e:	009b      	lsls	r3, r3, #2
 8030050:	9304      	str	r3, [sp, #16]
            break;
 8030052:	e7ce      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 8030054:	23fa      	movs	r3, #250	; 0xfa
 8030056:	00db      	lsls	r3, r3, #3
 8030058:	9304      	str	r3, [sp, #16]
            break;
 803005a:	e7ca      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 803005c:	4b38      	ldr	r3, [pc, #224]	; (8030140 <RegionUS915GetPhyParam+0x168>)
 803005e:	9304      	str	r3, [sp, #16]
            break;
 8030060:	e7c7      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8030062:	4b38      	ldr	r3, [pc, #224]	; (8030144 <RegionUS915GetPhyParam+0x16c>)
 8030064:	9304      	str	r3, [sp, #16]
            break;
 8030066:	e7c4      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 8030068:	2380      	movs	r3, #128	; 0x80
 803006a:	01db      	lsls	r3, r3, #7
 803006c:	9304      	str	r3, [sp, #16]
            break;
 803006e:	e7c0      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 8030070:	21fa      	movs	r1, #250	; 0xfa
 8030072:	0089      	lsls	r1, r1, #2
 8030074:	4834      	ldr	r0, [pc, #208]	; (8030148 <RegionUS915GetPhyParam+0x170>)
 8030076:	f001 fb85 	bl	8031784 <randr>
 803007a:	23fa      	movs	r3, #250	; 0xfa
 803007c:	00db      	lsls	r3, r3, #3
 803007e:	469c      	mov	ip, r3
 8030080:	4460      	add	r0, ip
 8030082:	9004      	str	r0, [sp, #16]
            break;
 8030084:	e7b5      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_RX_WND_2_FREQ;
 8030086:	4b31      	ldr	r3, [pc, #196]	; (803014c <RegionUS915GetPhyParam+0x174>)
 8030088:	9304      	str	r3, [sp, #16]
            break;
 803008a:	e7b2      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_RX_WND_2_DR;
 803008c:	2308      	movs	r3, #8
 803008e:	9304      	str	r3, [sp, #16]
            break;
 8030090:	e7af      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8030092:	4b27      	ldr	r3, [pc, #156]	; (8030130 <RegionUS915GetPhyParam+0x158>)
 8030094:	681b      	ldr	r3, [r3, #0]
 8030096:	22d8      	movs	r2, #216	; 0xd8
 8030098:	0092      	lsls	r2, r2, #2
 803009a:	4694      	mov	ip, r2
 803009c:	4463      	add	r3, ip
 803009e:	9304      	str	r3, [sp, #16]
            break;
 80300a0:	e7a7      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 80300a2:	4b23      	ldr	r3, [pc, #140]	; (8030130 <RegionUS915GetPhyParam+0x158>)
 80300a4:	681b      	ldr	r3, [r3, #0]
 80300a6:	22db      	movs	r2, #219	; 0xdb
 80300a8:	0092      	lsls	r2, r2, #2
 80300aa:	4694      	mov	ip, r2
 80300ac:	4463      	add	r3, ip
 80300ae:	9304      	str	r3, [sp, #16]
            break;
 80300b0:	e79f      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_MAX_NB_CHANNELS;
 80300b2:	2348      	movs	r3, #72	; 0x48
 80300b4:	9304      	str	r3, [sp, #16]
            break;
 80300b6:	e79c      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Channels = RegionNvmGroup2->Channels;
 80300b8:	4b1d      	ldr	r3, [pc, #116]	; (8030130 <RegionUS915GetPhyParam+0x158>)
 80300ba:	681b      	ldr	r3, [r3, #0]
 80300bc:	9304      	str	r3, [sp, #16]
            break;
 80300be:	e798      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.fValue = US915_DEFAULT_MAX_ERP + 2.15f;
 80300c0:	4b23      	ldr	r3, [pc, #140]	; (8030150 <RegionUS915GetPhyParam+0x178>)
 80300c2:	9304      	str	r3, [sp, #16]
            break;
 80300c4:	e795      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.fValue = 0;
 80300c6:	2300      	movs	r3, #0
 80300c8:	9304      	str	r3, [sp, #16]
            break;
 80300ca:	e792      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 80300cc:	7900      	ldrb	r0, [r0, #4]
 80300ce:	4a21      	ldr	r2, [pc, #132]	; (8030154 <RegionUS915GetPhyParam+0x17c>)
 80300d0:	491e      	ldr	r1, [pc, #120]	; (803014c <RegionUS915GetPhyParam+0x174>)
 80300d2:	f7fe fca7 	bl	802ea24 <RegionBaseUSCalcDownlinkFrequency>
 80300d6:	9004      	str	r0, [sp, #16]
            break;
 80300d8:	e78b      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.BeaconFormat.BeaconSize = US915_BEACON_SIZE;
 80300da:	ab04      	add	r3, sp, #16
 80300dc:	2217      	movs	r2, #23
 80300de:	701a      	strb	r2, [r3, #0]
            phyParam.BeaconFormat.Rfu1Size = US915_RFU1_SIZE;
 80300e0:	3a12      	subs	r2, #18
 80300e2:	705a      	strb	r2, [r3, #1]
            phyParam.BeaconFormat.Rfu2Size = US915_RFU2_SIZE;
 80300e4:	3a02      	subs	r2, #2
 80300e6:	709a      	strb	r2, [r3, #2]
            break;
 80300e8:	e783      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_BEACON_CHANNEL_DR;
 80300ea:	2308      	movs	r3, #8
 80300ec:	9304      	str	r3, [sp, #16]
            break;
 80300ee:	e780      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_BEACON_NB_CHANNELS;
 80300f0:	2308      	movs	r3, #8
 80300f2:	9304      	str	r3, [sp, #16]
            break;
 80300f4:	e77d      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 80300f6:	7900      	ldrb	r0, [r0, #4]
 80300f8:	4a16      	ldr	r2, [pc, #88]	; (8030154 <RegionUS915GetPhyParam+0x17c>)
 80300fa:	4914      	ldr	r1, [pc, #80]	; (803014c <RegionUS915GetPhyParam+0x174>)
 80300fc:	f7fe fc92 	bl	802ea24 <RegionBaseUSCalcDownlinkFrequency>
 8030100:	9004      	str	r0, [sp, #16]
            break;
 8030102:	e776      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_PING_SLOT_CHANNEL_DR;
 8030104:	2308      	movs	r3, #8
 8030106:	9304      	str	r3, [sp, #16]
            break;
 8030108:	e773      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_BEACON_NB_CHANNELS;
 803010a:	2308      	movs	r3, #8
 803010c:	9304      	str	r3, [sp, #16]
            break;
 803010e:	e770      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 8030110:	2301      	movs	r3, #1
 8030112:	56c3      	ldrsb	r3, [r0, r3]
 8030114:	4a10      	ldr	r2, [pc, #64]	; (8030158 <RegionUS915GetPhyParam+0x180>)
 8030116:	5cd3      	ldrb	r3, [r2, r3]
 8030118:	9304      	str	r3, [sp, #16]
            break;
 803011a:	e76a      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 803011c:	7840      	ldrb	r0, [r0, #1]
 803011e:	b240      	sxtb	r0, r0
 8030120:	490e      	ldr	r1, [pc, #56]	; (803015c <RegionUS915GetPhyParam+0x184>)
 8030122:	f7ff f849 	bl	802f1b8 <RegionCommonGetBandwidth>
 8030126:	9004      	str	r0, [sp, #16]
            break;
 8030128:	e763      	b.n	802fff2 <RegionUS915GetPhyParam+0x1a>
 803012a:	46c0      	nop			; (mov r8, r8)
 803012c:	080352ac 	.word	0x080352ac
 8030130:	2000b1c0 	.word	0x2000b1c0
 8030134:	08035408 	.word	0x08035408
 8030138:	080353f8 	.word	0x080353f8
 803013c:	00000bb8 	.word	0x00000bb8
 8030140:	00001388 	.word	0x00001388
 8030144:	00001770 	.word	0x00001770
 8030148:	fffffc18 	.word	0xfffffc18
 803014c:	370870a0 	.word	0x370870a0
 8030150:	4200999a 	.word	0x4200999a
 8030154:	000927c0 	.word	0x000927c0
 8030158:	080353e8 	.word	0x080353e8
 803015c:	08035394 	.word	0x08035394

08030160 <RegionUS915SetBandTxDone>:

void RegionUS915SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 8030160:	b530      	push	{r4, r5, lr}
 8030162:	b083      	sub	sp, #12
 8030164:	0003      	movs	r3, r0
#if defined( REGION_US915 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8030166:	4a0b      	ldr	r2, [pc, #44]	; (8030194 <RegionUS915SetBandTxDone+0x34>)
 8030168:	6814      	ldr	r4, [r2, #0]
 803016a:	4a0b      	ldr	r2, [pc, #44]	; (8030198 <RegionUS915SetBandTxDone+0x38>)
 803016c:	6811      	ldr	r1, [r2, #0]
 803016e:	7800      	ldrb	r0, [r0, #0]
 8030170:	0042      	lsls	r2, r0, #1
 8030172:	1812      	adds	r2, r2, r0
 8030174:	0092      	lsls	r2, r2, #2
 8030176:	188a      	adds	r2, r1, r2
 8030178:	7a55      	ldrb	r5, [r2, #9]
 803017a:	785a      	ldrb	r2, [r3, #1]
 803017c:	6899      	ldr	r1, [r3, #8]
 803017e:	0068      	lsls	r0, r5, #1
 8030180:	1940      	adds	r0, r0, r5
 8030182:	00c0      	lsls	r0, r0, #3
 8030184:	1820      	adds	r0, r4, r0
 8030186:	691c      	ldr	r4, [r3, #16]
 8030188:	9400      	str	r4, [sp, #0]
 803018a:	68db      	ldr	r3, [r3, #12]
 803018c:	f7fe fdae 	bl	802ecec <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_US915 */
}
 8030190:	b003      	add	sp, #12
 8030192:	bd30      	pop	{r4, r5, pc}
 8030194:	2000b1bc 	.word	0x2000b1bc
 8030198:	2000b1c0 	.word	0x2000b1c0

0803019c <RegionUS915InitDefaults>:

void RegionUS915InitDefaults( InitDefaultsParams_t* params )
{
 803019c:	b510      	push	{r4, lr}
 803019e:	b086      	sub	sp, #24
#if defined( REGION_US915 )
    Band_t bands[US915_MAX_NB_BANDS] =
 80301a0:	2301      	movs	r3, #1
 80301a2:	466a      	mov	r2, sp
 80301a4:	8013      	strh	r3, [r2, #0]
 80301a6:	2300      	movs	r3, #0
 80301a8:	7093      	strb	r3, [r2, #2]
 80301aa:	9301      	str	r3, [sp, #4]
 80301ac:	9302      	str	r3, [sp, #8]
 80301ae:	9303      	str	r3, [sp, #12]
 80301b0:	9304      	str	r3, [sp, #16]
 80301b2:	7513      	strb	r3, [r2, #20]
    {
       US915_BAND0
    };

    switch( params->Type )
 80301b4:	7a04      	ldrb	r4, [r0, #8]
 80301b6:	2c00      	cmp	r4, #0
 80301b8:	d011      	beq.n	80301de <RegionUS915InitDefaults+0x42>
 80301ba:	3c01      	subs	r4, #1
 80301bc:	b2e4      	uxtb	r4, r4
 80301be:	2c01      	cmp	r4, #1
 80301c0:	d900      	bls.n	80301c4 <RegionUS915InitDefaults+0x28>
 80301c2:	e088      	b.n	80302d6 <RegionUS915InitDefaults+0x13a>
            // Intentional fallthrough
        }
        case INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS:
        {
            // Copy channels default mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 80301c4:	4b45      	ldr	r3, [pc, #276]	; (80302dc <RegionUS915InitDefaults+0x140>)
 80301c6:	6819      	ldr	r1, [r3, #0]
 80301c8:	23d8      	movs	r3, #216	; 0xd8
 80301ca:	009b      	lsls	r3, r3, #2
 80301cc:	18c8      	adds	r0, r1, r3
 80301ce:	330c      	adds	r3, #12
 80301d0:	469c      	mov	ip, r3
 80301d2:	4461      	add	r1, ip
 80301d4:	2206      	movs	r2, #6
 80301d6:	f7fe fd7a 	bl	802ecce <RegionCommonChanMaskCopy>

            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 80301da:	2300      	movs	r3, #0
 80301dc:	e079      	b.n	80302d2 <RegionUS915InitDefaults+0x136>
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 80301de:	6803      	ldr	r3, [r0, #0]
 80301e0:	2b00      	cmp	r3, #0
 80301e2:	d078      	beq.n	80302d6 <RegionUS915InitDefaults+0x13a>
 80301e4:	6842      	ldr	r2, [r0, #4]
 80301e6:	2a00      	cmp	r2, #0
 80301e8:	d075      	beq.n	80302d6 <RegionUS915InitDefaults+0x13a>
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 80301ea:	493d      	ldr	r1, [pc, #244]	; (80302e0 <RegionUS915InitDefaults+0x144>)
 80301ec:	600b      	str	r3, [r1, #0]
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 80301ee:	493b      	ldr	r1, [pc, #236]	; (80302dc <RegionUS915InitDefaults+0x140>)
 80301f0:	600a      	str	r2, [r1, #0]
            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 80301f2:	2200      	movs	r2, #0
 80301f4:	219c      	movs	r1, #156	; 0x9c
 80301f6:	545a      	strb	r2, [r3, r1]
            RegionNvmGroup1->JoinTrialsCounter = 0;
 80301f8:	3101      	adds	r1, #1
 80301fa:	545a      	strb	r2, [r3, r1]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 80301fc:	3218      	adds	r2, #24
 80301fe:	4669      	mov	r1, sp
 8030200:	0018      	movs	r0, r3
 8030202:	f001 faca 	bl	803179a <memcpy1>
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8030206:	e011      	b.n	803022c <RegionUS915InitDefaults+0x90>
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8030208:	4936      	ldr	r1, [pc, #216]	; (80302e4 <RegionUS915InitDefaults+0x148>)
 803020a:	4361      	muls	r1, r4
 803020c:	4b33      	ldr	r3, [pc, #204]	; (80302dc <RegionUS915InitDefaults+0x140>)
 803020e:	681a      	ldr	r2, [r3, #0]
 8030210:	4b35      	ldr	r3, [pc, #212]	; (80302e8 <RegionUS915InitDefaults+0x14c>)
 8030212:	469c      	mov	ip, r3
 8030214:	4461      	add	r1, ip
 8030216:	0063      	lsls	r3, r4, #1
 8030218:	1918      	adds	r0, r3, r4
 803021a:	0080      	lsls	r0, r0, #2
 803021c:	5081      	str	r1, [r0, r2]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 803021e:	1811      	adds	r1, r2, r0
 8030220:	2030      	movs	r0, #48	; 0x30
 8030222:	7208      	strb	r0, [r1, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8030224:	2200      	movs	r2, #0
 8030226:	724a      	strb	r2, [r1, #9]
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8030228:	3401      	adds	r4, #1
 803022a:	b2e4      	uxtb	r4, r4
 803022c:	2c3f      	cmp	r4, #63	; 0x3f
 803022e:	d9eb      	bls.n	8030208 <RegionUS915InitDefaults+0x6c>
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8030230:	2340      	movs	r3, #64	; 0x40
 8030232:	e013      	b.n	803025c <RegionUS915InitDefaults+0xc0>
                RegionNvmGroup2->Channels[i].Frequency = 903000000 + ( i - ( US915_MAX_NB_CHANNELS - 8 ) ) * 1600000;
 8030234:	001a      	movs	r2, r3
 8030236:	3a40      	subs	r2, #64	; 0x40
 8030238:	482c      	ldr	r0, [pc, #176]	; (80302ec <RegionUS915InitDefaults+0x150>)
 803023a:	4350      	muls	r0, r2
 803023c:	4a27      	ldr	r2, [pc, #156]	; (80302dc <RegionUS915InitDefaults+0x140>)
 803023e:	6811      	ldr	r1, [r2, #0]
 8030240:	4a2b      	ldr	r2, [pc, #172]	; (80302f0 <RegionUS915InitDefaults+0x154>)
 8030242:	4694      	mov	ip, r2
 8030244:	4460      	add	r0, ip
 8030246:	005a      	lsls	r2, r3, #1
 8030248:	18d4      	adds	r4, r2, r3
 803024a:	00a4      	lsls	r4, r4, #2
 803024c:	5060      	str	r0, [r4, r1]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 803024e:	1908      	adds	r0, r1, r4
 8030250:	2444      	movs	r4, #68	; 0x44
 8030252:	7204      	strb	r4, [r0, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8030254:	2100      	movs	r1, #0
 8030256:	7241      	strb	r1, [r0, #9]
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8030258:	3301      	adds	r3, #1
 803025a:	b2db      	uxtb	r3, r3
 803025c:	2b47      	cmp	r3, #71	; 0x47
 803025e:	d9e9      	bls.n	8030234 <RegionUS915InitDefaults+0x98>
            RegionNvmGroup2->ChannelsDefaultMask[0] = 0xFFFF;
 8030260:	4c1e      	ldr	r4, [pc, #120]	; (80302dc <RegionUS915InitDefaults+0x140>)
 8030262:	6821      	ldr	r1, [r4, #0]
 8030264:	2301      	movs	r3, #1
 8030266:	425b      	negs	r3, r3
 8030268:	22db      	movs	r2, #219	; 0xdb
 803026a:	0092      	lsls	r2, r2, #2
 803026c:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[1] = 0xFFFF;
 803026e:	4a21      	ldr	r2, [pc, #132]	; (80302f4 <RegionUS915InitDefaults+0x158>)
 8030270:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[2] = 0xFFFF;
 8030272:	3202      	adds	r2, #2
 8030274:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[3] = 0xFFFF;
 8030276:	4a20      	ldr	r2, [pc, #128]	; (80302f8 <RegionUS915InitDefaults+0x15c>)
 8030278:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[4] = 0x00FF;
 803027a:	23dd      	movs	r3, #221	; 0xdd
 803027c:	009b      	lsls	r3, r3, #2
 803027e:	22ff      	movs	r2, #255	; 0xff
 8030280:	52ca      	strh	r2, [r1, r3]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8030282:	4b1e      	ldr	r3, [pc, #120]	; (80302fc <RegionUS915InitDefaults+0x160>)
 8030284:	2200      	movs	r2, #0
 8030286:	52ca      	strh	r2, [r1, r3]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8030288:	3b16      	subs	r3, #22
 803028a:	18c8      	adds	r0, r1, r3
 803028c:	330c      	adds	r3, #12
 803028e:	469c      	mov	ip, r3
 8030290:	4461      	add	r1, ip
 8030292:	3206      	adds	r2, #6
 8030294:	f7fe fd1b 	bl	802ecce <RegionCommonChanMaskCopy>
            RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8030298:	4b11      	ldr	r3, [pc, #68]	; (80302e0 <RegionUS915InitDefaults+0x144>)
 803029a:	6818      	ldr	r0, [r3, #0]
 803029c:	3090      	adds	r0, #144	; 0x90
 803029e:	6821      	ldr	r1, [r4, #0]
 80302a0:	23d8      	movs	r3, #216	; 0xd8
 80302a2:	009b      	lsls	r3, r3, #2
 80302a4:	469c      	mov	ip, r3
 80302a6:	4461      	add	r1, ip
 80302a8:	2206      	movs	r2, #6
 80302aa:	f7fe fd10 	bl	802ecce <RegionCommonChanMaskCopy>
            break;
 80302ae:	e012      	b.n	80302d6 <RegionUS915InitDefaults+0x13a>
            { // Copy-And the channels mask
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 80302b0:	4a0b      	ldr	r2, [pc, #44]	; (80302e0 <RegionUS915InitDefaults+0x144>)
 80302b2:	6810      	ldr	r0, [r2, #0]
 80302b4:	4a09      	ldr	r2, [pc, #36]	; (80302dc <RegionUS915InitDefaults+0x140>)
 80302b6:	6811      	ldr	r1, [r2, #0]
 80302b8:	001a      	movs	r2, r3
 80302ba:	32b1      	adds	r2, #177	; 0xb1
 80302bc:	32ff      	adds	r2, #255	; 0xff
 80302be:	0052      	lsls	r2, r2, #1
 80302c0:	5a54      	ldrh	r4, [r2, r1]
 80302c2:	001a      	movs	r2, r3
 80302c4:	3248      	adds	r2, #72	; 0x48
 80302c6:	0052      	lsls	r2, r2, #1
 80302c8:	5a11      	ldrh	r1, [r2, r0]
 80302ca:	4021      	ands	r1, r4
 80302cc:	5211      	strh	r1, [r2, r0]
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 80302ce:	3301      	adds	r3, #1
 80302d0:	b2db      	uxtb	r3, r3
 80302d2:	2b05      	cmp	r3, #5
 80302d4:	d9ec      	bls.n	80302b0 <RegionUS915InitDefaults+0x114>
        {
            break;
        }
    }
#endif /* REGION_US915 */
}
 80302d6:	b006      	add	sp, #24
 80302d8:	bd10      	pop	{r4, pc}
 80302da:	46c0      	nop			; (mov r8, r8)
 80302dc:	2000b1c0 	.word	0x2000b1c0
 80302e0:	2000b1bc 	.word	0x2000b1bc
 80302e4:	00030d40 	.word	0x00030d40
 80302e8:	35c80160 	.word	0x35c80160
 80302ec:	00186a00 	.word	0x00186a00
 80302f0:	35d2afc0 	.word	0x35d2afc0
 80302f4:	0000036e 	.word	0x0000036e
 80302f8:	00000372 	.word	0x00000372
 80302fc:	00000376 	.word	0x00000376

08030300 <RegionUS915Verify>:

bool RegionUS915Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8030300:	b510      	push	{r4, lr}
#if defined( REGION_US915 )
    switch( phyAttribute )
 8030302:	2907      	cmp	r1, #7
 8030304:	d022      	beq.n	803034c <RegionUS915Verify+0x4c>
 8030306:	d80f      	bhi.n	8030328 <RegionUS915Verify+0x28>
 8030308:	2900      	cmp	r1, #0
 803030a:	d01b      	beq.n	8030344 <RegionUS915Verify+0x44>
 803030c:	3905      	subs	r1, #5
 803030e:	b2c9      	uxtb	r1, r1
 8030310:	2901      	cmp	r1, #1
 8030312:	d825      	bhi.n	8030360 <RegionUS915Verify+0x60>
            return VerifyRfFreq( verify->Frequency );
        }
        case PHY_TX_DR:
        case PHY_DEF_TX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
 8030314:	7800      	ldrb	r0, [r0, #0]
 8030316:	b240      	sxtb	r0, r0
 8030318:	2204      	movs	r2, #4
 803031a:	2100      	movs	r1, #0
 803031c:	f7fe fc5d 	bl	802ebda <RegionCommonValueInRange>
 8030320:	1e43      	subs	r3, r0, #1
 8030322:	4198      	sbcs	r0, r3
 8030324:	b2c0      	uxtb	r0, r0
 8030326:	e01e      	b.n	8030366 <RegionUS915Verify+0x66>
    switch( phyAttribute )
 8030328:	3909      	subs	r1, #9
 803032a:	b2c9      	uxtb	r1, r1
 803032c:	2901      	cmp	r1, #1
 803032e:	d819      	bhi.n	8030364 <RegionUS915Verify+0x64>
        }
        case PHY_DEF_TX_POWER:
        case PHY_TX_POWER:
        {
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8030330:	7800      	ldrb	r0, [r0, #0]
 8030332:	b240      	sxtb	r0, r0
 8030334:	220e      	movs	r2, #14
 8030336:	2100      	movs	r1, #0
 8030338:	f7fe fc4f 	bl	802ebda <RegionCommonValueInRange>
 803033c:	1e43      	subs	r3, r0, #1
 803033e:	4198      	sbcs	r0, r3
 8030340:	b2c0      	uxtb	r0, r0
 8030342:	e010      	b.n	8030366 <RegionUS915Verify+0x66>
            return VerifyRfFreq( verify->Frequency );
 8030344:	6800      	ldr	r0, [r0, #0]
 8030346:	f7ff fddf 	bl	802ff08 <VerifyRfFreq>
 803034a:	e00c      	b.n	8030366 <RegionUS915Verify+0x66>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE );
 803034c:	7800      	ldrb	r0, [r0, #0]
 803034e:	b240      	sxtb	r0, r0
 8030350:	220d      	movs	r2, #13
 8030352:	2108      	movs	r1, #8
 8030354:	f7fe fc41 	bl	802ebda <RegionCommonValueInRange>
 8030358:	1e43      	subs	r3, r0, #1
 803035a:	4198      	sbcs	r0, r3
 803035c:	b2c0      	uxtb	r0, r0
 803035e:	e002      	b.n	8030366 <RegionUS915Verify+0x66>
    switch( phyAttribute )
 8030360:	2000      	movs	r0, #0
 8030362:	e000      	b.n	8030366 <RegionUS915Verify+0x66>
 8030364:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_US915 */
}
 8030366:	bd10      	pop	{r4, pc}

08030368 <RegionUS915ApplyCFList>:

void RegionUS915ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8030368:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    // Size of the optional CF list must be 16 byte
    if( applyCFList->Size != 16 )
 803036a:	7903      	ldrb	r3, [r0, #4]
 803036c:	2b10      	cmp	r3, #16
 803036e:	d130      	bne.n	80303d2 <RegionUS915ApplyCFList+0x6a>
    {
        return;
    }

    // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
    if( applyCFList->Payload[15] != 0x01 )
 8030370:	6803      	ldr	r3, [r0, #0]
 8030372:	7bdb      	ldrb	r3, [r3, #15]
 8030374:	2b01      	cmp	r3, #1
 8030376:	d12c      	bne.n	80303d2 <RegionUS915ApplyCFList+0x6a>
    {
        return;
    }

    // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8030378:	2100      	movs	r1, #0
 803037a:	2300      	movs	r3, #0
 803037c:	e014      	b.n	80303a8 <RegionUS915ApplyCFList+0x40>
    {
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
        if( chMaskItr == 4 )
        {
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
 803037e:	25ff      	movs	r5, #255	; 0xff
 8030380:	402c      	ands	r4, r5
 8030382:	35b5      	adds	r5, #181	; 0xb5
 8030384:	006d      	lsls	r5, r5, #1
 8030386:	53ac      	strh	r4, [r5, r6]
        }
        // Set the channel mask to the remaining
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8030388:	4c12      	ldr	r4, [pc, #72]	; (80303d4 <RegionUS915ApplyCFList+0x6c>)
 803038a:	6825      	ldr	r5, [r4, #0]
 803038c:	0014      	movs	r4, r2
 803038e:	34b1      	adds	r4, #177	; 0xb1
 8030390:	34ff      	adds	r4, #255	; 0xff
 8030392:	0064      	lsls	r4, r4, #1
 8030394:	5ba6      	ldrh	r6, [r4, r6]
 8030396:	3248      	adds	r2, #72	; 0x48
 8030398:	0052      	lsls	r2, r2, #1
 803039a:	5b54      	ldrh	r4, [r2, r5]
 803039c:	4034      	ands	r4, r6
 803039e:	5354      	strh	r4, [r2, r5]
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 80303a0:	3301      	adds	r3, #1
 80303a2:	b2db      	uxtb	r3, r3
 80303a4:	3102      	adds	r1, #2
 80303a6:	b2c9      	uxtb	r1, r1
 80303a8:	2b04      	cmp	r3, #4
 80303aa:	d812      	bhi.n	80303d2 <RegionUS915ApplyCFList+0x6a>
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 80303ac:	4a0a      	ldr	r2, [pc, #40]	; (80303d8 <RegionUS915ApplyCFList+0x70>)
 80303ae:	6816      	ldr	r6, [r2, #0]
 80303b0:	001a      	movs	r2, r3
 80303b2:	6804      	ldr	r4, [r0, #0]
 80303b4:	5c64      	ldrb	r4, [r4, r1]
 80303b6:	001d      	movs	r5, r3
 80303b8:	35b1      	adds	r5, #177	; 0xb1
 80303ba:	35ff      	adds	r5, #255	; 0xff
 80303bc:	006d      	lsls	r5, r5, #1
 80303be:	53ac      	strh	r4, [r5, r6]
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 80303c0:	6807      	ldr	r7, [r0, #0]
 80303c2:	187f      	adds	r7, r7, r1
 80303c4:	787f      	ldrb	r7, [r7, #1]
 80303c6:	023f      	lsls	r7, r7, #8
 80303c8:	433c      	orrs	r4, r7
 80303ca:	53ac      	strh	r4, [r5, r6]
        if( chMaskItr == 4 )
 80303cc:	2b04      	cmp	r3, #4
 80303ce:	d1db      	bne.n	8030388 <RegionUS915ApplyCFList+0x20>
 80303d0:	e7d5      	b.n	803037e <RegionUS915ApplyCFList+0x16>
    }
#endif /* REGION_US915 */
}
 80303d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80303d4:	2000b1bc 	.word	0x2000b1bc
 80303d8:	2000b1c0 	.word	0x2000b1c0

080303dc <RegionUS915ChanMaskSet>:

bool RegionUS915ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 80303dc:	b570      	push	{r4, r5, r6, lr}
 80303de:	0005      	movs	r5, r0
#if defined( REGION_US915 )
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 80303e0:	2204      	movs	r2, #4
 80303e2:	2100      	movs	r1, #0
 80303e4:	6800      	ldr	r0, [r0, #0]
 80303e6:	f7fe fc5b 	bl	802eca0 <RegionCommonCountChannels>

    // Check the number of active channels
    if( ( nbChannels < 2 ) &&
 80303ea:	2801      	cmp	r0, #1
 80303ec:	d03b      	beq.n	8030466 <RegionUS915ChanMaskSet+0x8a>
        ( nbChannels > 0 ) )
    {
        return false;
    }

    switch( chanMaskSet->ChannelsMaskType )
 80303ee:	792c      	ldrb	r4, [r5, #4]
 80303f0:	2c00      	cmp	r4, #0
 80303f2:	d003      	beq.n	80303fc <RegionUS915ChanMaskSet+0x20>
 80303f4:	2c01      	cmp	r4, #1
 80303f6:	d02a      	beq.n	803044e <RegionUS915ChanMaskSet+0x72>
 80303f8:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 80303fa:	bd70      	pop	{r4, r5, r6, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 80303fc:	4e1b      	ldr	r6, [pc, #108]	; (803046c <RegionUS915ChanMaskSet+0x90>)
 80303fe:	6833      	ldr	r3, [r6, #0]
 8030400:	22d8      	movs	r2, #216	; 0xd8
 8030402:	0092      	lsls	r2, r2, #2
 8030404:	4694      	mov	ip, r2
 8030406:	4463      	add	r3, ip
 8030408:	0018      	movs	r0, r3
 803040a:	6829      	ldr	r1, [r5, #0]
 803040c:	2206      	movs	r2, #6
 803040e:	f7fe fc5e 	bl	802ecce <RegionCommonChanMaskCopy>
            RegionNvmGroup2->ChannelsDefaultMask[4] = RegionNvmGroup2->ChannelsDefaultMask[4] & CHANNELS_MASK_500KHZ_MASK;
 8030412:	6835      	ldr	r5, [r6, #0]
 8030414:	22dd      	movs	r2, #221	; 0xdd
 8030416:	0092      	lsls	r2, r2, #2
 8030418:	5aa9      	ldrh	r1, [r5, r2]
 803041a:	23ff      	movs	r3, #255	; 0xff
 803041c:	400b      	ands	r3, r1
 803041e:	52ab      	strh	r3, [r5, r2]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8030420:	4b13      	ldr	r3, [pc, #76]	; (8030470 <RegionUS915ChanMaskSet+0x94>)
 8030422:	2200      	movs	r2, #0
 8030424:	52ea      	strh	r2, [r5, r3]
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8030426:	2c05      	cmp	r4, #5
 8030428:	d80f      	bhi.n	803044a <RegionUS915ChanMaskSet+0x6e>
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 803042a:	4b12      	ldr	r3, [pc, #72]	; (8030474 <RegionUS915ChanMaskSet+0x98>)
 803042c:	6819      	ldr	r1, [r3, #0]
 803042e:	0023      	movs	r3, r4
 8030430:	33b1      	adds	r3, #177	; 0xb1
 8030432:	33ff      	adds	r3, #255	; 0xff
 8030434:	005b      	lsls	r3, r3, #1
 8030436:	5b58      	ldrh	r0, [r3, r5]
 8030438:	0023      	movs	r3, r4
 803043a:	3348      	adds	r3, #72	; 0x48
 803043c:	005b      	lsls	r3, r3, #1
 803043e:	5a5a      	ldrh	r2, [r3, r1]
 8030440:	4002      	ands	r2, r0
 8030442:	525a      	strh	r2, [r3, r1]
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8030444:	3401      	adds	r4, #1
 8030446:	b2e4      	uxtb	r4, r4
 8030448:	e7ed      	b.n	8030426 <RegionUS915ChanMaskSet+0x4a>
    return true;
 803044a:	2001      	movs	r0, #1
 803044c:	e7d5      	b.n	80303fa <RegionUS915ChanMaskSet+0x1e>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 803044e:	4b07      	ldr	r3, [pc, #28]	; (803046c <RegionUS915ChanMaskSet+0x90>)
 8030450:	6818      	ldr	r0, [r3, #0]
 8030452:	23db      	movs	r3, #219	; 0xdb
 8030454:	009b      	lsls	r3, r3, #2
 8030456:	469c      	mov	ip, r3
 8030458:	4460      	add	r0, ip
 803045a:	6829      	ldr	r1, [r5, #0]
 803045c:	2206      	movs	r2, #6
 803045e:	f7fe fc36 	bl	802ecce <RegionCommonChanMaskCopy>
    return true;
 8030462:	2001      	movs	r0, #1
            break;
 8030464:	e7c9      	b.n	80303fa <RegionUS915ChanMaskSet+0x1e>
        return false;
 8030466:	2000      	movs	r0, #0
 8030468:	e7c7      	b.n	80303fa <RegionUS915ChanMaskSet+0x1e>
 803046a:	46c0      	nop			; (mov r8, r8)
 803046c:	2000b1c0 	.word	0x2000b1c0
 8030470:	00000376 	.word	0x00000376
 8030474:	2000b1bc 	.word	0x2000b1bc

08030478 <RegionUS915ComputeRxWindowParameters>:

void RegionUS915ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8030478:	b5f0      	push	{r4, r5, r6, r7, lr}
 803047a:	b083      	sub	sp, #12
 803047c:	000e      	movs	r6, r1
 803047e:	0017      	movs	r7, r2
 8030480:	001c      	movs	r4, r3
#if defined( REGION_US915 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8030482:	1c03      	adds	r3, r0, #0
 8030484:	280d      	cmp	r0, #13
 8030486:	dd00      	ble.n	803048a <RegionUS915ComputeRxWindowParameters+0x12>
 8030488:	230d      	movs	r3, #13
 803048a:	b258      	sxtb	r0, r3
 803048c:	7063      	strb	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 803048e:	4d0f      	ldr	r5, [pc, #60]	; (80304cc <RegionUS915ComputeRxWindowParameters+0x54>)
 8030490:	0029      	movs	r1, r5
 8030492:	f7fe fe91 	bl	802f1b8 <RegionCommonGetBandwidth>
 8030496:	70a0      	strb	r0, [r4, #2]

    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8030498:	2301      	movs	r3, #1
 803049a:	56e3      	ldrsb	r3, [r4, r3]
 803049c:	009a      	lsls	r2, r3, #2
 803049e:	5951      	ldr	r1, [r2, r5]
 80304a0:	4a0b      	ldr	r2, [pc, #44]	; (80304d0 <RegionUS915ComputeRxWindowParameters+0x58>)
 80304a2:	5cd0      	ldrb	r0, [r2, r3]
 80304a4:	f7fe fd42 	bl	802ef2c <RegionCommonComputeSymbolTimeLoRa>
 80304a8:	0005      	movs	r5, r0

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 80304aa:	4b0a      	ldr	r3, [pc, #40]	; (80304d4 <RegionUS915ComputeRxWindowParameters+0x5c>)
 80304ac:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80304ae:	4798      	blx	r3
 80304b0:	0003      	movs	r3, r0
 80304b2:	0022      	movs	r2, r4
 80304b4:	320c      	adds	r2, #12
 80304b6:	9201      	str	r2, [sp, #4]
 80304b8:	3408      	adds	r4, #8
 80304ba:	9400      	str	r4, [sp, #0]
 80304bc:	003a      	movs	r2, r7
 80304be:	0031      	movs	r1, r6
 80304c0:	0028      	movs	r0, r5
 80304c2:	f7fe fd45 	bl	802ef50 <RegionCommonComputeRxWindowParameters>
#endif /* REGION_US915 */
}
 80304c6:	b003      	add	sp, #12
 80304c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80304ca:	46c0      	nop			; (mov r8, r8)
 80304cc:	08035394 	.word	0x08035394
 80304d0:	080353e8 	.word	0x080353e8
 80304d4:	080356b4 	.word	0x080356b4

080304d8 <RegionUS915RxConfig>:

bool RegionUS915RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 80304d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80304da:	46ce      	mov	lr, r9
 80304dc:	4647      	mov	r7, r8
 80304de:	b580      	push	{r7, lr}
 80304e0:	b08d      	sub	sp, #52	; 0x34
 80304e2:	0004      	movs	r4, r0
 80304e4:	910b      	str	r1, [sp, #44]	; 0x2c
#if defined( REGION_US915 )
    int8_t dr = rxConfig->Datarate;
 80304e6:	2701      	movs	r7, #1
 80304e8:	57c7      	ldrsb	r7, [r0, r7]
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;
 80304ea:	6845      	ldr	r5, [r0, #4]

    if( Radio.GetStatus( ) != RF_IDLE )
 80304ec:	4b24      	ldr	r3, [pc, #144]	; (8030580 <RegionUS915RxConfig+0xa8>)
 80304ee:	685b      	ldr	r3, [r3, #4]
 80304f0:	4798      	blx	r3
 80304f2:	2800      	cmp	r0, #0
 80304f4:	d142      	bne.n	803057c <RegionUS915RxConfig+0xa4>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 80304f6:	7ce3      	ldrb	r3, [r4, #19]
 80304f8:	2b00      	cmp	r3, #0
 80304fa:	d107      	bne.n	803050c <RegionUS915RxConfig+0x34>
    {
        // Apply window 1 frequency
        frequency = US915_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US915_STEPWIDTH_RX1_CHANNEL;
 80304fc:	7823      	ldrb	r3, [r4, #0]
 80304fe:	2507      	movs	r5, #7
 8030500:	402b      	ands	r3, r5
 8030502:	4d20      	ldr	r5, [pc, #128]	; (8030584 <RegionUS915RxConfig+0xac>)
 8030504:	435d      	muls	r5, r3
 8030506:	4b20      	ldr	r3, [pc, #128]	; (8030588 <RegionUS915RxConfig+0xb0>)
 8030508:	469c      	mov	ip, r3
 803050a:	4465      	add	r5, ip
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesUS915[dr];
 803050c:	4b1f      	ldr	r3, [pc, #124]	; (803058c <RegionUS915RxConfig+0xb4>)
 803050e:	57db      	ldrsb	r3, [r3, r7]
 8030510:	4699      	mov	r9, r3

    Radio.SetChannel( frequency );
 8030512:	4e1b      	ldr	r6, [pc, #108]	; (8030580 <RegionUS915RxConfig+0xa8>)
 8030514:	0028      	movs	r0, r5
 8030516:	68f3      	ldr	r3, [r6, #12]
 8030518:	4798      	blx	r3

    // Radio configuration
    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 803051a:	69b3      	ldr	r3, [r6, #24]
 803051c:	4698      	mov	r8, r3
 803051e:	78a1      	ldrb	r1, [r4, #2]
 8030520:	7ca3      	ldrb	r3, [r4, #18]
 8030522:	9309      	str	r3, [sp, #36]	; 0x24
 8030524:	2301      	movs	r3, #1
 8030526:	9308      	str	r3, [sp, #32]
 8030528:	2300      	movs	r3, #0
 803052a:	9307      	str	r3, [sp, #28]
 803052c:	9306      	str	r3, [sp, #24]
 803052e:	9305      	str	r3, [sp, #20]
 8030530:	9304      	str	r3, [sp, #16]
 8030532:	9303      	str	r3, [sp, #12]
 8030534:	8922      	ldrh	r2, [r4, #8]
 8030536:	9202      	str	r2, [sp, #8]
 8030538:	2208      	movs	r2, #8
 803053a:	9201      	str	r2, [sp, #4]
 803053c:	9300      	str	r3, [sp, #0]
 803053e:	3301      	adds	r3, #1
 8030540:	464a      	mov	r2, r9
 8030542:	2001      	movs	r0, #1
 8030544:	47c0      	blx	r8

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 8030546:	7c63      	ldrb	r3, [r4, #17]
 8030548:	2b00      	cmp	r3, #0
 803054a:	d014      	beq.n	8030576 <RegionUS915RxConfig+0x9e>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterUS915[dr];
 803054c:	4b10      	ldr	r3, [pc, #64]	; (8030590 <RegionUS915RxConfig+0xb8>)
 803054e:	5dd9      	ldrb	r1, [r3, r7]
    else
    {
        maxPayload = MaxPayloadOfDatarateUS915[dr];
    }

    Radio.SetMaxPayloadLength( MODEM_LORA, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8030550:	4b0b      	ldr	r3, [pc, #44]	; (8030580 <RegionUS915RxConfig+0xa8>)
 8030552:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8030554:	310d      	adds	r1, #13
 8030556:	b2c9      	uxtb	r1, r1
 8030558:	2001      	movs	r0, #1
 803055a:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 803055c:	7ce0      	ldrb	r0, [r4, #19]
 803055e:	003a      	movs	r2, r7
 8030560:	0029      	movs	r1, r5
 8030562:	f7fe fe3b 	bl	802f1dc <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 8030566:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8030568:	701f      	strb	r7, [r3, #0]
    return true;
 803056a:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 803056c:	b00d      	add	sp, #52	; 0x34
 803056e:	bcc0      	pop	{r6, r7}
 8030570:	46b9      	mov	r9, r7
 8030572:	46b0      	mov	r8, r6
 8030574:	bdf0      	pop	{r4, r5, r6, r7, pc}
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 8030576:	4b07      	ldr	r3, [pc, #28]	; (8030594 <RegionUS915RxConfig+0xbc>)
 8030578:	5dd9      	ldrb	r1, [r3, r7]
 803057a:	e7e9      	b.n	8030550 <RegionUS915RxConfig+0x78>
        return false;
 803057c:	2000      	movs	r0, #0
 803057e:	e7f5      	b.n	803056c <RegionUS915RxConfig+0x94>
 8030580:	080356b4 	.word	0x080356b4
 8030584:	000927c0 	.word	0x000927c0
 8030588:	370870a0 	.word	0x370870a0
 803058c:	080353e8 	.word	0x080353e8
 8030590:	080353f8 	.word	0x080353f8
 8030594:	08035408 	.word	0x08035408

08030598 <RegionUS915TxConfig>:

bool RegionUS915TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8030598:	b5f0      	push	{r4, r5, r6, r7, lr}
 803059a:	46de      	mov	lr, fp
 803059c:	4657      	mov	r7, sl
 803059e:	464e      	mov	r6, r9
 80305a0:	4645      	mov	r5, r8
 80305a2:	b5e0      	push	{r5, r6, r7, lr}
 80305a4:	b08d      	sub	sp, #52	; 0x34
 80305a6:	0004      	movs	r4, r0
 80305a8:	4689      	mov	r9, r1
 80305aa:	920a      	str	r2, [sp, #40]	; 0x28
#if defined( REGION_US915 )
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 80305ac:	2201      	movs	r2, #1
 80305ae:	5682      	ldrsb	r2, [r0, r2]
 80305b0:	4b33      	ldr	r3, [pc, #204]	; (8030680 <RegionUS915TxConfig+0xe8>)
 80305b2:	569b      	ldrsb	r3, [r3, r2]
 80305b4:	469b      	mov	fp, r3
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 80305b6:	4b33      	ldr	r3, [pc, #204]	; (8030684 <RegionUS915TxConfig+0xec>)
 80305b8:	6818      	ldr	r0, [r3, #0]
 80305ba:	4f33      	ldr	r7, [pc, #204]	; (8030688 <RegionUS915TxConfig+0xf0>)
 80305bc:	683b      	ldr	r3, [r7, #0]
 80305be:	7825      	ldrb	r5, [r4, #0]
 80305c0:	0069      	lsls	r1, r5, #1
 80305c2:	1949      	adds	r1, r1, r5
 80305c4:	0089      	lsls	r1, r1, #2
 80305c6:	1859      	adds	r1, r3, r1
 80305c8:	7a4d      	ldrb	r5, [r1, #9]
 80305ca:	21d8      	movs	r1, #216	; 0xd8
 80305cc:	0089      	lsls	r1, r1, #2
 80305ce:	468c      	mov	ip, r1
 80305d0:	4463      	add	r3, ip
 80305d2:	0069      	lsls	r1, r5, #1
 80305d4:	1949      	adds	r1, r1, r5
 80305d6:	00c9      	lsls	r1, r1, #3
 80305d8:	1841      	adds	r1, r0, r1
 80305da:	7889      	ldrb	r1, [r1, #2]
 80305dc:	b249      	sxtb	r1, r1
 80305de:	2002      	movs	r0, #2
 80305e0:	5620      	ldrsb	r0, [r4, r0]
 80305e2:	f7ff fcdb 	bl	802ff9c <LimitTxPower>
 80305e6:	0005      	movs	r5, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 80305e8:	2001      	movs	r0, #1
 80305ea:	5620      	ldrsb	r0, [r4, r0]
 80305ec:	4927      	ldr	r1, [pc, #156]	; (803068c <RegionUS915TxConfig+0xf4>)
 80305ee:	f7fe fde3 	bl	802f1b8 <RegionCommonGetBandwidth>
 80305f2:	4682      	mov	sl, r0
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 80305f4:	2200      	movs	r2, #0
 80305f6:	4926      	ldr	r1, [pc, #152]	; (8030690 <RegionUS915TxConfig+0xf8>)
 80305f8:	950b      	str	r5, [sp, #44]	; 0x2c
 80305fa:	0028      	movs	r0, r5
 80305fc:	f7fe fce6 	bl	802efcc <RegionCommonComputeTxPower>
 8030600:	4680      	mov	r8, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8030602:	4e24      	ldr	r6, [pc, #144]	; (8030694 <RegionUS915TxConfig+0xfc>)
 8030604:	7822      	ldrb	r2, [r4, #0]
 8030606:	0053      	lsls	r3, r2, #1
 8030608:	189b      	adds	r3, r3, r2
 803060a:	009b      	lsls	r3, r3, #2
 803060c:	6839      	ldr	r1, [r7, #0]
 803060e:	5858      	ldr	r0, [r3, r1]
 8030610:	68f3      	ldr	r3, [r6, #12]
 8030612:	4798      	blx	r3

    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 8030614:	23fa      	movs	r3, #250	; 0xfa
 8030616:	011b      	lsls	r3, r3, #4
 8030618:	9308      	str	r3, [sp, #32]
 803061a:	2300      	movs	r3, #0
 803061c:	9307      	str	r3, [sp, #28]
 803061e:	9306      	str	r3, [sp, #24]
 8030620:	9305      	str	r3, [sp, #20]
 8030622:	2201      	movs	r2, #1
 8030624:	9204      	str	r2, [sp, #16]
 8030626:	9303      	str	r3, [sp, #12]
 8030628:	3308      	adds	r3, #8
 803062a:	9302      	str	r3, [sp, #8]
 803062c:	9201      	str	r2, [sp, #4]
 803062e:	465b      	mov	r3, fp
 8030630:	9300      	str	r3, [sp, #0]
 8030632:	4653      	mov	r3, sl
 8030634:	2200      	movs	r2, #0
 8030636:	4641      	mov	r1, r8
 8030638:	2001      	movs	r0, #1
 803063a:	69f5      	ldr	r5, [r6, #28]
 803063c:	47a8      	blx	r5
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 803063e:	6838      	ldr	r0, [r7, #0]
 8030640:	7822      	ldrb	r2, [r4, #0]
 8030642:	2101      	movs	r1, #1
 8030644:	5661      	ldrsb	r1, [r4, r1]
 8030646:	0053      	lsls	r3, r2, #1
 8030648:	189b      	adds	r3, r3, r2
 803064a:	009b      	lsls	r3, r3, #2
 803064c:	5818      	ldr	r0, [r3, r0]
 803064e:	f7fe fded 	bl	802f22c <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
 8030652:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8030654:	7b21      	ldrb	r1, [r4, #12]
 8030656:	2001      	movs	r0, #1
 8030658:	4798      	blx	r3

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 803065a:	89a1      	ldrh	r1, [r4, #12]
 803065c:	2001      	movs	r0, #1
 803065e:	5620      	ldrsb	r0, [r4, r0]
 8030660:	f7ff fc7c 	bl	802ff5c <GetTimeOnAir>
 8030664:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8030666:	6018      	str	r0, [r3, #0]

    *txPower = txPowerLimited;
 8030668:	464b      	mov	r3, r9
 803066a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 803066c:	701a      	strb	r2, [r3, #0]
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 803066e:	2001      	movs	r0, #1
 8030670:	b00d      	add	sp, #52	; 0x34
 8030672:	bcf0      	pop	{r4, r5, r6, r7}
 8030674:	46bb      	mov	fp, r7
 8030676:	46b2      	mov	sl, r6
 8030678:	46a9      	mov	r9, r5
 803067a:	46a0      	mov	r8, r4
 803067c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803067e:	46c0      	nop			; (mov r8, r8)
 8030680:	080353e8 	.word	0x080353e8
 8030684:	2000b1bc 	.word	0x2000b1bc
 8030688:	2000b1c0 	.word	0x2000b1c0
 803068c:	08035394 	.word	0x08035394
 8030690:	41f00000 	.word	0x41f00000
 8030694:	080356b4 	.word	0x080356b4

08030698 <RegionUS915LinkAdrReq>:

uint8_t RegionUS915LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8030698:	b5f0      	push	{r4, r5, r6, r7, lr}
 803069a:	46de      	mov	lr, fp
 803069c:	4657      	mov	r7, sl
 803069e:	464e      	mov	r6, r9
 80306a0:	4645      	mov	r5, r8
 80306a2:	b5e0      	push	{r5, r6, r7, lr}
 80306a4:	b093      	sub	sp, #76	; 0x4c
 80306a6:	0005      	movs	r5, r0
 80306a8:	4688      	mov	r8, r1
 80306aa:	9201      	str	r2, [sp, #4]
 80306ac:	469b      	mov	fp, r3
    uint8_t status = 0x07;
#if defined( REGION_US915 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 80306ae:	2206      	movs	r2, #6
 80306b0:	2100      	movs	r1, #0
 80306b2:	a810      	add	r0, sp, #64	; 0x40
 80306b4:	f004 f837 	bl	8034726 <memset>
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 80306b8:	220c      	movs	r2, #12
 80306ba:	2100      	movs	r1, #0
 80306bc:	a80d      	add	r0, sp, #52	; 0x34
 80306be:	f004 f832 	bl	8034726 <memset>
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    // Initialize local copy of channels mask
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 80306c2:	4b96      	ldr	r3, [pc, #600]	; (803091c <RegionUS915LinkAdrReq+0x284>)
 80306c4:	6819      	ldr	r1, [r3, #0]
 80306c6:	23d8      	movs	r3, #216	; 0xd8
 80306c8:	009b      	lsls	r3, r3, #2
 80306ca:	469c      	mov	ip, r3
 80306cc:	4461      	add	r1, ip
 80306ce:	2206      	movs	r2, #6
 80306d0:	a80d      	add	r0, sp, #52	; 0x34
 80306d2:	f7fe fafc 	bl	802ecce <RegionCommonChanMaskCopy>
    uint8_t bytesProcessed = 0;
 80306d6:	2400      	movs	r4, #0

    while( bytesProcessed < linkAdrReq->PayloadSize )
 80306d8:	e00a      	b.n	80306f0 <RegionUS915LinkAdrReq+0x58>
        status = 0x07;

        if( linkAdrParams.ChMaskCtrl == 6 )
        {
            // Enable all 125 kHz channels
            channelsMask[0] = 0xFFFF;
 80306da:	aa0d      	add	r2, sp, #52	; 0x34
 80306dc:	3b07      	subs	r3, #7
 80306de:	8013      	strh	r3, [r2, #0]
            channelsMask[1] = 0xFFFF;
 80306e0:	8053      	strh	r3, [r2, #2]
            channelsMask[2] = 0xFFFF;
 80306e2:	8093      	strh	r3, [r2, #4]
            channelsMask[3] = 0xFFFF;
 80306e4:	80d3      	strh	r3, [r2, #6]
            // Apply chMask to channels 64 to 71
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 80306e6:	ab10      	add	r3, sp, #64	; 0x40
 80306e8:	8899      	ldrh	r1, [r3, #4]
 80306ea:	23ff      	movs	r3, #255	; 0xff
 80306ec:	400b      	ands	r3, r1
 80306ee:	8113      	strh	r3, [r2, #8]
    while( bytesProcessed < linkAdrReq->PayloadSize )
 80306f0:	7a2b      	ldrb	r3, [r5, #8]
 80306f2:	42a3      	cmp	r3, r4
 80306f4:	d969      	bls.n	80307ca <RegionUS915LinkAdrReq+0x132>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 80306f6:	686b      	ldr	r3, [r5, #4]
 80306f8:	1918      	adds	r0, r3, r4
 80306fa:	a910      	add	r1, sp, #64	; 0x40
 80306fc:	f7fe fba2 	bl	802ee44 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8030700:	2800      	cmp	r0, #0
 8030702:	d062      	beq.n	80307ca <RegionUS915LinkAdrReq+0x132>
        bytesProcessed += nextIndex;
 8030704:	1824      	adds	r4, r4, r0
 8030706:	b2e4      	uxtb	r4, r4
        if( linkAdrParams.ChMaskCtrl == 6 )
 8030708:	ab10      	add	r3, sp, #64	; 0x40
 803070a:	78db      	ldrb	r3, [r3, #3]
 803070c:	2b06      	cmp	r3, #6
 803070e:	d0e4      	beq.n	80306da <RegionUS915LinkAdrReq+0x42>
        }
        else if( linkAdrParams.ChMaskCtrl == 7 )
 8030710:	2b07      	cmp	r3, #7
 8030712:	d007      	beq.n	8030724 <RegionUS915LinkAdrReq+0x8c>
            channelsMask[2] = 0x0000;
            channelsMask[3] = 0x0000;
            // Apply chMask to channels 64 to 71
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
        }
        else if( linkAdrParams.ChMaskCtrl == 5 )
 8030714:	2b05      	cmp	r3, #5
 8030716:	d054      	beq.n	80307c2 <RegionUS915LinkAdrReq+0x12a>
                }
            }
        }
        else
        {
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
 8030718:	aa10      	add	r2, sp, #64	; 0x40
 803071a:	8891      	ldrh	r1, [r2, #4]
 803071c:	005b      	lsls	r3, r3, #1
 803071e:	aa0d      	add	r2, sp, #52	; 0x34
 8030720:	5299      	strh	r1, [r3, r2]
 8030722:	e7e5      	b.n	80306f0 <RegionUS915LinkAdrReq+0x58>
            channelsMask[0] = 0x0000;
 8030724:	ab0d      	add	r3, sp, #52	; 0x34
 8030726:	2200      	movs	r2, #0
 8030728:	801a      	strh	r2, [r3, #0]
            channelsMask[1] = 0x0000;
 803072a:	805a      	strh	r2, [r3, #2]
            channelsMask[2] = 0x0000;
 803072c:	809a      	strh	r2, [r3, #4]
            channelsMask[3] = 0x0000;
 803072e:	80da      	strh	r2, [r3, #6]
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 8030730:	aa10      	add	r2, sp, #64	; 0x40
 8030732:	8891      	ldrh	r1, [r2, #4]
 8030734:	22ff      	movs	r2, #255	; 0xff
 8030736:	400a      	ands	r2, r1
 8030738:	811a      	strh	r2, [r3, #8]
 803073a:	e7d9      	b.n	80306f0 <RegionUS915LinkAdrReq+0x58>
                        channelsMask[cntChannelMask] |= 0xFF00;
 803073c:	a90d      	add	r1, sp, #52	; 0x34
 803073e:	4648      	mov	r0, r9
 8030740:	0046      	lsls	r6, r0, #1
 8030742:	5a77      	ldrh	r7, [r6, r1]
 8030744:	4876      	ldr	r0, [pc, #472]	; (8030920 <RegionUS915LinkAdrReq+0x288>)
 8030746:	4307      	orrs	r7, r0
 8030748:	5277      	strh	r7, [r6, r1]
                        channelsMask[4] |= ( bitMask << i );
 803074a:	890e      	ldrh	r6, [r1, #8]
 803074c:	4332      	orrs	r2, r6
 803074e:	810a      	strh	r2, [r1, #8]
                        cntChannelMask++;
 8030750:	4648      	mov	r0, r9
 8030752:	3001      	adds	r0, #1
 8030754:	b2c2      	uxtb	r2, r0
 8030756:	4691      	mov	r9, r2
            for( uint8_t i = 0; i <= 7; i++ )
 8030758:	3301      	adds	r3, #1
 803075a:	b2db      	uxtb	r3, r3
 803075c:	2b07      	cmp	r3, #7
 803075e:	d8c7      	bhi.n	80306f0 <RegionUS915LinkAdrReq+0x58>
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 8030760:	aa10      	add	r2, sp, #64	; 0x40
 8030762:	8892      	ldrh	r2, [r2, #4]
 8030764:	21ff      	movs	r1, #255	; 0xff
 8030766:	4011      	ands	r1, r2
 8030768:	2201      	movs	r2, #1
 803076a:	409a      	lsls	r2, r3
 803076c:	420a      	tst	r2, r1
 803076e:	d00c      	beq.n	803078a <RegionUS915LinkAdrReq+0xf2>
                    if( ( i % 2 ) == 0 )
 8030770:	07d9      	lsls	r1, r3, #31
 8030772:	d4e3      	bmi.n	803073c <RegionUS915LinkAdrReq+0xa4>
                        channelsMask[cntChannelMask] |= 0x00FF;
 8030774:	a90d      	add	r1, sp, #52	; 0x34
 8030776:	4648      	mov	r0, r9
 8030778:	0046      	lsls	r6, r0, #1
 803077a:	5a70      	ldrh	r0, [r6, r1]
 803077c:	27ff      	movs	r7, #255	; 0xff
 803077e:	4307      	orrs	r7, r0
 8030780:	5277      	strh	r7, [r6, r1]
                        channelsMask[4] |= ( bitMask << i );
 8030782:	890e      	ldrh	r6, [r1, #8]
 8030784:	4332      	orrs	r2, r6
 8030786:	810a      	strh	r2, [r1, #8]
 8030788:	e7e6      	b.n	8030758 <RegionUS915LinkAdrReq+0xc0>
                    if( ( i % 2 ) == 0 )
 803078a:	07d9      	lsls	r1, r3, #31
 803078c:	d40a      	bmi.n	80307a4 <RegionUS915LinkAdrReq+0x10c>
                        channelsMask[cntChannelMask] &= 0xFF00;
 803078e:	a90d      	add	r1, sp, #52	; 0x34
 8030790:	4648      	mov	r0, r9
 8030792:	0046      	lsls	r6, r0, #1
 8030794:	5a77      	ldrh	r7, [r6, r1]
 8030796:	20ff      	movs	r0, #255	; 0xff
 8030798:	4387      	bics	r7, r0
 803079a:	5277      	strh	r7, [r6, r1]
                        channelsMask[4] &= ~( bitMask << i );
 803079c:	890e      	ldrh	r6, [r1, #8]
 803079e:	4396      	bics	r6, r2
 80307a0:	810e      	strh	r6, [r1, #8]
 80307a2:	e7d9      	b.n	8030758 <RegionUS915LinkAdrReq+0xc0>
                        channelsMask[cntChannelMask] &= 0x00FF;
 80307a4:	a90d      	add	r1, sp, #52	; 0x34
 80307a6:	4648      	mov	r0, r9
 80307a8:	0046      	lsls	r6, r0, #1
 80307aa:	5a77      	ldrh	r7, [r6, r1]
 80307ac:	20ff      	movs	r0, #255	; 0xff
 80307ae:	4038      	ands	r0, r7
 80307b0:	5270      	strh	r0, [r6, r1]
                        channelsMask[4] &= ~( bitMask << i );
 80307b2:	890e      	ldrh	r6, [r1, #8]
 80307b4:	4396      	bics	r6, r2
 80307b6:	810e      	strh	r6, [r1, #8]
                        cntChannelMask++;
 80307b8:	4648      	mov	r0, r9
 80307ba:	3001      	adds	r0, #1
 80307bc:	b2c2      	uxtb	r2, r0
 80307be:	4691      	mov	r9, r2
 80307c0:	e7ca      	b.n	8030758 <RegionUS915LinkAdrReq+0xc0>
            for( uint8_t i = 0; i <= 7; i++ )
 80307c2:	2300      	movs	r3, #0
            uint8_t cntChannelMask = 0;
 80307c4:	2200      	movs	r2, #0
 80307c6:	4691      	mov	r9, r2
 80307c8:	e7c8      	b.n	803075c <RegionUS915LinkAdrReq+0xc4>
        }
    }

    // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 80307ca:	ab10      	add	r3, sp, #64	; 0x40
 80307cc:	785b      	ldrb	r3, [r3, #1]
 80307ce:	b25b      	sxtb	r3, r3
 80307d0:	2b03      	cmp	r3, #3
 80307d2:	dd5a      	ble.n	803088a <RegionUS915LinkAdrReq+0x1f2>
 80307d4:	2307      	movs	r3, #7
 80307d6:	4699      	mov	r9, r3
    {
        status &= 0xFE; // Channel mask KO
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 80307d8:	2302      	movs	r3, #2
 80307da:	aa02      	add	r2, sp, #8
 80307dc:	2124      	movs	r1, #36	; 0x24
 80307de:	1852      	adds	r2, r2, r1
 80307e0:	7013      	strb	r3, [r2, #0]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 80307e2:	7a6b      	ldrb	r3, [r5, #9]
 80307e4:	aa02      	add	r2, sp, #8
 80307e6:	3102      	adds	r1, #2
 80307e8:	1852      	adds	r2, r2, r1
 80307ea:	7013      	strb	r3, [r2, #0]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 80307ec:	a80b      	add	r0, sp, #44	; 0x2c
 80307ee:	f7ff fbf3 	bl	802ffd8 <RegionUS915GetPhyParam>
 80307f2:	900a      	str	r0, [sp, #40]	; 0x28

    linkAdrVerifyParams.Status = status;
 80307f4:	ab02      	add	r3, sp, #8
 80307f6:	464a      	mov	r2, r9
 80307f8:	711a      	strb	r2, [r3, #4]
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 80307fa:	7aab      	ldrb	r3, [r5, #10]
 80307fc:	aa02      	add	r2, sp, #8
 80307fe:	7153      	strb	r3, [r2, #5]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8030800:	ab10      	add	r3, sp, #64	; 0x40
 8030802:	2201      	movs	r2, #1
 8030804:	569a      	ldrsb	r2, [r3, r2]
 8030806:	a902      	add	r1, sp, #8
 8030808:	718a      	strb	r2, [r1, #6]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 803080a:	2202      	movs	r2, #2
 803080c:	569a      	ldrsb	r2, [r3, r2]
 803080e:	71ca      	strb	r2, [r1, #7]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 8030810:	781a      	ldrb	r2, [r3, #0]
 8030812:	720a      	strb	r2, [r1, #8]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 8030814:	220b      	movs	r2, #11
 8030816:	56aa      	ldrsb	r2, [r5, r2]
 8030818:	724a      	strb	r2, [r1, #9]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 803081a:	220c      	movs	r2, #12
 803081c:	56aa      	ldrsb	r2, [r5, r2]
 803081e:	728a      	strb	r2, [r1, #10]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 8030820:	220d      	movs	r2, #13
 8030822:	56aa      	ldrsb	r2, [r5, r2]
 8030824:	72ca      	strb	r2, [r1, #11]
    linkAdrVerifyParams.NbChannels = US915_MAX_NB_CHANNELS;
 8030826:	2248      	movs	r2, #72	; 0x48
 8030828:	730a      	strb	r2, [r1, #12]
    linkAdrVerifyParams.ChannelsMask = channelsMask;
 803082a:	aa0d      	add	r2, sp, #52	; 0x34
 803082c:	9206      	str	r2, [sp, #24]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 803082e:	7508      	strb	r0, [r1, #20]
    linkAdrVerifyParams.MaxDatarate = US915_TX_MAX_DATARATE;
 8030830:	2204      	movs	r2, #4
 8030832:	754a      	strb	r2, [r1, #21]
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8030834:	4a39      	ldr	r2, [pc, #228]	; (803091c <RegionUS915LinkAdrReq+0x284>)
 8030836:	6812      	ldr	r2, [r2, #0]
 8030838:	9200      	str	r2, [sp, #0]
 803083a:	9208      	str	r2, [sp, #32]
    linkAdrVerifyParams.MinTxPower = US915_MIN_TX_POWER;
 803083c:	220e      	movs	r2, #14
 803083e:	770a      	strb	r2, [r1, #28]
    linkAdrVerifyParams.MaxTxPower = US915_MAX_TX_POWER;
 8030840:	2200      	movs	r2, #0
 8030842:	774a      	strb	r2, [r1, #29]
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 8030844:	682a      	ldr	r2, [r5, #0]
 8030846:	9202      	str	r2, [sp, #8]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8030848:	223a      	movs	r2, #58	; 0x3a
 803084a:	468c      	mov	ip, r1
 803084c:	4462      	add	r2, ip
 803084e:	2139      	movs	r1, #57	; 0x39
 8030850:	4660      	mov	r0, ip
 8030852:	4461      	add	r1, ip
 8030854:	f7fe fb13 	bl	802ee7e <RegionCommonLinkAdrReqVerifyParams>
 8030858:	0005      	movs	r5, r0

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 803085a:	2807      	cmp	r0, #7
 803085c:	d022      	beq.n	80308a4 <RegionUS915LinkAdrReq+0x20c>
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 803085e:	ab10      	add	r3, sp, #64	; 0x40
 8030860:	2201      	movs	r2, #1
 8030862:	569a      	ldrsb	r2, [r3, r2]
 8030864:	4641      	mov	r1, r8
 8030866:	700a      	strb	r2, [r1, #0]
    *txPowOut = linkAdrParams.TxPower;
 8030868:	2202      	movs	r2, #2
 803086a:	569a      	ldrsb	r2, [r3, r2]
 803086c:	9901      	ldr	r1, [sp, #4]
 803086e:	700a      	strb	r2, [r1, #0]
    *nbRepOut = linkAdrParams.NbRep;
 8030870:	781b      	ldrb	r3, [r3, #0]
 8030872:	465a      	mov	r2, fp
 8030874:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 8030876:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8030878:	701c      	strb	r4, [r3, #0]

#endif /* REGION_US915 */
    return status;
}
 803087a:	0028      	movs	r0, r5
 803087c:	b013      	add	sp, #76	; 0x4c
 803087e:	bcf0      	pop	{r4, r5, r6, r7}
 8030880:	46bb      	mov	fp, r7
 8030882:	46b2      	mov	sl, r6
 8030884:	46a9      	mov	r9, r5
 8030886:	46a0      	mov	r8, r4
 8030888:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 803088a:	2204      	movs	r2, #4
 803088c:	2100      	movs	r1, #0
 803088e:	a80d      	add	r0, sp, #52	; 0x34
 8030890:	f7fe fa06 	bl	802eca0 <RegionCommonCountChannels>
 8030894:	2801      	cmp	r0, #1
 8030896:	d902      	bls.n	803089e <RegionUS915LinkAdrReq+0x206>
 8030898:	2307      	movs	r3, #7
 803089a:	4699      	mov	r9, r3
 803089c:	e79c      	b.n	80307d8 <RegionUS915LinkAdrReq+0x140>
        status &= 0xFE; // Channel mask KO
 803089e:	2306      	movs	r3, #6
 80308a0:	4699      	mov	r9, r3
 80308a2:	e799      	b.n	80307d8 <RegionUS915LinkAdrReq+0x140>
        RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
 80308a4:	4b1d      	ldr	r3, [pc, #116]	; (803091c <RegionUS915LinkAdrReq+0x284>)
 80308a6:	4699      	mov	r9, r3
 80308a8:	681b      	ldr	r3, [r3, #0]
 80308aa:	22d8      	movs	r2, #216	; 0xd8
 80308ac:	0092      	lsls	r2, r2, #2
 80308ae:	4694      	mov	ip, r2
 80308b0:	4463      	add	r3, ip
 80308b2:	0018      	movs	r0, r3
 80308b4:	2206      	movs	r2, #6
 80308b6:	a90d      	add	r1, sp, #52	; 0x34
 80308b8:	f7fe fa09 	bl	802ecce <RegionCommonChanMaskCopy>
        RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
 80308bc:	4b19      	ldr	r3, [pc, #100]	; (8030924 <RegionUS915LinkAdrReq+0x28c>)
 80308be:	681b      	ldr	r3, [r3, #0]
 80308c0:	464a      	mov	r2, r9
 80308c2:	6812      	ldr	r2, [r2, #0]
 80308c4:	21d8      	movs	r1, #216	; 0xd8
 80308c6:	0089      	lsls	r1, r1, #2
 80308c8:	5a51      	ldrh	r1, [r2, r1]
 80308ca:	468c      	mov	ip, r1
 80308cc:	2090      	movs	r0, #144	; 0x90
 80308ce:	5a19      	ldrh	r1, [r3, r0]
 80308d0:	4666      	mov	r6, ip
 80308d2:	4031      	ands	r1, r6
 80308d4:	5219      	strh	r1, [r3, r0]
        RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
 80308d6:	4914      	ldr	r1, [pc, #80]	; (8030928 <RegionUS915LinkAdrReq+0x290>)
 80308d8:	5a51      	ldrh	r1, [r2, r1]
 80308da:	468c      	mov	ip, r1
 80308dc:	3002      	adds	r0, #2
 80308de:	5a19      	ldrh	r1, [r3, r0]
 80308e0:	4666      	mov	r6, ip
 80308e2:	4031      	ands	r1, r6
 80308e4:	5219      	strh	r1, [r3, r0]
        RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
 80308e6:	21d9      	movs	r1, #217	; 0xd9
 80308e8:	0089      	lsls	r1, r1, #2
 80308ea:	5a51      	ldrh	r1, [r2, r1]
 80308ec:	468c      	mov	ip, r1
 80308ee:	3002      	adds	r0, #2
 80308f0:	5a19      	ldrh	r1, [r3, r0]
 80308f2:	4666      	mov	r6, ip
 80308f4:	4031      	ands	r1, r6
 80308f6:	5219      	strh	r1, [r3, r0]
        RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
 80308f8:	490c      	ldr	r1, [pc, #48]	; (803092c <RegionUS915LinkAdrReq+0x294>)
 80308fa:	5a51      	ldrh	r1, [r2, r1]
 80308fc:	468c      	mov	ip, r1
 80308fe:	3002      	adds	r0, #2
 8030900:	5a19      	ldrh	r1, [r3, r0]
 8030902:	4666      	mov	r6, ip
 8030904:	4031      	ands	r1, r6
 8030906:	5219      	strh	r1, [r3, r0]
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8030908:	21da      	movs	r1, #218	; 0xda
 803090a:	0089      	lsls	r1, r1, #2
 803090c:	5a50      	ldrh	r0, [r2, r1]
 803090e:	2198      	movs	r1, #152	; 0x98
 8030910:	5258      	strh	r0, [r3, r1]
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 8030912:	4907      	ldr	r1, [pc, #28]	; (8030930 <RegionUS915LinkAdrReq+0x298>)
 8030914:	5a51      	ldrh	r1, [r2, r1]
 8030916:	229a      	movs	r2, #154	; 0x9a
 8030918:	5299      	strh	r1, [r3, r2]
 803091a:	e7a0      	b.n	803085e <RegionUS915LinkAdrReq+0x1c6>
 803091c:	2000b1c0 	.word	0x2000b1c0
 8030920:	ffffff00 	.word	0xffffff00
 8030924:	2000b1bc 	.word	0x2000b1bc
 8030928:	00000362 	.word	0x00000362
 803092c:	00000366 	.word	0x00000366
 8030930:	0000036a 	.word	0x0000036a

08030934 <RegionUS915RxParamSetupReq>:

uint8_t RegionUS915RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 8030934:	b570      	push	{r4, r5, r6, lr}
 8030936:	0004      	movs	r4, r0
    uint8_t status = 0x07;
#if defined( REGION_US915 )

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
 8030938:	6840      	ldr	r0, [r0, #4]
 803093a:	f7ff fae5 	bl	802ff08 <VerifyRfFreq>
 803093e:	2800      	cmp	r0, #0
 8030940:	d024      	beq.n	803098c <RegionUS915RxParamSetupReq+0x58>
    uint8_t status = 0x07;
 8030942:	2507      	movs	r5, #7
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 8030944:	2000      	movs	r0, #0
 8030946:	5620      	ldrsb	r0, [r4, r0]
 8030948:	220d      	movs	r2, #13
 803094a:	2108      	movs	r1, #8
 803094c:	f7fe f945 	bl	802ebda <RegionCommonValueInRange>
 8030950:	2800      	cmp	r0, #0
 8030952:	d101      	bne.n	8030958 <RegionUS915RxParamSetupReq+0x24>
    {
        status &= 0xFD; // Datarate KO
 8030954:	2302      	movs	r3, #2
 8030956:	439d      	bics	r5, r3
    }
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 8030958:	2000      	movs	r0, #0
 803095a:	5620      	ldrsb	r0, [r4, r0]
 803095c:	2207      	movs	r2, #7
 803095e:	2105      	movs	r1, #5
 8030960:	f7fe f93b 	bl	802ebda <RegionCommonValueInRange>
 8030964:	2801      	cmp	r0, #1
 8030966:	d003      	beq.n	8030970 <RegionUS915RxParamSetupReq+0x3c>
        ( rxParamSetupReq->Datarate > DR_13 ) )
 8030968:	2300      	movs	r3, #0
 803096a:	56e3      	ldrsb	r3, [r4, r3]
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 803096c:	2b0d      	cmp	r3, #13
 803096e:	dd01      	ble.n	8030974 <RegionUS915RxParamSetupReq+0x40>
    {
        status &= 0xFD; // Datarate KO
 8030970:	2302      	movs	r3, #2
 8030972:	439d      	bics	r5, r3
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, US915_MIN_RX1_DR_OFFSET, US915_MAX_RX1_DR_OFFSET ) == false )
 8030974:	2001      	movs	r0, #1
 8030976:	5620      	ldrsb	r0, [r4, r0]
 8030978:	2203      	movs	r2, #3
 803097a:	2100      	movs	r1, #0
 803097c:	f7fe f92d 	bl	802ebda <RegionCommonValueInRange>
 8030980:	2800      	cmp	r0, #0
 8030982:	d101      	bne.n	8030988 <RegionUS915RxParamSetupReq+0x54>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 8030984:	2304      	movs	r3, #4
 8030986:	439d      	bics	r5, r3
    }

#endif /* REGION_US915 */
    return status;
}
 8030988:	0028      	movs	r0, r5
 803098a:	bd70      	pop	{r4, r5, r6, pc}
        status &= 0xFE; // Channel frequency KO
 803098c:	2506      	movs	r5, #6
 803098e:	e7d9      	b.n	8030944 <RegionUS915RxParamSetupReq+0x10>

08030990 <RegionUS915NewChannelReq>:

int8_t RegionUS915NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
    // Do not accept the request
    return -1;
 8030990:	2001      	movs	r0, #1
}
 8030992:	4240      	negs	r0, r0
 8030994:	4770      	bx	lr

08030996 <RegionUS915TxParamSetupReq>:

int8_t RegionUS915TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
 8030996:	2001      	movs	r0, #1
}
 8030998:	4240      	negs	r0, r0
 803099a:	4770      	bx	lr

0803099c <RegionUS915DlChannelReq>:

int8_t RegionUS915DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
    // Do not accept the request
    return -1;
 803099c:	2001      	movs	r0, #1
}
 803099e:	4240      	negs	r0, r0
 80309a0:	4770      	bx	lr
	...

080309a4 <RegionUS915AlternateDr>:

int8_t RegionUS915AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
 80309a4:	b510      	push	{r4, lr}
#if defined( REGION_US915 )
    // Alternates the data rate according to the channel sequence:
    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
    if( type == ALTERNATE_DR )
 80309a6:	2900      	cmp	r1, #0
 80309a8:	d111      	bne.n	80309ce <RegionUS915AlternateDr+0x2a>
    {
        RegionNvmGroup1->JoinTrialsCounter++;
 80309aa:	4b0d      	ldr	r3, [pc, #52]	; (80309e0 <RegionUS915AlternateDr+0x3c>)
 80309ac:	6819      	ldr	r1, [r3, #0]
 80309ae:	229d      	movs	r2, #157	; 0x9d
 80309b0:	5c8b      	ldrb	r3, [r1, r2]
 80309b2:	3301      	adds	r3, #1
 80309b4:	548b      	strb	r3, [r1, r2]
    else
    {
        RegionNvmGroup1->JoinTrialsCounter--;
    }

    if( RegionNvmGroup1->JoinTrialsCounter % 9 == 0 )
 80309b6:	4b0a      	ldr	r3, [pc, #40]	; (80309e0 <RegionUS915AlternateDr+0x3c>)
 80309b8:	681a      	ldr	r2, [r3, #0]
 80309ba:	239d      	movs	r3, #157	; 0x9d
 80309bc:	5cd0      	ldrb	r0, [r2, r3]
 80309be:	2109      	movs	r1, #9
 80309c0:	f7ef fc30 	bl	8020224 <__aeabi_uidivmod>
 80309c4:	b2c9      	uxtb	r1, r1
 80309c6:	2900      	cmp	r1, #0
 80309c8:	d008      	beq.n	80309dc <RegionUS915AlternateDr+0x38>
        // Use DR_4 every 9th times.
        currentDr = DR_4;
    }
    else
    {
        currentDr = DR_0;
 80309ca:	2000      	movs	r0, #0
    }
    return currentDr;
#else
    return -1;
#endif /* REGION_US915 */
}
 80309cc:	bd10      	pop	{r4, pc}
        RegionNvmGroup1->JoinTrialsCounter--;
 80309ce:	4b04      	ldr	r3, [pc, #16]	; (80309e0 <RegionUS915AlternateDr+0x3c>)
 80309d0:	6819      	ldr	r1, [r3, #0]
 80309d2:	229d      	movs	r2, #157	; 0x9d
 80309d4:	5c8b      	ldrb	r3, [r1, r2]
 80309d6:	3b01      	subs	r3, #1
 80309d8:	548b      	strb	r3, [r1, r2]
 80309da:	e7ec      	b.n	80309b6 <RegionUS915AlternateDr+0x12>
        currentDr = DR_4;
 80309dc:	2004      	movs	r0, #4
 80309de:	e7f5      	b.n	80309cc <RegionUS915AlternateDr+0x28>
 80309e0:	2000b1bc 	.word	0x2000b1bc

080309e4 <RegionUS915NextChannel>:

LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 80309e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80309e6:	46ce      	mov	lr, r9
 80309e8:	4647      	mov	r7, r8
 80309ea:	b580      	push	{r7, lr}
 80309ec:	b0a5      	sub	sp, #148	; 0x94
 80309ee:	0004      	movs	r4, r0
 80309f0:	000d      	movs	r5, r1
 80309f2:	4691      	mov	r9, r2
 80309f4:	4698      	mov	r8, r3
#if defined( REGION_US915 )
    uint8_t nbEnabledChannels = 0;
 80309f6:	2300      	movs	r3, #0
 80309f8:	228f      	movs	r2, #143	; 0x8f
 80309fa:	446a      	add	r2, sp
 80309fc:	7013      	strb	r3, [r2, #0]
    uint8_t nbRestrictedChannels = 0;
 80309fe:	228e      	movs	r2, #142	; 0x8e
 8030a00:	446a      	add	r2, sp
 8030a02:	7013      	strb	r3, [r2, #0]
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 8030a04:	9311      	str	r3, [sp, #68]	; 0x44
 8030a06:	2244      	movs	r2, #68	; 0x44
 8030a08:	2100      	movs	r1, #0
 8030a0a:	a812      	add	r0, sp, #72	; 0x48
 8030a0c:	f003 fe8b 	bl	8034726 <memset>
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;

    // Count 125kHz channels
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 8030a10:	4b4d      	ldr	r3, [pc, #308]	; (8030b48 <RegionUS915NextChannel+0x164>)
 8030a12:	6818      	ldr	r0, [r3, #0]
 8030a14:	3090      	adds	r0, #144	; 0x90
 8030a16:	2204      	movs	r2, #4
 8030a18:	2100      	movs	r1, #0
 8030a1a:	f7fe f941 	bl	802eca0 <RegionCommonCountChannels>
 8030a1e:	2800      	cmp	r0, #0
 8030a20:	d05b      	beq.n	8030ada <RegionUS915NextChannel+0xf6>
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );

        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
    }
    // Check other channels
    if( nextChanParams->Datarate >= DR_4 )
 8030a22:	2308      	movs	r3, #8
 8030a24:	56e3      	ldrsb	r3, [r4, r3]
 8030a26:	2b03      	cmp	r3, #3
 8030a28:	dd0d      	ble.n	8030a46 <RegionUS915NextChannel+0x62>
    {
        if( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) == 0 )
 8030a2a:	4b47      	ldr	r3, [pc, #284]	; (8030b48 <RegionUS915NextChannel+0x164>)
 8030a2c:	681b      	ldr	r3, [r3, #0]
 8030a2e:	2298      	movs	r2, #152	; 0x98
 8030a30:	5a9a      	ldrh	r2, [r3, r2]
 8030a32:	21ff      	movs	r1, #255	; 0xff
 8030a34:	4211      	tst	r1, r2
 8030a36:	d106      	bne.n	8030a46 <RegionUS915NextChannel+0x62>
        {
            RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8030a38:	4a44      	ldr	r2, [pc, #272]	; (8030b4c <RegionUS915NextChannel+0x168>)
 8030a3a:	6811      	ldr	r1, [r2, #0]
 8030a3c:	22da      	movs	r2, #218	; 0xda
 8030a3e:	0092      	lsls	r2, r2, #2
 8030a40:	5a89      	ldrh	r1, [r1, r2]
 8030a42:	2298      	movs	r2, #152	; 0x98
 8030a44:	5299      	strh	r1, [r3, r2]
        }
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 8030a46:	7a63      	ldrb	r3, [r4, #9]
 8030a48:	ae03      	add	r6, sp, #12
 8030a4a:	7033      	strb	r3, [r6, #0]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 8030a4c:	7a23      	ldrb	r3, [r4, #8]
 8030a4e:	7073      	strb	r3, [r6, #1]
    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
 8030a50:	4b3d      	ldr	r3, [pc, #244]	; (8030b48 <RegionUS915NextChannel+0x164>)
 8030a52:	681b      	ldr	r3, [r3, #0]
 8030a54:	001a      	movs	r2, r3
 8030a56:	3290      	adds	r2, #144	; 0x90
 8030a58:	9204      	str	r2, [sp, #16]
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8030a5a:	4a3c      	ldr	r2, [pc, #240]	; (8030b4c <RegionUS915NextChannel+0x168>)
 8030a5c:	6812      	ldr	r2, [r2, #0]
 8030a5e:	9205      	str	r2, [sp, #20]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 8030a60:	9306      	str	r3, [sp, #24]
    countChannelsParams.MaxNbChannels = US915_MAX_NB_CHANNELS;
 8030a62:	2348      	movs	r3, #72	; 0x48
 8030a64:	8233      	strh	r3, [r6, #16]
    countChannelsParams.JoinChannels = NULL;
 8030a66:	2300      	movs	r3, #0
 8030a68:	9308      	str	r3, [sp, #32]

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 8030a6a:	af09      	add	r7, sp, #36	; 0x24
 8030a6c:	6823      	ldr	r3, [r4, #0]
 8030a6e:	9309      	str	r3, [sp, #36]	; 0x24
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 8030a70:	6863      	ldr	r3, [r4, #4]
 8030a72:	930a      	str	r3, [sp, #40]	; 0x28
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 8030a74:	7aa3      	ldrb	r3, [r4, #10]
 8030a76:	723b      	strb	r3, [r7, #8]
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;
 8030a78:	2301      	movs	r3, #1
 8030a7a:	727b      	strb	r3, [r7, #9]

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 8030a7c:	a90c      	add	r1, sp, #48	; 0x30
 8030a7e:	0020      	movs	r0, r4
 8030a80:	300c      	adds	r0, #12
 8030a82:	c80c      	ldmia	r0!, {r2, r3}
 8030a84:	c10c      	stmia	r1!, {r2, r3}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8030a86:	7d23      	ldrb	r3, [r4, #20]
 8030a88:	753b      	strb	r3, [r7, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 8030a8a:	8ae1      	ldrh	r1, [r4, #22]
 8030a8c:	2008      	movs	r0, #8
 8030a8e:	5620      	ldrsb	r0, [r4, r0]
 8030a90:	f7ff fa64 	bl	802ff5c <GetTimeOnAir>
 8030a94:	61b8      	str	r0, [r7, #24]

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 8030a96:	61fe      	str	r6, [r7, #28]

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8030a98:	464b      	mov	r3, r9
 8030a9a:	9301      	str	r3, [sp, #4]
 8030a9c:	238e      	movs	r3, #142	; 0x8e
 8030a9e:	446b      	add	r3, sp
 8030aa0:	9300      	str	r3, [sp, #0]
 8030aa2:	238f      	movs	r3, #143	; 0x8f
 8030aa4:	446b      	add	r3, sp
 8030aa6:	aa11      	add	r2, sp, #68	; 0x44
 8030aa8:	4641      	mov	r1, r8
 8030aaa:	0038      	movs	r0, r7
 8030aac:	f7fe fb11 	bl	802f0d2 <RegionCommonIdentifyChannels>
 8030ab0:	1e06      	subs	r6, r0, #0
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 8030ab2:	d143      	bne.n	8030b3c <RegionUS915NextChannel+0x158>
    {
        if( nextChanParams->Joined == true )
 8030ab4:	7a63      	ldrb	r3, [r4, #9]
 8030ab6:	2b00      	cmp	r3, #0
 8030ab8:	d120      	bne.n	8030afc <RegionUS915NextChannel+0x118>
            // follow a random channel selection sequence. It probes alternating one out of a
            // group of eight 125 kHz channels followed by probing one 500 kHz channel each pass.
            // Each time a 125 kHz channel will be selected from another group.

            // 125kHz Channels (0 - 63) DR0
            if( nextChanParams->Datarate == DR_0 )
 8030aba:	2308      	movs	r3, #8
 8030abc:	56e3      	ldrsb	r3, [r4, r3]
 8030abe:	2b00      	cmp	r3, #0
 8030ac0:	d027      	beq.n	8030b12 <RegionUS915NextChannel+0x12e>
            // 500kHz Channels (64 - 71) DR4
            else
            {
                // Choose the next available channel
                uint8_t i = 0;
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
 8030ac2:	4b21      	ldr	r3, [pc, #132]	; (8030b48 <RegionUS915NextChannel+0x164>)
 8030ac4:	681a      	ldr	r2, [r3, #0]
 8030ac6:	2398      	movs	r3, #152	; 0x98
 8030ac8:	5ad2      	ldrh	r2, [r2, r3]
 8030aca:	3367      	adds	r3, #103	; 0x67
 8030acc:	4013      	ands	r3, r2
 8030ace:	4103      	asrs	r3, r0
 8030ad0:	07db      	lsls	r3, r3, #31
 8030ad2:	d42a      	bmi.n	8030b2a <RegionUS915NextChannel+0x146>
                {
                    i++;
 8030ad4:	3001      	adds	r0, #1
 8030ad6:	b2c0      	uxtb	r0, r0
 8030ad8:	e7f3      	b.n	8030ac2 <RegionUS915NextChannel+0xde>
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
 8030ada:	4e1b      	ldr	r6, [pc, #108]	; (8030b48 <RegionUS915NextChannel+0x164>)
 8030adc:	6830      	ldr	r0, [r6, #0]
 8030ade:	3090      	adds	r0, #144	; 0x90
 8030ae0:	4b1a      	ldr	r3, [pc, #104]	; (8030b4c <RegionUS915NextChannel+0x168>)
 8030ae2:	6819      	ldr	r1, [r3, #0]
 8030ae4:	23d8      	movs	r3, #216	; 0xd8
 8030ae6:	009b      	lsls	r3, r3, #2
 8030ae8:	469c      	mov	ip, r3
 8030aea:	4461      	add	r1, ip
 8030aec:	2204      	movs	r2, #4
 8030aee:	f7fe f8ee 	bl	802ecce <RegionCommonChanMaskCopy>
        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8030af2:	6832      	ldr	r2, [r6, #0]
 8030af4:	239c      	movs	r3, #156	; 0x9c
 8030af6:	2100      	movs	r1, #0
 8030af8:	54d1      	strb	r1, [r2, r3]
 8030afa:	e792      	b.n	8030a22 <RegionUS915NextChannel+0x3e>
            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 8030afc:	238f      	movs	r3, #143	; 0x8f
 8030afe:	446b      	add	r3, sp
 8030b00:	7819      	ldrb	r1, [r3, #0]
 8030b02:	3901      	subs	r1, #1
 8030b04:	2000      	movs	r0, #0
 8030b06:	f000 fe3d 	bl	8031784 <randr>
 8030b0a:	ab11      	add	r3, sp, #68	; 0x44
 8030b0c:	5c1b      	ldrb	r3, [r3, r0]
 8030b0e:	702b      	strb	r3, [r5, #0]
 8030b10:	e00d      	b.n	8030b2e <RegionUS915NextChannel+0x14a>
                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
 8030b12:	4b0d      	ldr	r3, [pc, #52]	; (8030b48 <RegionUS915NextChannel+0x164>)
 8030b14:	6819      	ldr	r1, [r3, #0]
 8030b16:	0008      	movs	r0, r1
 8030b18:	3090      	adds	r0, #144	; 0x90
 8030b1a:	319c      	adds	r1, #156	; 0x9c
 8030b1c:	002a      	movs	r2, r5
 8030b1e:	f7fd ff33 	bl	802e988 <RegionBaseUSComputeNext125kHzJoinChannel>
 8030b22:	2803      	cmp	r0, #3
 8030b24:	d103      	bne.n	8030b2e <RegionUS915NextChannel+0x14a>
                    return LORAMAC_STATUS_PARAMETER_INVALID;
 8030b26:	0006      	movs	r6, r0
 8030b28:	e008      	b.n	8030b3c <RegionUS915NextChannel+0x158>
                }
                *channel = 64 + i;
 8030b2a:	3040      	adds	r0, #64	; 0x40
 8030b2c:	7028      	strb	r0, [r5, #0]
            }
        }

        // Disable the channel in the mask
        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, US915_MAX_NB_CHANNELS );
 8030b2e:	4b06      	ldr	r3, [pc, #24]	; (8030b48 <RegionUS915NextChannel+0x164>)
 8030b30:	6818      	ldr	r0, [r3, #0]
 8030b32:	3090      	adds	r0, #144	; 0x90
 8030b34:	7829      	ldrb	r1, [r5, #0]
 8030b36:	2248      	movs	r2, #72	; 0x48
 8030b38:	f7fe f89d 	bl	802ec76 <RegionCommonChanDisable>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_US915 */
}
 8030b3c:	0030      	movs	r0, r6
 8030b3e:	b025      	add	sp, #148	; 0x94
 8030b40:	bcc0      	pop	{r6, r7}
 8030b42:	46b9      	mov	r9, r7
 8030b44:	46b0      	mov	r8, r6
 8030b46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8030b48:	2000b1bc 	.word	0x2000b1bc
 8030b4c:	2000b1c0 	.word	0x2000b1c0

08030b50 <RegionUS915SetContinuousWave>:
{
    return LORAMAC_STATUS_PARAMETER_INVALID;
}

void RegionUS915SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 8030b50:	b570      	push	{r4, r5, r6, lr}
 8030b52:	0004      	movs	r4, r0
#if defined( REGION_US915 )
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 8030b54:	4b15      	ldr	r3, [pc, #84]	; (8030bac <RegionUS915SetContinuousWave+0x5c>)
 8030b56:	6818      	ldr	r0, [r3, #0]
 8030b58:	4d15      	ldr	r5, [pc, #84]	; (8030bb0 <RegionUS915SetContinuousWave+0x60>)
 8030b5a:	682b      	ldr	r3, [r5, #0]
 8030b5c:	7821      	ldrb	r1, [r4, #0]
 8030b5e:	004a      	lsls	r2, r1, #1
 8030b60:	1852      	adds	r2, r2, r1
 8030b62:	0092      	lsls	r2, r2, #2
 8030b64:	189a      	adds	r2, r3, r2
 8030b66:	7a56      	ldrb	r6, [r2, #9]
 8030b68:	22d8      	movs	r2, #216	; 0xd8
 8030b6a:	0092      	lsls	r2, r2, #2
 8030b6c:	4694      	mov	ip, r2
 8030b6e:	4463      	add	r3, ip
 8030b70:	2201      	movs	r2, #1
 8030b72:	56a2      	ldrsb	r2, [r4, r2]
 8030b74:	0071      	lsls	r1, r6, #1
 8030b76:	1989      	adds	r1, r1, r6
 8030b78:	00c9      	lsls	r1, r1, #3
 8030b7a:	1841      	adds	r1, r0, r1
 8030b7c:	7889      	ldrb	r1, [r1, #2]
 8030b7e:	b249      	sxtb	r1, r1
 8030b80:	2002      	movs	r0, #2
 8030b82:	5620      	ldrsb	r0, [r4, r0]
 8030b84:	f7ff fa0a 	bl	802ff9c <LimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 8030b88:	6829      	ldr	r1, [r5, #0]
 8030b8a:	7822      	ldrb	r2, [r4, #0]
 8030b8c:	0053      	lsls	r3, r2, #1
 8030b8e:	189b      	adds	r3, r3, r2
 8030b90:	009b      	lsls	r3, r3, #2
 8030b92:	585d      	ldr	r5, [r3, r1]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8030b94:	2200      	movs	r2, #0
 8030b96:	4907      	ldr	r1, [pc, #28]	; (8030bb4 <RegionUS915SetContinuousWave+0x64>)
 8030b98:	f7fe fa18 	bl	802efcc <RegionCommonComputeTxPower>
 8030b9c:	0001      	movs	r1, r0

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 8030b9e:	4b06      	ldr	r3, [pc, #24]	; (8030bb8 <RegionUS915SetContinuousWave+0x68>)
 8030ba0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8030ba2:	89a2      	ldrh	r2, [r4, #12]
 8030ba4:	0028      	movs	r0, r5
 8030ba6:	4798      	blx	r3
#endif /* REGION_US915 */
}
 8030ba8:	bd70      	pop	{r4, r5, r6, pc}
 8030baa:	46c0      	nop			; (mov r8, r8)
 8030bac:	2000b1bc 	.word	0x2000b1bc
 8030bb0:	2000b1c0 	.word	0x2000b1c0
 8030bb4:	41f00000 	.word	0x41f00000
 8030bb8:	080356b4 	.word	0x080356b4

08030bbc <RegionUS915ApplyDrOffset>:

uint8_t RegionUS915ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_US915 )
    int8_t datarate = DatarateOffsetsUS915[dr][drOffset];
 8030bbc:	008b      	lsls	r3, r1, #2
 8030bbe:	4904      	ldr	r1, [pc, #16]	; (8030bd0 <RegionUS915ApplyDrOffset+0x14>)
 8030bc0:	18c9      	adds	r1, r1, r3
 8030bc2:	5688      	ldrsb	r0, [r1, r2]

    if( datarate < 0 )
 8030bc4:	2800      	cmp	r0, #0
 8030bc6:	db01      	blt.n	8030bcc <RegionUS915ApplyDrOffset+0x10>
    {
        datarate = DR_0;
    }
    return datarate;
 8030bc8:	b2c0      	uxtb	r0, r0
#else
    return 0;
#endif /* REGION_US915 */
}
 8030bca:	4770      	bx	lr
        datarate = DR_0;
 8030bcc:	2000      	movs	r0, #0
 8030bce:	e7fb      	b.n	8030bc8 <RegionUS915ApplyDrOffset+0xc>
 8030bd0:	080353d4 	.word	0x080353d4

08030bd4 <GetKeyIndexByID>:
 * \param[IN]    keyID                    - Key identifier
 * \param[OUT] keyIndex             - Key item reference
 * \retval                                        - Status of the operation
 */
static SecureElementStatus_t GetKeyIndexByID( KeyIdentifier_t keyID, CK_OBJECT_HANDLE *keyIndex )
{
 8030bd4:	b530      	push	{r4, r5, lr}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 8030bd6:	2300      	movs	r3, #0
 8030bd8:	2b09      	cmp	r3, #9
 8030bda:	d814      	bhi.n	8030c06 <GetKeyIndexByID+0x32>
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 8030bdc:	4a0b      	ldr	r2, [pc, #44]	; (8030c0c <GetKeyIndexByID+0x38>)
 8030bde:	6814      	ldr	r4, [r2, #0]
 8030be0:	001d      	movs	r5, r3
 8030be2:	005a      	lsls	r2, r3, #1
 8030be4:	18d2      	adds	r2, r2, r3
 8030be6:	00d2      	lsls	r2, r2, #3
 8030be8:	18a2      	adds	r2, r4, r2
 8030bea:	7c12      	ldrb	r2, [r2, #16]
 8030bec:	4282      	cmp	r2, r0
 8030bee:	d002      	beq.n	8030bf6 <GetKeyIndexByID+0x22>
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 8030bf0:	3301      	adds	r3, #1
 8030bf2:	b2db      	uxtb	r3, r3
 8030bf4:	e7f0      	b.n	8030bd8 <GetKeyIndexByID+0x4>
        {
            *keyIndex = SeNvm->KeyList[i].Object_Index;
 8030bf6:	005b      	lsls	r3, r3, #1
 8030bf8:	195d      	adds	r5, r3, r5
 8030bfa:	00ed      	lsls	r5, r5, #3
 8030bfc:	1964      	adds	r4, r4, r5
 8030bfe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8030c00:	600b      	str	r3, [r1, #0]
            return SECURE_ELEMENT_SUCCESS;
 8030c02:	2000      	movs	r0, #0
 8030c04:	e000      	b.n	8030c08 <GetKeyIndexByID+0x34>
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8030c06:	2003      	movs	r0, #3
}
 8030c08:	bd30      	pop	{r4, r5, pc}
 8030c0a:	46c0      	nop			; (mov r8, r8)
 8030c0c:	2000b1c4 	.word	0x2000b1c4

08030c10 <GetSpecificLabelByID>:

static SecureElementStatus_t GetSpecificLabelByID( KeyIdentifier_t keyID, uint32_t *specificLabel )
{
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
    switch (keyID)
 8030c10:	2804      	cmp	r0, #4
 8030c12:	d804      	bhi.n	8030c1e <GetSpecificLabelByID+0xe>
 8030c14:	d833      	bhi.n	8030c7e <GetSpecificLabelByID+0x6e>
 8030c16:	0083      	lsls	r3, r0, #2
 8030c18:	4a1a      	ldr	r2, [pc, #104]	; (8030c84 <GetSpecificLabelByID+0x74>)
 8030c1a:	58d3      	ldr	r3, [r2, r3]
 8030c1c:	469f      	mov	pc, r3
 8030c1e:	2881      	cmp	r0, #129	; 0x81
 8030c20:	d029      	beq.n	8030c76 <GetSpecificLabelByID+0x66>
 8030c22:	d905      	bls.n	8030c30 <GetSpecificLabelByID+0x20>
 8030c24:	2882      	cmp	r0, #130	; 0x82
 8030c26:	d10d      	bne.n	8030c44 <GetSpecificLabelByID+0x34>
            break;
        case MC_APP_S_KEY_0:
            *specificLabel = 0x3053414DU;
            break;
        case MC_NWK_S_KEY_0:
            *specificLabel = 0x30534E4DU;
 8030c28:	4b17      	ldr	r3, [pc, #92]	; (8030c88 <GetSpecificLabelByID+0x78>)
 8030c2a:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c2c:	2000      	movs	r0, #0
            break;
 8030c2e:	e00a      	b.n	8030c46 <GetSpecificLabelByID+0x36>
    switch (keyID)
 8030c30:	287f      	cmp	r0, #127	; 0x7f
 8030c32:	d01c      	beq.n	8030c6e <GetSpecificLabelByID+0x5e>
 8030c34:	2880      	cmp	r0, #128	; 0x80
 8030c36:	d103      	bne.n	8030c40 <GetSpecificLabelByID+0x30>
            *specificLabel = 0x304B434DU;
 8030c38:	4b14      	ldr	r3, [pc, #80]	; (8030c8c <GetSpecificLabelByID+0x7c>)
 8030c3a:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c3c:	2000      	movs	r0, #0
            break;
 8030c3e:	e002      	b.n	8030c46 <GetSpecificLabelByID+0x36>
    switch (keyID)
 8030c40:	2003      	movs	r0, #3
 8030c42:	e000      	b.n	8030c46 <GetSpecificLabelByID+0x36>
 8030c44:	2003      	movs	r0, #3
        default:
            retval = SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
            break;
    }
    return retval;
}
 8030c46:	4770      	bx	lr
            *specificLabel = 0x5F505041U;
 8030c48:	4b11      	ldr	r3, [pc, #68]	; (8030c90 <GetSpecificLabelByID+0x80>)
 8030c4a:	600b      	str	r3, [r1, #0]
            break;
 8030c4c:	e7fb      	b.n	8030c46 <GetSpecificLabelByID+0x36>
            *specificLabel = 0x5F4B574EU;
 8030c4e:	4b11      	ldr	r3, [pc, #68]	; (8030c94 <GetSpecificLabelByID+0x84>)
 8030c50:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c52:	2000      	movs	r0, #0
            break;
 8030c54:	e7f7      	b.n	8030c46 <GetSpecificLabelByID+0x36>
            *specificLabel = 0x534B574EU;
 8030c56:	4b10      	ldr	r3, [pc, #64]	; (8030c98 <GetSpecificLabelByID+0x88>)
 8030c58:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c5a:	2000      	movs	r0, #0
            break;
 8030c5c:	e7f3      	b.n	8030c46 <GetSpecificLabelByID+0x36>
            *specificLabel = 0x53505041U;
 8030c5e:	4b0f      	ldr	r3, [pc, #60]	; (8030c9c <GetSpecificLabelByID+0x8c>)
 8030c60:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c62:	2000      	movs	r0, #0
            break;
 8030c64:	e7ef      	b.n	8030c46 <GetSpecificLabelByID+0x36>
            *specificLabel = 0x5452434DU;
 8030c66:	4b0e      	ldr	r3, [pc, #56]	; (8030ca0 <GetSpecificLabelByID+0x90>)
 8030c68:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c6a:	2000      	movs	r0, #0
            break;
 8030c6c:	e7eb      	b.n	8030c46 <GetSpecificLabelByID+0x36>
            *specificLabel = 0x454B434DU;
 8030c6e:	4b0d      	ldr	r3, [pc, #52]	; (8030ca4 <GetSpecificLabelByID+0x94>)
 8030c70:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c72:	2000      	movs	r0, #0
            break;
 8030c74:	e7e7      	b.n	8030c46 <GetSpecificLabelByID+0x36>
            *specificLabel = 0x3053414DU;
 8030c76:	4b0c      	ldr	r3, [pc, #48]	; (8030ca8 <GetSpecificLabelByID+0x98>)
 8030c78:	600b      	str	r3, [r1, #0]
    SecureElementStatus_t retval = SECURE_ELEMENT_SUCCESS;
 8030c7a:	2000      	movs	r0, #0
            break;
 8030c7c:	e7e3      	b.n	8030c46 <GetSpecificLabelByID+0x36>
    switch (keyID)
 8030c7e:	2003      	movs	r0, #3
 8030c80:	e7e1      	b.n	8030c46 <GetSpecificLabelByID+0x36>
 8030c82:	46c0      	nop			; (mov r8, r8)
 8030c84:	08035418 	.word	0x08035418
 8030c88:	30534e4d 	.word	0x30534e4d
 8030c8c:	304b434d 	.word	0x304b434d
 8030c90:	5f505041 	.word	0x5f505041
 8030c94:	5f4b574e 	.word	0x5f4b574e
 8030c98:	534b574e 	.word	0x534b574e
 8030c9c:	53505041 	.word	0x53505041
 8030ca0:	5452434d 	.word	0x5452434d
 8030ca4:	454b434d 	.word	0x454b434d
 8030ca8:	3053414d 	.word	0x3053414d

08030cac <DeleteAllDynamicKeys>:

static SecureElementStatus_t DeleteAllDynamicKeys( void )
{
 8030cac:	b530      	push	{r4, r5, lr}
 8030cae:	b08f      	sub	sp, #60	; 0x3c
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    uint32_t ulCount = 0;
 8030cb0:	2300      	movs	r3, #0
 8030cb2:	9302      	str	r3, [sp, #8]

    /* Open session with KMS */
    rv = C_OpenSession(0,  session_flags, NULL, 0, &session);
 8030cb4:	ab0d      	add	r3, sp, #52	; 0x34
 8030cb6:	9300      	str	r3, [sp, #0]
 8030cb8:	2300      	movs	r3, #0
 8030cba:	2200      	movs	r2, #0
 8030cbc:	2104      	movs	r1, #4
 8030cbe:	2000      	movs	r0, #0
 8030cc0:	f7f6 fa7a 	bl	80271b8 <KMS_OpenSession>
 8030cc4:	1e05      	subs	r5, r0, #0

    /* Get all keys handle */
    if (rv == CKR_OK)
 8030cc6:	d00e      	beq.n	8030ce6 <DeleteAllDynamicKeys+0x3a>
    {
        rv = C_FindObjectsInit(session, NULL, 0);
    }

    /* Find all existing keys handle */
    if (rv == CKR_OK)
 8030cc8:	2d00      	cmp	r5, #0
 8030cca:	d013      	beq.n	8030cf4 <DeleteAllDynamicKeys+0x48>
    {
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
    }

    if (rv == CKR_OK)
 8030ccc:	2d00      	cmp	r5, #0
 8030cce:	d019      	beq.n	8030d04 <DeleteAllDynamicKeys+0x58>
    {
        rv = C_FindObjectsFinal(session);
    }

    if (ulCount <= NUM_OF_KEYS)
 8030cd0:	9b02      	ldr	r3, [sp, #8]
 8030cd2:	2b0a      	cmp	r3, #10
 8030cd4:	d92c      	bls.n	8030d30 <DeleteAllDynamicKeys+0x84>
            }
        }
    }

    /* Close sessions */
    if (session > 0)
 8030cd6:	980d      	ldr	r0, [sp, #52]	; 0x34
 8030cd8:	2800      	cmp	r0, #0
 8030cda:	d12b      	bne.n	8030d34 <DeleteAllDynamicKeys+0x88>
    {
        (void)C_CloseSession(session);
    }

    if (rv != CKR_OK)
 8030cdc:	2d00      	cmp	r5, #0
 8030cde:	d12c      	bne.n	8030d3a <DeleteAllDynamicKeys+0x8e>
    {
        return SECURE_ELEMENT_ERROR;
    }
    return SECURE_ELEMENT_SUCCESS;
 8030ce0:	2000      	movs	r0, #0
}
 8030ce2:	b00f      	add	sp, #60	; 0x3c
 8030ce4:	bd30      	pop	{r4, r5, pc}
        rv = C_FindObjectsInit(session, NULL, 0);
 8030ce6:	2200      	movs	r2, #0
 8030ce8:	2100      	movs	r1, #0
 8030cea:	980d      	ldr	r0, [sp, #52]	; 0x34
 8030cec:	f7f5 fdec 	bl	80268c8 <KMS_FindObjectsInit>
 8030cf0:	0005      	movs	r5, r0
 8030cf2:	e7e9      	b.n	8030cc8 <DeleteAllDynamicKeys+0x1c>
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 8030cf4:	ab02      	add	r3, sp, #8
 8030cf6:	220a      	movs	r2, #10
 8030cf8:	a903      	add	r1, sp, #12
 8030cfa:	980d      	ldr	r0, [sp, #52]	; 0x34
 8030cfc:	f7f5 fe4c 	bl	8026998 <KMS_FindObjects>
 8030d00:	0005      	movs	r5, r0
 8030d02:	e7e3      	b.n	8030ccc <DeleteAllDynamicKeys+0x20>
        rv = C_FindObjectsFinal(session);
 8030d04:	980d      	ldr	r0, [sp, #52]	; 0x34
 8030d06:	f7f5 fe93 	bl	8026a30 <KMS_FindObjectsFinal>
 8030d0a:	0005      	movs	r5, r0
 8030d0c:	e7e0      	b.n	8030cd0 <DeleteAllDynamicKeys+0x24>
                    rv = C_DestroyObject(session, hObject[i]);
 8030d0e:	980d      	ldr	r0, [sp, #52]	; 0x34
 8030d10:	f7f5 fcfc 	bl	802670c <KMS_DestroyObject>
 8030d14:	0005      	movs	r5, r0
        for (uint8_t i = 0; i < ulCount; i++)
 8030d16:	3401      	adds	r4, #1
 8030d18:	b2e4      	uxtb	r4, r4
 8030d1a:	9b02      	ldr	r3, [sp, #8]
 8030d1c:	429c      	cmp	r4, r3
 8030d1e:	d2da      	bcs.n	8030cd6 <DeleteAllDynamicKeys+0x2a>
            if (hObject[i] > LAST_KMS_KEY_OBJECT_HANDLE)
 8030d20:	00a3      	lsls	r3, r4, #2
 8030d22:	aa03      	add	r2, sp, #12
 8030d24:	5899      	ldr	r1, [r3, r2]
 8030d26:	2906      	cmp	r1, #6
 8030d28:	d9f5      	bls.n	8030d16 <DeleteAllDynamicKeys+0x6a>
                if (rv == CKR_OK)
 8030d2a:	2d00      	cmp	r5, #0
 8030d2c:	d1f3      	bne.n	8030d16 <DeleteAllDynamicKeys+0x6a>
 8030d2e:	e7ee      	b.n	8030d0e <DeleteAllDynamicKeys+0x62>
        for (uint8_t i = 0; i < ulCount; i++)
 8030d30:	2400      	movs	r4, #0
 8030d32:	e7f2      	b.n	8030d1a <DeleteAllDynamicKeys+0x6e>
        (void)C_CloseSession(session);
 8030d34:	f7f6 fa82 	bl	802723c <KMS_CloseSession>
 8030d38:	e7d0      	b.n	8030cdc <DeleteAllDynamicKeys+0x30>
        return SECURE_ELEMENT_ERROR;
 8030d3a:	2006      	movs	r0, #6
 8030d3c:	e7d1      	b.n	8030ce2 <DeleteAllDynamicKeys+0x36>
	...

08030d40 <ComputeCmac>:
 * \param[OUT] cmac           - Computed cmac
 * \retval                    - Status of the operation
 */
static SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                          uint32_t* cmac )
{
 8030d40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030d42:	46ce      	mov	lr, r9
 8030d44:	b500      	push	{lr}
 8030d46:	b08a      	sub	sp, #40	; 0x28
 8030d48:	0007      	movs	r7, r0
 8030d4a:	000d      	movs	r5, r1
 8030d4c:	9203      	str	r2, [sp, #12]
 8030d4e:	0018      	movs	r0, r3
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 8030d50:	2900      	cmp	r1, #0
 8030d52:	d066      	beq.n	8030e22 <ComputeCmac+0xe2>
 8030d54:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8030d56:	2b00      	cmp	r3, #0
 8030d58:	d065      	beq.n	8030e26 <ComputeCmac+0xe6>
    }
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    uint32_t tag_lenth = 0;
 8030d5a:	2300      	movs	r3, #0
 8030d5c:	9308      	str	r3, [sp, #32]
    CK_OBJECT_HANDLE key_handle ;

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8030d5e:	4a33      	ldr	r2, [pc, #204]	; (8030e2c <ComputeCmac+0xec>)
 8030d60:	9204      	str	r2, [sp, #16]
 8030d62:	9305      	str	r3, [sp, #20]
 8030d64:	9306      	str	r3, [sp, #24]

    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &key_handle);
 8030d66:	a907      	add	r1, sp, #28
 8030d68:	f7ff ff34 	bl	8030bd4 <GetKeyIndexByID>
 8030d6c:	1e04      	subs	r4, r0, #0
    if (retval != SECURE_ELEMENT_SUCCESS)
 8030d6e:	d004      	beq.n	8030d7a <ComputeCmac+0x3a>
    {
        retval = SECURE_ELEMENT_ERROR;
    }
#endif /* LORAWAN_KMS */
    return retval;
}
 8030d70:	0020      	movs	r0, r4
 8030d72:	b00a      	add	sp, #40	; 0x28
 8030d74:	bc80      	pop	{r7}
 8030d76:	46b9      	mov	r9, r7
 8030d78:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8030d7a:	ab09      	add	r3, sp, #36	; 0x24
 8030d7c:	9300      	str	r3, [sp, #0]
 8030d7e:	2300      	movs	r3, #0
 8030d80:	2200      	movs	r2, #0
 8030d82:	2104      	movs	r1, #4
 8030d84:	2000      	movs	r0, #0
 8030d86:	f7f6 fa17 	bl	80271b8 <KMS_OpenSession>
 8030d8a:	1e06      	subs	r6, r0, #0
    if (rv == CKR_OK)
 8030d8c:	d032      	beq.n	8030df4 <ComputeCmac+0xb4>
    if (rv == CKR_OK)
 8030d8e:	2e00      	cmp	r6, #0
 8030d90:	d10e      	bne.n	8030db0 <ComputeCmac+0x70>
        if (micBxBuffer != NULL)
 8030d92:	2f00      	cmp	r7, #0
 8030d94:	d035      	beq.n	8030e02 <ComputeCmac+0xc2>
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) micBxBuffer, SE_KEY_SIZE);
 8030d96:	4b26      	ldr	r3, [pc, #152]	; (8030e30 <ComputeCmac+0xf0>)
 8030d98:	4699      	mov	r9, r3
 8030d9a:	2210      	movs	r2, #16
 8030d9c:	0039      	movs	r1, r7
 8030d9e:	0018      	movs	r0, r3
 8030da0:	f000 fcfb 	bl	803179a <memcpy1>
            memcpy1((uint8_t *) &input_align_combined_buf[SE_KEY_SIZE], (uint8_t *) buffer, size);
 8030da4:	4648      	mov	r0, r9
 8030da6:	3010      	adds	r0, #16
 8030da8:	9a03      	ldr	r2, [sp, #12]
 8030daa:	0029      	movs	r1, r5
 8030dac:	f000 fcf5 	bl	803179a <memcpy1>
    if (rv == CKR_OK)
 8030db0:	2e00      	cmp	r6, #0
 8030db2:	d10b      	bne.n	8030dcc <ComputeCmac+0x8c>
        if (micBxBuffer != NULL)
 8030db4:	2f00      	cmp	r7, #0
 8030db6:	d02a      	beq.n	8030e0e <ComputeCmac+0xce>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size + SE_KEY_SIZE, &tag[0],
 8030db8:	9a03      	ldr	r2, [sp, #12]
 8030dba:	3210      	adds	r2, #16
 8030dbc:	ab08      	add	r3, sp, #32
 8030dbe:	9300      	str	r3, [sp, #0]
 8030dc0:	4b1c      	ldr	r3, [pc, #112]	; (8030e34 <ComputeCmac+0xf4>)
 8030dc2:	491b      	ldr	r1, [pc, #108]	; (8030e30 <ComputeCmac+0xf0>)
 8030dc4:	9809      	ldr	r0, [sp, #36]	; 0x24
 8030dc6:	f7f7 fe5d 	bl	8028a84 <KMS_Sign>
 8030dca:	0006      	movs	r6, r0
    (void)C_CloseSession(session);
 8030dcc:	9809      	ldr	r0, [sp, #36]	; 0x24
 8030dce:	f7f6 fa35 	bl	802723c <KMS_CloseSession>
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8030dd2:	4a18      	ldr	r2, [pc, #96]	; (8030e34 <ComputeCmac+0xf4>)
 8030dd4:	78d3      	ldrb	r3, [r2, #3]
 8030dd6:	061b      	lsls	r3, r3, #24
 8030dd8:	7891      	ldrb	r1, [r2, #2]
 8030dda:	0409      	lsls	r1, r1, #16
 8030ddc:	430b      	orrs	r3, r1
 8030dde:	7851      	ldrb	r1, [r2, #1]
 8030de0:	0209      	lsls	r1, r1, #8
 8030de2:	430b      	orrs	r3, r1
                       (uint32_t) tag[0]);
 8030de4:	7812      	ldrb	r2, [r2, #0]
    *cmac = (uint32_t)((uint32_t) tag[3] << 24 | (uint32_t) tag[2] << 16 | (uint32_t) tag[1] << 8 |
 8030de6:	4313      	orrs	r3, r2
 8030de8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8030dea:	6013      	str	r3, [r2, #0]
    if (rv != CKR_OK)
 8030dec:	2e00      	cmp	r6, #0
 8030dee:	d0bf      	beq.n	8030d70 <ComputeCmac+0x30>
        retval = SECURE_ELEMENT_ERROR;
 8030df0:	2406      	movs	r4, #6
 8030df2:	e7bd      	b.n	8030d70 <ComputeCmac+0x30>
        rv = C_SignInit(session, &aes_cmac_mechanism, key_handle);
 8030df4:	9a07      	ldr	r2, [sp, #28]
 8030df6:	a904      	add	r1, sp, #16
 8030df8:	9809      	ldr	r0, [sp, #36]	; 0x24
 8030dfa:	f7f7 fe31 	bl	8028a60 <KMS_SignInit>
 8030dfe:	0006      	movs	r6, r0
 8030e00:	e7c5      	b.n	8030d8e <ComputeCmac+0x4e>
            memcpy1((uint8_t *) &input_align_combined_buf[0], (uint8_t *) buffer, size);
 8030e02:	9a03      	ldr	r2, [sp, #12]
 8030e04:	0029      	movs	r1, r5
 8030e06:	480a      	ldr	r0, [pc, #40]	; (8030e30 <ComputeCmac+0xf0>)
 8030e08:	f000 fcc7 	bl	803179a <memcpy1>
 8030e0c:	e7d0      	b.n	8030db0 <ComputeCmac+0x70>
            rv = C_Sign(session, (CK_BYTE_PTR)&input_align_combined_buf[0], size, &tag[0],
 8030e0e:	ab08      	add	r3, sp, #32
 8030e10:	9300      	str	r3, [sp, #0]
 8030e12:	4b08      	ldr	r3, [pc, #32]	; (8030e34 <ComputeCmac+0xf4>)
 8030e14:	9a03      	ldr	r2, [sp, #12]
 8030e16:	4906      	ldr	r1, [pc, #24]	; (8030e30 <ComputeCmac+0xf0>)
 8030e18:	9809      	ldr	r0, [sp, #36]	; 0x24
 8030e1a:	f7f7 fe33 	bl	8028a84 <KMS_Sign>
 8030e1e:	0006      	movs	r6, r0
 8030e20:	e7d4      	b.n	8030dcc <ComputeCmac+0x8c>
        return SECURE_ELEMENT_ERROR_NPE;
 8030e22:	2402      	movs	r4, #2
 8030e24:	e7a4      	b.n	8030d70 <ComputeCmac+0x30>
 8030e26:	2402      	movs	r4, #2
 8030e28:	e7a2      	b.n	8030d70 <ComputeCmac+0x30>
 8030e2a:	46c0      	nop			; (mov r8, r8)
 8030e2c:	0000108a 	.word	0x0000108a
 8030e30:	2000b1c8 	.word	0x2000b1c8
 8030e34:	2000b3f8 	.word	0x2000b3f8

08030e38 <SecureElementGetKeyByID>:
    return SECURE_ELEMENT_SUCCESS;
}

/* ST_WORKAROUND_BEGIN: Add KMS specific functions */
SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, Key_t **keyItem )
{
 8030e38:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030e3a:	46c6      	mov	lr, r8
 8030e3c:	b500      	push	{lr}
 8030e3e:	b08c      	sub	sp, #48	; 0x30
 8030e40:	0005      	movs	r5, r0
 8030e42:	000e      	movs	r6, r1
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE key_handle = (CK_OBJECT_HANDLE)(~0UL);
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 8030e44:	2304      	movs	r3, #4
 8030e46:	930a      	str	r3, [sp, #40]	; 0x28
    uint8_t extractable_key[16] = {0};
 8030e48:	2300      	movs	r3, #0
 8030e4a:	9306      	str	r3, [sp, #24]
 8030e4c:	220c      	movs	r2, #12
 8030e4e:	2100      	movs	r1, #0
 8030e50:	a807      	add	r0, sp, #28
 8030e52:	f003 fc68 	bl	8034726 <memset>
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, (CK_VOID_PTR) &derive_key_template_class, 16UL};
 8030e56:	2311      	movs	r3, #17
 8030e58:	9303      	str	r3, [sp, #12]
 8030e5a:	ab0a      	add	r3, sp, #40	; 0x28
 8030e5c:	9304      	str	r3, [sp, #16]
 8030e5e:	2310      	movs	r3, #16
 8030e60:	9305      	str	r3, [sp, #20]
    uint8_t index_keylist = 0;
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
 8030e62:	2400      	movs	r4, #0
 8030e64:	2c09      	cmp	r4, #9
 8030e66:	d811      	bhi.n	8030e8c <SecureElementGetKeyByID+0x54>
    {
        if (SeNvm->KeyList[index_keylist].KeyID == keyID)
 8030e68:	4b27      	ldr	r3, [pc, #156]	; (8030f08 <SecureElementGetKeyByID+0xd0>)
 8030e6a:	6819      	ldr	r1, [r3, #0]
 8030e6c:	0063      	lsls	r3, r4, #1
 8030e6e:	191b      	adds	r3, r3, r4
 8030e70:	00db      	lsls	r3, r3, #3
 8030e72:	18cb      	adds	r3, r1, r3
 8030e74:	7c1b      	ldrb	r3, [r3, #16]
 8030e76:	42ab      	cmp	r3, r5
 8030e78:	d002      	beq.n	8030e80 <SecureElementGetKeyByID+0x48>
    for (index_keylist = 0; index_keylist < NUM_OF_KEYS; index_keylist++)
 8030e7a:	3401      	adds	r4, #1
 8030e7c:	b2e4      	uxtb	r4, r4
 8030e7e:	e7f1      	b.n	8030e64 <SecureElementGetKeyByID+0x2c>
        {
            key_handle = SeNvm->KeyList[index_keylist].Object_Index;
 8030e80:	0063      	lsls	r3, r4, #1
 8030e82:	191a      	adds	r2, r3, r4
 8030e84:	00d2      	lsls	r2, r2, #3
 8030e86:	1889      	adds	r1, r1, r2
 8030e88:	6a4f      	ldr	r7, [r1, #36]	; 0x24
            break;
 8030e8a:	e001      	b.n	8030e90 <SecureElementGetKeyByID+0x58>
    CK_OBJECT_HANDLE key_handle = (CK_OBJECT_HANDLE)(~0UL);
 8030e8c:	2701      	movs	r7, #1
 8030e8e:	427f      	negs	r7, r7
        }
    }
    if (key_handle == (CK_OBJECT_HANDLE)(~0UL))
 8030e90:	1c7b      	adds	r3, r7, #1
 8030e92:	d035      	beq.n	8030f00 <SecureElementGetKeyByID+0xc8>
    {
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 8030e94:	ab0b      	add	r3, sp, #44	; 0x2c
 8030e96:	9300      	str	r3, [sp, #0]
 8030e98:	2300      	movs	r3, #0
 8030e9a:	2200      	movs	r2, #0
 8030e9c:	2104      	movs	r1, #4
 8030e9e:	2000      	movs	r0, #0
 8030ea0:	f7f6 f98a 	bl	80271b8 <KMS_OpenSession>
 8030ea4:	1e05      	subs	r5, r0, #0

    /* Get key to display */
    if (rv == CKR_OK)
 8030ea6:	d00b      	beq.n	8030ec0 <SecureElementGetKeyByID+0x88>
    {
        key_attribute_template.pValue = extractable_key;
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
    }
    if (rv == CKR_OK)
 8030ea8:	2d00      	cmp	r5, #0
 8030eaa:	d013      	beq.n	8030ed4 <SecureElementGetKeyByID+0x9c>
        memcpy1(SeNvm->KeyList[index_keylist].KeyValue, extractable_key, sizeof(extractable_key));
        *keyItem = &(SeNvm->KeyList[index_keylist]);
    }

    /* Close sessions */
    (void)C_CloseSession(session);
 8030eac:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8030eae:	f7f6 f9c5 	bl	802723c <KMS_CloseSession>

    if (rv != CKR_OK)
 8030eb2:	2d00      	cmp	r5, #0
 8030eb4:	d126      	bne.n	8030f04 <SecureElementGetKeyByID+0xcc>
    {
        return SECURE_ELEMENT_ERROR;
    }
    return SECURE_ELEMENT_SUCCESS;
 8030eb6:	2000      	movs	r0, #0

#endif /* LORAWAN_KMS == 1 */
}
 8030eb8:	b00c      	add	sp, #48	; 0x30
 8030eba:	bc80      	pop	{r7}
 8030ebc:	46b8      	mov	r8, r7
 8030ebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
        key_attribute_template.pValue = extractable_key;
 8030ec0:	ab06      	add	r3, sp, #24
 8030ec2:	9304      	str	r3, [sp, #16]
        rv = C_GetAttributeValue(session, key_handle, &key_attribute_template, 1UL);
 8030ec4:	2301      	movs	r3, #1
 8030ec6:	aa03      	add	r2, sp, #12
 8030ec8:	0039      	movs	r1, r7
 8030eca:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8030ecc:	f7f5 fc5c 	bl	8026788 <KMS_GetAttributeValue>
 8030ed0:	0005      	movs	r5, r0
 8030ed2:	e7e9      	b.n	8030ea8 <SecureElementGetKeyByID+0x70>
        memcpy1(SeNvm->KeyList[index_keylist].KeyValue, extractable_key, sizeof(extractable_key));
 8030ed4:	4b0c      	ldr	r3, [pc, #48]	; (8030f08 <SecureElementGetKeyByID+0xd0>)
 8030ed6:	4698      	mov	r8, r3
 8030ed8:	0067      	lsls	r7, r4, #1
 8030eda:	1938      	adds	r0, r7, r4
 8030edc:	00c0      	lsls	r0, r0, #3
 8030ede:	3010      	adds	r0, #16
 8030ee0:	681b      	ldr	r3, [r3, #0]
 8030ee2:	469c      	mov	ip, r3
 8030ee4:	4460      	add	r0, ip
 8030ee6:	3001      	adds	r0, #1
 8030ee8:	2210      	movs	r2, #16
 8030eea:	a906      	add	r1, sp, #24
 8030eec:	f000 fc55 	bl	803179a <memcpy1>
        *keyItem = &(SeNvm->KeyList[index_keylist]);
 8030ef0:	4643      	mov	r3, r8
 8030ef2:	681b      	ldr	r3, [r3, #0]
 8030ef4:	193c      	adds	r4, r7, r4
 8030ef6:	00e4      	lsls	r4, r4, #3
 8030ef8:	3410      	adds	r4, #16
 8030efa:	191c      	adds	r4, r3, r4
 8030efc:	6034      	str	r4, [r6, #0]
 8030efe:	e7d5      	b.n	8030eac <SecureElementGetKeyByID+0x74>
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8030f00:	2003      	movs	r0, #3
 8030f02:	e7d9      	b.n	8030eb8 <SecureElementGetKeyByID+0x80>
        return SECURE_ELEMENT_ERROR;
 8030f04:	2006      	movs	r0, #6
 8030f06:	e7d7      	b.n	8030eb8 <SecureElementGetKeyByID+0x80>
 8030f08:	2000b1c4 	.word	0x2000b1c4

08030f0c <PrintKey>:
{
 8030f0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030f0e:	46de      	mov	lr, fp
 8030f10:	4657      	mov	r7, sl
 8030f12:	464e      	mov	r6, r9
 8030f14:	4645      	mov	r5, r8
 8030f16:	b5e0      	push	{r5, r6, r7, lr}
 8030f18:	b097      	sub	sp, #92	; 0x5c
 8030f1a:	0004      	movs	r4, r0
    retval = SecureElementGetKeyByID(key, &keyItem);
 8030f1c:	a915      	add	r1, sp, #84	; 0x54
 8030f1e:	f7ff ff8b 	bl	8030e38 <SecureElementGetKeyByID>
    if (retval == SECURE_ELEMENT_SUCCESS)
 8030f22:	2800      	cmp	r0, #0
 8030f24:	d157      	bne.n	8030fd6 <PrintKey+0xca>
        if (key == APP_KEY)
 8030f26:	2c00      	cmp	r4, #0
 8030f28:	d018      	beq.n	8030f5c <PrintKey+0x50>
        else if (key == NWK_KEY)
 8030f2a:	2c01      	cmp	r4, #1
 8030f2c:	d05a      	beq.n	8030fe4 <PrintKey+0xd8>
        else if (key == APP_S_KEY)
 8030f2e:	2c03      	cmp	r4, #3
 8030f30:	d05f      	beq.n	8030ff2 <PrintKey+0xe6>
        else if (key == NWK_S_KEY)
 8030f32:	2c02      	cmp	r4, #2
 8030f34:	d064      	beq.n	8031000 <PrintKey+0xf4>
        else if (key == MC_ROOT_KEY)
 8030f36:	2c04      	cmp	r4, #4
 8030f38:	d069      	beq.n	803100e <PrintKey+0x102>
        else if (key == MC_KE_KEY)
 8030f3a:	2c7f      	cmp	r4, #127	; 0x7f
 8030f3c:	d06e      	beq.n	803101c <PrintKey+0x110>
        else if (key == MC_KEY_0)
 8030f3e:	2c80      	cmp	r4, #128	; 0x80
 8030f40:	d100      	bne.n	8030f44 <PrintKey+0x38>
 8030f42:	e072      	b.n	803102a <PrintKey+0x11e>
        else if (key == MC_APP_S_KEY_0)
 8030f44:	2c81      	cmp	r4, #129	; 0x81
 8030f46:	d100      	bne.n	8030f4a <PrintKey+0x3e>
 8030f48:	e076      	b.n	8031038 <PrintKey+0x12c>
        else if (key == MC_NWK_S_KEY_0)
 8030f4a:	2c82      	cmp	r4, #130	; 0x82
 8030f4c:	d10c      	bne.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCNwkSKey_0: ");
 8030f4e:	4b3e      	ldr	r3, [pc, #248]	; (8031048 <PrintKey+0x13c>)
 8030f50:	2200      	movs	r2, #0
 8030f52:	2100      	movs	r1, #0
 8030f54:	2002      	movs	r0, #2
 8030f56:	f002 fdaf 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 8030f5a:	e005      	b.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppKey:      ");
 8030f5c:	4b3b      	ldr	r3, [pc, #236]	; (803104c <PrintKey+0x140>)
 8030f5e:	2200      	movs	r2, #0
 8030f60:	2100      	movs	r1, #0
 8030f62:	3002      	adds	r0, #2
 8030f64:	f002 fda8 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
        MW_LOG(TS_OFF, VLEVEL_M, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 8030f68:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8030f6a:	785a      	ldrb	r2, [r3, #1]
 8030f6c:	9210      	str	r2, [sp, #64]	; 0x40
 8030f6e:	7899      	ldrb	r1, [r3, #2]
 8030f70:	9111      	str	r1, [sp, #68]	; 0x44
 8030f72:	78d8      	ldrb	r0, [r3, #3]
 8030f74:	9012      	str	r0, [sp, #72]	; 0x48
 8030f76:	791a      	ldrb	r2, [r3, #4]
 8030f78:	7959      	ldrb	r1, [r3, #5]
 8030f7a:	7998      	ldrb	r0, [r3, #6]
 8030f7c:	79dc      	ldrb	r4, [r3, #7]
 8030f7e:	9413      	str	r4, [sp, #76]	; 0x4c
 8030f80:	7a1d      	ldrb	r5, [r3, #8]
 8030f82:	7a5e      	ldrb	r6, [r3, #9]
 8030f84:	7a9f      	ldrb	r7, [r3, #10]
 8030f86:	7adc      	ldrb	r4, [r3, #11]
 8030f88:	46a4      	mov	ip, r4
 8030f8a:	7b1c      	ldrb	r4, [r3, #12]
 8030f8c:	46a0      	mov	r8, r4
 8030f8e:	7b5c      	ldrb	r4, [r3, #13]
 8030f90:	46a1      	mov	r9, r4
 8030f92:	7b9c      	ldrb	r4, [r3, #14]
 8030f94:	46a2      	mov	sl, r4
 8030f96:	7bdc      	ldrb	r4, [r3, #15]
 8030f98:	7c1b      	ldrb	r3, [r3, #16]
 8030f9a:	930f      	str	r3, [sp, #60]	; 0x3c
 8030f9c:	940e      	str	r4, [sp, #56]	; 0x38
 8030f9e:	4653      	mov	r3, sl
 8030fa0:	930d      	str	r3, [sp, #52]	; 0x34
 8030fa2:	464b      	mov	r3, r9
 8030fa4:	930c      	str	r3, [sp, #48]	; 0x30
 8030fa6:	4643      	mov	r3, r8
 8030fa8:	930b      	str	r3, [sp, #44]	; 0x2c
 8030faa:	4663      	mov	r3, ip
 8030fac:	930a      	str	r3, [sp, #40]	; 0x28
 8030fae:	9709      	str	r7, [sp, #36]	; 0x24
 8030fb0:	9608      	str	r6, [sp, #32]
 8030fb2:	9507      	str	r5, [sp, #28]
 8030fb4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8030fb6:	9306      	str	r3, [sp, #24]
 8030fb8:	9005      	str	r0, [sp, #20]
 8030fba:	9104      	str	r1, [sp, #16]
 8030fbc:	9203      	str	r2, [sp, #12]
 8030fbe:	9812      	ldr	r0, [sp, #72]	; 0x48
 8030fc0:	9002      	str	r0, [sp, #8]
 8030fc2:	9911      	ldr	r1, [sp, #68]	; 0x44
 8030fc4:	9101      	str	r1, [sp, #4]
 8030fc6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8030fc8:	9200      	str	r2, [sp, #0]
 8030fca:	4b21      	ldr	r3, [pc, #132]	; (8031050 <PrintKey+0x144>)
 8030fcc:	2200      	movs	r2, #0
 8030fce:	2100      	movs	r1, #0
 8030fd0:	2002      	movs	r0, #2
 8030fd2:	f002 fd71 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 8030fd6:	b017      	add	sp, #92	; 0x5c
 8030fd8:	bcf0      	pop	{r4, r5, r6, r7}
 8030fda:	46bb      	mov	fp, r7
 8030fdc:	46b2      	mov	sl, r6
 8030fde:	46a9      	mov	r9, r5
 8030fe0:	46a0      	mov	r8, r4
 8030fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkKey:      ");
 8030fe4:	4b1b      	ldr	r3, [pc, #108]	; (8031054 <PrintKey+0x148>)
 8030fe6:	2200      	movs	r2, #0
 8030fe8:	2100      	movs	r1, #0
 8030fea:	2002      	movs	r0, #2
 8030fec:	f002 fd64 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 8030ff0:	e7ba      	b.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppSKey:     ");
 8030ff2:	4b19      	ldr	r3, [pc, #100]	; (8031058 <PrintKey+0x14c>)
 8030ff4:	2200      	movs	r2, #0
 8030ff6:	2100      	movs	r1, #0
 8030ff8:	2002      	movs	r0, #2
 8030ffa:	f002 fd5d 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 8030ffe:	e7b3      	b.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkSKey:     ");
 8031000:	4b16      	ldr	r3, [pc, #88]	; (803105c <PrintKey+0x150>)
 8031002:	2200      	movs	r2, #0
 8031004:	2100      	movs	r1, #0
 8031006:	2002      	movs	r0, #2
 8031008:	f002 fd56 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 803100c:	e7ac      	b.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCRootKey:   ");
 803100e:	4b14      	ldr	r3, [pc, #80]	; (8031060 <PrintKey+0x154>)
 8031010:	2200      	movs	r2, #0
 8031012:	2100      	movs	r1, #0
 8031014:	2002      	movs	r0, #2
 8031016:	f002 fd4f 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 803101a:	e7a5      	b.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKEKey:     ");
 803101c:	4b11      	ldr	r3, [pc, #68]	; (8031064 <PrintKey+0x158>)
 803101e:	2200      	movs	r2, #0
 8031020:	2100      	movs	r1, #0
 8031022:	2002      	movs	r0, #2
 8031024:	f002 fd48 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 8031028:	e79e      	b.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCKey_0:     ");
 803102a:	4b0f      	ldr	r3, [pc, #60]	; (8031068 <PrintKey+0x15c>)
 803102c:	2200      	movs	r2, #0
 803102e:	2100      	movs	r1, #0
 8031030:	2002      	movs	r0, #2
 8031032:	f002 fd41 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 8031036:	e797      	b.n	8030f68 <PrintKey+0x5c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### MCAppSKey_0: ");
 8031038:	4b0c      	ldr	r3, [pc, #48]	; (803106c <PrintKey+0x160>)
 803103a:	2200      	movs	r2, #0
 803103c:	2100      	movs	r1, #0
 803103e:	2002      	movs	r0, #2
 8031040:	f002 fd3a 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 8031044:	e790      	b.n	8030f68 <PrintKey+0x5c>
 8031046:	46c0      	nop			; (mov r8, r8)
 8031048:	080354ec 	.word	0x080354ec
 803104c:	0803542c 	.word	0x0803542c
 8031050:	08035504 	.word	0x08035504
 8031054:	08035444 	.word	0x08035444
 8031058:	0803545c 	.word	0x0803545c
 803105c:	08035474 	.word	0x08035474
 8031060:	0803548c 	.word	0x0803548c
 8031064:	080354a4 	.word	0x080354a4
 8031068:	080354bc 	.word	0x080354bc
 803106c:	080354d4 	.word	0x080354d4

08031070 <SecureElementDeleteDynamicKeys>:

SecureElementStatus_t SecureElementDeleteDynamicKeys( KeyIdentifier_t keyID, uint32_t *key_label )
{
 8031070:	b570      	push	{r4, r5, r6, lr}
 8031072:	b094      	sub	sp, #80	; 0x50
 8031074:	000d      	movs	r5, r1
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    CK_ULONG local_template_label[] = {GlobalTemplateLabel, 0UL};
 8031076:	aa07      	add	r2, sp, #28
 8031078:	4b2a      	ldr	r3, [pc, #168]	; (8031124 <SecureElementDeleteDynamicKeys+0xb4>)
 803107a:	9307      	str	r3, [sp, #28]
 803107c:	2300      	movs	r3, #0
 803107e:	9308      	str	r3, [sp, #32]
    CK_ATTRIBUTE dynamic_key_template = {CKA_LABEL, (CK_VOID_PTR)local_template_label, sizeof(local_template_label)};
 8031080:	2103      	movs	r1, #3
 8031082:	9104      	str	r1, [sp, #16]
 8031084:	9205      	str	r2, [sp, #20]
 8031086:	2208      	movs	r2, #8
 8031088:	9206      	str	r2, [sp, #24]
    uint32_t ulCount = 0;
 803108a:	9303      	str	r3, [sp, #12]

    if (SECURE_ELEMENT_SUCCESS != GetSpecificLabelByID(keyID, &local_template_label[1]))
 803108c:	a908      	add	r1, sp, #32
 803108e:	f7ff fdbf 	bl	8030c10 <GetSpecificLabelByID>
 8031092:	0004      	movs	r4, r0
 8031094:	1e06      	subs	r6, r0, #0
 8031096:	d140      	bne.n	803111a <SecureElementDeleteDynamicKeys+0xaa>
    {
        return SECURE_ELEMENT_ERROR;
    }
    *key_label = local_template_label[1];
 8031098:	9b08      	ldr	r3, [sp, #32]
 803109a:	602b      	str	r3, [r5, #0]

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 803109c:	ab13      	add	r3, sp, #76	; 0x4c
 803109e:	9300      	str	r3, [sp, #0]
 80310a0:	2300      	movs	r3, #0
 80310a2:	2200      	movs	r2, #0
 80310a4:	2104      	movs	r1, #4
 80310a6:	2000      	movs	r0, #0
 80310a8:	f7f6 f886 	bl	80271b8 <KMS_OpenSession>
 80310ac:	1e05      	subs	r5, r0, #0

    /* Search from Template pattern */
    if (rv == CKR_OK)
 80310ae:	d00e      	beq.n	80310ce <SecureElementDeleteDynamicKeys+0x5e>
    {
        rv = C_FindObjectsInit(session, &dynamic_key_template, sizeof(dynamic_key_template) / sizeof(CK_ATTRIBUTE));
    }

    /* Find all existing keys handle Template pattern */
    if (rv == CKR_OK)
 80310b0:	2d00      	cmp	r5, #0
 80310b2:	d013      	beq.n	80310dc <SecureElementDeleteDynamicKeys+0x6c>
    {
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
    }

    if (rv == CKR_OK)
 80310b4:	2d00      	cmp	r5, #0
 80310b6:	d019      	beq.n	80310ec <SecureElementDeleteDynamicKeys+0x7c>
    {
        rv = C_FindObjectsFinal(session);
    }

    if (ulCount <= NUM_OF_KEYS)
 80310b8:	9b03      	ldr	r3, [sp, #12]
 80310ba:	2b0a      	cmp	r3, #10
 80310bc:	d924      	bls.n	8031108 <SecureElementDeleteDynamicKeys+0x98>
            }
        }
    }

    /* Close sessions */
    if (session > 0)
 80310be:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80310c0:	2800      	cmp	r0, #0
 80310c2:	d127      	bne.n	8031114 <SecureElementDeleteDynamicKeys+0xa4>
    {
        (void)C_CloseSession(session);
    }

    if (rv != CKR_OK)
 80310c4:	2d00      	cmp	r5, #0
 80310c6:	d12a      	bne.n	803111e <SecureElementDeleteDynamicKeys+0xae>
    {
        return SECURE_ELEMENT_ERROR;
    }
    return SECURE_ELEMENT_SUCCESS;
#endif /* LORAWAN_KMS == 1 */
}
 80310c8:	0030      	movs	r0, r6
 80310ca:	b014      	add	sp, #80	; 0x50
 80310cc:	bd70      	pop	{r4, r5, r6, pc}
        rv = C_FindObjectsInit(session, &dynamic_key_template, sizeof(dynamic_key_template) / sizeof(CK_ATTRIBUTE));
 80310ce:	2201      	movs	r2, #1
 80310d0:	a904      	add	r1, sp, #16
 80310d2:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80310d4:	f7f5 fbf8 	bl	80268c8 <KMS_FindObjectsInit>
 80310d8:	0005      	movs	r5, r0
 80310da:	e7e9      	b.n	80310b0 <SecureElementDeleteDynamicKeys+0x40>
        rv = C_FindObjects(session, hObject, NUM_OF_KEYS, (CK_ULONG *) &ulCount);
 80310dc:	ab03      	add	r3, sp, #12
 80310de:	220a      	movs	r2, #10
 80310e0:	a909      	add	r1, sp, #36	; 0x24
 80310e2:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80310e4:	f7f5 fc58 	bl	8026998 <KMS_FindObjects>
 80310e8:	0005      	movs	r5, r0
 80310ea:	e7e3      	b.n	80310b4 <SecureElementDeleteDynamicKeys+0x44>
        rv = C_FindObjectsFinal(session);
 80310ec:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80310ee:	f7f5 fc9f 	bl	8026a30 <KMS_FindObjectsFinal>
 80310f2:	0005      	movs	r5, r0
 80310f4:	e7e0      	b.n	80310b8 <SecureElementDeleteDynamicKeys+0x48>
                rv = C_DestroyObject(session, hObject[i]);
 80310f6:	00a3      	lsls	r3, r4, #2
 80310f8:	aa09      	add	r2, sp, #36	; 0x24
 80310fa:	5899      	ldr	r1, [r3, r2]
 80310fc:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80310fe:	f7f5 fb05 	bl	802670c <KMS_DestroyObject>
 8031102:	0005      	movs	r5, r0
        for (uint8_t i = 0; i < ulCount; i++)
 8031104:	3401      	adds	r4, #1
 8031106:	b2e4      	uxtb	r4, r4
 8031108:	9b03      	ldr	r3, [sp, #12]
 803110a:	429c      	cmp	r4, r3
 803110c:	d2d7      	bcs.n	80310be <SecureElementDeleteDynamicKeys+0x4e>
            if (rv == CKR_OK)
 803110e:	2d00      	cmp	r5, #0
 8031110:	d1f8      	bne.n	8031104 <SecureElementDeleteDynamicKeys+0x94>
 8031112:	e7f0      	b.n	80310f6 <SecureElementDeleteDynamicKeys+0x86>
        (void)C_CloseSession(session);
 8031114:	f7f6 f892 	bl	802723c <KMS_CloseSession>
 8031118:	e7d4      	b.n	80310c4 <SecureElementDeleteDynamicKeys+0x54>
        return SECURE_ELEMENT_ERROR;
 803111a:	2606      	movs	r6, #6
 803111c:	e7d4      	b.n	80310c8 <SecureElementDeleteDynamicKeys+0x58>
        return SECURE_ELEMENT_ERROR;
 803111e:	2606      	movs	r6, #6
 8031120:	e7d2      	b.n	80310c8 <SecureElementDeleteDynamicKeys+0x58>
 8031122:	46c0      	nop			; (mov r8, r8)
 8031124:	444e524c 	.word	0x444e524c

08031128 <SecureElementSetObjHandler>:

SecureElementStatus_t SecureElementSetObjHandler( KeyIdentifier_t keyID, uint32_t keyIndex )
{
 8031128:	b530      	push	{r4, r5, lr}
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    return SECURE_ELEMENT_ERROR;
#else /* LORAWAN_KMS == 1 */
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 803112a:	2300      	movs	r3, #0
 803112c:	2b09      	cmp	r3, #9
 803112e:	d813      	bhi.n	8031158 <SecureElementSetObjHandler+0x30>
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 8031130:	4a0a      	ldr	r2, [pc, #40]	; (803115c <SecureElementSetObjHandler+0x34>)
 8031132:	6814      	ldr	r4, [r2, #0]
 8031134:	001d      	movs	r5, r3
 8031136:	005a      	lsls	r2, r3, #1
 8031138:	18d2      	adds	r2, r2, r3
 803113a:	00d2      	lsls	r2, r2, #3
 803113c:	18a2      	adds	r2, r4, r2
 803113e:	7c12      	ldrb	r2, [r2, #16]
 8031140:	4282      	cmp	r2, r0
 8031142:	d002      	beq.n	803114a <SecureElementSetObjHandler+0x22>
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 8031144:	3301      	adds	r3, #1
 8031146:	b2db      	uxtb	r3, r3
 8031148:	e7f0      	b.n	803112c <SecureElementSetObjHandler+0x4>
        {
            SeNvm->KeyList[i].Object_Index = (CK_OBJECT_HANDLE) keyIndex;
 803114a:	005b      	lsls	r3, r3, #1
 803114c:	195d      	adds	r5, r3, r5
 803114e:	00ed      	lsls	r5, r5, #3
 8031150:	1964      	adds	r4, r4, r5
 8031152:	6261      	str	r1, [r4, #36]	; 0x24
            return SECURE_ELEMENT_SUCCESS;
 8031154:	2000      	movs	r0, #0
 8031156:	e000      	b.n	803115a <SecureElementSetObjHandler+0x32>
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8031158:	2003      	movs	r0, #3
#endif /* LORAWAN_KMS */
}
 803115a:	bd30      	pop	{r4, r5, pc}
 803115c:	2000b1c4 	.word	0x2000b1c4

08031160 <SecureElementInit>:
{
 8031160:	b530      	push	{r4, r5, lr}
 8031162:	b085      	sub	sp, #20
 8031164:	000c      	movs	r4, r1
    uint8_t devEUI[SE_EUI_SIZE] = LORAWAN_DEVICE_EUI;
 8031166:	aa02      	add	r2, sp, #8
 8031168:	4b34      	ldr	r3, [pc, #208]	; (803123c <SecureElementInit+0xdc>)
 803116a:	cb22      	ldmia	r3!, {r1, r5}
 803116c:	c222      	stmia	r2!, {r1, r5}
    uint8_t joinEUI[SE_EUI_SIZE] = LORAWAN_JOIN_EUI;
 803116e:	466a      	mov	r2, sp
 8031170:	4b33      	ldr	r3, [pc, #204]	; (8031240 <SecureElementInit+0xe0>)
 8031172:	cb22      	ldmia	r3!, {r1, r5}
 8031174:	c222      	stmia	r2!, {r1, r5}
    if (nvm == NULL)
 8031176:	2800      	cmp	r0, #0
 8031178:	d05b      	beq.n	8031232 <SecureElementInit+0xd2>
    SeNvm = nvm;
 803117a:	4d32      	ldr	r5, [pc, #200]	; (8031244 <SecureElementInit+0xe4>)
 803117c:	6028      	str	r0, [r5, #0]
    memcpy1((uint8_t *)SeNvm->DevEui, devEUI, SE_EUI_SIZE);
 803117e:	2208      	movs	r2, #8
 8031180:	a902      	add	r1, sp, #8
 8031182:	f000 fb0a 	bl	803179a <memcpy1>
    memcpy1((uint8_t *)SeNvm->JoinEui, joinEUI, SE_EUI_SIZE);
 8031186:	6828      	ldr	r0, [r5, #0]
 8031188:	3008      	adds	r0, #8
 803118a:	2208      	movs	r2, #8
 803118c:	4669      	mov	r1, sp
 803118e:	f000 fb04 	bl	803179a <memcpy1>
    SeNvm->KeyList[itr++].KeyID = APP_KEY;
 8031192:	682b      	ldr	r3, [r5, #0]
 8031194:	2200      	movs	r2, #0
 8031196:	741a      	strb	r2, [r3, #16]
    SeNvm->KeyList[itr++].KeyID = NWK_KEY;
 8031198:	3228      	adds	r2, #40	; 0x28
 803119a:	2101      	movs	r1, #1
 803119c:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr++].KeyID = NWK_S_KEY;
 803119e:	3218      	adds	r2, #24
 80311a0:	3101      	adds	r1, #1
 80311a2:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr++].KeyID = APP_S_KEY;
 80311a4:	3218      	adds	r2, #24
 80311a6:	3101      	adds	r1, #1
 80311a8:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr++].KeyID = MC_ROOT_KEY;
 80311aa:	3218      	adds	r2, #24
 80311ac:	3101      	adds	r1, #1
 80311ae:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr++].KeyID = MC_KE_KEY;
 80311b0:	3218      	adds	r2, #24
 80311b2:	317b      	adds	r1, #123	; 0x7b
 80311b4:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr++].KeyID = MC_KEY_0;
 80311b6:	3218      	adds	r2, #24
 80311b8:	3101      	adds	r1, #1
 80311ba:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr++].KeyID = MC_APP_S_KEY_0;
 80311bc:	3218      	adds	r2, #24
 80311be:	3101      	adds	r1, #1
 80311c0:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr++].KeyID = MC_NWK_S_KEY_0;
 80311c2:	3218      	adds	r2, #24
 80311c4:	3101      	adds	r1, #1
 80311c6:	5499      	strb	r1, [r3, r2]
    SeNvm->KeyList[itr].KeyID = SLOT_RAND_ZERO_KEY;
 80311c8:	3218      	adds	r2, #24
 80311ca:	3101      	adds	r1, #1
 80311cc:	5499      	strb	r1, [r3, r2]
    DeleteAllDynamicKeys();
 80311ce:	f7ff fd6d 	bl	8030cac <DeleteAllDynamicKeys>
    SecureElementSetObjHandler(APP_KEY, KMS_APP_KEY_OBJECT_HANDLE);
 80311d2:	2102      	movs	r1, #2
 80311d4:	2000      	movs	r0, #0
 80311d6:	f7ff ffa7 	bl	8031128 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_KEY, KMS_NWK_KEY_OBJECT_HANDLE);
 80311da:	2103      	movs	r1, #3
 80311dc:	2001      	movs	r0, #1
 80311de:	f7ff ffa3 	bl	8031128 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(APP_S_KEY, KMS_APP_S_KEY_OBJECT_HANDLE);
 80311e2:	2105      	movs	r1, #5
 80311e4:	2003      	movs	r0, #3
 80311e6:	f7ff ff9f 	bl	8031128 <SecureElementSetObjHandler>
    SecureElementSetObjHandler(NWK_S_KEY, KMS_NWK_S_KEY_OBJECT_HANDLE);
 80311ea:	2104      	movs	r1, #4
 80311ec:	2002      	movs	r0, #2
 80311ee:	f7ff ff9b 	bl	8031128 <SecureElementSetObjHandler>
    MW_LOG(TS_OFF, VLEVEL_M, "###### OTAA ######\r\n");
 80311f2:	4b15      	ldr	r3, [pc, #84]	; (8031248 <SecureElementInit+0xe8>)
 80311f4:	2200      	movs	r2, #0
 80311f6:	2100      	movs	r1, #0
 80311f8:	2002      	movs	r0, #2
 80311fa:	f002 fc5d 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_KEY);
 80311fe:	2000      	movs	r0, #0
 8031200:	f7ff fe84 	bl	8030f0c <PrintKey>
    PrintKey(NWK_KEY);
 8031204:	2001      	movs	r0, #1
 8031206:	f7ff fe81 	bl	8030f0c <PrintKey>
    MW_LOG(TS_OFF, VLEVEL_M, "###### ABP  ######\r\n");
 803120a:	4b10      	ldr	r3, [pc, #64]	; (803124c <SecureElementInit+0xec>)
 803120c:	2200      	movs	r2, #0
 803120e:	2100      	movs	r1, #0
 8031210:	2002      	movs	r0, #2
 8031212:	f002 fc51 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_S_KEY);
 8031216:	2003      	movs	r0, #3
 8031218:	f7ff fe78 	bl	8030f0c <PrintKey>
    PrintKey(NWK_S_KEY);
 803121c:	2002      	movs	r0, #2
 803121e:	f7ff fe75 	bl	8030f0c <PrintKey>
    if (seGetUniqueId != NULL)
 8031222:	2c00      	cmp	r4, #0
 8031224:	d007      	beq.n	8031236 <SecureElementInit+0xd6>
        seGetUniqueId(SeNvm->DevEui);
 8031226:	4b07      	ldr	r3, [pc, #28]	; (8031244 <SecureElementInit+0xe4>)
 8031228:	6818      	ldr	r0, [r3, #0]
 803122a:	47a0      	blx	r4
    return SECURE_ELEMENT_SUCCESS;
 803122c:	2000      	movs	r0, #0
}
 803122e:	b005      	add	sp, #20
 8031230:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8031232:	2002      	movs	r0, #2
 8031234:	e7fb      	b.n	803122e <SecureElementInit+0xce>
    return SECURE_ELEMENT_SUCCESS;
 8031236:	2000      	movs	r0, #0
 8031238:	e7f9      	b.n	803122e <SecureElementInit+0xce>
 803123a:	46c0      	nop			; (mov r8, r8)
 803123c:	080348ec 	.word	0x080348ec
 8031240:	08035588 	.word	0x08035588
 8031244:	2000b1c4 	.word	0x2000b1c4
 8031248:	08035558 	.word	0x08035558
 803124c:	08035570 	.word	0x08035570

08031250 <SecureElementComputeAesCmac>:
#endif /* LORAWAN_KMS */
}

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,
                                                   KeyIdentifier_t keyID, uint32_t* cmac )
{
 8031250:	b510      	push	{r4, lr}
 8031252:	b082      	sub	sp, #8
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 8031254:	2b7e      	cmp	r3, #126	; 0x7e
 8031256:	d805      	bhi.n	8031264 <SecureElementComputeAesCmac+0x14>
    {
        // Never accept multicast key identifier for cmac computation
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 8031258:	9c04      	ldr	r4, [sp, #16]
 803125a:	9400      	str	r4, [sp, #0]
 803125c:	f7ff fd70 	bl	8030d40 <ComputeCmac>
}
 8031260:	b002      	add	sp, #8
 8031262:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8031264:	2003      	movs	r0, #3
 8031266:	e7fb      	b.n	8031260 <SecureElementComputeAesCmac+0x10>

08031268 <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
 8031268:	b5f0      	push	{r4, r5, r6, r7, lr}
 803126a:	b08b      	sub	sp, #44	; 0x2c
 803126c:	0005      	movs	r5, r0
 803126e:	000e      	movs	r6, r1
 8031270:	9203      	str	r2, [sp, #12]
 8031272:	0018      	movs	r0, r3
    if( buffer == NULL )
 8031274:	2d00      	cmp	r5, #0
 8031276:	d036      	beq.n	80312e6 <SecureElementVerifyAesCmac+0x7e>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, (CK_VOID_PTR)NULL, 0 };
 8031278:	4b1c      	ldr	r3, [pc, #112]	; (80312ec <SecureElementVerifyAesCmac+0x84>)
 803127a:	9305      	str	r3, [sp, #20]
 803127c:	2300      	movs	r3, #0
 803127e:	9306      	str	r3, [sp, #24]
 8031280:	9307      	str	r3, [sp, #28]

    retval = GetKeyIndexByID(keyID, &object_handle);
 8031282:	a908      	add	r1, sp, #32
 8031284:	f7ff fca6 	bl	8030bd4 <GetKeyIndexByID>
 8031288:	1e04      	subs	r4, r0, #0
    if (retval != SECURE_ELEMENT_SUCCESS)
 803128a:	d002      	beq.n	8031292 <SecureElementVerifyAesCmac+0x2a>
    }

#endif /* LORAWAN_KMS */

    return retval;
}
 803128c:	0020      	movs	r0, r4
 803128e:	b00b      	add	sp, #44	; 0x2c
 8031290:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8031292:	ab09      	add	r3, sp, #36	; 0x24
 8031294:	9300      	str	r3, [sp, #0]
 8031296:	2300      	movs	r3, #0
 8031298:	2200      	movs	r2, #0
 803129a:	2104      	movs	r1, #4
 803129c:	2000      	movs	r0, #0
 803129e:	f7f5 ff8b 	bl	80271b8 <KMS_OpenSession>
 80312a2:	1e07      	subs	r7, r0, #0
    if (rv == CKR_OK)
 80312a4:	d008      	beq.n	80312b8 <SecureElementVerifyAesCmac+0x50>
    if (rv == CKR_OK)
 80312a6:	2f00      	cmp	r7, #0
 80312a8:	d00d      	beq.n	80312c6 <SecureElementVerifyAesCmac+0x5e>
    (void)C_CloseSession(session);
 80312aa:	9809      	ldr	r0, [sp, #36]	; 0x24
 80312ac:	f7f5 ffc6 	bl	802723c <KMS_CloseSession>
    if (rv != CKR_OK)
 80312b0:	2f00      	cmp	r7, #0
 80312b2:	d0eb      	beq.n	803128c <SecureElementVerifyAesCmac+0x24>
        retval = SECURE_ELEMENT_ERROR;
 80312b4:	2406      	movs	r4, #6
 80312b6:	e7e9      	b.n	803128c <SecureElementVerifyAesCmac+0x24>
        rv = C_VerifyInit(session, &aes_cmac_mechanism, object_handle);
 80312b8:	9a08      	ldr	r2, [sp, #32]
 80312ba:	a905      	add	r1, sp, #20
 80312bc:	9809      	ldr	r0, [sp, #36]	; 0x24
 80312be:	f7f7 fc77 	bl	8028bb0 <KMS_VerifyInit>
 80312c2:	0007      	movs	r7, r0
 80312c4:	e7ef      	b.n	80312a6 <SecureElementVerifyAesCmac+0x3e>
        memcpy1(input_align_combined_buf, buffer, size);
 80312c6:	4f0a      	ldr	r7, [pc, #40]	; (80312f0 <SecureElementVerifyAesCmac+0x88>)
 80312c8:	0032      	movs	r2, r6
 80312ca:	0029      	movs	r1, r5
 80312cc:	0038      	movs	r0, r7
 80312ce:	f000 fa64 	bl	803179a <memcpy1>
        rv = C_Verify(session, (CK_BYTE_PTR)input_align_combined_buf, size, (CK_BYTE_PTR)&expectedCmac, 4);
 80312d2:	2304      	movs	r3, #4
 80312d4:	9300      	str	r3, [sp, #0]
 80312d6:	ab03      	add	r3, sp, #12
 80312d8:	0032      	movs	r2, r6
 80312da:	0039      	movs	r1, r7
 80312dc:	9809      	ldr	r0, [sp, #36]	; 0x24
 80312de:	f7f7 fc79 	bl	8028bd4 <KMS_Verify>
 80312e2:	0007      	movs	r7, r0
 80312e4:	e7e1      	b.n	80312aa <SecureElementVerifyAesCmac+0x42>
        return SECURE_ELEMENT_ERROR_NPE;
 80312e6:	2402      	movs	r4, #2
 80312e8:	e7d0      	b.n	803128c <SecureElementVerifyAesCmac+0x24>
 80312ea:	46c0      	nop			; (mov r8, r8)
 80312ec:	0000108a 	.word	0x0000108a
 80312f0:	2000b1c8 	.word	0x2000b1c8

080312f4 <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                               uint8_t* encBuffer )
{
 80312f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80312f6:	46c6      	mov	lr, r8
 80312f8:	b500      	push	{lr}
 80312fa:	b090      	sub	sp, #64	; 0x40
 80312fc:	0004      	movs	r4, r0
 80312fe:	000d      	movs	r5, r1
 8031300:	9203      	str	r2, [sp, #12]
 8031302:	001e      	movs	r6, r3
    if( buffer == NULL || encBuffer == NULL )
 8031304:	2800      	cmp	r0, #0
 8031306:	d059      	beq.n	80313bc <SecureElementAesEncrypt+0xc8>
 8031308:	2b00      	cmp	r3, #0
 803130a:	d059      	beq.n	80313c0 <SecureElementAesEncrypt+0xcc>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check if the size is divisible by 16,
    if( ( size % 16 ) != 0 )
 803130c:	070b      	lsls	r3, r1, #28
 803130e:	d159      	bne.n	80313c4 <SecureElementAesEncrypt+0xd0>
    }
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    uint32_t encrypted_length = 0;
 8031310:	2700      	movs	r7, #0
 8031312:	970e      	str	r7, [sp, #56]	; 0x38
    CK_OBJECT_HANDLE object_handle;
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
 8031314:	9709      	str	r7, [sp, #36]	; 0x24
 8031316:	220c      	movs	r2, #12
 8031318:	2100      	movs	r1, #0
 803131a:	a80a      	add	r0, sp, #40	; 0x28
 803131c:	f003 fa03 	bl	8034726 <memset>
    uint32_t dummy_tag_lenth = 0;
 8031320:	9708      	str	r7, [sp, #32]

    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, (CK_VOID_PTR *) NULL, 0 };
 8031322:	4b2b      	ldr	r3, [pc, #172]	; (80313d0 <SecureElementAesEncrypt+0xdc>)
 8031324:	9305      	str	r3, [sp, #20]
 8031326:	9706      	str	r7, [sp, #24]
 8031328:	9707      	str	r7, [sp, #28]

    SecureElementStatus_t retval = GetKeyIndexByID(keyID, &object_handle);
 803132a:	a90d      	add	r1, sp, #52	; 0x34
 803132c:	9803      	ldr	r0, [sp, #12]
 803132e:	f7ff fc51 	bl	8030bd4 <GetKeyIndexByID>
 8031332:	1e07      	subs	r7, r0, #0
    if (retval != SECURE_ELEMENT_SUCCESS)
 8031334:	d147      	bne.n	80313c6 <SecureElementAesEncrypt+0xd2>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 8031336:	ab0f      	add	r3, sp, #60	; 0x3c
 8031338:	9300      	str	r3, [sp, #0]
 803133a:	2300      	movs	r3, #0
 803133c:	2200      	movs	r2, #0
 803133e:	2104      	movs	r1, #4
 8031340:	2000      	movs	r0, #0
 8031342:	f7f5 ff39 	bl	80271b8 <KMS_OpenSession>
 8031346:	4680      	mov	r8, r0

    /* Configure session to encrypt message in AES ECB with settings included into the mechanism */
    if (rv == CKR_OK)
 8031348:	2800      	cmp	r0, #0
 803134a:	d00d      	beq.n	8031368 <SecureElementAesEncrypt+0x74>
    {
        rv = C_EncryptInit(session, &aes_ecb_mechanism, object_handle);
    }

    /* Encrypt clear message */
    if (rv == CKR_OK)
 803134c:	4643      	mov	r3, r8
 803134e:	2b00      	cmp	r3, #0
 8031350:	d011      	beq.n	8031376 <SecureElementAesEncrypt+0x82>
                             output_align, (CK_ULONG_PTR)&encrypted_length);
        memcpy1(encBuffer, output_align, size);
    }

    /* In this case C_EncryptFinal is just called to Free the Alloc mem */
    if (rv == CKR_OK)
 8031352:	4643      	mov	r3, r8
 8031354:	2b00      	cmp	r3, #0
 8031356:	d028      	beq.n	80313aa <SecureElementAesEncrypt+0xb6>
        dummy_tag_lenth = sizeof(tag);
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
    }

    /* Close session with KMS */
    (void)C_CloseSession(session);
 8031358:	980f      	ldr	r0, [sp, #60]	; 0x3c
 803135a:	f7f5 ff6f 	bl	802723c <KMS_CloseSession>

    if (rv != CKR_OK)
 803135e:	4643      	mov	r3, r8
 8031360:	2b00      	cmp	r3, #0
 8031362:	d030      	beq.n	80313c6 <SecureElementAesEncrypt+0xd2>
    {
        retval = SECURE_ELEMENT_ERROR;
 8031364:	2706      	movs	r7, #6
 8031366:	e02e      	b.n	80313c6 <SecureElementAesEncrypt+0xd2>
        rv = C_EncryptInit(session, &aes_ecb_mechanism, object_handle);
 8031368:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 803136a:	a905      	add	r1, sp, #20
 803136c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 803136e:	f7f5 fd89 	bl	8026e84 <KMS_EncryptInit>
 8031372:	4680      	mov	r8, r0
 8031374:	e7ea      	b.n	803134c <SecureElementAesEncrypt+0x58>
        memcpy1(input_align_combined_buf, buffer, size);
 8031376:	4b17      	ldr	r3, [pc, #92]	; (80313d4 <SecureElementAesEncrypt+0xe0>)
 8031378:	4698      	mov	r8, r3
 803137a:	002a      	movs	r2, r5
 803137c:	0021      	movs	r1, r4
 803137e:	0018      	movs	r0, r3
 8031380:	f000 fa0b 	bl	803179a <memcpy1>
        encrypted_length = sizeof(output_align);
 8031384:	2387      	movs	r3, #135	; 0x87
 8031386:	005b      	lsls	r3, r3, #1
 8031388:	930e      	str	r3, [sp, #56]	; 0x38
        rv = C_EncryptUpdate(session, (CK_BYTE_PTR)input_align_combined_buf, size,
 803138a:	4c13      	ldr	r4, [pc, #76]	; (80313d8 <SecureElementAesEncrypt+0xe4>)
 803138c:	ab0e      	add	r3, sp, #56	; 0x38
 803138e:	9300      	str	r3, [sp, #0]
 8031390:	0023      	movs	r3, r4
 8031392:	002a      	movs	r2, r5
 8031394:	4641      	mov	r1, r8
 8031396:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8031398:	f7f5 fd7a 	bl	8026e90 <KMS_EncryptUpdate>
 803139c:	4680      	mov	r8, r0
        memcpy1(encBuffer, output_align, size);
 803139e:	002a      	movs	r2, r5
 80313a0:	0021      	movs	r1, r4
 80313a2:	0030      	movs	r0, r6
 80313a4:	f000 f9f9 	bl	803179a <memcpy1>
 80313a8:	e7d3      	b.n	8031352 <SecureElementAesEncrypt+0x5e>
        dummy_tag_lenth = sizeof(tag);
 80313aa:	3310      	adds	r3, #16
 80313ac:	9308      	str	r3, [sp, #32]
        rv = C_EncryptFinal(session, &dummy_tag[0], (CK_ULONG_PTR)&dummy_tag_lenth);
 80313ae:	aa08      	add	r2, sp, #32
 80313b0:	a909      	add	r1, sp, #36	; 0x24
 80313b2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80313b4:	f7f5 fe34 	bl	8027020 <KMS_EncryptFinal>
 80313b8:	4680      	mov	r8, r0
 80313ba:	e7cd      	b.n	8031358 <SecureElementAesEncrypt+0x64>
        return SECURE_ELEMENT_ERROR_NPE;
 80313bc:	2702      	movs	r7, #2
 80313be:	e002      	b.n	80313c6 <SecureElementAesEncrypt+0xd2>
 80313c0:	2702      	movs	r7, #2
 80313c2:	e000      	b.n	80313c6 <SecureElementAesEncrypt+0xd2>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 80313c4:	2705      	movs	r7, #5
    }
#endif /* LORAWAN_KMS */

    return retval;
}
 80313c6:	0038      	movs	r0, r7
 80313c8:	b010      	add	sp, #64	; 0x40
 80313ca:	bc80      	pop	{r7}
 80313cc:	46b8      	mov	r8, r7
 80313ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80313d0:	00001081 	.word	0x00001081
 80313d4:	2000b1c8 	.word	0x2000b1c8
 80313d8:	2000b2e8 	.word	0x2000b2e8

080313dc <SecureElementSetKey>:
{
 80313dc:	b570      	push	{r4, r5, r6, lr}
 80313de:	b0a0      	sub	sp, #128	; 0x80
 80313e0:	0005      	movs	r5, r0
 80313e2:	1e0c      	subs	r4, r1, #0
    if( key == NULL )
 80313e4:	d100      	bne.n	80313e8 <SecureElementSetKey+0xc>
 80313e6:	e0c2      	b.n	803156e <SecureElementSetKey+0x192>
    CK_ULONG template_class = CKO_SECRET_KEY;
 80313e8:	2304      	movs	r3, #4
 80313ea:	931d      	str	r3, [sp, #116]	; 0x74
    CK_ULONG template_type = CKK_AES;
 80313ec:	331b      	adds	r3, #27
 80313ee:	931c      	str	r3, [sp, #112]	; 0x70
    CK_ULONG template_true = CK_TRUE;
 80313f0:	2201      	movs	r2, #1
 80313f2:	921b      	str	r2, [sp, #108]	; 0x6c
        key[3]  | (key[2] << 8)  | (key[1] << 16)  | (key[0] << 24),
 80313f4:	78cb      	ldrb	r3, [r1, #3]
 80313f6:	7889      	ldrb	r1, [r1, #2]
 80313f8:	0209      	lsls	r1, r1, #8
 80313fa:	430b      	orrs	r3, r1
 80313fc:	7861      	ldrb	r1, [r4, #1]
 80313fe:	0409      	lsls	r1, r1, #16
 8031400:	430b      	orrs	r3, r1
 8031402:	7821      	ldrb	r1, [r4, #0]
 8031404:	0609      	lsls	r1, r1, #24
 8031406:	430b      	orrs	r3, r1
    uint32_t key_ui32[] =
 8031408:	a917      	add	r1, sp, #92	; 0x5c
 803140a:	9317      	str	r3, [sp, #92]	; 0x5c
        key[7]  | (key[6] << 8)  | (key[5] << 16)  | (key[4] << 24),
 803140c:	79e3      	ldrb	r3, [r4, #7]
 803140e:	79a0      	ldrb	r0, [r4, #6]
 8031410:	0200      	lsls	r0, r0, #8
 8031412:	4303      	orrs	r3, r0
 8031414:	7960      	ldrb	r0, [r4, #5]
 8031416:	0400      	lsls	r0, r0, #16
 8031418:	4303      	orrs	r3, r0
 803141a:	7920      	ldrb	r0, [r4, #4]
 803141c:	0600      	lsls	r0, r0, #24
 803141e:	4303      	orrs	r3, r0
    uint32_t key_ui32[] =
 8031420:	9318      	str	r3, [sp, #96]	; 0x60
        key[11] | (key[10] << 8) | (key[9] << 16)  | (key[8] << 24),
 8031422:	7ae3      	ldrb	r3, [r4, #11]
 8031424:	7aa0      	ldrb	r0, [r4, #10]
 8031426:	0200      	lsls	r0, r0, #8
 8031428:	4303      	orrs	r3, r0
 803142a:	7a60      	ldrb	r0, [r4, #9]
 803142c:	0400      	lsls	r0, r0, #16
 803142e:	4303      	orrs	r3, r0
 8031430:	7a20      	ldrb	r0, [r4, #8]
 8031432:	0600      	lsls	r0, r0, #24
 8031434:	4303      	orrs	r3, r0
    uint32_t key_ui32[] =
 8031436:	9319      	str	r3, [sp, #100]	; 0x64
        key[15] | (key[14] << 8) | (key[13] << 16) | (key[12] << 24),
 8031438:	7be3      	ldrb	r3, [r4, #15]
 803143a:	7ba0      	ldrb	r0, [r4, #14]
 803143c:	0200      	lsls	r0, r0, #8
 803143e:	4303      	orrs	r3, r0
 8031440:	7b60      	ldrb	r0, [r4, #13]
 8031442:	0400      	lsls	r0, r0, #16
 8031444:	4303      	orrs	r3, r0
 8031446:	7b20      	ldrb	r0, [r4, #12]
 8031448:	0600      	lsls	r0, r0, #24
 803144a:	4303      	orrs	r3, r0
    uint32_t key_ui32[] =
 803144c:	931a      	str	r3, [sp, #104]	; 0x68
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 803144e:	ab15      	add	r3, sp, #84	; 0x54
 8031450:	484b      	ldr	r0, [pc, #300]	; (8031580 <SecureElementSetKey+0x1a4>)
 8031452:	9015      	str	r0, [sp, #84]	; 0x54
 8031454:	2000      	movs	r0, #0
 8031456:	9016      	str	r0, [sp, #88]	; 0x58
    CK_ATTRIBUTE key_attribute_template[] =
 8031458:	9006      	str	r0, [sp, #24]
 803145a:	a81d      	add	r0, sp, #116	; 0x74
 803145c:	9007      	str	r0, [sp, #28]
 803145e:	9208      	str	r2, [sp, #32]
 8031460:	2080      	movs	r0, #128	; 0x80
 8031462:	0040      	lsls	r0, r0, #1
 8031464:	9009      	str	r0, [sp, #36]	; 0x24
 8031466:	a81c      	add	r0, sp, #112	; 0x70
 8031468:	900a      	str	r0, [sp, #40]	; 0x28
 803146a:	920b      	str	r2, [sp, #44]	; 0x2c
 803146c:	2011      	movs	r0, #17
 803146e:	900c      	str	r0, [sp, #48]	; 0x30
 8031470:	910d      	str	r1, [sp, #52]	; 0x34
 8031472:	2110      	movs	r1, #16
 8031474:	910e      	str	r1, [sp, #56]	; 0x38
 8031476:	3153      	adds	r1, #83	; 0x53
 8031478:	31ff      	adds	r1, #255	; 0xff
 803147a:	910f      	str	r1, [sp, #60]	; 0x3c
 803147c:	a91b      	add	r1, sp, #108	; 0x6c
 803147e:	9110      	str	r1, [sp, #64]	; 0x40
 8031480:	9211      	str	r2, [sp, #68]	; 0x44
 8031482:	3202      	adds	r2, #2
 8031484:	9212      	str	r2, [sp, #72]	; 0x48
 8031486:	9313      	str	r3, [sp, #76]	; 0x4c
 8031488:	2308      	movs	r3, #8
 803148a:	9314      	str	r3, [sp, #80]	; 0x50
    if ( keyID == MC_KEY_0 )
 803148c:	2d80      	cmp	r5, #128	; 0x80
 803148e:	d021      	beq.n	80314d4 <SecureElementSetKey+0xf8>
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(keyID, &key_handle))
 8031490:	a91e      	add	r1, sp, #120	; 0x78
 8031492:	0028      	movs	r0, r5
 8031494:	f7ff fb9e 	bl	8030bd4 <GetKeyIndexByID>
 8031498:	2800      	cmp	r0, #0
 803149a:	d16a      	bne.n	8031572 <SecureElementSetKey+0x196>
    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(keyID, &specific_label[1]))
 803149c:	a916      	add	r1, sp, #88	; 0x58
 803149e:	0028      	movs	r0, r5
 80314a0:	f7ff fde6 	bl	8031070 <SecureElementDeleteDynamicKeys>
 80314a4:	2800      	cmp	r0, #0
 80314a6:	d168      	bne.n	803157a <SecureElementSetKey+0x19e>
    rv = C_OpenSession(0, session_flags, NULL, 0, &session);
 80314a8:	ab1f      	add	r3, sp, #124	; 0x7c
 80314aa:	9300      	str	r3, [sp, #0]
 80314ac:	2300      	movs	r3, #0
 80314ae:	2200      	movs	r2, #0
 80314b0:	2104      	movs	r1, #4
 80314b2:	f7f5 fe81 	bl	80271b8 <KMS_OpenSession>
 80314b6:	1e04      	subs	r4, r0, #0
    if (rv == CKR_OK)
 80314b8:	d04b      	beq.n	8031552 <SecureElementSetKey+0x176>
    if (rv == CKR_OK)
 80314ba:	2c00      	cmp	r4, #0
 80314bc:	d051      	beq.n	8031562 <SecureElementSetKey+0x186>
    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 80314be:	2606      	movs	r6, #6
    PrintKey(keyID);
 80314c0:	0028      	movs	r0, r5
 80314c2:	f7ff fd23 	bl	8030f0c <PrintKey>
    (void)C_CloseSession(session);
 80314c6:	981f      	ldr	r0, [sp, #124]	; 0x7c
 80314c8:	f7f5 feb8 	bl	802723c <KMS_CloseSession>
    if (rv != CKR_OK)
 80314cc:	2c00      	cmp	r4, #0
 80314ce:	d051      	beq.n	8031574 <SecureElementSetKey+0x198>
        retval = SECURE_ELEMENT_ERROR;
 80314d0:	2606      	movs	r6, #6
 80314d2:	e04f      	b.n	8031574 <SecureElementSetKey+0x198>
        uint8_t decryptedKey[16] = { 0 };
 80314d4:	2300      	movs	r3, #0
 80314d6:	9302      	str	r3, [sp, #8]
 80314d8:	3209      	adds	r2, #9
 80314da:	2100      	movs	r1, #0
 80314dc:	a803      	add	r0, sp, #12
 80314de:	f003 f922 	bl	8034726 <memset>
        if (SECURE_ELEMENT_SUCCESS != SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey ))
 80314e2:	ab02      	add	r3, sp, #8
 80314e4:	227f      	movs	r2, #127	; 0x7f
 80314e6:	2110      	movs	r1, #16
 80314e8:	0020      	movs	r0, r4
 80314ea:	f7ff ff03 	bl	80312f4 <SecureElementAesEncrypt>
 80314ee:	2800      	cmp	r0, #0
 80314f0:	d12d      	bne.n	803154e <SecureElementSetKey+0x172>
        key_ui32[0] = decryptedKey[3]  | (decryptedKey[2] << 8)  | (decryptedKey[1] << 16)  | (decryptedKey[0] << 24);
 80314f2:	ab02      	add	r3, sp, #8
 80314f4:	78da      	ldrb	r2, [r3, #3]
 80314f6:	7899      	ldrb	r1, [r3, #2]
 80314f8:	0209      	lsls	r1, r1, #8
 80314fa:	430a      	orrs	r2, r1
 80314fc:	7859      	ldrb	r1, [r3, #1]
 80314fe:	0409      	lsls	r1, r1, #16
 8031500:	430a      	orrs	r2, r1
 8031502:	7819      	ldrb	r1, [r3, #0]
 8031504:	0609      	lsls	r1, r1, #24
 8031506:	430a      	orrs	r2, r1
 8031508:	9217      	str	r2, [sp, #92]	; 0x5c
        key_ui32[1] = decryptedKey[7]  | (decryptedKey[6] << 8)  | (decryptedKey[5] << 16)  | (decryptedKey[4] << 24);
 803150a:	79da      	ldrb	r2, [r3, #7]
 803150c:	7999      	ldrb	r1, [r3, #6]
 803150e:	0209      	lsls	r1, r1, #8
 8031510:	430a      	orrs	r2, r1
 8031512:	7959      	ldrb	r1, [r3, #5]
 8031514:	0409      	lsls	r1, r1, #16
 8031516:	430a      	orrs	r2, r1
 8031518:	7919      	ldrb	r1, [r3, #4]
 803151a:	0609      	lsls	r1, r1, #24
 803151c:	430a      	orrs	r2, r1
 803151e:	9218      	str	r2, [sp, #96]	; 0x60
        key_ui32[2] = decryptedKey[11] | (decryptedKey[10] << 8) | (decryptedKey[9] << 16)  | (decryptedKey[8] << 24);
 8031520:	7ada      	ldrb	r2, [r3, #11]
 8031522:	7a99      	ldrb	r1, [r3, #10]
 8031524:	0209      	lsls	r1, r1, #8
 8031526:	430a      	orrs	r2, r1
 8031528:	7a59      	ldrb	r1, [r3, #9]
 803152a:	0409      	lsls	r1, r1, #16
 803152c:	430a      	orrs	r2, r1
 803152e:	7a19      	ldrb	r1, [r3, #8]
 8031530:	0609      	lsls	r1, r1, #24
 8031532:	430a      	orrs	r2, r1
 8031534:	9219      	str	r2, [sp, #100]	; 0x64
        key_ui32[3] = decryptedKey[15] | (decryptedKey[14] << 8) | (decryptedKey[13] << 16) | (decryptedKey[12] << 24);
 8031536:	7bda      	ldrb	r2, [r3, #15]
 8031538:	7b99      	ldrb	r1, [r3, #14]
 803153a:	0209      	lsls	r1, r1, #8
 803153c:	430a      	orrs	r2, r1
 803153e:	7b59      	ldrb	r1, [r3, #13]
 8031540:	0409      	lsls	r1, r1, #16
 8031542:	430a      	orrs	r2, r1
 8031544:	7b1b      	ldrb	r3, [r3, #12]
 8031546:	061b      	lsls	r3, r3, #24
 8031548:	4313      	orrs	r3, r2
 803154a:	931a      	str	r3, [sp, #104]	; 0x68
 803154c:	e7a0      	b.n	8031490 <SecureElementSetKey+0xb4>
            return SECURE_ELEMENT_ERROR;
 803154e:	2606      	movs	r6, #6
 8031550:	e010      	b.n	8031574 <SecureElementSetKey+0x198>
        rv = C_CreateObject(session, key_attribute_template, sizeof(key_attribute_template) / sizeof(CK_ATTRIBUTE),
 8031552:	ab1e      	add	r3, sp, #120	; 0x78
 8031554:	2205      	movs	r2, #5
 8031556:	a906      	add	r1, sp, #24
 8031558:	981f      	ldr	r0, [sp, #124]	; 0x7c
 803155a:	f7f5 f885 	bl	8026668 <KMS_CreateObject>
 803155e:	0004      	movs	r4, r0
 8031560:	e7ab      	b.n	80314ba <SecureElementSetKey+0xde>
        retval = SecureElementSetObjHandler(keyID, key_handle);
 8031562:	991e      	ldr	r1, [sp, #120]	; 0x78
 8031564:	0028      	movs	r0, r5
 8031566:	f7ff fddf 	bl	8031128 <SecureElementSetObjHandler>
 803156a:	0006      	movs	r6, r0
 803156c:	e7a8      	b.n	80314c0 <SecureElementSetKey+0xe4>
        return SECURE_ELEMENT_ERROR_NPE;
 803156e:	2602      	movs	r6, #2
 8031570:	e000      	b.n	8031574 <SecureElementSetKey+0x198>
        return SECURE_ELEMENT_ERROR;
 8031572:	2606      	movs	r6, #6
}
 8031574:	0030      	movs	r0, r6
 8031576:	b020      	add	sp, #128	; 0x80
 8031578:	bd70      	pop	{r4, r5, r6, pc}
        return SECURE_ELEMENT_ERROR;
 803157a:	2606      	movs	r6, #6
 803157c:	e7fa      	b.n	8031574 <SecureElementSetKey+0x198>
 803157e:	46c0      	nop			; (mov r8, r8)
 8031580:	444e524c 	.word	0x444e524c

08031584 <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( uint8_t* input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
 8031584:	b570      	push	{r4, r5, r6, lr}
 8031586:	b08e      	sub	sp, #56	; 0x38
 8031588:	0003      	movs	r3, r0
 803158a:	0008      	movs	r0, r1
 803158c:	0014      	movs	r4, r2
    if( input == NULL )
 803158e:	2b00      	cmp	r3, #0
 8031590:	d04b      	beq.n	803162a <SecureElementDeriveAndStoreKey+0xa6>
    }

    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;

    // In case of MC_KE_KEY, only McRootKey can be used as root key
    if( targetKeyID == MC_KE_KEY )
 8031592:	2a7f      	cmp	r2, #127	; 0x7f
 8031594:	d101      	bne.n	803159a <SecureElementDeriveAndStoreKey+0x16>
    {
        if( rootKeyID != MC_ROOT_KEY )
 8031596:	2904      	cmp	r1, #4
 8031598:	d149      	bne.n	803162e <SecureElementDeriveAndStoreKey+0xaa>
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    /* Key derivation */
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 803159a:	4a2a      	ldr	r2, [pc, #168]	; (8031644 <SecureElementDeriveAndStoreKey+0xc0>)
 803159c:	920a      	str	r2, [sp, #40]	; 0x28
 803159e:	930b      	str	r3, [sp, #44]	; 0x2c
 80315a0:	2310      	movs	r3, #16
 80315a2:	930c      	str	r3, [sp, #48]	; 0x30
    CK_OBJECT_HANDLE  derived_object_handle;
    CK_OBJECT_HANDLE    rootkey_object_handle;
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 80315a4:	ab06      	add	r3, sp, #24
 80315a6:	4a28      	ldr	r2, [pc, #160]	; (8031648 <SecureElementDeriveAndStoreKey+0xc4>)
 80315a8:	9206      	str	r2, [sp, #24]
 80315aa:	2200      	movs	r2, #0
 80315ac:	9207      	str	r2, [sp, #28]
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, (CK_VOID_PTR)specific_label, sizeof(specific_label)};
 80315ae:	3203      	adds	r2, #3
 80315b0:	9203      	str	r2, [sp, #12]
 80315b2:	9304      	str	r3, [sp, #16]
 80315b4:	2308      	movs	r3, #8
 80315b6:	9305      	str	r3, [sp, #20]

    /* Derive key */
    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(rootKeyID, &rootkey_object_handle))
 80315b8:	a908      	add	r1, sp, #32
 80315ba:	f7ff fb0b 	bl	8030bd4 <GetKeyIndexByID>
 80315be:	2800      	cmp	r0, #0
 80315c0:	d137      	bne.n	8031632 <SecureElementDeriveAndStoreKey+0xae>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != GetKeyIndexByID(targetKeyID, &derived_object_handle))
 80315c2:	a909      	add	r1, sp, #36	; 0x24
 80315c4:	0020      	movs	r0, r4
 80315c6:	f7ff fb05 	bl	8030bd4 <GetKeyIndexByID>
 80315ca:	2800      	cmp	r0, #0
 80315cc:	d135      	bne.n	803163a <SecureElementDeriveAndStoreKey+0xb6>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if (SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKeys(targetKeyID, &specific_label[1]))
 80315ce:	a907      	add	r1, sp, #28
 80315d0:	0020      	movs	r0, r4
 80315d2:	f7ff fd4d 	bl	8031070 <SecureElementDeleteDynamicKeys>
 80315d6:	2800      	cmp	r0, #0
 80315d8:	d131      	bne.n	803163e <SecureElementDeriveAndStoreKey+0xba>
    {
        return SECURE_ELEMENT_ERROR;
    }

    /* Open session with KMS */
    rv = C_OpenSession(0,    session_flags, NULL, 0, &session);
 80315da:	ab0d      	add	r3, sp, #52	; 0x34
 80315dc:	9300      	str	r3, [sp, #0]
 80315de:	2300      	movs	r3, #0
 80315e0:	2200      	movs	r2, #0
 80315e2:	2104      	movs	r1, #4
 80315e4:	f7f5 fde8 	bl	80271b8 <KMS_OpenSession>
 80315e8:	1e06      	subs	r6, r0, #0

    /* Derive key with pass phrase */
    if (rv == CKR_OK)
 80315ea:	d00c      	beq.n	8031606 <SecureElementDeriveAndStoreKey+0x82>
    {
        rv = C_DeriveKey(session, &(mech), rootkey_object_handle,
                         &DeriveKey_template, sizeof(DeriveKey_template) / sizeof(CK_ATTRIBUTE), &derived_object_handle);
    }

    if (rv == CKR_OK)
 80315ec:	2e00      	cmp	r6, #0
 80315ee:	d016      	beq.n	803161e <SecureElementDeriveAndStoreKey+0x9a>
    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;
 80315f0:	2506      	movs	r5, #6
    {
        /* Store Derived Index in table */
        retval = SecureElementSetObjHandler(targetKeyID, derived_object_handle);
    }

    PrintKey(targetKeyID);
 80315f2:	0020      	movs	r0, r4
 80315f4:	f7ff fc8a 	bl	8030f0c <PrintKey>

    /* Close session with KMS */
    (void)C_CloseSession(session);
 80315f8:	980d      	ldr	r0, [sp, #52]	; 0x34
 80315fa:	f7f5 fe1f 	bl	802723c <KMS_CloseSession>

    if (rv != CKR_OK)
 80315fe:	2e00      	cmp	r6, #0
 8031600:	d018      	beq.n	8031634 <SecureElementDeriveAndStoreKey+0xb0>
    {
        retval = SECURE_ELEMENT_ERROR;
 8031602:	2506      	movs	r5, #6
 8031604:	e016      	b.n	8031634 <SecureElementDeriveAndStoreKey+0xb0>
        rv = C_DeriveKey(session, &(mech), rootkey_object_handle,
 8031606:	ab09      	add	r3, sp, #36	; 0x24
 8031608:	9301      	str	r3, [sp, #4]
 803160a:	2301      	movs	r3, #1
 803160c:	9300      	str	r3, [sp, #0]
 803160e:	ab03      	add	r3, sp, #12
 8031610:	9a08      	ldr	r2, [sp, #32]
 8031612:	a90a      	add	r1, sp, #40	; 0x28
 8031614:	980d      	ldr	r0, [sp, #52]	; 0x34
 8031616:	f7f5 fe51 	bl	80272bc <KMS_DeriveKey>
 803161a:	0006      	movs	r6, r0
 803161c:	e7e6      	b.n	80315ec <SecureElementDeriveAndStoreKey+0x68>
        retval = SecureElementSetObjHandler(targetKeyID, derived_object_handle);
 803161e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8031620:	0020      	movs	r0, r4
 8031622:	f7ff fd81 	bl	8031128 <SecureElementSetObjHandler>
 8031626:	0005      	movs	r5, r0
 8031628:	e7e3      	b.n	80315f2 <SecureElementDeriveAndStoreKey+0x6e>
        return SECURE_ELEMENT_ERROR_NPE;
 803162a:	2502      	movs	r5, #2
 803162c:	e002      	b.n	8031634 <SecureElementDeriveAndStoreKey+0xb0>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 803162e:	2503      	movs	r5, #3
 8031630:	e000      	b.n	8031634 <SecureElementDeriveAndStoreKey+0xb0>
        return SECURE_ELEMENT_ERROR;
 8031632:	2506      	movs	r5, #6
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 8031634:	0028      	movs	r0, r5
 8031636:	b00e      	add	sp, #56	; 0x38
 8031638:	bd70      	pop	{r4, r5, r6, pc}
        return SECURE_ELEMENT_ERROR;
 803163a:	2506      	movs	r5, #6
 803163c:	e7fa      	b.n	8031634 <SecureElementDeriveAndStoreKey+0xb0>
        return SECURE_ELEMENT_ERROR;
 803163e:	2506      	movs	r5, #6
 8031640:	e7f8      	b.n	8031634 <SecureElementDeriveAndStoreKey+0xb0>
 8031642:	46c0      	nop			; (mov r8, r8)
 8031644:	00001104 	.word	0x00001104
 8031648:	444e524c 	.word	0x444e524c

0803164c <SecureElementProcessJoinAccept>:

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,
                                                      uint16_t devNonce, uint8_t* encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,
                                                      uint8_t* versionMinor )
{
 803164c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803164e:	001c      	movs	r4, r3
 8031650:	ab06      	add	r3, sp, #24
 8031652:	781d      	ldrb	r5, [r3, #0]
 8031654:	9e07      	ldr	r6, [sp, #28]
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8031656:	2c00      	cmp	r4, #0
 8031658:	d034      	beq.n	80316c4 <SecureElementProcessJoinAccept+0x78>
 803165a:	2e00      	cmp	r6, #0
 803165c:	d034      	beq.n	80316c8 <SecureElementProcessJoinAccept+0x7c>
 803165e:	9b08      	ldr	r3, [sp, #32]
 8031660:	2b00      	cmp	r3, #0
 8031662:	d033      	beq.n	80316cc <SecureElementProcessJoinAccept+0x80>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check that frame size isn't bigger than a JoinAccept with CFList size
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 8031664:	2d21      	cmp	r5, #33	; 0x21
 8031666:	d833      	bhi.n	80316d0 <SecureElementProcessJoinAccept+0x84>
    {
        encKeyID = J_S_ENC_KEY;
    }
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 8031668:	b2af      	uxth	r7, r5
 803166a:	003a      	movs	r2, r7
 803166c:	0021      	movs	r1, r4
 803166e:	0030      	movs	r0, r6
 8031670:	f000 f893 	bl	803179a <memcpy1>

    // Decrypt JoinAccept, skip MHDR
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 8031674:	1c73      	adds	r3, r6, #1
 8031676:	1e79      	subs	r1, r7, #1
 8031678:	b289      	uxth	r1, r1
 803167a:	1c60      	adds	r0, r4, #1
 803167c:	2201      	movs	r2, #1
 803167e:	f7ff fe39 	bl	80312f4 <SecureElementAesEncrypt>
 8031682:	2800      	cmp	r0, #0
 8031684:	d126      	bne.n	80316d4 <SecureElementProcessJoinAccept+0x88>
                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )
    {
        return SECURE_ELEMENT_FAIL_ENCRYPT;
    }

    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 8031686:	7af1      	ldrb	r1, [r6, #11]
 8031688:	09c9      	lsrs	r1, r1, #7
 803168a:	9b08      	ldr	r3, [sp, #32]
 803168c:	7019      	strb	r1, [r3, #0]

    uint32_t mic = 0;

    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );
 803168e:	1975      	adds	r5, r6, r5
 8031690:	1f2b      	subs	r3, r5, #4
 8031692:	781b      	ldrb	r3, [r3, #0]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );
 8031694:	1eea      	subs	r2, r5, #3
 8031696:	7812      	ldrb	r2, [r2, #0]
 8031698:	0212      	lsls	r2, r2, #8
 803169a:	4313      	orrs	r3, r2
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 803169c:	1eaa      	subs	r2, r5, #2
 803169e:	7812      	ldrb	r2, [r2, #0]
 80316a0:	0412      	lsls	r2, r2, #16
 80316a2:	431a      	orrs	r2, r3
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 80316a4:	3d01      	subs	r5, #1
 80316a6:	782b      	ldrb	r3, [r5, #0]
 80316a8:	061b      	lsls	r3, r3, #24
 80316aa:	431a      	orrs	r2, r3
    //  - Header buffer to be used for MIC computation
    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]

    // Verify mic
    if( *versionMinor == 0 )
 80316ac:	2900      	cmp	r1, #0
 80316ae:	d113      	bne.n	80316d8 <SecureElementProcessJoinAccept+0x8c>
    {
        // For LoRaWAN 1.0.x
        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
        //   CFListType)
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 80316b0:	1f39      	subs	r1, r7, #4
 80316b2:	b289      	uxth	r1, r1
 80316b4:	2301      	movs	r3, #1
 80316b6:	0030      	movs	r0, r6
 80316b8:	f7ff fdd6 	bl	8031268 <SecureElementVerifyAesCmac>
 80316bc:	2800      	cmp	r0, #0
 80316be:	d008      	beq.n	80316d2 <SecureElementProcessJoinAccept+0x86>
            SECURE_ELEMENT_SUCCESS )
        {
            return SECURE_ELEMENT_FAIL_CMAC;
 80316c0:	2001      	movs	r0, #1
 80316c2:	e006      	b.n	80316d2 <SecureElementProcessJoinAccept+0x86>
        return SECURE_ELEMENT_ERROR_NPE;
 80316c4:	2002      	movs	r0, #2
 80316c6:	e004      	b.n	80316d2 <SecureElementProcessJoinAccept+0x86>
 80316c8:	2002      	movs	r0, #2
 80316ca:	e002      	b.n	80316d2 <SecureElementProcessJoinAccept+0x86>
 80316cc:	2002      	movs	r0, #2
 80316ce:	e000      	b.n	80316d2 <SecureElementProcessJoinAccept+0x86>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 80316d0:	2005      	movs	r0, #5
    {
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
    }

    return SECURE_ELEMENT_SUCCESS;
}
 80316d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 80316d4:	2007      	movs	r0, #7
 80316d6:	e7fc      	b.n	80316d2 <SecureElementProcessJoinAccept+0x86>
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 80316d8:	2004      	movs	r0, #4
 80316da:	e7fa      	b.n	80316d2 <SecureElementProcessJoinAccept+0x86>

080316dc <SecureElementRandomNumber>:

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
 80316dc:	b510      	push	{r4, lr}
 80316de:	1e04      	subs	r4, r0, #0
    if( randomNum == NULL )
 80316e0:	d005      	beq.n	80316ee <SecureElementRandomNumber+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    *randomNum = Radio.Random();
 80316e2:	4b04      	ldr	r3, [pc, #16]	; (80316f4 <SecureElementRandomNumber+0x18>)
 80316e4:	695b      	ldr	r3, [r3, #20]
 80316e6:	4798      	blx	r3
 80316e8:	6020      	str	r0, [r4, #0]
    return SECURE_ELEMENT_SUCCESS;
 80316ea:	2000      	movs	r0, #0
}
 80316ec:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 80316ee:	2002      	movs	r0, #2
 80316f0:	e7fc      	b.n	80316ec <SecureElementRandomNumber+0x10>
 80316f2:	46c0      	nop			; (mov r8, r8)
 80316f4:	080356b4 	.word	0x080356b4

080316f8 <SecureElementSetDevEui>:

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
 80316f8:	b510      	push	{r4, lr}
 80316fa:	1e01      	subs	r1, r0, #0
    if( devEui == NULL )
 80316fc:	d006      	beq.n	803170c <SecureElementSetDevEui+0x14>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->DevEui, devEui, SE_EUI_SIZE );
 80316fe:	4b04      	ldr	r3, [pc, #16]	; (8031710 <SecureElementSetDevEui+0x18>)
 8031700:	6818      	ldr	r0, [r3, #0]
 8031702:	2208      	movs	r2, #8
 8031704:	f000 f849 	bl	803179a <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8031708:	2000      	movs	r0, #0
}
 803170a:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 803170c:	2002      	movs	r0, #2
 803170e:	e7fc      	b.n	803170a <SecureElementSetDevEui+0x12>
 8031710:	2000b1c4 	.word	0x2000b1c4

08031714 <SecureElementGetDevEui>:

uint8_t* SecureElementGetDevEui( void )
{
    return SeNvm->DevEui;
 8031714:	4b01      	ldr	r3, [pc, #4]	; (803171c <SecureElementGetDevEui+0x8>)
 8031716:	6818      	ldr	r0, [r3, #0]
}
 8031718:	4770      	bx	lr
 803171a:	46c0      	nop			; (mov r8, r8)
 803171c:	2000b1c4 	.word	0x2000b1c4

08031720 <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
 8031720:	b510      	push	{r4, lr}
 8031722:	1e01      	subs	r1, r0, #0
    if( joinEui == NULL )
 8031724:	d007      	beq.n	8031736 <SecureElementSetJoinEui+0x16>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->JoinEui, joinEui, SE_EUI_SIZE );
 8031726:	4b05      	ldr	r3, [pc, #20]	; (803173c <SecureElementSetJoinEui+0x1c>)
 8031728:	6818      	ldr	r0, [r3, #0]
 803172a:	3008      	adds	r0, #8
 803172c:	2208      	movs	r2, #8
 803172e:	f000 f834 	bl	803179a <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 8031732:	2000      	movs	r0, #0
}
 8031734:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8031736:	2002      	movs	r0, #2
 8031738:	e7fc      	b.n	8031734 <SecureElementSetJoinEui+0x14>
 803173a:	46c0      	nop			; (mov r8, r8)
 803173c:	2000b1c4 	.word	0x2000b1c4

08031740 <SecureElementGetJoinEui>:

uint8_t* SecureElementGetJoinEui( void )
{
    return SeNvm->JoinEui;
 8031740:	4b01      	ldr	r3, [pc, #4]	; (8031748 <SecureElementGetJoinEui+0x8>)
 8031742:	6818      	ldr	r0, [r3, #0]
 8031744:	3008      	adds	r0, #8
}
 8031746:	4770      	bx	lr
 8031748:	2000b1c4 	.word	0x2000b1c4

0803174c <rand1>:
static uint32_t next = 1;

static int32_t rand1( void );

static int32_t rand1( void )
{
 803174c:	b510      	push	{r4, lr}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 803174e:	4b06      	ldr	r3, [pc, #24]	; (8031768 <rand1+0x1c>)
 8031750:	4806      	ldr	r0, [pc, #24]	; (803176c <rand1+0x20>)
 8031752:	681a      	ldr	r2, [r3, #0]
 8031754:	4350      	muls	r0, r2
 8031756:	4a06      	ldr	r2, [pc, #24]	; (8031770 <rand1+0x24>)
 8031758:	4694      	mov	ip, r2
 803175a:	4460      	add	r0, ip
 803175c:	6018      	str	r0, [r3, #0]
 803175e:	4905      	ldr	r1, [pc, #20]	; (8031774 <rand1+0x28>)
 8031760:	f7ee fd60 	bl	8020224 <__aeabi_uidivmod>
 8031764:	0008      	movs	r0, r1
}
 8031766:	bd10      	pop	{r4, pc}
 8031768:	2000a0b4 	.word	0x2000a0b4
 803176c:	41c64e6d 	.word	0x41c64e6d
 8031770:	00003039 	.word	0x00003039
 8031774:	7fffffff 	.word	0x7fffffff

08031778 <srand1>:

void srand1( uint32_t seed )
{
    next = seed;
 8031778:	4b01      	ldr	r3, [pc, #4]	; (8031780 <srand1+0x8>)
 803177a:	6018      	str	r0, [r3, #0]
}
 803177c:	4770      	bx	lr
 803177e:	46c0      	nop			; (mov r8, r8)
 8031780:	2000a0b4 	.word	0x2000a0b4

08031784 <randr>:
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 8031784:	b570      	push	{r4, r5, r6, lr}
 8031786:	0005      	movs	r5, r0
 8031788:	000c      	movs	r4, r1
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 803178a:	f7ff ffdf 	bl	803174c <rand1>
 803178e:	1b61      	subs	r1, r4, r5
 8031790:	3101      	adds	r1, #1
 8031792:	f7ee fe31 	bl	80203f8 <__aeabi_idivmod>
 8031796:	1948      	adds	r0, r1, r5
}
 8031798:	bd70      	pop	{r4, r5, r6, pc}

0803179a <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 803179a:	1e53      	subs	r3, r2, #1
 803179c:	b29b      	uxth	r3, r3
 803179e:	2a00      	cmp	r2, #0
 80317a0:	d005      	beq.n	80317ae <memcpy1+0x14>
    {
        *dst++ = *src++;
 80317a2:	780a      	ldrb	r2, [r1, #0]
 80317a4:	7002      	strb	r2, [r0, #0]
    while( size-- )
 80317a6:	001a      	movs	r2, r3
        *dst++ = *src++;
 80317a8:	3101      	adds	r1, #1
 80317aa:	3001      	adds	r0, #1
 80317ac:	e7f5      	b.n	803179a <memcpy1>
    }
}
 80317ae:	4770      	bx	lr

080317b0 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
 80317b0:	1e53      	subs	r3, r2, #1
 80317b2:	18c0      	adds	r0, r0, r3
    while( size-- )
 80317b4:	1e53      	subs	r3, r2, #1
 80317b6:	b29b      	uxth	r3, r3
 80317b8:	2a00      	cmp	r2, #0
 80317ba:	d005      	beq.n	80317c8 <memcpyr+0x18>
    {
        *dst-- = *src++;
 80317bc:	780a      	ldrb	r2, [r1, #0]
 80317be:	7002      	strb	r2, [r0, #0]
    while( size-- )
 80317c0:	001a      	movs	r2, r3
        *dst-- = *src++;
 80317c2:	3101      	adds	r1, #1
 80317c4:	3801      	subs	r0, #1
 80317c6:	e7f5      	b.n	80317b4 <memcpyr+0x4>
    }
}
 80317c8:	4770      	bx	lr

080317ca <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 80317ca:	1e53      	subs	r3, r2, #1
 80317cc:	b29b      	uxth	r3, r3
 80317ce:	2a00      	cmp	r2, #0
 80317d0:	d003      	beq.n	80317da <memset1+0x10>
    {
        *dst++ = value;
 80317d2:	7001      	strb	r1, [r0, #0]
    while( size-- )
 80317d4:	001a      	movs	r2, r3
        *dst++ = value;
 80317d6:	3001      	adds	r0, #1
 80317d8:	e7f7      	b.n	80317ca <memset1>
    }
}
 80317da:	4770      	bx	lr

080317dc <Crc32>:
        return '?';
    }
}

uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
 80317dc:	b570      	push	{r4, r5, r6, lr}
 80317de:	1e06      	subs	r6, r0, #0
    const uint32_t reversedPolynom = 0xEDB88320;

    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 80317e0:	d018      	beq.n	8031814 <Crc32+0x38>
    {
        return 0;
    }

    for( uint16_t i = 0; i < length; ++i )
 80317e2:	2500      	movs	r5, #0
    uint32_t crc = 0xFFFFFFFF;
 80317e4:	2301      	movs	r3, #1
 80317e6:	425b      	negs	r3, r3
 80317e8:	e00c      	b.n	8031804 <Crc32+0x28>
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 80317ea:	085c      	lsrs	r4, r3, #1
 80317ec:	2001      	movs	r0, #1
 80317ee:	4003      	ands	r3, r0
 80317f0:	425b      	negs	r3, r3
 80317f2:	4809      	ldr	r0, [pc, #36]	; (8031818 <Crc32+0x3c>)
 80317f4:	4003      	ands	r3, r0
 80317f6:	4063      	eors	r3, r4
        for( uint16_t i = 0; i < 8; i++ )
 80317f8:	3201      	adds	r2, #1
 80317fa:	b292      	uxth	r2, r2
 80317fc:	2a07      	cmp	r2, #7
 80317fe:	d9f4      	bls.n	80317ea <Crc32+0xe>
    for( uint16_t i = 0; i < length; ++i )
 8031800:	3501      	adds	r5, #1
 8031802:	b2ad      	uxth	r5, r5
 8031804:	428d      	cmp	r5, r1
 8031806:	d203      	bcs.n	8031810 <Crc32+0x34>
        crc ^= ( uint32_t )buffer[i];
 8031808:	5d72      	ldrb	r2, [r6, r5]
 803180a:	4053      	eors	r3, r2
        for( uint16_t i = 0; i < 8; i++ )
 803180c:	2200      	movs	r2, #0
 803180e:	e7f5      	b.n	80317fc <Crc32+0x20>
        }
    }

    return ~crc;
 8031810:	43d8      	mvns	r0, r3
}
 8031812:	bd70      	pop	{r4, r5, r6, pc}
        return 0;
 8031814:	2000      	movs	r0, #0
 8031816:	e7fc      	b.n	8031812 <Crc32+0x36>
 8031818:	edb88320 	.word	0xedb88320

0803181c <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 803181c:	2001      	movs	r0, #1
 803181e:	4770      	bx	lr

08031820 <RadioGetLoRaBandwidthInHz>:

static uint32_t RadioGetLoRaBandwidthInHz( RadioLoRaBandwidths_t bw )
{
    uint32_t bandwidthInHz = 0;

    switch( bw )
 8031820:	280a      	cmp	r0, #10
 8031822:	d803      	bhi.n	803182c <RadioGetLoRaBandwidthInHz+0xc>
 8031824:	0080      	lsls	r0, r0, #2
 8031826:	4b0c      	ldr	r3, [pc, #48]	; (8031858 <RadioGetLoRaBandwidthInHz+0x38>)
 8031828:	581b      	ldr	r3, [r3, r0]
 803182a:	469f      	mov	pc, r3
        break;
    case LORA_BW_125:
        bandwidthInHz = 125000UL;
        break;
    case LORA_BW_250:
        bandwidthInHz = 250000UL;
 803182c:	2000      	movs	r0, #0
 803182e:	e012      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 10417UL;
 8031830:	480a      	ldr	r0, [pc, #40]	; (803185c <RadioGetLoRaBandwidthInHz+0x3c>)
        break;
 8031832:	e010      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 15625UL;
 8031834:	480a      	ldr	r0, [pc, #40]	; (8031860 <RadioGetLoRaBandwidthInHz+0x40>)
        break;
 8031836:	e00e      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 20833UL;
 8031838:	480a      	ldr	r0, [pc, #40]	; (8031864 <RadioGetLoRaBandwidthInHz+0x44>)
        break;
 803183a:	e00c      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 31250UL;
 803183c:	480a      	ldr	r0, [pc, #40]	; (8031868 <RadioGetLoRaBandwidthInHz+0x48>)
        break;
 803183e:	e00a      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 41667UL;
 8031840:	480a      	ldr	r0, [pc, #40]	; (803186c <RadioGetLoRaBandwidthInHz+0x4c>)
        break;
 8031842:	e008      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 62500UL;
 8031844:	480a      	ldr	r0, [pc, #40]	; (8031870 <RadioGetLoRaBandwidthInHz+0x50>)
        break;
 8031846:	e006      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 125000UL;
 8031848:	480a      	ldr	r0, [pc, #40]	; (8031874 <RadioGetLoRaBandwidthInHz+0x54>)
        break;
 803184a:	e004      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 250000UL;
 803184c:	480a      	ldr	r0, [pc, #40]	; (8031878 <RadioGetLoRaBandwidthInHz+0x58>)
        break;
 803184e:	e002      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_500:
        bandwidthInHz = 500000UL;
 8031850:	480a      	ldr	r0, [pc, #40]	; (803187c <RadioGetLoRaBandwidthInHz+0x5c>)
        break;
 8031852:	e000      	b.n	8031856 <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 7812UL;
 8031854:	480a      	ldr	r0, [pc, #40]	; (8031880 <RadioGetLoRaBandwidthInHz+0x60>)
    }

    return bandwidthInHz;
}
 8031856:	4770      	bx	lr
 8031858:	08035594 	.word	0x08035594
 803185c:	000028b1 	.word	0x000028b1
 8031860:	00003d09 	.word	0x00003d09
 8031864:	00005161 	.word	0x00005161
 8031868:	00007a12 	.word	0x00007a12
 803186c:	0000a2c3 	.word	0x0000a2c3
 8031870:	0000f424 	.word	0x0000f424
 8031874:	0001e848 	.word	0x0001e848
 8031878:	0003d090 	.word	0x0003d090
 803187c:	0007a120 	.word	0x0007a120
 8031880:	00001e84 	.word	0x00001e84

08031884 <RadioGetGfskTimeOnAirNumerator>:

static uint32_t RadioGetGfskTimeOnAirNumerator( uint32_t datarate, uint8_t coderate,
                                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                                bool crcOn )
{
 8031884:	b510      	push	{r4, lr}
 8031886:	a902      	add	r1, sp, #8
 8031888:	7809      	ldrb	r1, [r1, #0]
 803188a:	a803      	add	r0, sp, #12
 803188c:	7804      	ldrb	r4, [r0, #0]
    /* ST_WORKAROUND_BEGIN: Simplified calculation without const values */
    return ( preambleLen << 3 ) +
 803188e:	00d2      	lsls	r2, r2, #3
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8031890:	2b00      	cmp	r3, #0
 8031892:	d109      	bne.n	80318a8 <RadioGetGfskTimeOnAirNumerator+0x24>
 8031894:	2008      	movs	r0, #8
    return ( preambleLen << 3 ) +
 8031896:	1810      	adds	r0, r2, r0
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8031898:	3018      	adds	r0, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 803189a:	2c00      	cmp	r4, #0
 803189c:	d006      	beq.n	80318ac <RadioGetGfskTimeOnAirNumerator+0x28>
 803189e:	2202      	movs	r2, #2
 80318a0:	1889      	adds	r1, r1, r2
 80318a2:	00c9      	lsls	r1, r1, #3
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80318a4:	1840      	adds	r0, r0, r1
    /* ST_WORKAROUND_END */
}
 80318a6:	bd10      	pop	{r4, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80318a8:	2000      	movs	r0, #0
 80318aa:	e7f4      	b.n	8031896 <RadioGetGfskTimeOnAirNumerator+0x12>
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 80318ac:	2200      	movs	r2, #0
 80318ae:	e7f7      	b.n	80318a0 <RadioGetGfskTimeOnAirNumerator+0x1c>

080318b0 <RadioGetLoRaTimeOnAirNumerator>:

static uint32_t RadioGetLoRaTimeOnAirNumerator( uint32_t bandwidth,
                                                uint32_t datarate, uint8_t coderate,
                                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                                bool crcOn )
{
 80318b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80318b2:	000d      	movs	r5, r1
 80318b4:	001e      	movs	r6, r3
 80318b6:	ab06      	add	r3, sp, #24
 80318b8:	781b      	ldrb	r3, [r3, #0]
 80318ba:	a907      	add	r1, sp, #28
 80318bc:	780c      	ldrb	r4, [r1, #0]
 80318be:	a908      	add	r1, sp, #32
 80318c0:	7809      	ldrb	r1, [r1, #0]
    int32_t crDenom           = coderate + 4;
 80318c2:	1d17      	adds	r7, r2, #4
    bool    lowDatareOptimize = false;

    // Ensure that the preamble length is at least 12 symbols when using SF5 or SF6
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 80318c4:	1f6a      	subs	r2, r5, #5
 80318c6:	2a01      	cmp	r2, #1
 80318c8:	d92c      	bls.n	8031924 <RadioGetLoRaTimeOnAirNumerator+0x74>
        {
            preambleLen = 12;
        }
    }

    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 80318ca:	2800      	cmp	r0, #0
 80318cc:	d103      	bne.n	80318d6 <RadioGetLoRaTimeOnAirNumerator+0x26>
 80318ce:	002a      	movs	r2, r5
 80318d0:	3a0b      	subs	r2, #11
 80318d2:	2a01      	cmp	r2, #1
 80318d4:	d92e      	bls.n	8031934 <RadioGetLoRaTimeOnAirNumerator+0x84>
 80318d6:	2801      	cmp	r0, #1
 80318d8:	d028      	beq.n	803192c <RadioGetLoRaTimeOnAirNumerator+0x7c>
    bool    lowDatareOptimize = false;
 80318da:	2200      	movs	r2, #0
    {
        lowDatareOptimize = true;
    }

    int32_t ceilDenominator;
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 80318dc:	00e4      	lsls	r4, r4, #3
                            ( crcOn ? 16 : 0 ) -
 80318de:	2900      	cmp	r1, #0
 80318e0:	d02c      	beq.n	803193c <RadioGetLoRaTimeOnAirNumerator+0x8c>
 80318e2:	2010      	movs	r0, #16
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 80318e4:	1820      	adds	r0, r4, r0
                            ( 4 * datarate ) +
 80318e6:	00a9      	lsls	r1, r5, #2
                            ( crcOn ? 16 : 0 ) -
 80318e8:	1a40      	subs	r0, r0, r1
                            ( fixLen ? 0 : 20 );
 80318ea:	2b00      	cmp	r3, #0
 80318ec:	d028      	beq.n	8031940 <RadioGetLoRaTimeOnAirNumerator+0x90>
 80318ee:	2300      	movs	r3, #0
                            ( 4 * datarate ) +
 80318f0:	18c0      	adds	r0, r0, r3

    if( datarate <= 6 )
 80318f2:	2d06      	cmp	r5, #6
 80318f4:	d904      	bls.n	8031900 <RadioGetLoRaTimeOnAirNumerator+0x50>
    {
        ceilDenominator = 4 * datarate;
    }
    else
    {
        ceilNumerator += 8;
 80318f6:	3008      	adds	r0, #8

        if( lowDatareOptimize == true )
 80318f8:	2a00      	cmp	r2, #0
 80318fa:	d001      	beq.n	8031900 <RadioGetLoRaTimeOnAirNumerator+0x50>
        {
            ceilDenominator = 4 * ( datarate - 2 );
 80318fc:	1ea9      	subs	r1, r5, #2
 80318fe:	0089      	lsls	r1, r1, #2
        {
            ceilDenominator = 4 * datarate;
        }
    }

    if( ceilNumerator < 0 )
 8031900:	2800      	cmp	r0, #0
 8031902:	db1f      	blt.n	8031944 <RadioGetLoRaTimeOnAirNumerator+0x94>
        ceilNumerator = 0;
    }

    // Perform integral ceil()
    int32_t intermediate =
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 8031904:	1808      	adds	r0, r1, r0
 8031906:	3801      	subs	r0, #1
 8031908:	f7ee fc90 	bl	802022c <__divsi3>
 803190c:	4347      	muls	r7, r0
 803190e:	19f6      	adds	r6, r6, r7
    int32_t intermediate =
 8031910:	0030      	movs	r0, r6
 8031912:	300c      	adds	r0, #12

    if( datarate <= 6 )
 8031914:	2d06      	cmp	r5, #6
 8031916:	d800      	bhi.n	803191a <RadioGetLoRaTimeOnAirNumerator+0x6a>
    {
        intermediate += 2;
 8031918:	3002      	adds	r0, #2
    }

    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 803191a:	0080      	lsls	r0, r0, #2
 803191c:	3001      	adds	r0, #1
 803191e:	3d02      	subs	r5, #2
 8031920:	40a8      	lsls	r0, r5
}
 8031922:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( preambleLen < 12 )
 8031924:	2e0b      	cmp	r6, #11
 8031926:	d8d0      	bhi.n	80318ca <RadioGetLoRaTimeOnAirNumerator+0x1a>
            preambleLen = 12;
 8031928:	260c      	movs	r6, #12
 803192a:	e7ce      	b.n	80318ca <RadioGetLoRaTimeOnAirNumerator+0x1a>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 803192c:	2d0c      	cmp	r5, #12
 803192e:	d003      	beq.n	8031938 <RadioGetLoRaTimeOnAirNumerator+0x88>
    bool    lowDatareOptimize = false;
 8031930:	2200      	movs	r2, #0
 8031932:	e7d3      	b.n	80318dc <RadioGetLoRaTimeOnAirNumerator+0x2c>
        lowDatareOptimize = true;
 8031934:	2201      	movs	r2, #1
 8031936:	e7d1      	b.n	80318dc <RadioGetLoRaTimeOnAirNumerator+0x2c>
 8031938:	2201      	movs	r2, #1
 803193a:	e7cf      	b.n	80318dc <RadioGetLoRaTimeOnAirNumerator+0x2c>
                            ( crcOn ? 16 : 0 ) -
 803193c:	2000      	movs	r0, #0
 803193e:	e7d1      	b.n	80318e4 <RadioGetLoRaTimeOnAirNumerator+0x34>
                            ( fixLen ? 0 : 20 );
 8031940:	2314      	movs	r3, #20
 8031942:	e7d5      	b.n	80318f0 <RadioGetLoRaTimeOnAirNumerator+0x40>
        ceilNumerator = 0;
 8031944:	2000      	movs	r0, #0
 8031946:	e7dd      	b.n	8031904 <RadioGetLoRaTimeOnAirNumerator+0x54>

08031948 <RadioTimeOnAir>:

static uint32_t RadioTimeOnAir( RadioModems_t modem, uint32_t bandwidth,
                                uint32_t datarate, uint8_t coderate,
                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                bool crcOn )
{
 8031948:	b5f0      	push	{r4, r5, r6, r7, lr}
 803194a:	b085      	sub	sp, #20
 803194c:	000d      	movs	r5, r1
 803194e:	0016      	movs	r6, r2
 8031950:	0019      	movs	r1, r3
 8031952:	ab0a      	add	r3, sp, #40	; 0x28
 8031954:	881a      	ldrh	r2, [r3, #0]
 8031956:	ab0b      	add	r3, sp, #44	; 0x2c
 8031958:	781b      	ldrb	r3, [r3, #0]
 803195a:	ac0c      	add	r4, sp, #48	; 0x30
 803195c:	7827      	ldrb	r7, [r4, #0]
 803195e:	ac0d      	add	r4, sp, #52	; 0x34
 8031960:	7824      	ldrb	r4, [r4, #0]
    uint32_t numerator = 0;
    uint32_t denominator = 1;

    switch( modem )
 8031962:	2800      	cmp	r0, #0
 8031964:	d00a      	beq.n	803197c <RadioTimeOnAir+0x34>
 8031966:	2801      	cmp	r0, #1
 8031968:	d013      	beq.n	8031992 <RadioTimeOnAir+0x4a>
 803196a:	2601      	movs	r6, #1
 803196c:	2400      	movs	r4, #0
        break;
    default:
        break;
    }
    // Perform integral ceil()
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 803196e:	19a0      	adds	r0, r4, r6
 8031970:	3801      	subs	r0, #1
 8031972:	0031      	movs	r1, r6
 8031974:	f7ee fbd0 	bl	8020118 <__udivsi3>
}
 8031978:	b005      	add	sp, #20
 803197a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 803197c:	9401      	str	r4, [sp, #4]
 803197e:	9700      	str	r7, [sp, #0]
 8031980:	0030      	movs	r0, r6
 8031982:	f7ff ff7f 	bl	8031884 <RadioGetGfskTimeOnAirNumerator>
 8031986:	0144      	lsls	r4, r0, #5
 8031988:	1a24      	subs	r4, r4, r0
 803198a:	00a4      	lsls	r4, r4, #2
 803198c:	1824      	adds	r4, r4, r0
 803198e:	00e4      	lsls	r4, r4, #3
        break;
 8031990:	e7ed      	b.n	803196e <RadioTimeOnAir+0x26>
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 8031992:	9402      	str	r4, [sp, #8]
 8031994:	9701      	str	r7, [sp, #4]
 8031996:	9300      	str	r3, [sp, #0]
 8031998:	0013      	movs	r3, r2
 803199a:	000a      	movs	r2, r1
 803199c:	0031      	movs	r1, r6
 803199e:	0028      	movs	r0, r5
 80319a0:	f7ff ff86 	bl	80318b0 <RadioGetLoRaTimeOnAirNumerator>
 80319a4:	0144      	lsls	r4, r0, #5
 80319a6:	1a24      	subs	r4, r4, r0
 80319a8:	00a4      	lsls	r4, r4, #2
 80319aa:	1824      	adds	r4, r4, r0
 80319ac:	00e4      	lsls	r4, r4, #3
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 80319ae:	4b03      	ldr	r3, [pc, #12]	; (80319bc <RadioTimeOnAir+0x74>)
 80319b0:	5d58      	ldrb	r0, [r3, r5]
 80319b2:	f7ff ff35 	bl	8031820 <RadioGetLoRaBandwidthInHz>
 80319b6:	0006      	movs	r6, r0
        break;
 80319b8:	e7d9      	b.n	803196e <RadioTimeOnAir+0x26>
 80319ba:	46c0      	nop			; (mov r8, r8)
 80319bc:	080356b0 	.word	0x080356b0

080319c0 <RadioOnTxTimeoutProcess>:
{
    RADIO_RX_TIMEOUT_PROCESS();
}

static void RadioOnTxTimeoutProcess( void )
{
 80319c0:	b510      	push	{r4, lr}
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_TX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 80319c2:	4b04      	ldr	r3, [pc, #16]	; (80319d4 <RadioOnTxTimeoutProcess+0x14>)
 80319c4:	681b      	ldr	r3, [r3, #0]
 80319c6:	2b00      	cmp	r3, #0
 80319c8:	d003      	beq.n	80319d2 <RadioOnTxTimeoutProcess+0x12>
 80319ca:	685b      	ldr	r3, [r3, #4]
 80319cc:	2b00      	cmp	r3, #0
 80319ce:	d000      	beq.n	80319d2 <RadioOnTxTimeoutProcess+0x12>
    {
        RadioEvents->TxTimeout( );
 80319d0:	4798      	blx	r3
    }
}
 80319d2:	bd10      	pop	{r4, pc}
 80319d4:	2000b508 	.word	0x2000b508

080319d8 <RadioOnTxTimeoutIrq>:
{
 80319d8:	b510      	push	{r4, lr}
    RADIO_TX_TIMEOUT_PROCESS();
 80319da:	f7ff fff1 	bl	80319c0 <RadioOnTxTimeoutProcess>
}
 80319de:	bd10      	pop	{r4, pc}

080319e0 <RadioOnRxTimeoutProcess>:

static void RadioOnRxTimeoutProcess( void )
{
 80319e0:	b510      	push	{r4, lr}
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_RX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 80319e2:	4b04      	ldr	r3, [pc, #16]	; (80319f4 <RadioOnRxTimeoutProcess+0x14>)
 80319e4:	681b      	ldr	r3, [r3, #0]
 80319e6:	2b00      	cmp	r3, #0
 80319e8:	d003      	beq.n	80319f2 <RadioOnRxTimeoutProcess+0x12>
 80319ea:	68db      	ldr	r3, [r3, #12]
 80319ec:	2b00      	cmp	r3, #0
 80319ee:	d000      	beq.n	80319f2 <RadioOnRxTimeoutProcess+0x12>
    {
        RadioEvents->RxTimeout( );
 80319f0:	4798      	blx	r3
    }
}
 80319f2:	bd10      	pop	{r4, pc}
 80319f4:	2000b508 	.word	0x2000b508

080319f8 <RadioOnRxTimeoutIrq>:
{
 80319f8:	b510      	push	{r4, lr}
    RADIO_RX_TIMEOUT_PROCESS();
 80319fa:	f7ff fff1 	bl	80319e0 <RadioOnRxTimeoutProcess>
}
 80319fe:	bd10      	pop	{r4, pc}

08031a00 <payload_integration>:
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
    SUBGRF_SetTxContinuousWave( );
}

static void payload_integration( uint8_t *outBuffer, uint8_t *inBuffer, uint8_t size )
{
 8031a00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8031a02:	46de      	mov	lr, fp
 8031a04:	4657      	mov	r7, sl
 8031a06:	464e      	mov	r6, r9
 8031a08:	4645      	mov	r5, r8
 8031a0a:	b5e0      	push	{r5, r6, r7, lr}
 8031a0c:	b083      	sub	sp, #12
 8031a0e:	9201      	str	r2, [sp, #4]
    uint8_t index_byte;
    uint8_t index_bit_out;
    uint8_t index_byte_out;
    int i = 0;

    for (i = 0; i < size; i++)
 8031a10:	2300      	movs	r3, #0
 8031a12:	9a01      	ldr	r2, [sp, #4]
 8031a14:	4692      	mov	sl, r2
 8031a16:	429a      	cmp	r2, r3
 8031a18:	dd07      	ble.n	8031a2a <payload_integration+0x2a>
    {
        /* reverse all inputs */
        inBuffer[i] = ~inBuffer[i];
 8031a1a:	5ccc      	ldrb	r4, [r1, r3]
 8031a1c:	43e4      	mvns	r4, r4
 8031a1e:	54cc      	strb	r4, [r1, r3]
        /* init outBuffer */
        outBuffer[i] = 0;
 8031a20:	18c4      	adds	r4, r0, r3
 8031a22:	2500      	movs	r5, #0
 8031a24:	7025      	strb	r5, [r4, #0]
    for (i = 0; i < size; i++)
 8031a26:	3301      	adds	r3, #1
 8031a28:	e7f3      	b.n	8031a12 <payload_integration+0x12>
    }

    for (i = 0; i < (size * 8); i++)
 8031a2a:	2500      	movs	r5, #0
    uint8_t prevInt = 0;
 8031a2c:	2600      	movs	r6, #0
 8031a2e:	e036      	b.n	8031a9e <payload_integration+0x9e>
    {
        /* index to take bit in inBuffer */
        index_bit = 7 - ( i % 8 );
 8031a30:	17ef      	asrs	r7, r5, #31
 8031a32:	0f7a      	lsrs	r2, r7, #29
 8031a34:	18ab      	adds	r3, r5, r2
 8031a36:	2407      	movs	r4, #7
 8031a38:	4023      	ands	r3, r4
 8031a3a:	1a9b      	subs	r3, r3, r2
 8031a3c:	b2db      	uxtb	r3, r3
 8031a3e:	2207      	movs	r2, #7
 8031a40:	4690      	mov	r8, r2
 8031a42:	4642      	mov	r2, r8
 8031a44:	1ad3      	subs	r3, r2, r3
 8031a46:	b2da      	uxtb	r2, r3
 8031a48:	9200      	str	r2, [sp, #0]
        index_byte = i / 8;
 8031a4a:	4027      	ands	r7, r4
 8031a4c:	46bc      	mov	ip, r7
 8031a4e:	44ac      	add	ip, r5
 8031a50:	4663      	mov	r3, ip
 8031a52:	10db      	asrs	r3, r3, #3
 8031a54:	469c      	mov	ip, r3
        /* index to place bit in outBuffer is shifted 1 bit right */
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 8031a56:	3501      	adds	r5, #1
 8031a58:	17ef      	asrs	r7, r5, #31
 8031a5a:	0f7b      	lsrs	r3, r7, #29
 8031a5c:	469b      	mov	fp, r3
 8031a5e:	46a9      	mov	r9, r5
 8031a60:	44d9      	add	r9, fp
 8031a62:	464b      	mov	r3, r9
 8031a64:	4023      	ands	r3, r4
 8031a66:	465a      	mov	r2, fp
 8031a68:	1a9b      	subs	r3, r3, r2
 8031a6a:	b2db      	uxtb	r3, r3
 8031a6c:	4642      	mov	r2, r8
 8031a6e:	1ad3      	subs	r3, r2, r3
 8031a70:	b2db      	uxtb	r3, r3
 8031a72:	4698      	mov	r8, r3
        index_byte_out = ( i + 1 ) / 8;
 8031a74:	403c      	ands	r4, r7
 8031a76:	1964      	adds	r4, r4, r5
 8031a78:	10e4      	asrs	r4, r4, #3
        /* extract current bit from input */
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 8031a7a:	27ff      	movs	r7, #255	; 0xff
 8031a7c:	4663      	mov	r3, ip
 8031a7e:	403b      	ands	r3, r7
 8031a80:	5ccb      	ldrb	r3, [r1, r3]
 8031a82:	9a00      	ldr	r2, [sp, #0]
 8031a84:	4113      	asrs	r3, r2
 8031a86:	2201      	movs	r2, #1
 8031a88:	4013      	ands	r3, r2
        /* integration */
        prevInt ^= currBit;
 8031a8a:	405e      	eors	r6, r3
        /* write result integration in output */
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 8031a8c:	403c      	ands	r4, r7
 8031a8e:	0033      	movs	r3, r6
 8031a90:	4642      	mov	r2, r8
 8031a92:	4093      	lsls	r3, r2
 8031a94:	469c      	mov	ip, r3
 8031a96:	5d03      	ldrb	r3, [r0, r4]
 8031a98:	4662      	mov	r2, ip
 8031a9a:	4313      	orrs	r3, r2
 8031a9c:	5503      	strb	r3, [r0, r4]
    for (i = 0; i < (size * 8); i++)
 8031a9e:	4653      	mov	r3, sl
 8031aa0:	00db      	lsls	r3, r3, #3
 8031aa2:	42ab      	cmp	r3, r5
 8031aa4:	dcc4      	bgt.n	8031a30 <payload_integration+0x30>
    }

    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8031aa6:	01f3      	lsls	r3, r6, #7
 8031aa8:	01b1      	lsls	r1, r6, #6
 8031aaa:	430b      	orrs	r3, r1
 8031aac:	b25b      	sxtb	r3, r3
 8031aae:	2e00      	cmp	r6, #0
 8031ab0:	d10a      	bne.n	8031ac8 <payload_integration+0xc8>
 8031ab2:	2120      	movs	r1, #32
 8031ab4:	430b      	orrs	r3, r1
 8031ab6:	9a01      	ldr	r2, [sp, #4]
 8031ab8:	5483      	strb	r3, [r0, r2]
}
 8031aba:	b003      	add	sp, #12
 8031abc:	bcf0      	pop	{r4, r5, r6, r7}
 8031abe:	46bb      	mov	fp, r7
 8031ac0:	46b2      	mov	sl, r6
 8031ac2:	46a9      	mov	r9, r5
 8031ac4:	46a0      	mov	r8, r4
 8031ac6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 8031ac8:	2100      	movs	r1, #0
 8031aca:	e7f3      	b.n	8031ab4 <payload_integration+0xb4>

08031acc <RadioSetMaxPayloadLength>:
{
 8031acc:	b510      	push	{r4, lr}
    if( modem == MODEM_LORA )
 8031ace:	2801      	cmp	r0, #1
 8031ad0:	d004      	beq.n	8031adc <RadioSetMaxPayloadLength+0x10>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 8031ad2:	4b0a      	ldr	r3, [pc, #40]	; (8031afc <RadioSetMaxPayloadLength+0x30>)
 8031ad4:	7d5b      	ldrb	r3, [r3, #21]
 8031ad6:	2b01      	cmp	r3, #1
 8031ad8:	d008      	beq.n	8031aec <RadioSetMaxPayloadLength+0x20>
}
 8031ada:	bd10      	pop	{r4, pc}
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 8031adc:	4b08      	ldr	r3, [pc, #32]	; (8031b00 <RadioSetMaxPayloadLength+0x34>)
 8031ade:	7019      	strb	r1, [r3, #0]
 8031ae0:	4806      	ldr	r0, [pc, #24]	; (8031afc <RadioSetMaxPayloadLength+0x30>)
 8031ae2:	77c1      	strb	r1, [r0, #31]
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8031ae4:	300e      	adds	r0, #14
 8031ae6:	f001 fd19 	bl	803351c <SUBGRF_SetPacketParams>
 8031aea:	e7f6      	b.n	8031ada <RadioSetMaxPayloadLength+0xe>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 8031aec:	4b04      	ldr	r3, [pc, #16]	; (8031b00 <RadioSetMaxPayloadLength+0x34>)
 8031aee:	7019      	strb	r1, [r3, #0]
 8031af0:	4802      	ldr	r0, [pc, #8]	; (8031afc <RadioSetMaxPayloadLength+0x30>)
 8031af2:	7581      	strb	r1, [r0, #22]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8031af4:	300e      	adds	r0, #14
 8031af6:	f001 fd11 	bl	803351c <SUBGRF_SetPacketParams>
}
 8031afa:	e7ee      	b.n	8031ada <RadioSetMaxPayloadLength+0xe>
 8031afc:	2000bd0c 	.word	0x2000bd0c
 8031b00:	2000a0b8 	.word	0x2000a0b8

08031b04 <RadioRead>:
{
 8031b04:	b510      	push	{r4, lr}
    return SUBGRF_ReadRegister(addr);
 8031b06:	f001 fbb9 	bl	803327c <SUBGRF_ReadRegister>
}
 8031b0a:	bd10      	pop	{r4, pc}

08031b0c <RadioWrite>:
{
 8031b0c:	b510      	push	{r4, lr}
    SUBGRF_WriteRegister(addr, data );
 8031b0e:	f001 fadb 	bl	80330c8 <SUBGRF_WriteRegister>
}
 8031b12:	bd10      	pop	{r4, pc}

08031b14 <RadioTxCw>:
{
 8031b14:	b510      	push	{r4, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 8031b16:	f001 fe16 	bl	8033746 <SUBGRF_SetRfTxPower>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 8031b1a:	2101      	movs	r1, #1
 8031b1c:	f001 fdff 	bl	803371e <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 8031b20:	f001 f986 	bl	8032e30 <SUBGRF_SetTxContinuousWave>
}
 8031b24:	bd10      	pop	{r4, pc}
	...

08031b28 <RadioTxPrbs>:
{
 8031b28:	b510      	push	{r4, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 8031b2a:	4a08      	ldr	r2, [pc, #32]	; (8031b4c <RadioTxPrbs+0x24>)
 8031b2c:	2356      	movs	r3, #86	; 0x56
 8031b2e:	5cd0      	ldrb	r0, [r2, r3]
 8031b30:	2101      	movs	r1, #1
 8031b32:	f001 fdf4 	bl	803371e <SUBGRF_SetSwitch>
    Radio.Write( SUBGHZ_PKTCTL1A, 0x2d );  // sel mode prbs9 instead of preamble
 8031b36:	20d7      	movs	r0, #215	; 0xd7
 8031b38:	212d      	movs	r1, #45	; 0x2d
 8031b3a:	00c0      	lsls	r0, r0, #3
 8031b3c:	f7ff ffe6 	bl	8031b0c <RadioWrite>
    SUBGRF_SetTxInfinitePreamble( );
 8031b40:	f001 f97d 	bl	8032e3e <SUBGRF_SetTxInfinitePreamble>
    SUBGRF_SetTx( 0x0fffff );
 8031b44:	4802      	ldr	r0, [pc, #8]	; (8031b50 <RadioTxPrbs+0x28>)
 8031b46:	f001 f925 	bl	8032d94 <SUBGRF_SetTx>
}
 8031b4a:	bd10      	pop	{r4, pc}
 8031b4c:	2000bd0c 	.word	0x2000bd0c
 8031b50:	000fffff 	.word	0x000fffff

08031b54 <RadioSetRxDutyCycle>:
{
 8031b54:	b570      	push	{r4, r5, r6, lr}
 8031b56:	0004      	movs	r4, r0
 8031b58:	000d      	movs	r5, r1
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8031b5a:	4a05      	ldr	r2, [pc, #20]	; (8031b70 <RadioSetRxDutyCycle+0x1c>)
 8031b5c:	2356      	movs	r3, #86	; 0x56
 8031b5e:	5cd0      	ldrb	r0, [r2, r3]
 8031b60:	2100      	movs	r1, #0
 8031b62:	f001 fddc 	bl	803371e <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8031b66:	0029      	movs	r1, r5
 8031b68:	0020      	movs	r0, r4
 8031b6a:	f001 f93b 	bl	8032de4 <SUBGRF_SetRxDutyCycle>
}
 8031b6e:	bd70      	pop	{r4, r5, r6, pc}
 8031b70:	2000bd0c 	.word	0x2000bd0c

08031b74 <RadioRxBoosted>:
{
 8031b74:	b570      	push	{r4, r5, r6, lr}
 8031b76:	0004      	movs	r4, r0
    if (1UL==RFW_Is_Init())
 8031b78:	f001 febc 	bl	80338f4 <RFW_Is_Init>
 8031b7c:	2801      	cmp	r0, #1
 8031b7e:	d014      	beq.n	8031baa <RadioRxBoosted+0x36>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8031b80:	4813      	ldr	r0, [pc, #76]	; (8031bd0 <RadioRxBoosted+0x5c>)
 8031b82:	2300      	movs	r3, #0
 8031b84:	2200      	movs	r2, #0
 8031b86:	0001      	movs	r1, r0
 8031b88:	f001 f9f6 	bl	8032f78 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 8031b8c:	2c00      	cmp	r4, #0
 8031b8e:	d10f      	bne.n	8031bb0 <RadioRxBoosted+0x3c>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8031b90:	4c10      	ldr	r4, [pc, #64]	; (8031bd4 <RadioRxBoosted+0x60>)
 8031b92:	2356      	movs	r3, #86	; 0x56
 8031b94:	5ce0      	ldrb	r0, [r4, r3]
 8031b96:	2100      	movs	r1, #0
 8031b98:	f001 fdc1 	bl	803371e <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8031b9c:	7863      	ldrb	r3, [r4, #1]
 8031b9e:	2b00      	cmp	r3, #0
 8031ba0:	d00f      	beq.n	8031bc2 <RadioRxBoosted+0x4e>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 8031ba2:	480d      	ldr	r0, [pc, #52]	; (8031bd8 <RadioRxBoosted+0x64>)
 8031ba4:	f001 fa9e 	bl	80330e4 <SUBGRF_SetRxBoosted>
}
 8031ba8:	bd70      	pop	{r4, r5, r6, pc}
      RFW_ReceiveInit();
 8031baa:	f001 feab 	bl	8033904 <RFW_ReceiveInit>
 8031bae:	e7ed      	b.n	8031b8c <RadioRxBoosted+0x18>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8031bb0:	4d0a      	ldr	r5, [pc, #40]	; (8031bdc <RadioRxBoosted+0x68>)
 8031bb2:	0021      	movs	r1, r4
 8031bb4:	0028      	movs	r0, r5
 8031bb6:	f002 fb8f 	bl	80342d8 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8031bba:	0028      	movs	r0, r5
 8031bbc:	f002 fb46 	bl	803424c <UTIL_TIMER_Start>
 8031bc0:	e7e6      	b.n	8031b90 <RadioRxBoosted+0x1c>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 8031bc2:	4b04      	ldr	r3, [pc, #16]	; (8031bd4 <RadioRxBoosted+0x60>)
 8031bc4:	6898      	ldr	r0, [r3, #8]
 8031bc6:	0180      	lsls	r0, r0, #6
 8031bc8:	f001 fa8c 	bl	80330e4 <SUBGRF_SetRxBoosted>
}
 8031bcc:	e7ec      	b.n	8031ba8 <RadioRxBoosted+0x34>
 8031bce:	46c0      	nop			; (mov r8, r8)
 8031bd0:	00000262 	.word	0x00000262
 8031bd4:	2000bd0c 	.word	0x2000bd0c
 8031bd8:	00ffffff 	.word	0x00ffffff
 8031bdc:	2000bd7c 	.word	0x2000bd7c

08031be0 <RadioStandby>:
{
 8031be0:	b510      	push	{r4, lr}
    SUBGRF_SetStandby( STDBY_RC );
 8031be2:	2000      	movs	r0, #0
 8031be4:	f001 f8be 	bl	8032d64 <SUBGRF_SetStandby>
}
 8031be8:	bd10      	pop	{r4, pc}

08031bea <RadioGetStatus>:
{
 8031bea:	b510      	push	{r4, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 8031bec:	f001 f8b4 	bl	8032d58 <SUBGRF_GetOperatingMode>
 8031bf0:	2805      	cmp	r0, #5
 8031bf2:	d007      	beq.n	8031c04 <RadioGetStatus+0x1a>
 8031bf4:	2807      	cmp	r0, #7
 8031bf6:	d007      	beq.n	8031c08 <RadioGetStatus+0x1e>
 8031bf8:	2804      	cmp	r0, #4
 8031bfa:	d001      	beq.n	8031c00 <RadioGetStatus+0x16>
            return RF_IDLE;
 8031bfc:	2000      	movs	r0, #0
}
 8031bfe:	bd10      	pop	{r4, pc}
    switch( SUBGRF_GetOperatingMode( ) )
 8031c00:	3802      	subs	r0, #2
 8031c02:	e7fc      	b.n	8031bfe <RadioGetStatus+0x14>
            return RF_RX_RUNNING;
 8031c04:	2001      	movs	r0, #1
 8031c06:	e7fa      	b.n	8031bfe <RadioGetStatus+0x14>
            return RF_CAD;
 8031c08:	2003      	movs	r0, #3
 8031c0a:	e7f8      	b.n	8031bfe <RadioGetStatus+0x14>

08031c0c <RadioIrqProcess>:
{
 8031c0c:	b530      	push	{r4, r5, lr}
 8031c0e:	b083      	sub	sp, #12
    uint8_t size = 0;
 8031c10:	2300      	movs	r3, #0
 8031c12:	466a      	mov	r2, sp
 8031c14:	71d3      	strb	r3, [r2, #7]
    int32_t cfo = 0;
 8031c16:	9300      	str	r3, [sp, #0]
    switch ( SubgRf.RadioIrq )
 8031c18:	4a90      	ldr	r2, [pc, #576]	; (8031e5c <RadioIrqProcess+0x250>)
 8031c1a:	3354      	adds	r3, #84	; 0x54
 8031c1c:	5ad3      	ldrh	r3, [r2, r3]
 8031c1e:	2b20      	cmp	r3, #32
 8031c20:	d80a      	bhi.n	8031c38 <RadioIrqProcess+0x2c>
 8031c22:	b21a      	sxth	r2, r3
 8031c24:	2a00      	cmp	r2, #0
 8031c26:	d100      	bne.n	8031c2a <RadioIrqProcess+0x1e>
 8031c28:	e0d0      	b.n	8031dcc <RadioIrqProcess+0x1c0>
 8031c2a:	2b20      	cmp	r3, #32
 8031c2c:	d900      	bls.n	8031c30 <RadioIrqProcess+0x24>
 8031c2e:	e0cd      	b.n	8031dcc <RadioIrqProcess+0x1c0>
 8031c30:	009b      	lsls	r3, r3, #2
 8031c32:	4a8b      	ldr	r2, [pc, #556]	; (8031e60 <RadioIrqProcess+0x254>)
 8031c34:	58d3      	ldr	r3, [r2, r3]
 8031c36:	469f      	mov	pc, r3
 8031c38:	2280      	movs	r2, #128	; 0x80
 8031c3a:	0052      	lsls	r2, r2, #1
 8031c3c:	4293      	cmp	r3, r2
 8031c3e:	d100      	bne.n	8031c42 <RadioIrqProcess+0x36>
 8031c40:	e0a2      	b.n	8031d88 <RadioIrqProcess+0x17c>
 8031c42:	d925      	bls.n	8031c90 <RadioIrqProcess+0x84>
 8031c44:	2280      	movs	r2, #128	; 0x80
 8031c46:	0092      	lsls	r2, r2, #2
 8031c48:	4293      	cmp	r3, r2
 8031c4a:	d000      	beq.n	8031c4e <RadioIrqProcess+0x42>
 8031c4c:	e0be      	b.n	8031dcc <RadioIrqProcess+0x1c0>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 8031c4e:	4b85      	ldr	r3, [pc, #532]	; (8031e64 <RadioIrqProcess+0x258>)
 8031c50:	2201      	movs	r2, #1
 8031c52:	2100      	movs	r1, #0
 8031c54:	2002      	movs	r0, #2
 8031c56:	f001 ff2f 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 8031c5a:	f001 f87d 	bl	8032d58 <SUBGRF_GetOperatingMode>
 8031c5e:	2804      	cmp	r0, #4
 8031c60:	d100      	bne.n	8031c64 <RadioIrqProcess+0x58>
 8031c62:	e09e      	b.n	8031da2 <RadioIrqProcess+0x196>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 8031c64:	f001 f878 	bl	8032d58 <SUBGRF_GetOperatingMode>
 8031c68:	2805      	cmp	r0, #5
 8031c6a:	d000      	beq.n	8031c6e <RadioIrqProcess+0x62>
 8031c6c:	e0ae      	b.n	8031dcc <RadioIrqProcess+0x1c0>
            TimerStop( &RxTimeoutTimer );
 8031c6e:	487e      	ldr	r0, [pc, #504]	; (8031e68 <RadioIrqProcess+0x25c>)
 8031c70:	f002 fa8a 	bl	8034188 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8031c74:	2000      	movs	r0, #0
 8031c76:	f001 f875 	bl	8032d64 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8031c7a:	4b7c      	ldr	r3, [pc, #496]	; (8031e6c <RadioIrqProcess+0x260>)
 8031c7c:	681b      	ldr	r3, [r3, #0]
 8031c7e:	2b00      	cmp	r3, #0
 8031c80:	d100      	bne.n	8031c84 <RadioIrqProcess+0x78>
 8031c82:	e0a3      	b.n	8031dcc <RadioIrqProcess+0x1c0>
 8031c84:	68db      	ldr	r3, [r3, #12]
 8031c86:	2b00      	cmp	r3, #0
 8031c88:	d100      	bne.n	8031c8c <RadioIrqProcess+0x80>
 8031c8a:	e09f      	b.n	8031dcc <RadioIrqProcess+0x1c0>
                RadioEvents->RxTimeout( );
 8031c8c:	4798      	blx	r3
 8031c8e:	e09d      	b.n	8031dcc <RadioIrqProcess+0x1c0>
    switch ( SubgRf.RadioIrq )
 8031c90:	2b40      	cmp	r3, #64	; 0x40
 8031c92:	d100      	bne.n	8031c96 <RadioIrqProcess+0x8a>
 8031c94:	e0ca      	b.n	8031e2c <RadioIrqProcess+0x220>
 8031c96:	2b80      	cmp	r3, #128	; 0x80
 8031c98:	d000      	beq.n	8031c9c <RadioIrqProcess+0x90>
 8031c9a:	e097      	b.n	8031dcc <RadioIrqProcess+0x1c0>
        SUBGRF_SetStandby( STDBY_RC );
 8031c9c:	2000      	movs	r0, #0
 8031c9e:	f001 f861 	bl	8032d64 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8031ca2:	4b72      	ldr	r3, [pc, #456]	; (8031e6c <RadioIrqProcess+0x260>)
 8031ca4:	681b      	ldr	r3, [r3, #0]
 8031ca6:	2b00      	cmp	r3, #0
 8031ca8:	d100      	bne.n	8031cac <RadioIrqProcess+0xa0>
 8031caa:	e08f      	b.n	8031dcc <RadioIrqProcess+0x1c0>
 8031cac:	699b      	ldr	r3, [r3, #24]
 8031cae:	2b00      	cmp	r3, #0
 8031cb0:	d100      	bne.n	8031cb4 <RadioIrqProcess+0xa8>
 8031cb2:	e08b      	b.n	8031dcc <RadioIrqProcess+0x1c0>
            RadioEvents->CadDone( false );
 8031cb4:	2000      	movs	r0, #0
 8031cb6:	4798      	blx	r3
 8031cb8:	e088      	b.n	8031dcc <RadioIrqProcess+0x1c0>
        TimerStop( &TxTimeoutTimer );
 8031cba:	486d      	ldr	r0, [pc, #436]	; (8031e70 <RadioIrqProcess+0x264>)
 8031cbc:	f002 fa64 	bl	8034188 <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 8031cc0:	2000      	movs	r0, #0
 8031cc2:	f001 f84f 	bl	8032d64 <SUBGRF_SetStandby>
        if ( RFW_Is_LongPacketModeEnabled() == 1 )
 8031cc6:	f001 fe17 	bl	80338f8 <RFW_Is_LongPacketModeEnabled>
 8031cca:	2801      	cmp	r0, #1
 8031ccc:	d008      	beq.n	8031ce0 <RadioIrqProcess+0xd4>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 8031cce:	4b67      	ldr	r3, [pc, #412]	; (8031e6c <RadioIrqProcess+0x260>)
 8031cd0:	681b      	ldr	r3, [r3, #0]
 8031cd2:	2b00      	cmp	r3, #0
 8031cd4:	d07a      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
 8031cd6:	681b      	ldr	r3, [r3, #0]
 8031cd8:	2b00      	cmp	r3, #0
 8031cda:	d077      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
            RadioEvents->TxDone( );
 8031cdc:	4798      	blx	r3
 8031cde:	e075      	b.n	8031dcc <RadioIrqProcess+0x1c0>
            RFW_DeInit_TxLongPacket( );
 8031ce0:	f001 fe13 	bl	803390a <RFW_DeInit_TxLongPacket>
 8031ce4:	e7f3      	b.n	8031cce <RadioIrqProcess+0xc2>
        TimerStop( &RxTimeoutTimer );
 8031ce6:	4860      	ldr	r0, [pc, #384]	; (8031e68 <RadioIrqProcess+0x25c>)
 8031ce8:	f002 fa4e 	bl	8034188 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 8031cec:	4b5b      	ldr	r3, [pc, #364]	; (8031e5c <RadioIrqProcess+0x250>)
 8031cee:	785b      	ldrb	r3, [r3, #1]
 8031cf0:	2b00      	cmp	r3, #0
 8031cf2:	d01e      	beq.n	8031d32 <RadioIrqProcess+0x126>
        SUBGRF_GetPayload( RadioBuffer, &size , 255 );
 8031cf4:	22ff      	movs	r2, #255	; 0xff
 8031cf6:	466b      	mov	r3, sp
 8031cf8:	1dd9      	adds	r1, r3, #7
 8031cfa:	485e      	ldr	r0, [pc, #376]	; (8031e74 <RadioIrqProcess+0x268>)
 8031cfc:	f001 fcf6 	bl	80336ec <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &(SubgRf.PacketStatus) );
 8031d00:	485d      	ldr	r0, [pc, #372]	; (8031e78 <RadioIrqProcess+0x26c>)
 8031d02:	f001 f9a7 	bl	8033054 <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 8031d06:	4b59      	ldr	r3, [pc, #356]	; (8031e6c <RadioIrqProcess+0x260>)
 8031d08:	681b      	ldr	r3, [r3, #0]
 8031d0a:	2b00      	cmp	r3, #0
 8031d0c:	d05e      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
 8031d0e:	689c      	ldr	r4, [r3, #8]
 8031d10:	2c00      	cmp	r4, #0
 8031d12:	d05b      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
            switch ( SubgRf.PacketStatus.packetType )
 8031d14:	4a51      	ldr	r2, [pc, #324]	; (8031e5c <RadioIrqProcess+0x250>)
 8031d16:	2324      	movs	r3, #36	; 0x24
 8031d18:	5cd3      	ldrb	r3, [r2, r3]
 8031d1a:	2b01      	cmp	r3, #1
 8031d1c:	d11b      	bne.n	8031d56 <RadioIrqProcess+0x14a>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt, SubgRf.PacketStatus.Params.LoRa.SnrPkt );
 8031d1e:	3330      	adds	r3, #48	; 0x30
 8031d20:	56d3      	ldrsb	r3, [r2, r3]
 8031d22:	2130      	movs	r1, #48	; 0x30
 8031d24:	5652      	ldrsb	r2, [r2, r1]
 8031d26:	4669      	mov	r1, sp
 8031d28:	3107      	adds	r1, #7
 8031d2a:	7809      	ldrb	r1, [r1, #0]
 8031d2c:	4851      	ldr	r0, [pc, #324]	; (8031e74 <RadioIrqProcess+0x268>)
 8031d2e:	47a0      	blx	r4
                break;
 8031d30:	e04c      	b.n	8031dcc <RadioIrqProcess+0x1c0>
            SUBGRF_SetStandby( STDBY_RC );
 8031d32:	2000      	movs	r0, #0
 8031d34:	f001 f816 	bl	8032d64 <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( 0x0902, 0x00 );
 8031d38:	2100      	movs	r1, #0
 8031d3a:	4850      	ldr	r0, [pc, #320]	; (8031e7c <RadioIrqProcess+0x270>)
 8031d3c:	f001 f9c4 	bl	80330c8 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( 0x0944, SUBGRF_ReadRegister( 0x0944 ) | ( 1 << 1 ) );
 8031d40:	4c4f      	ldr	r4, [pc, #316]	; (8031e80 <RadioIrqProcess+0x274>)
 8031d42:	0020      	movs	r0, r4
 8031d44:	f001 fa9a 	bl	803327c <SUBGRF_ReadRegister>
 8031d48:	2102      	movs	r1, #2
 8031d4a:	4301      	orrs	r1, r0
 8031d4c:	b2c9      	uxtb	r1, r1
 8031d4e:	0020      	movs	r0, r4
 8031d50:	f001 f9ba 	bl	80330c8 <SUBGRF_WriteRegister>
 8031d54:	e7ce      	b.n	8031cf4 <RadioIrqProcess+0xe8>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 8031d56:	4c41      	ldr	r4, [pc, #260]	; (8031e5c <RadioIrqProcess+0x250>)
 8031d58:	4669      	mov	r1, sp
 8031d5a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8031d5c:	f001 fd7c 	bl	8033858 <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, (int8_t) DIVR(cfo, 1000) );
 8031d60:	4b42      	ldr	r3, [pc, #264]	; (8031e6c <RadioIrqProcess+0x260>)
 8031d62:	681b      	ldr	r3, [r3, #0]
 8031d64:	689d      	ldr	r5, [r3, #8]
 8031d66:	2329      	movs	r3, #41	; 0x29
 8031d68:	56e4      	ldrsb	r4, [r4, r3]
 8031d6a:	9800      	ldr	r0, [sp, #0]
 8031d6c:	30f5      	adds	r0, #245	; 0xf5
 8031d6e:	30ff      	adds	r0, #255	; 0xff
 8031d70:	21fa      	movs	r1, #250	; 0xfa
 8031d72:	0089      	lsls	r1, r1, #2
 8031d74:	f7ee fa5a 	bl	802022c <__divsi3>
 8031d78:	b243      	sxtb	r3, r0
 8031d7a:	b222      	sxth	r2, r4
 8031d7c:	4669      	mov	r1, sp
 8031d7e:	3107      	adds	r1, #7
 8031d80:	7809      	ldrb	r1, [r1, #0]
 8031d82:	483c      	ldr	r0, [pc, #240]	; (8031e74 <RadioIrqProcess+0x268>)
 8031d84:	47a8      	blx	r5
                break;
 8031d86:	e021      	b.n	8031dcc <RadioIrqProcess+0x1c0>
        SUBGRF_SetStandby( STDBY_RC );
 8031d88:	2000      	movs	r0, #0
 8031d8a:	f000 ffeb 	bl	8032d64 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8031d8e:	4b37      	ldr	r3, [pc, #220]	; (8031e6c <RadioIrqProcess+0x260>)
 8031d90:	681b      	ldr	r3, [r3, #0]
 8031d92:	2b00      	cmp	r3, #0
 8031d94:	d01a      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
 8031d96:	699b      	ldr	r3, [r3, #24]
 8031d98:	2b00      	cmp	r3, #0
 8031d9a:	d017      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
            RadioEvents->CadDone( true );
 8031d9c:	2001      	movs	r0, #1
 8031d9e:	4798      	blx	r3
 8031da0:	e014      	b.n	8031dcc <RadioIrqProcess+0x1c0>
            TimerStop( &TxTimeoutTimer );
 8031da2:	4833      	ldr	r0, [pc, #204]	; (8031e70 <RadioIrqProcess+0x264>)
 8031da4:	f002 f9f0 	bl	8034188 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8031da8:	2000      	movs	r0, #0
 8031daa:	f000 ffdb 	bl	8032d64 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8031dae:	4b2f      	ldr	r3, [pc, #188]	; (8031e6c <RadioIrqProcess+0x260>)
 8031db0:	681b      	ldr	r3, [r3, #0]
 8031db2:	2b00      	cmp	r3, #0
 8031db4:	d00a      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
 8031db6:	685b      	ldr	r3, [r3, #4]
 8031db8:	2b00      	cmp	r3, #0
 8031dba:	d007      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
                RadioEvents->TxTimeout( );
 8031dbc:	4798      	blx	r3
 8031dbe:	e005      	b.n	8031dcc <RadioIrqProcess+0x1c0>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 8031dc0:	4b30      	ldr	r3, [pc, #192]	; (8031e84 <RadioIrqProcess+0x278>)
 8031dc2:	2201      	movs	r2, #1
 8031dc4:	2100      	movs	r1, #0
 8031dc6:	2002      	movs	r0, #2
 8031dc8:	f001 fe76 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
}
 8031dcc:	b003      	add	sp, #12
 8031dce:	bd30      	pop	{r4, r5, pc}
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 8031dd0:	4b2d      	ldr	r3, [pc, #180]	; (8031e88 <RadioIrqProcess+0x27c>)
 8031dd2:	2201      	movs	r2, #1
 8031dd4:	2100      	movs	r1, #0
 8031dd6:	2002      	movs	r0, #2
 8031dd8:	f001 fe6e 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
        if ( 1UL == RFW_Is_Init( ) )
 8031ddc:	f001 fd8a 	bl	80338f4 <RFW_Is_Init>
 8031de0:	2801      	cmp	r0, #1
 8031de2:	d1f3      	bne.n	8031dcc <RadioIrqProcess+0x1c0>
            RFW_ReceivePayload( );
 8031de4:	f001 fd92 	bl	803390c <RFW_ReceivePayload>
 8031de8:	e7f0      	b.n	8031dcc <RadioIrqProcess+0x1c0>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 8031dea:	4b28      	ldr	r3, [pc, #160]	; (8031e8c <RadioIrqProcess+0x280>)
 8031dec:	2201      	movs	r2, #1
 8031dee:	2100      	movs	r1, #0
 8031df0:	2002      	movs	r0, #2
 8031df2:	f001 fe61 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
        break;
 8031df6:	e7e9      	b.n	8031dcc <RadioIrqProcess+0x1c0>
        TimerStop( &RxTimeoutTimer );
 8031df8:	481b      	ldr	r0, [pc, #108]	; (8031e68 <RadioIrqProcess+0x25c>)
 8031dfa:	f002 f9c5 	bl	8034188 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 8031dfe:	4b17      	ldr	r3, [pc, #92]	; (8031e5c <RadioIrqProcess+0x250>)
 8031e00:	785b      	ldrb	r3, [r3, #1]
 8031e02:	2b00      	cmp	r3, #0
 8031e04:	d00e      	beq.n	8031e24 <RadioIrqProcess+0x218>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8031e06:	4b19      	ldr	r3, [pc, #100]	; (8031e6c <RadioIrqProcess+0x260>)
 8031e08:	681b      	ldr	r3, [r3, #0]
 8031e0a:	2b00      	cmp	r3, #0
 8031e0c:	d0de      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
 8031e0e:	68db      	ldr	r3, [r3, #12]
 8031e10:	2b00      	cmp	r3, #0
 8031e12:	d0db      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
            RadioEvents->RxTimeout( );
 8031e14:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 8031e16:	4b1e      	ldr	r3, [pc, #120]	; (8031e90 <RadioIrqProcess+0x284>)
 8031e18:	2201      	movs	r2, #1
 8031e1a:	2100      	movs	r1, #0
 8031e1c:	2002      	movs	r0, #2
 8031e1e:	f001 fe4b 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
 8031e22:	e7d3      	b.n	8031dcc <RadioIrqProcess+0x1c0>
            SUBGRF_SetStandby( STDBY_RC );
 8031e24:	2000      	movs	r0, #0
 8031e26:	f000 ff9d 	bl	8032d64 <SUBGRF_SetStandby>
 8031e2a:	e7ec      	b.n	8031e06 <RadioIrqProcess+0x1fa>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 8031e2c:	4b19      	ldr	r3, [pc, #100]	; (8031e94 <RadioIrqProcess+0x288>)
 8031e2e:	2201      	movs	r2, #1
 8031e30:	2100      	movs	r1, #0
 8031e32:	2002      	movs	r0, #2
 8031e34:	f001 fe40 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 8031e38:	4b08      	ldr	r3, [pc, #32]	; (8031e5c <RadioIrqProcess+0x250>)
 8031e3a:	785b      	ldrb	r3, [r3, #1]
 8031e3c:	2b00      	cmp	r3, #0
 8031e3e:	d008      	beq.n	8031e52 <RadioIrqProcess+0x246>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 8031e40:	4b0a      	ldr	r3, [pc, #40]	; (8031e6c <RadioIrqProcess+0x260>)
 8031e42:	681b      	ldr	r3, [r3, #0]
 8031e44:	2b00      	cmp	r3, #0
 8031e46:	d0c1      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
 8031e48:	691b      	ldr	r3, [r3, #16]
 8031e4a:	2b00      	cmp	r3, #0
 8031e4c:	d0be      	beq.n	8031dcc <RadioIrqProcess+0x1c0>
            RadioEvents->RxError( );
 8031e4e:	4798      	blx	r3
}
 8031e50:	e7bc      	b.n	8031dcc <RadioIrqProcess+0x1c0>
            SUBGRF_SetStandby( STDBY_RC );
 8031e52:	2000      	movs	r0, #0
 8031e54:	f000 ff86 	bl	8032d64 <SUBGRF_SetStandby>
 8031e58:	e7f2      	b.n	8031e40 <RadioIrqProcess+0x234>
 8031e5a:	46c0      	nop			; (mov r8, r8)
 8031e5c:	2000bd0c 	.word	0x2000bd0c
 8031e60:	08035614 	.word	0x08035614
 8031e64:	080355c0 	.word	0x080355c0
 8031e68:	2000bd7c 	.word	0x2000bd7c
 8031e6c:	2000b508 	.word	0x2000b508
 8031e70:	2000bd64 	.word	0x2000bd64
 8031e74:	2000b408 	.word	0x2000b408
 8031e78:	2000bd30 	.word	0x2000bd30
 8031e7c:	00000902 	.word	0x00000902
 8031e80:	00000944 	.word	0x00000944
 8031e84:	080355d4 	.word	0x080355d4
 8031e88:	080355e0 	.word	0x080355e0
 8031e8c:	080355ec 	.word	0x080355ec
 8031e90:	080355f8 	.word	0x080355f8
 8031e94:	08035604 	.word	0x08035604

08031e98 <RadioOnDioIrq>:
{
 8031e98:	b510      	push	{r4, lr}
    SubgRf.RadioIrq = radioIrq;
 8031e9a:	4a03      	ldr	r2, [pc, #12]	; (8031ea8 <RadioOnDioIrq+0x10>)
 8031e9c:	2354      	movs	r3, #84	; 0x54
 8031e9e:	52d0      	strh	r0, [r2, r3]
    RADIO_IRQ_PROCESS();
 8031ea0:	f7ff feb4 	bl	8031c0c <RadioIrqProcess>
}
 8031ea4:	bd10      	pop	{r4, pc}
 8031ea6:	46c0      	nop			; (mov r8, r8)
 8031ea8:	2000bd0c 	.word	0x2000bd0c

08031eac <RadioGetWakeupTime>:
{
 8031eac:	b510      	push	{r4, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 8031eae:	f001 fc62 	bl	8033776 <SUBGRF_GetRadioWakeUpTime>
 8031eb2:	3003      	adds	r0, #3
}
 8031eb4:	bd10      	pop	{r4, pc}

08031eb6 <RadioReadRegisters>:
{
 8031eb6:	b510      	push	{r4, lr}
    SUBGRF_ReadRegisters( addr, buffer, size );
 8031eb8:	f001 fba0 	bl	80335fc <SUBGRF_ReadRegisters>
}
 8031ebc:	bd10      	pop	{r4, pc}

08031ebe <RadioWriteRegisters>:
{
 8031ebe:	b510      	push	{r4, lr}
    SUBGRF_WriteRegisters( addr, buffer, size );
 8031ec0:	f001 faea 	bl	8033498 <SUBGRF_WriteRegisters>
}
 8031ec4:	bd10      	pop	{r4, pc}

08031ec6 <RadioRssi>:
{
 8031ec6:	b510      	push	{r4, lr}
    return SUBGRF_GetRssiInst( );
 8031ec8:	f001 f8b6 	bl	8033038 <SUBGRF_GetRssiInst>
 8031ecc:	b200      	sxth	r0, r0
}
 8031ece:	bd10      	pop	{r4, pc}

08031ed0 <RadioSetTxContinuousWave>:
{
 8031ed0:	b570      	push	{r4, r5, r6, lr}
 8031ed2:	000d      	movs	r5, r1
    uint32_t timeout = ( uint32_t )time * 1000;
 8031ed4:	0154      	lsls	r4, r2, #5
 8031ed6:	1aa4      	subs	r4, r4, r2
 8031ed8:	00a4      	lsls	r4, r4, #2
 8031eda:	18a4      	adds	r4, r4, r2
 8031edc:	00e4      	lsls	r4, r4, #3
    SUBGRF_SetRfFrequency( freq );
 8031ede:	f001 f873 	bl	8032fc8 <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 8031ee2:	0028      	movs	r0, r5
 8031ee4:	f001 fc2f 	bl	8033746 <SUBGRF_SetRfTxPower>
    SUBGRF_SetSwitch(antswitchpow, RFSWITCH_TX);
 8031ee8:	2101      	movs	r1, #1
 8031eea:	f001 fc18 	bl	803371e <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 8031eee:	f000 ff9f 	bl	8032e30 <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 8031ef2:	4d04      	ldr	r5, [pc, #16]	; (8031f04 <RadioSetTxContinuousWave+0x34>)
 8031ef4:	0021      	movs	r1, r4
 8031ef6:	0028      	movs	r0, r5
 8031ef8:	f002 f9ee 	bl	80342d8 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 8031efc:	0028      	movs	r0, r5
 8031efe:	f002 f9a5 	bl	803424c <UTIL_TIMER_Start>
}
 8031f02:	bd70      	pop	{r4, r5, r6, pc}
 8031f04:	2000bd64 	.word	0x2000bd64

08031f08 <RadioSetChannel>:
{
 8031f08:	b510      	push	{r4, lr}
    SUBGRF_SetRfFrequency( freq );
 8031f0a:	f001 f85d 	bl	8032fc8 <SUBGRF_SetRfFrequency>
}
 8031f0e:	bd10      	pop	{r4, pc}

08031f10 <RadioStartCad>:
{
 8031f10:	b510      	push	{r4, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8031f12:	4a08      	ldr	r2, [pc, #32]	; (8031f34 <RadioStartCad+0x24>)
 8031f14:	2356      	movs	r3, #86	; 0x56
 8031f16:	5cd0      	ldrb	r0, [r2, r3]
 8031f18:	2100      	movs	r1, #0
 8031f1a:	f001 fc00 	bl	803371e <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 8031f1e:	20c0      	movs	r0, #192	; 0xc0
 8031f20:	0040      	lsls	r0, r0, #1
 8031f22:	2300      	movs	r3, #0
 8031f24:	2200      	movs	r2, #0
 8031f26:	0001      	movs	r1, r0
 8031f28:	f001 f826 	bl	8032f78 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetCad( );
 8031f2c:	f000 ff74 	bl	8032e18 <SUBGRF_SetCad>
}
 8031f30:	bd10      	pop	{r4, pc}
 8031f32:	46c0      	nop			; (mov r8, r8)
 8031f34:	2000bd0c 	.word	0x2000bd0c

08031f38 <RadioRx>:
{
 8031f38:	b570      	push	{r4, r5, r6, lr}
 8031f3a:	0004      	movs	r4, r0
    if ( 1UL == RFW_Is_Init( ) )
 8031f3c:	f001 fcda 	bl	80338f4 <RFW_Is_Init>
 8031f40:	2801      	cmp	r0, #1
 8031f42:	d014      	beq.n	8031f6e <RadioRx+0x36>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8031f44:	4813      	ldr	r0, [pc, #76]	; (8031f94 <RadioRx+0x5c>)
 8031f46:	2300      	movs	r3, #0
 8031f48:	2200      	movs	r2, #0
 8031f4a:	0001      	movs	r1, r0
 8031f4c:	f001 f814 	bl	8032f78 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 8031f50:	2c00      	cmp	r4, #0
 8031f52:	d10f      	bne.n	8031f74 <RadioRx+0x3c>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 8031f54:	4c10      	ldr	r4, [pc, #64]	; (8031f98 <RadioRx+0x60>)
 8031f56:	2356      	movs	r3, #86	; 0x56
 8031f58:	5ce0      	ldrb	r0, [r4, r3]
 8031f5a:	2100      	movs	r1, #0
 8031f5c:	f001 fbdf 	bl	803371e <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8031f60:	7863      	ldrb	r3, [r4, #1]
 8031f62:	2b00      	cmp	r3, #0
 8031f64:	d00f      	beq.n	8031f86 <RadioRx+0x4e>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8031f66:	480d      	ldr	r0, [pc, #52]	; (8031f9c <RadioRx+0x64>)
 8031f68:	f000 ff28 	bl	8032dbc <SUBGRF_SetRx>
}
 8031f6c:	bd70      	pop	{r4, r5, r6, pc}
      RFW_ReceiveInit( );
 8031f6e:	f001 fcc9 	bl	8033904 <RFW_ReceiveInit>
 8031f72:	e7ed      	b.n	8031f50 <RadioRx+0x18>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8031f74:	4d0a      	ldr	r5, [pc, #40]	; (8031fa0 <RadioRx+0x68>)
 8031f76:	0021      	movs	r1, r4
 8031f78:	0028      	movs	r0, r5
 8031f7a:	f002 f9ad 	bl	80342d8 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8031f7e:	0028      	movs	r0, r5
 8031f80:	f002 f964 	bl	803424c <UTIL_TIMER_Start>
 8031f84:	e7e6      	b.n	8031f54 <RadioRx+0x1c>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 8031f86:	4b04      	ldr	r3, [pc, #16]	; (8031f98 <RadioRx+0x60>)
 8031f88:	6898      	ldr	r0, [r3, #8]
 8031f8a:	0180      	lsls	r0, r0, #6
 8031f8c:	f000 ff16 	bl	8032dbc <SUBGRF_SetRx>
}
 8031f90:	e7ec      	b.n	8031f6c <RadioRx+0x34>
 8031f92:	46c0      	nop			; (mov r8, r8)
 8031f94:	00000262 	.word	0x00000262
 8031f98:	2000bd0c 	.word	0x2000bd0c
 8031f9c:	00ffffff 	.word	0x00ffffff
 8031fa0:	2000bd7c 	.word	0x2000bd7c

08031fa4 <RadioSleep>:
{
 8031fa4:	b510      	push	{r4, lr}
    SUBGRF_SetSleep( params );
 8031fa6:	2004      	movs	r0, #4
 8031fa8:	f001 f9c6 	bl	8033338 <SUBGRF_SetSleep>
    RADIO_DELAY_MS( 2 );
 8031fac:	2002      	movs	r0, #2
 8031fae:	f7ef fe1b 	bl	8021be8 <HAL_Delay>
}
 8031fb2:	bd10      	pop	{r4, pc}

08031fb4 <RadioSend>:
{
 8031fb4:	b570      	push	{r4, r5, r6, lr}
 8031fb6:	b082      	sub	sp, #8
 8031fb8:	0005      	movs	r5, r0
 8031fba:	000c      	movs	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8031fbc:	485e      	ldr	r0, [pc, #376]	; (8032138 <RadioSend+0x184>)
 8031fbe:	2300      	movs	r3, #0
 8031fc0:	2200      	movs	r2, #0
 8031fc2:	0001      	movs	r1, r0
 8031fc4:	f000 ffd8 	bl	8032f78 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 8031fc8:	4e5c      	ldr	r6, [pc, #368]	; (803213c <RadioSend+0x188>)
 8031fca:	2356      	movs	r3, #86	; 0x56
 8031fcc:	5cf0      	ldrb	r0, [r6, r3]
 8031fce:	2101      	movs	r1, #1
 8031fd0:	f001 fba5 	bl	803371e <SUBGRF_SetSwitch>
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 8031fd4:	7833      	ldrb	r3, [r6, #0]
 8031fd6:	2b01      	cmp	r3, #1
 8031fd8:	d104      	bne.n	8031fe4 <RadioSend+0x30>
 8031fda:	4a58      	ldr	r2, [pc, #352]	; (803213c <RadioSend+0x188>)
 8031fdc:	3350      	adds	r3, #80	; 0x50
 8031fde:	5cd3      	ldrb	r3, [r2, r3]
 8031fe0:	2b06      	cmp	r3, #6
 8031fe2:	d028      	beq.n	8032036 <RadioSend+0x82>
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8031fe4:	4e56      	ldr	r6, [pc, #344]	; (8032140 <RadioSend+0x18c>)
 8031fe6:	0030      	movs	r0, r6
 8031fe8:	f001 f948 	bl	803327c <SUBGRF_ReadRegister>
 8031fec:	2104      	movs	r1, #4
 8031fee:	4301      	orrs	r1, r0
 8031ff0:	b2c9      	uxtb	r1, r1
 8031ff2:	0030      	movs	r0, r6
 8031ff4:	f001 f868 	bl	80330c8 <SUBGRF_WriteRegister>
    switch(SubgRf.Modem)
 8031ff8:	4b50      	ldr	r3, [pc, #320]	; (803213c <RadioSend+0x188>)
 8031ffa:	781b      	ldrb	r3, [r3, #0]
 8031ffc:	2b02      	cmp	r3, #2
 8031ffe:	d100      	bne.n	8032002 <RadioSend+0x4e>
 8032000:	e084      	b.n	803210c <RadioSend+0x158>
 8032002:	d823      	bhi.n	803204c <RadioSend+0x98>
 8032004:	2b00      	cmp	r3, #0
 8032006:	d055      	beq.n	80320b4 <RadioSend+0x100>
 8032008:	2b01      	cmp	r3, #1
 803200a:	d109      	bne.n	8032020 <RadioSend+0x6c>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 803200c:	484b      	ldr	r0, [pc, #300]	; (803213c <RadioSend+0x188>)
 803200e:	77c4      	strb	r4, [r0, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032010:	300e      	adds	r0, #14
 8032012:	f001 fa83 	bl	803351c <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8032016:	2200      	movs	r2, #0
 8032018:	0021      	movs	r1, r4
 803201a:	0028      	movs	r0, r5
 803201c:	f001 fb4d 	bl	80336ba <SUBGRF_SendPayload>
    TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 8032020:	4b46      	ldr	r3, [pc, #280]	; (803213c <RadioSend+0x188>)
 8032022:	6859      	ldr	r1, [r3, #4]
 8032024:	4c47      	ldr	r4, [pc, #284]	; (8032144 <RadioSend+0x190>)
 8032026:	0020      	movs	r0, r4
 8032028:	f002 f956 	bl	80342d8 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 803202c:	0020      	movs	r0, r4
 803202e:	f002 f90d 	bl	803424c <UTIL_TIMER_Start>
}
 8032032:	b002      	add	sp, #8
 8032034:	bd70      	pop	{r4, r5, r6, pc}
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 8032036:	4e42      	ldr	r6, [pc, #264]	; (8032140 <RadioSend+0x18c>)
 8032038:	0030      	movs	r0, r6
 803203a:	f001 f91f 	bl	803327c <SUBGRF_ReadRegister>
 803203e:	2304      	movs	r3, #4
 8032040:	4398      	bics	r0, r3
 8032042:	b2c1      	uxtb	r1, r0
 8032044:	0030      	movs	r0, r6
 8032046:	f001 f83f 	bl	80330c8 <SUBGRF_WriteRegister>
 803204a:	e7d5      	b.n	8031ff8 <RadioSend+0x44>
    switch(SubgRf.Modem)
 803204c:	2b03      	cmp	r3, #3
 803204e:	d1e7      	bne.n	8032020 <RadioSend+0x6c>
            payload_integration( RadioBuffer, buffer, size );
 8032050:	0022      	movs	r2, r4
 8032052:	0029      	movs	r1, r5
 8032054:	483c      	ldr	r0, [pc, #240]	; (8032148 <RadioSend+0x194>)
 8032056:	f7ff fcd3 	bl	8031a00 <payload_integration>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 803205a:	4e38      	ldr	r6, [pc, #224]	; (803213c <RadioSend+0x188>)
 803205c:	2302      	movs	r3, #2
 803205e:	73b3      	strb	r3, [r6, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 8032060:	1c65      	adds	r5, r4, #1
 8032062:	b2ed      	uxtb	r5, r5
 8032064:	76b5      	strb	r5, [r6, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032066:	0030      	movs	r0, r6
 8032068:	300e      	adds	r0, #14
 803206a:	f001 fa57 	bl	803351c <SUBGRF_SetPacketParams>
            RadioWrite( 0x00F1, 0 ); // clean start-up LSB
 803206e:	2100      	movs	r1, #0
 8032070:	20f1      	movs	r0, #241	; 0xf1
 8032072:	f7ff fd4b 	bl	8031b0c <RadioWrite>
            RadioWrite( 0x00F0, 0 ); // clean start-up MSB
 8032076:	2100      	movs	r1, #0
 8032078:	20f0      	movs	r0, #240	; 0xf0
 803207a:	f7ff fd47 	bl	8031b0c <RadioWrite>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 803207e:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8032080:	2b64      	cmp	r3, #100	; 0x64
 8032082:	d050      	beq.n	8032126 <RadioSend+0x172>
                RadioWrite( 0x00F3, 0xE1 ); // clean end of frame LSB
 8032084:	21e1      	movs	r1, #225	; 0xe1
 8032086:	20f3      	movs	r0, #243	; 0xf3
 8032088:	f7ff fd40 	bl	8031b0c <RadioWrite>
                RadioWrite( 0x00F2, 0x04 ); // clean end of frame MSB
 803208c:	2104      	movs	r1, #4
 803208e:	20f2      	movs	r0, #242	; 0xf2
 8032090:	f7ff fd3c 	bl	8031b0c <RadioWrite>
            uint16_t bitNum = ( size * 8 ) + 2;
 8032094:	00e4      	lsls	r4, r4, #3
 8032096:	1ca6      	adds	r6, r4, #2
            RadioWrite( 0x00F4, ( bitNum >> 8 ) & 0x00FF );    // limit frame
 8032098:	0a21      	lsrs	r1, r4, #8
 803209a:	20f4      	movs	r0, #244	; 0xf4
 803209c:	f7ff fd36 	bl	8031b0c <RadioWrite>
            RadioWrite( 0x00F5, bitNum & 0x00FF );             // limit frame
 80320a0:	b2f1      	uxtb	r1, r6
 80320a2:	20f5      	movs	r0, #245	; 0xf5
 80320a4:	f7ff fd32 	bl	8031b0c <RadioWrite>
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 80320a8:	4a28      	ldr	r2, [pc, #160]	; (803214c <RadioSend+0x198>)
 80320aa:	0029      	movs	r1, r5
 80320ac:	4826      	ldr	r0, [pc, #152]	; (8032148 <RadioSend+0x194>)
 80320ae:	f001 fb04 	bl	80336ba <SUBGRF_SendPayload>
            break;
 80320b2:	e7b5      	b.n	8032020 <RadioSend+0x6c>
            if ( 1UL == RFW_Is_Init( ) )
 80320b4:	f001 fc1e 	bl	80338f4 <RFW_Is_Init>
 80320b8:	2801      	cmp	r0, #1
 80320ba:	d00a      	beq.n	80320d2 <RadioSend+0x11e>
              SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 80320bc:	481f      	ldr	r0, [pc, #124]	; (803213c <RadioSend+0x188>)
 80320be:	7584      	strb	r4, [r0, #22]
              SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80320c0:	300e      	adds	r0, #14
 80320c2:	f001 fa2b 	bl	803351c <SUBGRF_SetPacketParams>
              SUBGRF_SendPayload( buffer, size, 0 );
 80320c6:	2200      	movs	r2, #0
 80320c8:	0021      	movs	r1, r4
 80320ca:	0028      	movs	r0, r5
 80320cc:	f001 faf5 	bl	80336ba <SUBGRF_SendPayload>
 80320d0:	e7a6      	b.n	8032020 <RadioSend+0x6c>
              if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 80320d2:	466b      	mov	r3, sp
 80320d4:	1dda      	adds	r2, r3, #7
 80320d6:	0021      	movs	r1, r4
 80320d8:	0028      	movs	r0, r5
 80320da:	f001 fc10 	bl	80338fe <RFW_TransmitInit>
 80320de:	2800      	cmp	r0, #0
 80320e0:	d10d      	bne.n	80320fe <RadioSend+0x14a>
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 80320e2:	4816      	ldr	r0, [pc, #88]	; (803213c <RadioSend+0x188>)
 80320e4:	466b      	mov	r3, sp
 80320e6:	1ddc      	adds	r4, r3, #7
 80320e8:	79db      	ldrb	r3, [r3, #7]
 80320ea:	7583      	strb	r3, [r0, #22]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80320ec:	300e      	adds	r0, #14
 80320ee:	f001 fa15 	bl	803351c <SUBGRF_SetPacketParams>
                  SUBGRF_SendPayload( buffer, outsize, 0 );
 80320f2:	7821      	ldrb	r1, [r4, #0]
 80320f4:	2200      	movs	r2, #0
 80320f6:	0028      	movs	r0, r5
 80320f8:	f001 fadf 	bl	80336ba <SUBGRF_SendPayload>
 80320fc:	e790      	b.n	8032020 <RadioSend+0x6c>
                MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n");
 80320fe:	4b14      	ldr	r3, [pc, #80]	; (8032150 <RadioSend+0x19c>)
 8032100:	2201      	movs	r2, #1
 8032102:	2100      	movs	r1, #0
 8032104:	2002      	movs	r0, #2
 8032106:	f001 fcd7 	bl	8033ab8 <UTIL_ADV_TRACE_COND_FSend>
                return;
 803210a:	e792      	b.n	8032032 <RadioSend+0x7e>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 803210c:	480b      	ldr	r0, [pc, #44]	; (803213c <RadioSend+0x188>)
 803210e:	2302      	movs	r3, #2
 8032110:	7383      	strb	r3, [r0, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 8032112:	7684      	strb	r4, [r0, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032114:	300e      	adds	r0, #14
 8032116:	f001 fa01 	bl	803351c <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 803211a:	2200      	movs	r2, #0
 803211c:	0021      	movs	r1, r4
 803211e:	0028      	movs	r0, r5
 8032120:	f001 facb 	bl	80336ba <SUBGRF_SendPayload>
            break;
 8032124:	e77c      	b.n	8032020 <RadioSend+0x6c>
                RadioWrite( 0x00F3, 0x70 ); // clean end of frame LSB
 8032126:	2170      	movs	r1, #112	; 0x70
 8032128:	20f3      	movs	r0, #243	; 0xf3
 803212a:	f7ff fcef 	bl	8031b0c <RadioWrite>
                RadioWrite( 0x00F2, 0x1D ); // clean end of frame MSB
 803212e:	211d      	movs	r1, #29
 8032130:	20f2      	movs	r0, #242	; 0xf2
 8032132:	f7ff fceb 	bl	8031b0c <RadioWrite>
 8032136:	e7ad      	b.n	8032094 <RadioSend+0xe0>
 8032138:	00000201 	.word	0x00000201
 803213c:	2000bd0c 	.word	0x2000bd0c
 8032140:	00000889 	.word	0x00000889
 8032144:	2000bd64 	.word	0x2000bd64
 8032148:	2000b408 	.word	0x2000b408
 803214c:	00ffffff 	.word	0x00ffffff
 8032150:	08035698 	.word	0x08035698

08032154 <RadioSetModem>:
{
 8032154:	b510      	push	{r4, lr}
 8032156:	0004      	movs	r4, r0
    SubgRf.Modem = modem;
 8032158:	4b1a      	ldr	r3, [pc, #104]	; (80321c4 <RadioSetModem+0x70>)
 803215a:	7018      	strb	r0, [r3, #0]
    RFW_SetRadioModem(modem);
 803215c:	f001 fbd7 	bl	803390e <RFW_SetRadioModem>
    switch( modem )
 8032160:	2c03      	cmp	r4, #3
 8032162:	d027      	beq.n	80321b4 <RadioSetModem+0x60>
 8032164:	d80a      	bhi.n	803217c <RadioSetModem+0x28>
 8032166:	2c01      	cmp	r4, #1
 8032168:	d018      	beq.n	803219c <RadioSetModem+0x48>
 803216a:	2c02      	cmp	r4, #2
 803216c:	d10f      	bne.n	803218e <RadioSetModem+0x3a>
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 803216e:	2002      	movs	r0, #2
 8032170:	f000 fff2 	bl	8033158 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8032174:	4b13      	ldr	r3, [pc, #76]	; (80321c4 <RadioSetModem+0x70>)
 8032176:	2200      	movs	r2, #0
 8032178:	735a      	strb	r2, [r3, #13]
        break;
 803217a:	e00e      	b.n	803219a <RadioSetModem+0x46>
    switch( modem )
 803217c:	2c04      	cmp	r4, #4
 803217e:	d106      	bne.n	803218e <RadioSetModem+0x3a>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8032180:	2000      	movs	r0, #0
 8032182:	f000 ffe9 	bl	8033158 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8032186:	4b0f      	ldr	r3, [pc, #60]	; (80321c4 <RadioSetModem+0x70>)
 8032188:	2200      	movs	r2, #0
 803218a:	735a      	strb	r2, [r3, #13]
}
 803218c:	e005      	b.n	803219a <RadioSetModem+0x46>
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 803218e:	2000      	movs	r0, #0
 8032190:	f000 ffe2 	bl	8033158 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8032194:	4b0b      	ldr	r3, [pc, #44]	; (80321c4 <RadioSetModem+0x70>)
 8032196:	2200      	movs	r2, #0
 8032198:	735a      	strb	r2, [r3, #13]
}
 803219a:	bd10      	pop	{r4, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 803219c:	2001      	movs	r0, #1
 803219e:	f000 ffdb 	bl	8033158 <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 80321a2:	4b08      	ldr	r3, [pc, #32]	; (80321c4 <RadioSetModem+0x70>)
 80321a4:	7b5a      	ldrb	r2, [r3, #13]
 80321a6:	7b18      	ldrb	r0, [r3, #12]
 80321a8:	4282      	cmp	r2, r0
 80321aa:	d0f6      	beq.n	803219a <RadioSetModem+0x46>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 80321ac:	7358      	strb	r0, [r3, #13]
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 80321ae:	f000 fa7d 	bl	80326ac <RadioSetPublicNetwork>
 80321b2:	e7f2      	b.n	803219a <RadioSetModem+0x46>
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 80321b4:	2002      	movs	r0, #2
 80321b6:	f000 ffcf 	bl	8033158 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 80321ba:	4b02      	ldr	r3, [pc, #8]	; (80321c4 <RadioSetModem+0x70>)
 80321bc:	2200      	movs	r2, #0
 80321be:	735a      	strb	r2, [r3, #13]
        break;
 80321c0:	e7eb      	b.n	803219a <RadioSetModem+0x46>
 80321c2:	46c0      	nop			; (mov r8, r8)
 80321c4:	2000bd0c 	.word	0x2000bd0c

080321c8 <RadioSetTxGenericConfig>:
    }
    return status;
}

static int32_t RadioSetTxGenericConfig( GenericModems_t modem, TxConfigGeneric_t* config, int8_t power, uint32_t timeout )
{
 80321c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80321ca:	46c6      	mov	lr, r8
 80321cc:	b500      	push	{lr}
 80321ce:	b086      	sub	sp, #24
 80321d0:	0005      	movs	r5, r0
 80321d2:	000c      	movs	r4, r1
 80321d4:	0017      	movs	r7, r2
 80321d6:	001e      	movs	r6, r3
    uint8_t syncword[8] = {0};
 80321d8:	2300      	movs	r3, #0
 80321da:	9304      	str	r3, [sp, #16]
 80321dc:	9305      	str	r3, [sp, #20]
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 80321de:	f001 fb88 	bl	80338f2 <RFW_DeInit>
    switch( modem )
 80321e2:	2d01      	cmp	r5, #1
 80321e4:	d100      	bne.n	80321e8 <RadioSetTxGenericConfig+0x20>
 80321e6:	e085      	b.n	80322f4 <RadioSetTxGenericConfig+0x12c>
 80321e8:	2d02      	cmp	r5, #2
 80321ea:	d100      	bne.n	80321ee <RadioSetTxGenericConfig+0x26>
 80321ec:	e0eb      	b.n	80323c6 <RadioSetTxGenericConfig+0x1fe>
 80321ee:	2d00      	cmp	r5, #0
 80321f0:	d00d      	beq.n	803220e <RadioSetTxGenericConfig+0x46>
        break;
    default:
        break;
    }

    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 80321f2:	0038      	movs	r0, r7
 80321f4:	f001 faa7 	bl	8033746 <SUBGRF_SetRfTxPower>
 80321f8:	4c84      	ldr	r4, [pc, #528]	; (803240c <RadioSetTxGenericConfig+0x244>)
 80321fa:	2356      	movs	r3, #86	; 0x56
 80321fc:	54e0      	strb	r0, [r4, r3]
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 80321fe:	f001 fb7d 	bl	80338fc <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8032202:	6066      	str	r6, [r4, #4]
    return 0;
 8032204:	2000      	movs	r0, #0
}
 8032206:	b006      	add	sp, #24
 8032208:	bc80      	pop	{r7}
 803220a:	46b8      	mov	r8, r7
 803220c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 803220e:	68a3      	ldr	r3, [r4, #8]
 8032210:	2b00      	cmp	r3, #0
 8032212:	d100      	bne.n	8032216 <RadioSetTxGenericConfig+0x4e>
 8032214:	e0ed      	b.n	80323f2 <RadioSetTxGenericConfig+0x22a>
 8032216:	6923      	ldr	r3, [r4, #16]
 8032218:	2b00      	cmp	r3, #0
 803221a:	d100      	bne.n	803221e <RadioSetTxGenericConfig+0x56>
 803221c:	e0ec      	b.n	80323f8 <RadioSetTxGenericConfig+0x230>
        if( config->fsk.SyncWordLength > 8 )
 803221e:	7d20      	ldrb	r0, [r4, #20]
 8032220:	2808      	cmp	r0, #8
 8032222:	d900      	bls.n	8032226 <RadioSetTxGenericConfig+0x5e>
 8032224:	e0eb      	b.n	80323fe <RadioSetTxGenericConfig+0x236>
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8032226:	2100      	movs	r1, #0
 8032228:	e004      	b.n	8032234 <RadioSetTxGenericConfig+0x6c>
                syncword[i] = config->fsk.SyncWord[i];
 803222a:	69a3      	ldr	r3, [r4, #24]
 803222c:	5c5a      	ldrb	r2, [r3, r1]
 803222e:	ab04      	add	r3, sp, #16
 8032230:	545a      	strb	r2, [r3, r1]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8032232:	3101      	adds	r1, #1
 8032234:	4288      	cmp	r0, r1
 8032236:	dcf8      	bgt.n	803222a <RadioSetTxGenericConfig+0x62>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8032238:	4d74      	ldr	r5, [pc, #464]	; (803240c <RadioSetTxGenericConfig+0x244>)
 803223a:	2300      	movs	r3, #0
 803223c:	4698      	mov	r8, r3
 803223e:	3338      	adds	r3, #56	; 0x38
 8032240:	4642      	mov	r2, r8
 8032242:	54ea      	strb	r2, [r5, r3]
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8032244:	68a3      	ldr	r3, [r4, #8]
 8032246:	63eb      	str	r3, [r5, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 8032248:	7822      	ldrb	r2, [r4, #0]
 803224a:	2344      	movs	r3, #68	; 0x44
 803224c:	54ea      	strb	r2, [r5, r3]
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 803224e:	6860      	ldr	r0, [r4, #4]
 8032250:	f001 faea 	bl	8033828 <SUBGRF_GetFskBandwidthRegValue>
 8032254:	2345      	movs	r3, #69	; 0x45
 8032256:	54e8      	strb	r0, [r5, r3]
        SubgRf.ModulationParams.Params.Gfsk.Fdev = config->fsk.FrequencyDeviation;
 8032258:	68e3      	ldr	r3, [r4, #12]
 803225a:	642b      	str	r3, [r5, #64]	; 0x40
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 803225c:	4643      	mov	r3, r8
 803225e:	73ab      	strb	r3, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 8032260:	6923      	ldr	r3, [r4, #16]
 8032262:	00db      	lsls	r3, r3, #3
 8032264:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 8032266:	2304      	movs	r3, #4
 8032268:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 803226a:	7d23      	ldrb	r3, [r4, #20]
 803226c:	00db      	lsls	r3, r3, #3
 803226e:	74eb      	strb	r3, [r5, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 8032270:	4643      	mov	r3, r8
 8032272:	752b      	strb	r3, [r5, #20]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 8032274:	3324      	adds	r3, #36	; 0x24
 8032276:	5ce3      	ldrb	r3, [r4, r3]
 8032278:	2b02      	cmp	r3, #2
 803227a:	d008      	beq.n	803228e <RadioSetTxGenericConfig+0xc6>
 803227c:	7fa2      	ldrb	r2, [r4, #30]
 803227e:	2a02      	cmp	r2, #2
 8032280:	d005      	beq.n	803228e <RadioSetTxGenericConfig+0xc6>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 8032282:	7fe0      	ldrb	r0, [r4, #31]
 8032284:	4961      	ldr	r1, [pc, #388]	; (803240c <RadioSetTxGenericConfig+0x244>)
 8032286:	75c8      	strb	r0, [r1, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 8032288:	760b      	strb	r3, [r1, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 803228a:	754a      	strb	r2, [r1, #21]
 803228c:	e018      	b.n	80322c0 <RadioSetTxGenericConfig+0xf8>
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) &&( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 803228e:	7fe2      	ldrb	r2, [r4, #31]
 8032290:	0013      	movs	r3, r2
 8032292:	330f      	adds	r3, #15
 8032294:	b2db      	uxtb	r3, r3
 8032296:	2b01      	cmp	r3, #1
 8032298:	d901      	bls.n	803229e <RadioSetTxGenericConfig+0xd6>
 803229a:	2a01      	cmp	r2, #1
 803229c:	d127      	bne.n	80322ee <RadioSetTxGenericConfig+0x126>
            ConfigGeneric.rtx = CONFIG_TX;
 803229e:	a801      	add	r0, sp, #4
 80322a0:	2301      	movs	r3, #1
 80322a2:	7203      	strb	r3, [r0, #8]
            ConfigGeneric.TxConfig = config;
 80322a4:	9401      	str	r4, [sp, #4]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 80322a6:	4b5a      	ldr	r3, [pc, #360]	; (8032410 <RadioSetTxGenericConfig+0x248>)
 80322a8:	6819      	ldr	r1, [r3, #0]
 80322aa:	4a5a      	ldr	r2, [pc, #360]	; (8032414 <RadioSetTxGenericConfig+0x24c>)
 80322ac:	f001 fb1e 	bl	80338ec <RFW_Init>
 80322b0:	2800      	cmp	r0, #0
 80322b2:	d11c      	bne.n	80322ee <RadioSetTxGenericConfig+0x126>
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 80322b4:	4b55      	ldr	r3, [pc, #340]	; (803240c <RadioSetTxGenericConfig+0x244>)
 80322b6:	2200      	movs	r2, #0
 80322b8:	761a      	strb	r2, [r3, #24]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = (RadioCrcTypes_t) RADIO_CRC_OFF;
 80322ba:	2101      	movs	r1, #1
 80322bc:	75d9      	strb	r1, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 80322be:	755a      	strb	r2, [r3, #21]
        RadioStandby( );
 80322c0:	f7ff fc8e 	bl	8031be0 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 80322c4:	2000      	movs	r0, #0
 80322c6:	f7ff ff45 	bl	8032154 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80322ca:	4d53      	ldr	r5, [pc, #332]	; (8032418 <RadioSetTxGenericConfig+0x250>)
 80322cc:	0028      	movs	r0, r5
 80322ce:	f000 ff5d 	bl	803318c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80322d2:	0028      	movs	r0, r5
 80322d4:	382a      	subs	r0, #42	; 0x2a
 80322d6:	f001 f921 	bl	803351c <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 80322da:	a804      	add	r0, sp, #16
 80322dc:	f001 f8ec 	bl	80334b8 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 80322e0:	8ba0      	ldrh	r0, [r4, #28]
 80322e2:	f001 f84b 	bl	803337c <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial(config->fsk.CrcPolynomial );
 80322e6:	8c20      	ldrh	r0, [r4, #32]
 80322e8:	f001 f904 	bl	80334f4 <SUBGRF_SetCrcPolynomial>
        break;
 80322ec:	e781      	b.n	80321f2 <RadioSetTxGenericConfig+0x2a>
                return -1;
 80322ee:	2001      	movs	r0, #1
 80322f0:	4240      	negs	r0, r0
 80322f2:	e788      	b.n	8032206 <RadioSetTxGenericConfig+0x3e>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80322f4:	4b45      	ldr	r3, [pc, #276]	; (803240c <RadioSetTxGenericConfig+0x244>)
 80322f6:	2238      	movs	r2, #56	; 0x38
 80322f8:	2101      	movs	r1, #1
 80322fa:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 80322fc:	3a10      	subs	r2, #16
 80322fe:	5ca1      	ldrb	r1, [r4, r2]
 8032300:	3228      	adds	r2, #40	; 0x28
 8032302:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 8032304:	3a27      	subs	r2, #39	; 0x27
 8032306:	5ca1      	ldrb	r1, [r4, r2]
 8032308:	3228      	adds	r2, #40	; 0x28
 803230a:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 803230c:	3a27      	subs	r2, #39	; 0x27
 803230e:	5ca1      	ldrb	r1, [r4, r2]
 8032310:	3228      	adds	r2, #40	; 0x28
 8032312:	5499      	strb	r1, [r3, r2]
        switch( config->lora.LowDatarateOptimize )
 8032314:	232b      	movs	r3, #43	; 0x2b
 8032316:	5ce3      	ldrb	r3, [r4, r3]
 8032318:	2b01      	cmp	r3, #1
 803231a:	d034      	beq.n	8032386 <RadioSetTxGenericConfig+0x1be>
 803231c:	2b02      	cmp	r3, #2
 803231e:	d037      	beq.n	8032390 <RadioSetTxGenericConfig+0x1c8>
 8032320:	2b00      	cmp	r3, #0
 8032322:	d02b      	beq.n	803237c <RadioSetTxGenericConfig+0x1b4>
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8032324:	4d39      	ldr	r5, [pc, #228]	; (803240c <RadioSetTxGenericConfig+0x244>)
 8032326:	2301      	movs	r3, #1
 8032328:	73ab      	strb	r3, [r5, #14]
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 803232a:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 803232c:	83ab      	strh	r3, [r5, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 803232e:	232e      	movs	r3, #46	; 0x2e
 8032330:	5ce3      	ldrb	r3, [r4, r3]
 8032332:	77ab      	strb	r3, [r5, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 8032334:	232f      	movs	r3, #47	; 0x2f
 8032336:	5ce2      	ldrb	r2, [r4, r3]
 8032338:	3b0f      	subs	r3, #15
 803233a:	54ea      	strb	r2, [r5, r3]
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 803233c:	3310      	adds	r3, #16
 803233e:	5ce2      	ldrb	r2, [r4, r3]
 8032340:	3b0f      	subs	r3, #15
 8032342:	54ea      	strb	r2, [r5, r3]
        RadioStandby( );
 8032344:	f7ff fc4c 	bl	8031be0 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 8032348:	2001      	movs	r0, #1
 803234a:	f7ff ff03 	bl	8032154 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 803234e:	0028      	movs	r0, r5
 8032350:	3038      	adds	r0, #56	; 0x38
 8032352:	f000 ff1b 	bl	803318c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032356:	0028      	movs	r0, r5
 8032358:	300e      	adds	r0, #14
 803235a:	f001 f8df 	bl	803351c <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 803235e:	2351      	movs	r3, #81	; 0x51
 8032360:	5ceb      	ldrb	r3, [r5, r3]
 8032362:	2b06      	cmp	r3, #6
 8032364:	d024      	beq.n	80323b0 <RadioSetTxGenericConfig+0x1e8>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 8032366:	4c2d      	ldr	r4, [pc, #180]	; (803241c <RadioSetTxGenericConfig+0x254>)
 8032368:	0020      	movs	r0, r4
 803236a:	f000 ff87 	bl	803327c <SUBGRF_ReadRegister>
 803236e:	2104      	movs	r1, #4
 8032370:	4301      	orrs	r1, r0
 8032372:	b2c9      	uxtb	r1, r1
 8032374:	0020      	movs	r0, r4
 8032376:	f000 fea7 	bl	80330c8 <SUBGRF_WriteRegister>
 803237a:	e73a      	b.n	80321f2 <RadioSetTxGenericConfig+0x2a>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 803237c:	4a23      	ldr	r2, [pc, #140]	; (803240c <RadioSetTxGenericConfig+0x244>)
 803237e:	3353      	adds	r3, #83	; 0x53
 8032380:	2100      	movs	r1, #0
 8032382:	54d1      	strb	r1, [r2, r3]
            break;
 8032384:	e7ce      	b.n	8032324 <RadioSetTxGenericConfig+0x15c>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 8032386:	4a21      	ldr	r2, [pc, #132]	; (803240c <RadioSetTxGenericConfig+0x244>)
 8032388:	2353      	movs	r3, #83	; 0x53
 803238a:	2101      	movs	r1, #1
 803238c:	54d1      	strb	r1, [r2, r3]
            break;
 803238e:	e7c9      	b.n	8032324 <RadioSetTxGenericConfig+0x15c>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 8032390:	2328      	movs	r3, #40	; 0x28
 8032392:	5ce3      	ldrb	r3, [r4, r3]
 8032394:	3b0b      	subs	r3, #11
 8032396:	b2db      	uxtb	r3, r3
 8032398:	2b01      	cmp	r3, #1
 803239a:	d904      	bls.n	80323a6 <RadioSetTxGenericConfig+0x1de>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 803239c:	4a1b      	ldr	r2, [pc, #108]	; (803240c <RadioSetTxGenericConfig+0x244>)
 803239e:	2353      	movs	r3, #83	; 0x53
 80323a0:	2100      	movs	r1, #0
 80323a2:	54d1      	strb	r1, [r2, r3]
 80323a4:	e7be      	b.n	8032324 <RadioSetTxGenericConfig+0x15c>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 80323a6:	4a19      	ldr	r2, [pc, #100]	; (803240c <RadioSetTxGenericConfig+0x244>)
 80323a8:	2353      	movs	r3, #83	; 0x53
 80323aa:	2101      	movs	r1, #1
 80323ac:	54d1      	strb	r1, [r2, r3]
 80323ae:	e7b9      	b.n	8032324 <RadioSetTxGenericConfig+0x15c>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 80323b0:	4c1a      	ldr	r4, [pc, #104]	; (803241c <RadioSetTxGenericConfig+0x254>)
 80323b2:	0020      	movs	r0, r4
 80323b4:	f000 ff62 	bl	803327c <SUBGRF_ReadRegister>
 80323b8:	2304      	movs	r3, #4
 80323ba:	4398      	bics	r0, r3
 80323bc:	b2c1      	uxtb	r1, r0
 80323be:	0020      	movs	r0, r4
 80323c0:	f000 fe82 	bl	80330c8 <SUBGRF_WriteRegister>
 80323c4:	e715      	b.n	80321f2 <RadioSetTxGenericConfig+0x2a>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 80323c6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80323c8:	3b01      	subs	r3, #1
 80323ca:	22fa      	movs	r2, #250	; 0xfa
 80323cc:	0092      	lsls	r2, r2, #2
 80323ce:	4293      	cmp	r3, r2
 80323d0:	d218      	bcs.n	8032404 <RadioSetTxGenericConfig+0x23c>
        RadioSetModem( MODEM_BPSK );
 80323d2:	2002      	movs	r0, #2
 80323d4:	f7ff febe 	bl	8032154 <RadioSetModem>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 80323d8:	480c      	ldr	r0, [pc, #48]	; (803240c <RadioSetTxGenericConfig+0x244>)
 80323da:	2338      	movs	r3, #56	; 0x38
 80323dc:	2202      	movs	r2, #2
 80323de:	54c2      	strb	r2, [r0, r3]
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 80323e0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80323e2:	6483      	str	r3, [r0, #72]	; 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 80323e4:	234c      	movs	r3, #76	; 0x4c
 80323e6:	3214      	adds	r2, #20
 80323e8:	54c2      	strb	r2, [r0, r3]
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80323ea:	3038      	adds	r0, #56	; 0x38
 80323ec:	f000 fece 	bl	803318c <SUBGRF_SetModulationParams>
        break;
 80323f0:	e6ff      	b.n	80321f2 <RadioSetTxGenericConfig+0x2a>
            return -1;
 80323f2:	2001      	movs	r0, #1
 80323f4:	4240      	negs	r0, r0
 80323f6:	e706      	b.n	8032206 <RadioSetTxGenericConfig+0x3e>
 80323f8:	2001      	movs	r0, #1
 80323fa:	4240      	negs	r0, r0
 80323fc:	e703      	b.n	8032206 <RadioSetTxGenericConfig+0x3e>
            return -1;
 80323fe:	2001      	movs	r0, #1
 8032400:	4240      	negs	r0, r0
 8032402:	e700      	b.n	8032206 <RadioSetTxGenericConfig+0x3e>
            return -1;
 8032404:	2001      	movs	r0, #1
 8032406:	4240      	negs	r0, r0
 8032408:	e6fd      	b.n	8032206 <RadioSetTxGenericConfig+0x3e>
 803240a:	46c0      	nop			; (mov r8, r8)
 803240c:	2000bd0c 	.word	0x2000bd0c
 8032410:	2000b508 	.word	0x2000b508
 8032414:	2000bd64 	.word	0x2000bd64
 8032418:	2000bd44 	.word	0x2000bd44
 803241c:	00000889 	.word	0x00000889

08032420 <RadioSetRxGenericConfig>:
{
 8032420:	b5f0      	push	{r4, r5, r6, r7, lr}
 8032422:	b087      	sub	sp, #28
 8032424:	0007      	movs	r7, r0
 8032426:	000c      	movs	r4, r1
 8032428:	0015      	movs	r5, r2
 803242a:	001e      	movs	r6, r3
    uint8_t syncword[8] = {0};
 803242c:	2300      	movs	r3, #0
 803242e:	9304      	str	r3, [sp, #16]
 8032430:	9305      	str	r3, [sp, #20]
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 8032432:	f001 fa5e 	bl	80338f2 <RFW_DeInit>
    if( rxContinuous != 0 )
 8032436:	2d00      	cmp	r5, #0
 8032438:	d000      	beq.n	803243c <RadioSetRxGenericConfig+0x1c>
        symbTimeout = 0;
 803243a:	2600      	movs	r6, #0
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 803243c:	1e6a      	subs	r2, r5, #1
 803243e:	4195      	sbcs	r5, r2
 8032440:	4b94      	ldr	r3, [pc, #592]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 8032442:	705d      	strb	r5, [r3, #1]
    switch( modem )
 8032444:	2f00      	cmp	r7, #0
 8032446:	d005      	beq.n	8032454 <RadioSetRxGenericConfig+0x34>
 8032448:	2f01      	cmp	r7, #1
 803244a:	d100      	bne.n	803244e <RadioSetRxGenericConfig+0x2e>
 803244c:	e094      	b.n	8032578 <RadioSetRxGenericConfig+0x158>
 803244e:	2000      	movs	r0, #0
}
 8032450:	b007      	add	sp, #28
 8032452:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 8032454:	68e3      	ldr	r3, [r4, #12]
 8032456:	2b00      	cmp	r3, #0
 8032458:	d100      	bne.n	803245c <RadioSetRxGenericConfig+0x3c>
 803245a:	e10e      	b.n	803267a <RadioSetRxGenericConfig+0x25a>
 803245c:	6923      	ldr	r3, [r4, #16]
 803245e:	2b00      	cmp	r3, #0
 8032460:	d100      	bne.n	8032464 <RadioSetRxGenericConfig+0x44>
 8032462:	e10d      	b.n	8032680 <RadioSetRxGenericConfig+0x260>
        if( config->fsk.SyncWordLength > 8 )
 8032464:	7d60      	ldrb	r0, [r4, #21]
 8032466:	2808      	cmp	r0, #8
 8032468:	d900      	bls.n	803246c <RadioSetRxGenericConfig+0x4c>
 803246a:	e10c      	b.n	8032686 <RadioSetRxGenericConfig+0x266>
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 803246c:	2200      	movs	r2, #0
 803246e:	e004      	b.n	803247a <RadioSetRxGenericConfig+0x5a>
                syncword[i] = config->fsk.SyncWord[i];
 8032470:	69a3      	ldr	r3, [r4, #24]
 8032472:	5c99      	ldrb	r1, [r3, r2]
 8032474:	ab04      	add	r3, sp, #16
 8032476:	5499      	strb	r1, [r3, r2]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 8032478:	3201      	adds	r2, #1
 803247a:	4290      	cmp	r0, r2
 803247c:	dcf8      	bgt.n	8032470 <RadioSetRxGenericConfig+0x50>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803247e:	6820      	ldr	r0, [r4, #0]
 8032480:	1e43      	subs	r3, r0, #1
 8032482:	4198      	sbcs	r0, r3
 8032484:	b2c0      	uxtb	r0, r0
 8032486:	f000 fce1 	bl	8032e4c <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 803248a:	4d82      	ldr	r5, [pc, #520]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 803248c:	2700      	movs	r7, #0
 803248e:	2338      	movs	r3, #56	; 0x38
 8032490:	54ef      	strb	r7, [r5, r3]
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 8032492:	68e3      	ldr	r3, [r4, #12]
 8032494:	63eb      	str	r3, [r5, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = (RadioModShapings_t) config->fsk.ModulationShaping;
 8032496:	7922      	ldrb	r2, [r4, #4]
 8032498:	2344      	movs	r3, #68	; 0x44
 803249a:	54ea      	strb	r2, [r5, r3]
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 803249c:	68a0      	ldr	r0, [r4, #8]
 803249e:	f001 f9c3 	bl	8033828 <SUBGRF_GetFskBandwidthRegValue>
 80324a2:	2345      	movs	r3, #69	; 0x45
 80324a4:	54e8      	strb	r0, [r5, r3]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 80324a6:	73af      	strb	r7, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 80324a8:	6923      	ldr	r3, [r4, #16]
 80324aa:	00db      	lsls	r3, r3, #3
 80324ac:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 80324ae:	7d23      	ldrb	r3, [r4, #20]
 80324b0:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 80324b2:	7d63      	ldrb	r3, [r4, #21]
 80324b4:	00db      	lsls	r3, r3, #3
 80324b6:	74eb      	strb	r3, [r5, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 80324b8:	2322      	movs	r3, #34	; 0x22
 80324ba:	5ce3      	ldrb	r3, [r4, r3]
 80324bc:	752b      	strb	r3, [r5, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 80324be:	2323      	movs	r3, #35	; 0x23
 80324c0:	5ce3      	ldrb	r3, [r4, r3]
 80324c2:	2b00      	cmp	r3, #0
 80324c4:	d10f      	bne.n	80324e6 <RadioSetRxGenericConfig+0xc6>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 80324c6:	4a73      	ldr	r2, [pc, #460]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 80324c8:	69e1      	ldr	r1, [r4, #28]
 80324ca:	7591      	strb	r1, [r2, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 80324cc:	222a      	movs	r2, #42	; 0x2a
 80324ce:	5ca2      	ldrb	r2, [r4, r2]
 80324d0:	2a02      	cmp	r2, #2
 80324d2:	d012      	beq.n	80324fa <RadioSetRxGenericConfig+0xda>
 80324d4:	2b02      	cmp	r3, #2
 80324d6:	d010      	beq.n	80324fa <RadioSetRxGenericConfig+0xda>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 80324d8:	2124      	movs	r1, #36	; 0x24
 80324da:	5c60      	ldrb	r0, [r4, r1]
 80324dc:	496d      	ldr	r1, [pc, #436]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 80324de:	75c8      	strb	r0, [r1, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 80324e0:	760a      	strb	r2, [r1, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 80324e2:	754b      	strb	r3, [r1, #21]
 80324e4:	e023      	b.n	803252e <RadioSetRxGenericConfig+0x10e>
        else if( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH )
 80324e6:	2b02      	cmp	r3, #2
 80324e8:	d003      	beq.n	80324f2 <RadioSetRxGenericConfig+0xd2>
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 80324ea:	4a6a      	ldr	r2, [pc, #424]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 80324ec:	21ff      	movs	r1, #255	; 0xff
 80324ee:	7591      	strb	r1, [r2, #22]
 80324f0:	e7ec      	b.n	80324cc <RadioSetRxGenericConfig+0xac>
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 80324f2:	4a68      	ldr	r2, [pc, #416]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 80324f4:	21ff      	movs	r1, #255	; 0xff
 80324f6:	7591      	strb	r1, [r2, #22]
 80324f8:	e7e8      	b.n	80324cc <RadioSetRxGenericConfig+0xac>
          if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 80324fa:	2324      	movs	r3, #36	; 0x24
 80324fc:	5ce2      	ldrb	r2, [r4, r3]
 80324fe:	0013      	movs	r3, r2
 8032500:	330f      	adds	r3, #15
 8032502:	b2db      	uxtb	r3, r3
 8032504:	2b01      	cmp	r3, #1
 8032506:	d901      	bls.n	803250c <RadioSetRxGenericConfig+0xec>
 8032508:	2a01      	cmp	r2, #1
 803250a:	d132      	bne.n	8032572 <RadioSetRxGenericConfig+0x152>
          ConfigGeneric.rtx = CONFIG_RX;
 803250c:	a801      	add	r0, sp, #4
 803250e:	2300      	movs	r3, #0
 8032510:	7203      	strb	r3, [r0, #8]
          ConfigGeneric.RxConfig = config;
 8032512:	6044      	str	r4, [r0, #4]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 8032514:	4b60      	ldr	r3, [pc, #384]	; (8032698 <RadioSetRxGenericConfig+0x278>)
 8032516:	6819      	ldr	r1, [r3, #0]
 8032518:	4a60      	ldr	r2, [pc, #384]	; (803269c <RadioSetRxGenericConfig+0x27c>)
 803251a:	f001 f9e7 	bl	80338ec <RFW_Init>
 803251e:	2800      	cmp	r0, #0
 8032520:	d127      	bne.n	8032572 <RadioSetRxGenericConfig+0x152>
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 8032522:	4b5c      	ldr	r3, [pc, #368]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 8032524:	2200      	movs	r2, #0
 8032526:	761a      	strb	r2, [r3, #24]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 8032528:	2101      	movs	r1, #1
 803252a:	75d9      	strb	r1, [r3, #23]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 803252c:	755a      	strb	r2, [r3, #21]
        RadioStandby( );
 803252e:	f7ff fb57 	bl	8031be0 <RadioStandby>
        RadioSetModem( MODEM_FSK );
 8032532:	2000      	movs	r0, #0
 8032534:	f7ff fe0e 	bl	8032154 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032538:	4d59      	ldr	r5, [pc, #356]	; (80326a0 <RadioSetRxGenericConfig+0x280>)
 803253a:	0028      	movs	r0, r5
 803253c:	f000 fe26 	bl	803318c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032540:	0028      	movs	r0, r5
 8032542:	382a      	subs	r0, #42	; 0x2a
 8032544:	f000 ffea 	bl	803351c <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 8032548:	a804      	add	r0, sp, #16
 803254a:	f000 ffb5 	bl	80334b8 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 803254e:	8c20      	ldrh	r0, [r4, #32]
 8032550:	f000 ff14 	bl	803337c <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 8032554:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
 8032556:	f000 ffcd 	bl	80334f4 <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 803255a:	0170      	lsls	r0, r6, #5
 803255c:	1b80      	subs	r0, r0, r6
 803255e:	0080      	lsls	r0, r0, #2
 8032560:	1980      	adds	r0, r0, r6
 8032562:	0180      	lsls	r0, r0, #6
 8032564:	68e1      	ldr	r1, [r4, #12]
 8032566:	f7ed fdd7 	bl	8020118 <__udivsi3>
 803256a:	3d38      	subs	r5, #56	; 0x38
 803256c:	60a8      	str	r0, [r5, #8]
    return status;
 803256e:	2000      	movs	r0, #0
        break;
 8032570:	e76e      	b.n	8032450 <RadioSetRxGenericConfig+0x30>
            return -1;
 8032572:	2001      	movs	r0, #1
 8032574:	4240      	negs	r0, r0
 8032576:	e76b      	b.n	8032450 <RadioSetRxGenericConfig+0x30>
        if( config->lora.PreambleLen == 0 )
 8032578:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 803257a:	2b00      	cmp	r3, #0
 803257c:	d100      	bne.n	8032580 <RadioSetRxGenericConfig+0x160>
 803257e:	e085      	b.n	803268c <RadioSetRxGenericConfig+0x26c>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 8032580:	2336      	movs	r3, #54	; 0x36
 8032582:	5ce3      	ldrb	r3, [r4, r3]
 8032584:	2b01      	cmp	r3, #1
 8032586:	d051      	beq.n	803262c <RadioSetRxGenericConfig+0x20c>
            MaxPayloadLength = 0xFF;
 8032588:	27ff      	movs	r7, #255	; 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 803258a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 803258c:	1e43      	subs	r3, r0, #1
 803258e:	4198      	sbcs	r0, r3
 8032590:	b2c0      	uxtb	r0, r0
 8032592:	f000 fc5b 	bl	8032e4c <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8032596:	b2f0      	uxtb	r0, r6
 8032598:	f000 fdbe 	bl	8033118 <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 803259c:	4b3d      	ldr	r3, [pc, #244]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 803259e:	2238      	movs	r2, #56	; 0x38
 80325a0:	2101      	movs	r1, #1
 80325a2:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 80325a4:	3a08      	subs	r2, #8
 80325a6:	5ca1      	ldrb	r1, [r4, r2]
 80325a8:	3220      	adds	r2, #32
 80325aa:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 80325ac:	3a1f      	subs	r2, #31
 80325ae:	5ca1      	ldrb	r1, [r4, r2]
 80325b0:	3220      	adds	r2, #32
 80325b2:	5499      	strb	r1, [r3, r2]
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 80325b4:	3a1f      	subs	r2, #31
 80325b6:	5ca1      	ldrb	r1, [r4, r2]
 80325b8:	3220      	adds	r2, #32
 80325ba:	5499      	strb	r1, [r3, r2]
        switch( config->lora.LowDatarateOptimize )
 80325bc:	2333      	movs	r3, #51	; 0x33
 80325be:	5ce3      	ldrb	r3, [r4, r3]
 80325c0:	2b01      	cmp	r3, #1
 80325c2:	d03a      	beq.n	803263a <RadioSetRxGenericConfig+0x21a>
 80325c4:	2b02      	cmp	r3, #2
 80325c6:	d03d      	beq.n	8032644 <RadioSetRxGenericConfig+0x224>
 80325c8:	2b00      	cmp	r3, #0
 80325ca:	d031      	beq.n	8032630 <RadioSetRxGenericConfig+0x210>
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 80325cc:	4d31      	ldr	r5, [pc, #196]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 80325ce:	2301      	movs	r3, #1
 80325d0:	73ab      	strb	r3, [r5, #14]
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 80325d2:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 80325d4:	83ab      	strh	r3, [r5, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 80325d6:	2336      	movs	r3, #54	; 0x36
 80325d8:	5ce3      	ldrb	r3, [r4, r3]
 80325da:	77ab      	strb	r3, [r5, #30]
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 80325dc:	77ef      	strb	r7, [r5, #31]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 80325de:	2338      	movs	r3, #56	; 0x38
 80325e0:	5ce2      	ldrb	r2, [r4, r3]
 80325e2:	3b18      	subs	r3, #24
 80325e4:	54ea      	strb	r2, [r5, r3]
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 80325e6:	3319      	adds	r3, #25
 80325e8:	5ce3      	ldrb	r3, [r4, r3]
 80325ea:	2421      	movs	r4, #33	; 0x21
 80325ec:	552b      	strb	r3, [r5, r4]
        RadioStandby( );
 80325ee:	f7ff faf7 	bl	8031be0 <RadioStandby>
        RadioSetModem( MODEM_LORA );
 80325f2:	2001      	movs	r0, #1
 80325f4:	f7ff fdae 	bl	8032154 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80325f8:	0028      	movs	r0, r5
 80325fa:	3038      	adds	r0, #56	; 0x38
 80325fc:	f000 fdc6 	bl	803318c <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032600:	0028      	movs	r0, r5
 8032602:	300e      	adds	r0, #14
 8032604:	f000 ff8a 	bl	803351c <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8032608:	5d2b      	ldrb	r3, [r5, r4]
 803260a:	2b01      	cmp	r3, #1
 803260c:	d02a      	beq.n	8032664 <RadioSetRxGenericConfig+0x244>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 803260e:	4c25      	ldr	r4, [pc, #148]	; (80326a4 <RadioSetRxGenericConfig+0x284>)
 8032610:	0020      	movs	r0, r4
 8032612:	f000 fe33 	bl	803327c <SUBGRF_ReadRegister>
 8032616:	2104      	movs	r1, #4
 8032618:	4301      	orrs	r1, r0
 803261a:	b2c9      	uxtb	r1, r1
 803261c:	0020      	movs	r0, r4
 803261e:	f000 fd53 	bl	80330c8 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 8032622:	4b1c      	ldr	r3, [pc, #112]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 8032624:	4a20      	ldr	r2, [pc, #128]	; (80326a8 <RadioSetRxGenericConfig+0x288>)
 8032626:	609a      	str	r2, [r3, #8]
    return status;
 8032628:	2000      	movs	r0, #0
        break;
 803262a:	e711      	b.n	8032450 <RadioSetRxGenericConfig+0x30>
            MaxPayloadLength = config->fsk.MaxPayloadLength;
 803262c:	7f27      	ldrb	r7, [r4, #28]
 803262e:	e7ac      	b.n	803258a <RadioSetRxGenericConfig+0x16a>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8032630:	4a18      	ldr	r2, [pc, #96]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 8032632:	3353      	adds	r3, #83	; 0x53
 8032634:	2100      	movs	r1, #0
 8032636:	54d1      	strb	r1, [r2, r3]
            break;
 8032638:	e7c8      	b.n	80325cc <RadioSetRxGenericConfig+0x1ac>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 803263a:	4a16      	ldr	r2, [pc, #88]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 803263c:	2353      	movs	r3, #83	; 0x53
 803263e:	2101      	movs	r1, #1
 8032640:	54d1      	strb	r1, [r2, r3]
            break;
 8032642:	e7c3      	b.n	80325cc <RadioSetRxGenericConfig+0x1ac>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 8032644:	2330      	movs	r3, #48	; 0x30
 8032646:	5ce3      	ldrb	r3, [r4, r3]
 8032648:	3b0b      	subs	r3, #11
 803264a:	b2db      	uxtb	r3, r3
 803264c:	2b01      	cmp	r3, #1
 803264e:	d904      	bls.n	803265a <RadioSetRxGenericConfig+0x23a>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 8032650:	4a10      	ldr	r2, [pc, #64]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 8032652:	2353      	movs	r3, #83	; 0x53
 8032654:	2100      	movs	r1, #0
 8032656:	54d1      	strb	r1, [r2, r3]
 8032658:	e7b8      	b.n	80325cc <RadioSetRxGenericConfig+0x1ac>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 803265a:	4a0e      	ldr	r2, [pc, #56]	; (8032694 <RadioSetRxGenericConfig+0x274>)
 803265c:	2353      	movs	r3, #83	; 0x53
 803265e:	2101      	movs	r1, #1
 8032660:	54d1      	strb	r1, [r2, r3]
 8032662:	e7b3      	b.n	80325cc <RadioSetRxGenericConfig+0x1ac>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8032664:	4c0f      	ldr	r4, [pc, #60]	; (80326a4 <RadioSetRxGenericConfig+0x284>)
 8032666:	0020      	movs	r0, r4
 8032668:	f000 fe08 	bl	803327c <SUBGRF_ReadRegister>
 803266c:	2304      	movs	r3, #4
 803266e:	4398      	bics	r0, r3
 8032670:	b2c1      	uxtb	r1, r0
 8032672:	0020      	movs	r0, r4
 8032674:	f000 fd28 	bl	80330c8 <SUBGRF_WriteRegister>
 8032678:	e7d3      	b.n	8032622 <RadioSetRxGenericConfig+0x202>
            return -1;
 803267a:	2001      	movs	r0, #1
 803267c:	4240      	negs	r0, r0
 803267e:	e6e7      	b.n	8032450 <RadioSetRxGenericConfig+0x30>
 8032680:	2001      	movs	r0, #1
 8032682:	4240      	negs	r0, r0
 8032684:	e6e4      	b.n	8032450 <RadioSetRxGenericConfig+0x30>
            return -1;
 8032686:	2001      	movs	r0, #1
 8032688:	4240      	negs	r0, r0
 803268a:	e6e1      	b.n	8032450 <RadioSetRxGenericConfig+0x30>
            return -1;
 803268c:	2001      	movs	r0, #1
 803268e:	4240      	negs	r0, r0
 8032690:	e6de      	b.n	8032450 <RadioSetRxGenericConfig+0x30>
 8032692:	46c0      	nop			; (mov r8, r8)
 8032694:	2000bd0c 	.word	0x2000bd0c
 8032698:	2000b508 	.word	0x2000b508
 803269c:	2000bd7c 	.word	0x2000bd7c
 80326a0:	2000bd44 	.word	0x2000bd44
 80326a4:	00000736 	.word	0x00000736
 80326a8:	0000ffff 	.word	0x0000ffff

080326ac <RadioSetPublicNetwork>:
{
 80326ac:	b510      	push	{r4, lr}
 80326ae:	0004      	movs	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 80326b0:	4b0d      	ldr	r3, [pc, #52]	; (80326e8 <RadioSetPublicNetwork+0x3c>)
 80326b2:	7318      	strb	r0, [r3, #12]
 80326b4:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 80326b6:	2001      	movs	r0, #1
 80326b8:	f7ff fd4c 	bl	8032154 <RadioSetModem>
    if( enable == true )
 80326bc:	2c00      	cmp	r4, #0
 80326be:	d009      	beq.n	80326d4 <RadioSetPublicNetwork+0x28>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 80326c0:	20e8      	movs	r0, #232	; 0xe8
 80326c2:	2134      	movs	r1, #52	; 0x34
 80326c4:	00c0      	lsls	r0, r0, #3
 80326c6:	f000 fcff 	bl	80330c8 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 80326ca:	2144      	movs	r1, #68	; 0x44
 80326cc:	4807      	ldr	r0, [pc, #28]	; (80326ec <RadioSetPublicNetwork+0x40>)
 80326ce:	f000 fcfb 	bl	80330c8 <SUBGRF_WriteRegister>
}
 80326d2:	bd10      	pop	{r4, pc}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 80326d4:	20e8      	movs	r0, #232	; 0xe8
 80326d6:	2114      	movs	r1, #20
 80326d8:	00c0      	lsls	r0, r0, #3
 80326da:	f000 fcf5 	bl	80330c8 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 80326de:	2124      	movs	r1, #36	; 0x24
 80326e0:	4802      	ldr	r0, [pc, #8]	; (80326ec <RadioSetPublicNetwork+0x40>)
 80326e2:	f000 fcf1 	bl	80330c8 <SUBGRF_WriteRegister>
}
 80326e6:	e7f4      	b.n	80326d2 <RadioSetPublicNetwork+0x26>
 80326e8:	2000bd0c 	.word	0x2000bd0c
 80326ec:	00000741 	.word	0x00000741

080326f0 <RadioSetTxConfig>:
{
 80326f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80326f2:	46de      	mov	lr, fp
 80326f4:	4657      	mov	r7, sl
 80326f6:	464e      	mov	r6, r9
 80326f8:	4645      	mov	r5, r8
 80326fa:	b5e0      	push	{r5, r6, r7, lr}
 80326fc:	b085      	sub	sp, #20
 80326fe:	0004      	movs	r4, r0
 8032700:	9100      	str	r1, [sp, #0]
 8032702:	9201      	str	r2, [sp, #4]
 8032704:	001d      	movs	r5, r3
 8032706:	ab0e      	add	r3, sp, #56	; 0x38
 8032708:	cb80      	ldmia	r3!, {r7}
 803270a:	781b      	ldrb	r3, [r3, #0]
 803270c:	469b      	mov	fp, r3
 803270e:	ab10      	add	r3, sp, #64	; 0x40
 8032710:	881e      	ldrh	r6, [r3, #0]
 8032712:	ab11      	add	r3, sp, #68	; 0x44
 8032714:	781b      	ldrb	r3, [r3, #0]
 8032716:	4699      	mov	r9, r3
 8032718:	ab12      	add	r3, sp, #72	; 0x48
 803271a:	781b      	ldrb	r3, [r3, #0]
 803271c:	4698      	mov	r8, r3
 803271e:	ab15      	add	r3, sp, #84	; 0x54
 8032720:	781b      	ldrb	r3, [r3, #0]
 8032722:	469a      	mov	sl, r3
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 8032724:	f001 f8e5 	bl	80338f2 <RFW_DeInit>
    switch( modem )
 8032728:	2c01      	cmp	r4, #1
 803272a:	d05d      	beq.n	80327e8 <RadioSetTxConfig+0xf8>
 803272c:	2c03      	cmp	r4, #3
 803272e:	d100      	bne.n	8032732 <RadioSetTxConfig+0x42>
 8032730:	e0ab      	b.n	803288a <RadioSetTxConfig+0x19a>
 8032732:	2c00      	cmp	r4, #0
 8032734:	d010      	beq.n	8032758 <RadioSetTxConfig+0x68>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8032736:	9800      	ldr	r0, [sp, #0]
 8032738:	f001 f805 	bl	8033746 <SUBGRF_SetRfTxPower>
 803273c:	4c5a      	ldr	r4, [pc, #360]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 803273e:	2356      	movs	r3, #86	; 0x56
 8032740:	54e0      	strb	r0, [r4, r3]
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect ); /* ST_WORKAROUND: ?????? */
 8032742:	f001 f8db 	bl	80338fc <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8032746:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8032748:	6063      	str	r3, [r4, #4]
}
 803274a:	b005      	add	sp, #20
 803274c:	bcf0      	pop	{r4, r5, r6, r7}
 803274e:	46bb      	mov	fp, r7
 8032750:	46b2      	mov	sl, r6
 8032752:	46a9      	mov	r9, r5
 8032754:	46a0      	mov	r8, r4
 8032756:	bdf0      	pop	{r4, r5, r6, r7, pc}
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8032758:	4c53      	ldr	r4, [pc, #332]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 803275a:	2300      	movs	r3, #0
 803275c:	469a      	mov	sl, r3
 803275e:	3338      	adds	r3, #56	; 0x38
 8032760:	4652      	mov	r2, sl
 8032762:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8032764:	63e7      	str	r7, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8032766:	330c      	adds	r3, #12
 8032768:	320b      	adds	r2, #11
 803276a:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 803276c:	0028      	movs	r0, r5
 803276e:	f001 f85b 	bl	8033828 <SUBGRF_GetFskBandwidthRegValue>
 8032772:	2345      	movs	r3, #69	; 0x45
 8032774:	54e0      	strb	r0, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 8032776:	9b01      	ldr	r3, [sp, #4]
 8032778:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 803277a:	4653      	mov	r3, sl
 803277c:	73a3      	strb	r3, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 803277e:	00f6      	lsls	r6, r6, #3
 8032780:	8226      	strh	r6, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8032782:	3304      	adds	r3, #4
 8032784:	74a3      	strb	r3, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 3 << 3 ; // convert byte into bit
 8032786:	3314      	adds	r3, #20
 8032788:	74e3      	strb	r3, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 803278a:	4653      	mov	r3, sl
 803278c:	7523      	strb	r3, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 803278e:	2301      	movs	r3, #1
 8032790:	464a      	mov	r2, r9
 8032792:	405a      	eors	r2, r3
 8032794:	7562      	strb	r2, [r4, #21]
            if( crcOn == true )
 8032796:	4643      	mov	r3, r8
 8032798:	2b00      	cmp	r3, #0
 803279a:	d021      	beq.n	80327e0 <RadioSetTxConfig+0xf0>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 803279c:	4b42      	ldr	r3, [pc, #264]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 803279e:	22f2      	movs	r2, #242	; 0xf2
 80327a0:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 80327a2:	4c41      	ldr	r4, [pc, #260]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 80327a4:	2301      	movs	r3, #1
 80327a6:	7623      	strb	r3, [r4, #24]
            RadioStandby( );
 80327a8:	f7ff fa1a 	bl	8031be0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 80327ac:	2338      	movs	r3, #56	; 0x38
 80327ae:	5ce0      	ldrb	r0, [r4, r3]
 80327b0:	1e43      	subs	r3, r0, #1
 80327b2:	4198      	sbcs	r0, r3
 80327b4:	b2c0      	uxtb	r0, r0
 80327b6:	f7ff fccd 	bl	8032154 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80327ba:	0020      	movs	r0, r4
 80327bc:	3038      	adds	r0, #56	; 0x38
 80327be:	f000 fce5 	bl	803318c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80327c2:	0020      	movs	r0, r4
 80327c4:	300e      	adds	r0, #14
 80327c6:	f000 fea9 	bl	803351c <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 80327ca:	a802      	add	r0, sp, #8
 80327cc:	4b37      	ldr	r3, [pc, #220]	; (80328ac <RadioSetTxConfig+0x1bc>)
 80327ce:	0002      	movs	r2, r0
 80327d0:	cb12      	ldmia	r3!, {r1, r4}
 80327d2:	c212      	stmia	r2!, {r1, r4}
 80327d4:	f000 fe70 	bl	80334b8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 80327d8:	4835      	ldr	r0, [pc, #212]	; (80328b0 <RadioSetTxConfig+0x1c0>)
 80327da:	f000 fdcf 	bl	803337c <SUBGRF_SetWhiteningSeed>
            break;
 80327de:	e7aa      	b.n	8032736 <RadioSetTxConfig+0x46>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 80327e0:	4b31      	ldr	r3, [pc, #196]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 80327e2:	2201      	movs	r2, #1
 80327e4:	75da      	strb	r2, [r3, #23]
 80327e6:	e7dc      	b.n	80327a2 <RadioSetTxConfig+0xb2>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 80327e8:	4a2f      	ldr	r2, [pc, #188]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 80327ea:	2338      	movs	r3, #56	; 0x38
 80327ec:	2101      	movs	r1, #1
 80327ee:	54d1      	strb	r1, [r2, r3]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 80327f0:	b2fb      	uxtb	r3, r7
 80327f2:	314f      	adds	r1, #79	; 0x4f
 80327f4:	5453      	strb	r3, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 80327f6:	492f      	ldr	r1, [pc, #188]	; (80328b4 <RadioSetTxConfig+0x1c4>)
 80327f8:	5d48      	ldrb	r0, [r1, r5]
 80327fa:	2151      	movs	r1, #81	; 0x51
 80327fc:	5450      	strb	r0, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 80327fe:	3101      	adds	r1, #1
 8032800:	4658      	mov	r0, fp
 8032802:	5450      	strb	r0, [r2, r1]
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8032804:	2d00      	cmp	r5, #0
 8032806:	d103      	bne.n	8032810 <RadioSetTxConfig+0x120>
 8032808:	003a      	movs	r2, r7
 803280a:	3a0b      	subs	r2, #11
 803280c:	2a01      	cmp	r2, #1
 803280e:	d92e      	bls.n	803286e <RadioSetTxConfig+0x17e>
 8032810:	2d01      	cmp	r5, #1
 8032812:	d02a      	beq.n	803286a <RadioSetTxConfig+0x17a>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8032814:	4924      	ldr	r1, [pc, #144]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 8032816:	2253      	movs	r2, #83	; 0x53
 8032818:	2000      	movs	r0, #0
 803281a:	5488      	strb	r0, [r1, r2]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 803281c:	4a22      	ldr	r2, [pc, #136]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 803281e:	2101      	movs	r1, #1
 8032820:	7391      	strb	r1, [r2, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8032822:	3b05      	subs	r3, #5
 8032824:	b2db      	uxtb	r3, r3
 8032826:	2b01      	cmp	r3, #1
 8032828:	d926      	bls.n	8032878 <RadioSetTxConfig+0x188>
                SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 803282a:	4b1f      	ldr	r3, [pc, #124]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 803282c:	839e      	strh	r6, [r3, #28]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 803282e:	4c1e      	ldr	r4, [pc, #120]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 8032830:	464b      	mov	r3, r9
 8032832:	77a3      	strb	r3, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8032834:	4b20      	ldr	r3, [pc, #128]	; (80328b8 <RadioSetTxConfig+0x1c8>)
 8032836:	781b      	ldrb	r3, [r3, #0]
 8032838:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 803283a:	2320      	movs	r3, #32
 803283c:	4642      	mov	r2, r8
 803283e:	54e2      	strb	r2, [r4, r3]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8032840:	3301      	adds	r3, #1
 8032842:	4652      	mov	r2, sl
 8032844:	54e2      	strb	r2, [r4, r3]
            RadioStandby( );
 8032846:	f7ff f9cb 	bl	8031be0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 803284a:	2338      	movs	r3, #56	; 0x38
 803284c:	5ce0      	ldrb	r0, [r4, r3]
 803284e:	1e43      	subs	r3, r0, #1
 8032850:	4198      	sbcs	r0, r3
 8032852:	b2c0      	uxtb	r0, r0
 8032854:	f7ff fc7e 	bl	8032154 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032858:	0020      	movs	r0, r4
 803285a:	3038      	adds	r0, #56	; 0x38
 803285c:	f000 fc96 	bl	803318c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032860:	0020      	movs	r0, r4
 8032862:	300e      	adds	r0, #14
 8032864:	f000 fe5a 	bl	803351c <SUBGRF_SetPacketParams>
            break;
 8032868:	e765      	b.n	8032736 <RadioSetTxConfig+0x46>
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 803286a:	2f0c      	cmp	r7, #12
 803286c:	d1d2      	bne.n	8032814 <RadioSetTxConfig+0x124>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
 803286e:	490e      	ldr	r1, [pc, #56]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 8032870:	2253      	movs	r2, #83	; 0x53
 8032872:	2001      	movs	r0, #1
 8032874:	5488      	strb	r0, [r1, r2]
 8032876:	e7d1      	b.n	803281c <RadioSetTxConfig+0x12c>
                if( preambleLen < 12 )
 8032878:	2e0b      	cmp	r6, #11
 803287a:	d803      	bhi.n	8032884 <RadioSetTxConfig+0x194>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 803287c:	0013      	movs	r3, r2
 803287e:	220c      	movs	r2, #12
 8032880:	839a      	strh	r2, [r3, #28]
 8032882:	e7d4      	b.n	803282e <RadioSetTxConfig+0x13e>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8032884:	4b08      	ldr	r3, [pc, #32]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 8032886:	839e      	strh	r6, [r3, #28]
 8032888:	e7d1      	b.n	803282e <RadioSetTxConfig+0x13e>
            RadioSetModem(MODEM_SIGFOX_TX);
 803288a:	2003      	movs	r0, #3
 803288c:	f7ff fc62 	bl	8032154 <RadioSetModem>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 8032890:	4805      	ldr	r0, [pc, #20]	; (80328a8 <RadioSetTxConfig+0x1b8>)
 8032892:	2338      	movs	r3, #56	; 0x38
 8032894:	2202      	movs	r2, #2
 8032896:	54c2      	strb	r2, [r0, r3]
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 8032898:	6487      	str	r7, [r0, #72]	; 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 803289a:	3314      	adds	r3, #20
 803289c:	3214      	adds	r2, #20
 803289e:	54c2      	strb	r2, [r0, r3]
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 80328a0:	3038      	adds	r0, #56	; 0x38
 80328a2:	f000 fc73 	bl	803318c <SUBGRF_SetModulationParams>
            break;
 80328a6:	e746      	b.n	8032736 <RadioSetTxConfig+0x46>
 80328a8:	2000bd0c 	.word	0x2000bd0c
 80328ac:	080348f4 	.word	0x080348f4
 80328b0:	000001ff 	.word	0x000001ff
 80328b4:	080356b0 	.word	0x080356b0
 80328b8:	2000a0b8 	.word	0x2000a0b8

080328bc <RadioSetRxConfig>:
{
 80328bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80328be:	46de      	mov	lr, fp
 80328c0:	4657      	mov	r7, sl
 80328c2:	464e      	mov	r6, r9
 80328c4:	4645      	mov	r5, r8
 80328c6:	b5e0      	push	{r5, r6, r7, lr}
 80328c8:	b089      	sub	sp, #36	; 0x24
 80328ca:	0004      	movs	r4, r0
 80328cc:	9102      	str	r1, [sp, #8]
 80328ce:	9201      	str	r2, [sp, #4]
 80328d0:	9303      	str	r3, [sp, #12]
 80328d2:	ab13      	add	r3, sp, #76	; 0x4c
 80328d4:	881b      	ldrh	r3, [r3, #0]
 80328d6:	4699      	mov	r9, r3
 80328d8:	ab14      	add	r3, sp, #80	; 0x50
 80328da:	881f      	ldrh	r7, [r3, #0]
 80328dc:	ab15      	add	r3, sp, #84	; 0x54
 80328de:	781b      	ldrb	r3, [r3, #0]
 80328e0:	469a      	mov	sl, r3
 80328e2:	ab16      	add	r3, sp, #88	; 0x58
 80328e4:	781b      	ldrb	r3, [r3, #0]
 80328e6:	469b      	mov	fp, r3
 80328e8:	ab17      	add	r3, sp, #92	; 0x5c
 80328ea:	781d      	ldrb	r5, [r3, #0]
 80328ec:	ab1a      	add	r3, sp, #104	; 0x68
 80328ee:	781b      	ldrb	r3, [r3, #0]
 80328f0:	4698      	mov	r8, r3
 80328f2:	ab1b      	add	r3, sp, #108	; 0x6c
 80328f4:	781e      	ldrb	r6, [r3, #0]
    SubgRf.RxContinuous = rxContinuous;
 80328f6:	4bb0      	ldr	r3, [pc, #704]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 80328f8:	705e      	strb	r6, [r3, #1]
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 80328fa:	f000 fffa 	bl	80338f2 <RFW_DeInit>
    if( rxContinuous == true )
 80328fe:	2e00      	cmp	r6, #0
 8032900:	d000      	beq.n	8032904 <RadioSetRxConfig+0x48>
        symbTimeout = 0;
 8032902:	2700      	movs	r7, #0
    if( fixLen == true )
 8032904:	4653      	mov	r3, sl
 8032906:	2b00      	cmp	r3, #0
 8032908:	d011      	beq.n	803292e <RadioSetRxConfig+0x72>
        MaxPayloadLength = payloadLen;
 803290a:	4bac      	ldr	r3, [pc, #688]	; (8032bbc <RadioSetRxConfig+0x300>)
 803290c:	465a      	mov	r2, fp
 803290e:	701a      	strb	r2, [r3, #0]
    switch( modem )
 8032910:	2c01      	cmp	r4, #1
 8032912:	d100      	bne.n	8032916 <RadioSetRxConfig+0x5a>
 8032914:	e0d8      	b.n	8032ac8 <RadioSetRxConfig+0x20c>
 8032916:	2c04      	cmp	r4, #4
 8032918:	d00d      	beq.n	8032936 <RadioSetRxConfig+0x7a>
 803291a:	2c00      	cmp	r4, #0
 803291c:	d100      	bne.n	8032920 <RadioSetRxConfig+0x64>
 803291e:	e081      	b.n	8032a24 <RadioSetRxConfig+0x168>
}
 8032920:	b009      	add	sp, #36	; 0x24
 8032922:	bcf0      	pop	{r4, r5, r6, r7}
 8032924:	46bb      	mov	fp, r7
 8032926:	46b2      	mov	sl, r6
 8032928:	46a9      	mov	r9, r5
 803292a:	46a0      	mov	r8, r4
 803292c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MaxPayloadLength = 0xFF;
 803292e:	4ba3      	ldr	r3, [pc, #652]	; (8032bbc <RadioSetRxConfig+0x300>)
 8032930:	22ff      	movs	r2, #255	; 0xff
 8032932:	701a      	strb	r2, [r3, #0]
 8032934:	e7ec      	b.n	8032910 <RadioSetRxConfig+0x54>
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 8032936:	2001      	movs	r0, #1
 8032938:	f000 fa88 	bl	8032e4c <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 803293c:	4c9e      	ldr	r4, [pc, #632]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 803293e:	2500      	movs	r5, #0
 8032940:	2338      	movs	r3, #56	; 0x38
 8032942:	54e5      	strb	r5, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8032944:	9b01      	ldr	r3, [sp, #4]
 8032946:	63e3      	str	r3, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 8032948:	2344      	movs	r3, #68	; 0x44
 803294a:	2209      	movs	r2, #9
 803294c:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 803294e:	23c8      	movs	r3, #200	; 0xc8
 8032950:	009b      	lsls	r3, r3, #2
 8032952:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8032954:	9802      	ldr	r0, [sp, #8]
 8032956:	f000 ff67 	bl	8033828 <SUBGRF_GetFskBandwidthRegValue>
 803295a:	2345      	movs	r3, #69	; 0x45
 803295c:	54e0      	strb	r0, [r4, r3]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 803295e:	73a5      	strb	r5, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8032960:	464a      	mov	r2, r9
 8032962:	00d3      	lsls	r3, r2, #3
 8032964:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 8032966:	74a5      	strb	r5, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 2 << 3; // convert byte into bit
 8032968:	2610      	movs	r6, #16
 803296a:	74e6      	strb	r6, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 803296c:	7525      	strb	r5, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = RADIO_PACKET_FIXED_LENGTH;
 803296e:	7565      	strb	r5, [r4, #21]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8032970:	4b92      	ldr	r3, [pc, #584]	; (8032bbc <RadioSetRxConfig+0x300>)
 8032972:	781b      	ldrb	r3, [r3, #0]
 8032974:	75a3      	strb	r3, [r4, #22]
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8032976:	2301      	movs	r3, #1
 8032978:	75e3      	strb	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 803297a:	7625      	strb	r5, [r4, #24]
            RadioSetModem( MODEM_SIGFOX_RX );
 803297c:	2004      	movs	r0, #4
 803297e:	f7ff fbe9 	bl	8032154 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032982:	0020      	movs	r0, r4
 8032984:	3038      	adds	r0, #56	; 0x38
 8032986:	f000 fc01 	bl	803318c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803298a:	0020      	movs	r0, r4
 803298c:	300e      	adds	r0, #14
 803298e:	f000 fdc5 	bl	803351c <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8032992:	a804      	add	r0, sp, #16
 8032994:	4b8a      	ldr	r3, [pc, #552]	; (8032bc0 <RadioSetRxConfig+0x304>)
 8032996:	3308      	adds	r3, #8
 8032998:	0002      	movs	r2, r0
 803299a:	cb22      	ldmia	r3!, {r1, r5}
 803299c:	c222      	stmia	r2!, {r1, r5}
 803299e:	f000 fd8b 	bl	80334b8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 80329a2:	4888      	ldr	r0, [pc, #544]	; (8032bc4 <RadioSetRxConfig+0x308>)
 80329a4:	f000 fcea 	bl	803337c <SUBGRF_SetWhiteningSeed>
            modReg= RadioRead(0x8b8);
 80329a8:	4d87      	ldr	r5, [pc, #540]	; (8032bc8 <RadioSetRxConfig+0x30c>)
 80329aa:	0028      	movs	r0, r5
 80329ac:	f7ff f8aa 	bl	8031b04 <RadioRead>
            modReg&=RADIO_BIT_MASK(4);
 80329b0:	43b0      	bics	r0, r6
 80329b2:	b2c1      	uxtb	r1, r0
            RadioWrite(0x8b8, modReg);
 80329b4:	0028      	movs	r0, r5
 80329b6:	f7ff f8a9 	bl	8031b0c <RadioWrite>
            RadioWrite(0x8b9, 0x4 );
 80329ba:	2104      	movs	r1, #4
 80329bc:	4883      	ldr	r0, [pc, #524]	; (8032bcc <RadioSetRxConfig+0x310>)
 80329be:	f7ff f8a5 	bl	8031b0c <RadioWrite>
            modReg= RadioRead(0x89b);
 80329c2:	4e83      	ldr	r6, [pc, #524]	; (8032bd0 <RadioSetRxConfig+0x314>)
 80329c4:	0030      	movs	r0, r6
 80329c6:	f7ff f89d 	bl	8031b04 <RadioRead>
            modReg&=( RADIO_BIT_MASK(2) & RADIO_BIT_MASK(3) & RADIO_BIT_MASK(4) );
 80329ca:	231c      	movs	r3, #28
 80329cc:	4398      	bics	r0, r3
 80329ce:	b2c1      	uxtb	r1, r0
            RadioWrite(0x89b, (modReg| (0x1<<3) ) );
 80329d0:	2008      	movs	r0, #8
 80329d2:	4301      	orrs	r1, r0
 80329d4:	b2c9      	uxtb	r1, r1
 80329d6:	0030      	movs	r0, r6
 80329d8:	f7ff f898 	bl	8031b0c <RadioWrite>
            modReg= RadioRead(0x6d1);
 80329dc:	4e7d      	ldr	r6, [pc, #500]	; (8032bd4 <RadioSetRxConfig+0x318>)
 80329de:	0030      	movs	r0, r6
 80329e0:	f7ff f890 	bl	8031b04 <RadioRead>
            modReg&=( RADIO_BIT_MASK(3) & RADIO_BIT_MASK(4) );
 80329e4:	2318      	movs	r3, #24
 80329e6:	4398      	bics	r0, r3
 80329e8:	b2c1      	uxtb	r1, r0
            RadioWrite(0x6d1, (modReg| (0x3<<3) ));
 80329ea:	2018      	movs	r0, #24
 80329ec:	4301      	orrs	r1, r0
 80329ee:	b2c9      	uxtb	r1, r1
 80329f0:	0030      	movs	r0, r6
 80329f2:	f7ff f88b 	bl	8031b0c <RadioWrite>
            modReg= RadioRead(0x6ac);
 80329f6:	4e78      	ldr	r6, [pc, #480]	; (8032bd8 <RadioSetRxConfig+0x31c>)
 80329f8:	0030      	movs	r0, r6
 80329fa:	f7ff f883 	bl	8031b04 <RadioRead>
            modReg&=( RADIO_BIT_MASK(4) & RADIO_BIT_MASK(5) & RADIO_BIT_MASK(6) );
 80329fe:	2370      	movs	r3, #112	; 0x70
 8032a00:	4398      	bics	r0, r3
 8032a02:	b2c1      	uxtb	r1, r0
            RadioWrite(0x6ac, (modReg| (0x5<<4) ));
 8032a04:	2050      	movs	r0, #80	; 0x50
 8032a06:	4301      	orrs	r1, r0
 8032a08:	b2c9      	uxtb	r1, r1
 8032a0a:	0030      	movs	r0, r6
 8032a0c:	f7ff f87e 	bl	8031b0c <RadioWrite>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8032a10:	0178      	lsls	r0, r7, #5
 8032a12:	1bc0      	subs	r0, r0, r7
 8032a14:	0080      	lsls	r0, r0, #2
 8032a16:	19c0      	adds	r0, r0, r7
 8032a18:	0180      	lsls	r0, r0, #6
 8032a1a:	9901      	ldr	r1, [sp, #4]
 8032a1c:	f7ed fb7c 	bl	8020118 <__udivsi3>
 8032a20:	60a0      	str	r0, [r4, #8]
            break;
 8032a22:	e77d      	b.n	8032920 <RadioSetRxConfig+0x64>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8032a24:	2000      	movs	r0, #0
 8032a26:	f000 fa11 	bl	8032e4c <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8032a2a:	4c63      	ldr	r4, [pc, #396]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032a2c:	2600      	movs	r6, #0
 8032a2e:	2338      	movs	r3, #56	; 0x38
 8032a30:	54e6      	strb	r6, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8032a32:	9b01      	ldr	r3, [sp, #4]
 8032a34:	63e3      	str	r3, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8032a36:	2344      	movs	r3, #68	; 0x44
 8032a38:	220b      	movs	r2, #11
 8032a3a:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8032a3c:	9802      	ldr	r0, [sp, #8]
 8032a3e:	f000 fef3 	bl	8033828 <SUBGRF_GetFskBandwidthRegValue>
 8032a42:	2345      	movs	r3, #69	; 0x45
 8032a44:	54e0      	strb	r0, [r4, r3]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8032a46:	73a6      	strb	r6, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8032a48:	464b      	mov	r3, r9
 8032a4a:	00db      	lsls	r3, r3, #3
 8032a4c:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8032a4e:	2304      	movs	r3, #4
 8032a50:	74a3      	strb	r3, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 3 << 3; // convert byte into bit
 8032a52:	3314      	adds	r3, #20
 8032a54:	74e3      	strb	r3, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8032a56:	7526      	strb	r6, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8032a58:	2301      	movs	r3, #1
 8032a5a:	4652      	mov	r2, sl
 8032a5c:	405a      	eors	r2, r3
 8032a5e:	7562      	strb	r2, [r4, #21]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8032a60:	4b56      	ldr	r3, [pc, #344]	; (8032bbc <RadioSetRxConfig+0x300>)
 8032a62:	781b      	ldrb	r3, [r3, #0]
 8032a64:	75a3      	strb	r3, [r4, #22]
            if( crcOn == true )
 8032a66:	2d00      	cmp	r5, #0
 8032a68:	d02a      	beq.n	8032ac0 <RadioSetRxConfig+0x204>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 8032a6a:	4b53      	ldr	r3, [pc, #332]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032a6c:	22f2      	movs	r2, #242	; 0xf2
 8032a6e:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8032a70:	4c51      	ldr	r4, [pc, #324]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032a72:	2301      	movs	r3, #1
 8032a74:	7623      	strb	r3, [r4, #24]
            RadioStandby( );
 8032a76:	f7ff f8b3 	bl	8031be0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8032a7a:	2338      	movs	r3, #56	; 0x38
 8032a7c:	5ce0      	ldrb	r0, [r4, r3]
 8032a7e:	1e43      	subs	r3, r0, #1
 8032a80:	4198      	sbcs	r0, r3
 8032a82:	b2c0      	uxtb	r0, r0
 8032a84:	f7ff fb66 	bl	8032154 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032a88:	0020      	movs	r0, r4
 8032a8a:	3038      	adds	r0, #56	; 0x38
 8032a8c:	f000 fb7e 	bl	803318c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032a90:	0020      	movs	r0, r4
 8032a92:	300e      	adds	r0, #14
 8032a94:	f000 fd42 	bl	803351c <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8032a98:	a806      	add	r0, sp, #24
 8032a9a:	4b49      	ldr	r3, [pc, #292]	; (8032bc0 <RadioSetRxConfig+0x304>)
 8032a9c:	0002      	movs	r2, r0
 8032a9e:	cb22      	ldmia	r3!, {r1, r5}
 8032aa0:	c222      	stmia	r2!, {r1, r5}
 8032aa2:	f000 fd09 	bl	80334b8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8032aa6:	4847      	ldr	r0, [pc, #284]	; (8032bc4 <RadioSetRxConfig+0x308>)
 8032aa8:	f000 fc68 	bl	803337c <SUBGRF_SetWhiteningSeed>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8032aac:	0178      	lsls	r0, r7, #5
 8032aae:	1bc0      	subs	r0, r0, r7
 8032ab0:	0080      	lsls	r0, r0, #2
 8032ab2:	19c0      	adds	r0, r0, r7
 8032ab4:	0180      	lsls	r0, r0, #6
 8032ab6:	9901      	ldr	r1, [sp, #4]
 8032ab8:	f7ed fb2e 	bl	8020118 <__udivsi3>
 8032abc:	60a0      	str	r0, [r4, #8]
            break;
 8032abe:	e72f      	b.n	8032920 <RadioSetRxConfig+0x64>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8032ac0:	4b3d      	ldr	r3, [pc, #244]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032ac2:	2201      	movs	r2, #1
 8032ac4:	75da      	strb	r2, [r3, #23]
 8032ac6:	e7d3      	b.n	8032a70 <RadioSetRxConfig+0x1b4>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8032ac8:	2000      	movs	r0, #0
 8032aca:	f000 f9bf 	bl	8032e4c <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8032ace:	4a3a      	ldr	r2, [pc, #232]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032ad0:	2338      	movs	r3, #56	; 0x38
 8032ad2:	2101      	movs	r1, #1
 8032ad4:	54d1      	strb	r1, [r2, r3]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8032ad6:	9e01      	ldr	r6, [sp, #4]
 8032ad8:	b2f3      	uxtb	r3, r6
 8032ada:	314f      	adds	r1, #79	; 0x4f
 8032adc:	5453      	strb	r3, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8032ade:	493f      	ldr	r1, [pc, #252]	; (8032bdc <RadioSetRxConfig+0x320>)
 8032ae0:	9c02      	ldr	r4, [sp, #8]
 8032ae2:	5d08      	ldrb	r0, [r1, r4]
 8032ae4:	2151      	movs	r1, #81	; 0x51
 8032ae6:	5450      	strb	r0, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8032ae8:	3101      	adds	r1, #1
 8032aea:	9803      	ldr	r0, [sp, #12]
 8032aec:	5450      	strb	r0, [r2, r1]
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8032aee:	2c00      	cmp	r4, #0
 8032af0:	d103      	bne.n	8032afa <RadioSetRxConfig+0x23e>
 8032af2:	0032      	movs	r2, r6
 8032af4:	3a0b      	subs	r2, #11
 8032af6:	2a01      	cmp	r2, #1
 8032af8:	d943      	bls.n	8032b82 <RadioSetRxConfig+0x2c6>
 8032afa:	9a02      	ldr	r2, [sp, #8]
 8032afc:	2a01      	cmp	r2, #1
 8032afe:	d03d      	beq.n	8032b7c <RadioSetRxConfig+0x2c0>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8032b00:	492d      	ldr	r1, [pc, #180]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032b02:	2253      	movs	r2, #83	; 0x53
 8032b04:	2000      	movs	r0, #0
 8032b06:	5488      	strb	r0, [r1, r2]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8032b08:	4a2b      	ldr	r2, [pc, #172]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032b0a:	2101      	movs	r1, #1
 8032b0c:	7391      	strb	r1, [r2, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8032b0e:	3b05      	subs	r3, #5
 8032b10:	b2db      	uxtb	r3, r3
 8032b12:	2b01      	cmp	r3, #1
 8032b14:	d93a      	bls.n	8032b8c <RadioSetRxConfig+0x2d0>
                SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8032b16:	4b28      	ldr	r3, [pc, #160]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032b18:	464a      	mov	r2, r9
 8032b1a:	839a      	strh	r2, [r3, #28]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8032b1c:	4c26      	ldr	r4, [pc, #152]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032b1e:	4653      	mov	r3, sl
 8032b20:	77a3      	strb	r3, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8032b22:	4b26      	ldr	r3, [pc, #152]	; (8032bbc <RadioSetRxConfig+0x300>)
 8032b24:	781b      	ldrb	r3, [r3, #0]
 8032b26:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8032b28:	2320      	movs	r3, #32
 8032b2a:	54e5      	strb	r5, [r4, r3]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8032b2c:	2521      	movs	r5, #33	; 0x21
 8032b2e:	4643      	mov	r3, r8
 8032b30:	5563      	strb	r3, [r4, r5]
            RadioStandby( );
 8032b32:	f7ff f855 	bl	8031be0 <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 8032b36:	2338      	movs	r3, #56	; 0x38
 8032b38:	5ce0      	ldrb	r0, [r4, r3]
 8032b3a:	1e43      	subs	r3, r0, #1
 8032b3c:	4198      	sbcs	r0, r3
 8032b3e:	b2c0      	uxtb	r0, r0
 8032b40:	f7ff fb08 	bl	8032154 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032b44:	0020      	movs	r0, r4
 8032b46:	3038      	adds	r0, #56	; 0x38
 8032b48:	f000 fb20 	bl	803318c <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032b4c:	0020      	movs	r0, r4
 8032b4e:	300e      	adds	r0, #14
 8032b50:	f000 fce4 	bl	803351c <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8032b54:	b2f8      	uxtb	r0, r7
 8032b56:	f000 fadf 	bl	8033118 <SUBGRF_SetLoRaSymbNumTimeout>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8032b5a:	5d63      	ldrb	r3, [r4, r5]
 8032b5c:	2b01      	cmp	r3, #1
 8032b5e:	d020      	beq.n	8032ba2 <RadioSetRxConfig+0x2e6>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 8032b60:	4c1f      	ldr	r4, [pc, #124]	; (8032be0 <RadioSetRxConfig+0x324>)
 8032b62:	0020      	movs	r0, r4
 8032b64:	f000 fb8a 	bl	803327c <SUBGRF_ReadRegister>
 8032b68:	2104      	movs	r1, #4
 8032b6a:	4301      	orrs	r1, r0
 8032b6c:	b2c9      	uxtb	r1, r1
 8032b6e:	0020      	movs	r0, r4
 8032b70:	f000 faaa 	bl	80330c8 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 8032b74:	4b10      	ldr	r3, [pc, #64]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032b76:	4a1b      	ldr	r2, [pc, #108]	; (8032be4 <RadioSetRxConfig+0x328>)
 8032b78:	609a      	str	r2, [r3, #8]
}
 8032b7a:	e6d1      	b.n	8032920 <RadioSetRxConfig+0x64>
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 8032b7c:	9a01      	ldr	r2, [sp, #4]
 8032b7e:	2a0c      	cmp	r2, #12
 8032b80:	d1be      	bne.n	8032b00 <RadioSetRxConfig+0x244>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
 8032b82:	490d      	ldr	r1, [pc, #52]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032b84:	2253      	movs	r2, #83	; 0x53
 8032b86:	2001      	movs	r0, #1
 8032b88:	5488      	strb	r0, [r1, r2]
 8032b8a:	e7bd      	b.n	8032b08 <RadioSetRxConfig+0x24c>
                if( preambleLen < 12 )
 8032b8c:	464b      	mov	r3, r9
 8032b8e:	2b0b      	cmp	r3, #11
 8032b90:	d803      	bhi.n	8032b9a <RadioSetRxConfig+0x2de>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8032b92:	0013      	movs	r3, r2
 8032b94:	220c      	movs	r2, #12
 8032b96:	839a      	strh	r2, [r3, #28]
 8032b98:	e7c0      	b.n	8032b1c <RadioSetRxConfig+0x260>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8032b9a:	4b07      	ldr	r3, [pc, #28]	; (8032bb8 <RadioSetRxConfig+0x2fc>)
 8032b9c:	464a      	mov	r2, r9
 8032b9e:	839a      	strh	r2, [r3, #28]
 8032ba0:	e7bc      	b.n	8032b1c <RadioSetRxConfig+0x260>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 8032ba2:	4c0f      	ldr	r4, [pc, #60]	; (8032be0 <RadioSetRxConfig+0x324>)
 8032ba4:	0020      	movs	r0, r4
 8032ba6:	f000 fb69 	bl	803327c <SUBGRF_ReadRegister>
 8032baa:	2304      	movs	r3, #4
 8032bac:	4398      	bics	r0, r3
 8032bae:	b2c1      	uxtb	r1, r0
 8032bb0:	0020      	movs	r0, r4
 8032bb2:	f000 fa89 	bl	80330c8 <SUBGRF_WriteRegister>
 8032bb6:	e7dd      	b.n	8032b74 <RadioSetRxConfig+0x2b8>
 8032bb8:	2000bd0c 	.word	0x2000bd0c
 8032bbc:	2000a0b8 	.word	0x2000a0b8
 8032bc0:	080348f4 	.word	0x080348f4
 8032bc4:	000001ff 	.word	0x000001ff
 8032bc8:	000008b8 	.word	0x000008b8
 8032bcc:	000008b9 	.word	0x000008b9
 8032bd0:	0000089b 	.word	0x0000089b
 8032bd4:	000006d1 	.word	0x000006d1
 8032bd8:	000006ac 	.word	0x000006ac
 8032bdc:	080356b0 	.word	0x080356b0
 8032be0:	00000736 	.word	0x00000736
 8032be4:	0000ffff 	.word	0x0000ffff

08032be8 <RadioRandom>:
{
 8032be8:	b510      	push	{r4, lr}
    RadioSetModem( MODEM_LORA );
 8032bea:	2001      	movs	r0, #1
 8032bec:	f7ff fab2 	bl	8032154 <RadioSetModem>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8032bf0:	2300      	movs	r3, #0
 8032bf2:	2200      	movs	r2, #0
 8032bf4:	2100      	movs	r1, #0
 8032bf6:	2000      	movs	r0, #0
 8032bf8:	f000 f9be 	bl	8032f78 <SUBGRF_SetDioIrqParams>
    rnd = SUBGRF_GetRandom();
 8032bfc:	f000 fd0e 	bl	803361c <SUBGRF_GetRandom>
}
 8032c00:	bd10      	pop	{r4, pc}

08032c02 <RadioIsChannelFree>:
{
 8032c02:	b5f0      	push	{r4, r5, r6, r7, lr}
 8032c04:	b08b      	sub	sp, #44	; 0x2c
 8032c06:	0007      	movs	r7, r0
 8032c08:	000c      	movs	r4, r1
 8032c0a:	0016      	movs	r6, r2
 8032c0c:	001d      	movs	r5, r3
    RadioStandby( );
 8032c0e:	f7fe ffe7 	bl	8031be0 <RadioStandby>
    RadioSetModem( MODEM_FSK );
 8032c12:	2000      	movs	r0, #0
 8032c14:	f7ff fa9e 	bl	8032154 <RadioSetModem>
    RadioSetChannel( freq );
 8032c18:	0038      	movs	r0, r7
 8032c1a:	f7ff f975 	bl	8031f08 <RadioSetChannel>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 8032c1e:	2296      	movs	r2, #150	; 0x96
 8032c20:	2301      	movs	r3, #1
 8032c22:	9309      	str	r3, [sp, #36]	; 0x24
 8032c24:	2300      	movs	r3, #0
 8032c26:	9308      	str	r3, [sp, #32]
 8032c28:	9307      	str	r3, [sp, #28]
 8032c2a:	9306      	str	r3, [sp, #24]
 8032c2c:	9305      	str	r3, [sp, #20]
 8032c2e:	9304      	str	r3, [sp, #16]
 8032c30:	9303      	str	r3, [sp, #12]
 8032c32:	9302      	str	r3, [sp, #8]
 8032c34:	3303      	adds	r3, #3
 8032c36:	9301      	str	r3, [sp, #4]
 8032c38:	9400      	str	r4, [sp, #0]
 8032c3a:	2300      	movs	r3, #0
 8032c3c:	0092      	lsls	r2, r2, #2
 8032c3e:	0021      	movs	r1, r4
 8032c40:	2000      	movs	r0, #0
 8032c42:	f7ff fe3b 	bl	80328bc <RadioSetRxConfig>
    RadioRx( 0 );
 8032c46:	2000      	movs	r0, #0
 8032c48:	f7ff f976 	bl	8031f38 <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8032c4c:	f7ff f92e 	bl	8031eac <RadioGetWakeupTime>
 8032c50:	f7ee ffca 	bl	8021be8 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 8032c54:	f001 fa58 	bl	8034108 <UTIL_TIMER_GetCurrentTime>
 8032c58:	0004      	movs	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8032c5a:	0020      	movs	r0, r4
 8032c5c:	f001 fa5e 	bl	803411c <UTIL_TIMER_GetElapsedTime>
 8032c60:	42a8      	cmp	r0, r5
 8032c62:	d206      	bcs.n	8032c72 <RadioIsChannelFree+0x70>
        rssi = RadioRssi( MODEM_FSK );
 8032c64:	2000      	movs	r0, #0
 8032c66:	f7ff f92e 	bl	8031ec6 <RadioRssi>
        if( rssi > rssiThresh )
 8032c6a:	42b0      	cmp	r0, r6
 8032c6c:	ddf5      	ble.n	8032c5a <RadioIsChannelFree+0x58>
            status = false;
 8032c6e:	2400      	movs	r4, #0
 8032c70:	e000      	b.n	8032c74 <RadioIsChannelFree+0x72>
    bool status = true;
 8032c72:	2401      	movs	r4, #1
    RadioStandby( );
 8032c74:	f7fe ffb4 	bl	8031be0 <RadioStandby>
}
 8032c78:	0020      	movs	r0, r4
 8032c7a:	b00b      	add	sp, #44	; 0x2c
 8032c7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08032c80 <RadioInit>:
{
 8032c80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8032c82:	b083      	sub	sp, #12
    RadioEvents = events;
 8032c84:	4b1c      	ldr	r3, [pc, #112]	; (8032cf8 <RadioInit+0x78>)
 8032c86:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 8032c88:	4b1c      	ldr	r3, [pc, #112]	; (8032cfc <RadioInit+0x7c>)
 8032c8a:	2400      	movs	r4, #0
 8032c8c:	705c      	strb	r4, [r3, #1]
    SubgRf.TxTimeout = 0;
 8032c8e:	605c      	str	r4, [r3, #4]
    SubgRf.RxTimeout = 0;
 8032c90:	609c      	str	r4, [r3, #8]
    SUBGRF_Init( RadioOnDioIrq );
 8032c92:	481b      	ldr	r0, [pc, #108]	; (8032d00 <RadioInit+0x80>)
 8032c94:	f000 fb18 	bl	80332c8 <SUBGRF_Init>
    RadioSetPublicNetwork( false );
 8032c98:	2000      	movs	r0, #0
 8032c9a:	f7ff fd07 	bl	80326ac <RadioSetPublicNetwork>
    SUBGRF_SetRegulatorMode(  );
 8032c9e:	f000 f8e0 	bl	8032e62 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 8032ca2:	2100      	movs	r1, #0
 8032ca4:	2000      	movs	r0, #0
 8032ca6:	f000 f9bb 	bl	8033020 <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams(RFO_LP, 0, RADIO_RAMP_200_US);
 8032caa:	2204      	movs	r2, #4
 8032cac:	2100      	movs	r1, #0
 8032cae:	2001      	movs	r0, #1
 8032cb0:	f000 fb82 	bl	80333b8 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8032cb4:	4813      	ldr	r0, [pc, #76]	; (8032d04 <RadioInit+0x84>)
 8032cb6:	2300      	movs	r3, #0
 8032cb8:	2200      	movs	r2, #0
 8032cba:	0001      	movs	r1, r0
 8032cbc:	f000 f95c 	bl	8032f78 <SUBGRF_SetDioIrqParams>
    RadioSleep();
 8032cc0:	f7ff f970 	bl	8031fa4 <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8032cc4:	2701      	movs	r7, #1
 8032cc6:	427f      	negs	r7, r7
 8032cc8:	4e0f      	ldr	r6, [pc, #60]	; (8032d08 <RadioInit+0x88>)
 8032cca:	9400      	str	r4, [sp, #0]
 8032ccc:	4b0f      	ldr	r3, [pc, #60]	; (8032d0c <RadioInit+0x8c>)
 8032cce:	2200      	movs	r2, #0
 8032cd0:	0039      	movs	r1, r7
 8032cd2:	0030      	movs	r0, r6
 8032cd4:	f001 f9f8 	bl	80340c8 <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8032cd8:	4d0d      	ldr	r5, [pc, #52]	; (8032d10 <RadioInit+0x90>)
 8032cda:	9400      	str	r4, [sp, #0]
 8032cdc:	4b0d      	ldr	r3, [pc, #52]	; (8032d14 <RadioInit+0x94>)
 8032cde:	2200      	movs	r2, #0
 8032ce0:	0039      	movs	r1, r7
 8032ce2:	0028      	movs	r0, r5
 8032ce4:	f001 f9f0 	bl	80340c8 <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 8032ce8:	0030      	movs	r0, r6
 8032cea:	f001 fa4d 	bl	8034188 <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8032cee:	0028      	movs	r0, r5
 8032cf0:	f001 fa4a 	bl	8034188 <UTIL_TIMER_Stop>
}
 8032cf4:	b003      	add	sp, #12
 8032cf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8032cf8:	2000b508 	.word	0x2000b508
 8032cfc:	2000bd0c 	.word	0x2000bd0c
 8032d00:	08031e99 	.word	0x08031e99
 8032d04:	0000ffff 	.word	0x0000ffff
 8032d08:	2000bd64 	.word	0x2000bd64
 8032d0c:	080319d9 	.word	0x080319d9
 8032d10:	2000bd7c 	.word	0x2000bd7c
 8032d14:	080319f9 	.word	0x080319f9

08032d18 <SUBGRF_WriteCommand>:
    CRITICAL_SECTION_END();
}

void SUBGRF_WriteCommand( SUBGHZ_RadioSetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 8032d18:	b510      	push	{r4, lr}
 8032d1a:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8032d1c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8032d20:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 8032d22:	000a      	movs	r2, r1
 8032d24:	0001      	movs	r1, r0
 8032d26:	4803      	ldr	r0, [pc, #12]	; (8032d34 <SUBGRF_WriteCommand+0x1c>)
 8032d28:	f7f2 fb78 	bl	802541c <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032d2c:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 8032d30:	bd10      	pop	{r4, pc}
 8032d32:	46c0      	nop			; (mov r8, r8)
 8032d34:	2000b850 	.word	0x2000b850

08032d38 <SUBGRF_ReadCommand>:

void SUBGRF_ReadCommand( SUBGHZ_RadioGetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 8032d38:	b510      	push	{r4, lr}
 8032d3a:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8032d3c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8032d40:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 8032d42:	000a      	movs	r2, r1
 8032d44:	0001      	movs	r1, r0
 8032d46:	4803      	ldr	r0, [pc, #12]	; (8032d54 <SUBGRF_ReadCommand+0x1c>)
 8032d48:	f7f2 fbc0 	bl	80254cc <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8032d4c:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 8032d50:	bd10      	pop	{r4, pc}
 8032d52:	46c0      	nop			; (mov r8, r8)
 8032d54:	2000b850 	.word	0x2000b850

08032d58 <SUBGRF_GetOperatingMode>:
    return OperatingMode;
 8032d58:	4b01      	ldr	r3, [pc, #4]	; (8032d60 <SUBGRF_GetOperatingMode+0x8>)
 8032d5a:	7818      	ldrb	r0, [r3, #0]
}
 8032d5c:	4770      	bx	lr
 8032d5e:	46c0      	nop			; (mov r8, r8)
 8032d60:	2000b512 	.word	0x2000b512

08032d64 <SUBGRF_SetStandby>:
{
 8032d64:	b500      	push	{lr}
 8032d66:	b083      	sub	sp, #12
 8032d68:	466b      	mov	r3, sp
 8032d6a:	71d8      	strb	r0, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 8032d6c:	2201      	movs	r2, #1
 8032d6e:	1dd9      	adds	r1, r3, #7
 8032d70:	2080      	movs	r0, #128	; 0x80
 8032d72:	f7ff ffd1 	bl	8032d18 <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 8032d76:	466b      	mov	r3, sp
 8032d78:	79db      	ldrb	r3, [r3, #7]
 8032d7a:	2b00      	cmp	r3, #0
 8032d7c:	d104      	bne.n	8032d88 <SUBGRF_SetStandby+0x24>
        OperatingMode = MODE_STDBY_RC;
 8032d7e:	4b04      	ldr	r3, [pc, #16]	; (8032d90 <SUBGRF_SetStandby+0x2c>)
 8032d80:	2201      	movs	r2, #1
 8032d82:	701a      	strb	r2, [r3, #0]
}
 8032d84:	b003      	add	sp, #12
 8032d86:	bd00      	pop	{pc}
        OperatingMode = MODE_STDBY_XOSC;
 8032d88:	4b01      	ldr	r3, [pc, #4]	; (8032d90 <SUBGRF_SetStandby+0x2c>)
 8032d8a:	2202      	movs	r2, #2
 8032d8c:	701a      	strb	r2, [r3, #0]
}
 8032d8e:	e7f9      	b.n	8032d84 <SUBGRF_SetStandby+0x20>
 8032d90:	2000b512 	.word	0x2000b512

08032d94 <SUBGRF_SetTx>:
{
 8032d94:	b500      	push	{lr}
 8032d96:	b083      	sub	sp, #12
    OperatingMode = MODE_TX;
 8032d98:	4b07      	ldr	r3, [pc, #28]	; (8032db8 <SUBGRF_SetTx+0x24>)
 8032d9a:	2204      	movs	r2, #4
 8032d9c:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8032d9e:	0c03      	lsrs	r3, r0, #16
 8032da0:	a901      	add	r1, sp, #4
 8032da2:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8032da4:	0a03      	lsrs	r3, r0, #8
 8032da6:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8032da8:	7088      	strb	r0, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 8032daa:	3a01      	subs	r2, #1
 8032dac:	2083      	movs	r0, #131	; 0x83
 8032dae:	f7ff ffb3 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032db2:	b003      	add	sp, #12
 8032db4:	bd00      	pop	{pc}
 8032db6:	46c0      	nop			; (mov r8, r8)
 8032db8:	2000b512 	.word	0x2000b512

08032dbc <SUBGRF_SetRx>:
{
 8032dbc:	b500      	push	{lr}
 8032dbe:	b083      	sub	sp, #12
    OperatingMode = MODE_RX;
 8032dc0:	4b07      	ldr	r3, [pc, #28]	; (8032de0 <SUBGRF_SetRx+0x24>)
 8032dc2:	2205      	movs	r2, #5
 8032dc4:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8032dc6:	0c03      	lsrs	r3, r0, #16
 8032dc8:	a901      	add	r1, sp, #4
 8032dca:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8032dcc:	0a03      	lsrs	r3, r0, #8
 8032dce:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8032dd0:	7088      	strb	r0, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 8032dd2:	3a02      	subs	r2, #2
 8032dd4:	2082      	movs	r0, #130	; 0x82
 8032dd6:	f7ff ff9f 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032dda:	b003      	add	sp, #12
 8032ddc:	bd00      	pop	{pc}
 8032dde:	46c0      	nop			; (mov r8, r8)
 8032de0:	2000b512 	.word	0x2000b512

08032de4 <SUBGRF_SetRxDutyCycle>:
{
 8032de4:	b500      	push	{lr}
 8032de6:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 8032de8:	0c03      	lsrs	r3, r0, #16
 8032dea:	466a      	mov	r2, sp
 8032dec:	7013      	strb	r3, [r2, #0]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 8032dee:	0a03      	lsrs	r3, r0, #8
 8032df0:	7053      	strb	r3, [r2, #1]
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 8032df2:	7090      	strb	r0, [r2, #2]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 8032df4:	0c0b      	lsrs	r3, r1, #16
 8032df6:	70d3      	strb	r3, [r2, #3]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 8032df8:	0a0b      	lsrs	r3, r1, #8
 8032dfa:	7113      	strb	r3, [r2, #4]
    buf[5] = ( uint8_t )( sleepTime & 0xFF );
 8032dfc:	7151      	strb	r1, [r2, #5]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 8032dfe:	2206      	movs	r2, #6
 8032e00:	4669      	mov	r1, sp
 8032e02:	2094      	movs	r0, #148	; 0x94
 8032e04:	f7ff ff88 	bl	8032d18 <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 8032e08:	4b02      	ldr	r3, [pc, #8]	; (8032e14 <SUBGRF_SetRxDutyCycle+0x30>)
 8032e0a:	2206      	movs	r2, #6
 8032e0c:	701a      	strb	r2, [r3, #0]
}
 8032e0e:	b003      	add	sp, #12
 8032e10:	bd00      	pop	{pc}
 8032e12:	46c0      	nop			; (mov r8, r8)
 8032e14:	2000b512 	.word	0x2000b512

08032e18 <SUBGRF_SetCad>:
{
 8032e18:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 8032e1a:	2200      	movs	r2, #0
 8032e1c:	2100      	movs	r1, #0
 8032e1e:	20c5      	movs	r0, #197	; 0xc5
 8032e20:	f7ff ff7a 	bl	8032d18 <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 8032e24:	4b01      	ldr	r3, [pc, #4]	; (8032e2c <SUBGRF_SetCad+0x14>)
 8032e26:	2207      	movs	r2, #7
 8032e28:	701a      	strb	r2, [r3, #0]
}
 8032e2a:	bd10      	pop	{r4, pc}
 8032e2c:	2000b512 	.word	0x2000b512

08032e30 <SUBGRF_SetTxContinuousWave>:
{
 8032e30:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 8032e32:	2200      	movs	r2, #0
 8032e34:	2100      	movs	r1, #0
 8032e36:	20d1      	movs	r0, #209	; 0xd1
 8032e38:	f7ff ff6e 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032e3c:	bd10      	pop	{r4, pc}

08032e3e <SUBGRF_SetTxInfinitePreamble>:
{
 8032e3e:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 8032e40:	2200      	movs	r2, #0
 8032e42:	2100      	movs	r1, #0
 8032e44:	20d2      	movs	r0, #210	; 0xd2
 8032e46:	f7ff ff67 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032e4a:	bd10      	pop	{r4, pc}

08032e4c <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 8032e4c:	b500      	push	{lr}
 8032e4e:	b083      	sub	sp, #12
 8032e50:	466b      	mov	r3, sp
 8032e52:	1dd9      	adds	r1, r3, #7
 8032e54:	7008      	strb	r0, [r1, #0]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 8032e56:	2201      	movs	r2, #1
 8032e58:	209f      	movs	r0, #159	; 0x9f
 8032e5a:	f7ff ff5d 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032e5e:	b003      	add	sp, #12
 8032e60:	bd00      	pop	{pc}

08032e62 <SUBGRF_SetRegulatorMode>:
{
 8032e62:	b500      	push	{lr}
 8032e64:	b083      	sub	sp, #12
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 8032e66:	f7ef f821 	bl	8021eac <RBI_IsDCDC>
 8032e6a:	2801      	cmp	r0, #1
 8032e6c:	d00a      	beq.n	8032e84 <SUBGRF_SetRegulatorMode+0x22>
        mode = USE_LDO ;
 8032e6e:	466b      	mov	r3, sp
 8032e70:	2200      	movs	r2, #0
 8032e72:	71da      	strb	r2, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 8032e74:	2201      	movs	r2, #1
 8032e76:	466b      	mov	r3, sp
 8032e78:	1dd9      	adds	r1, r3, #7
 8032e7a:	2096      	movs	r0, #150	; 0x96
 8032e7c:	f7ff ff4c 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032e80:	b003      	add	sp, #12
 8032e82:	bd00      	pop	{pc}
        mode = USE_DCDC ;
 8032e84:	466b      	mov	r3, sp
 8032e86:	2201      	movs	r2, #1
 8032e88:	71da      	strb	r2, [r3, #7]
 8032e8a:	e7f3      	b.n	8032e74 <SUBGRF_SetRegulatorMode+0x12>

08032e8c <SUBGRF_Calibrate>:
{
 8032e8c:	b500      	push	{lr}
 8032e8e:	b083      	sub	sp, #12
 8032e90:	1c03      	adds	r3, r0, #0
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8032e92:	0658      	lsls	r0, r3, #25
 8032e94:	0fc0      	lsrs	r0, r0, #31
 8032e96:	0180      	lsls	r0, r0, #6
                      ( ( uint8_t )calibParam.Fields.ADCBulkPEnable << 5 ) |
 8032e98:	069a      	lsls	r2, r3, #26
 8032e9a:	0fd2      	lsrs	r2, r2, #31
 8032e9c:	0152      	lsls	r2, r2, #5
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8032e9e:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.ADCBulkNEnable << 4 ) |
 8032ea0:	06da      	lsls	r2, r3, #27
 8032ea2:	0fd2      	lsrs	r2, r2, #31
 8032ea4:	0112      	lsls	r2, r2, #4
                      ( ( uint8_t )calibParam.Fields.ADCBulkPEnable << 5 ) |
 8032ea6:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.ADCPulseEnable << 3 ) |
 8032ea8:	071a      	lsls	r2, r3, #28
 8032eaa:	0fd2      	lsrs	r2, r2, #31
 8032eac:	00d2      	lsls	r2, r2, #3
                      ( ( uint8_t )calibParam.Fields.ADCBulkNEnable << 4 ) |
 8032eae:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.PLLEnable << 2 ) |
 8032eb0:	075a      	lsls	r2, r3, #29
 8032eb2:	0fd2      	lsrs	r2, r2, #31
 8032eb4:	0092      	lsls	r2, r2, #2
                      ( ( uint8_t )calibParam.Fields.ADCPulseEnable << 3 ) |
 8032eb6:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 8032eb8:	079a      	lsls	r2, r3, #30
 8032eba:	0fd2      	lsrs	r2, r2, #31
 8032ebc:	0052      	lsls	r2, r2, #1
                      ( ( uint8_t )calibParam.Fields.PLLEnable << 2 ) |
 8032ebe:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.RC64KEnable ) );
 8032ec0:	07db      	lsls	r3, r3, #31
 8032ec2:	0fdb      	lsrs	r3, r3, #31
 8032ec4:	b25b      	sxtb	r3, r3
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 8032ec6:	4318      	orrs	r0, r3
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8032ec8:	466b      	mov	r3, sp
 8032eca:	1dd9      	adds	r1, r3, #7
 8032ecc:	7008      	strb	r0, [r1, #0]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 8032ece:	2201      	movs	r2, #1
 8032ed0:	2089      	movs	r0, #137	; 0x89
 8032ed2:	f7ff ff21 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032ed6:	b003      	add	sp, #12
 8032ed8:	bd00      	pop	{pc}
	...

08032edc <SUBGRF_CalibrateImage>:
{
 8032edc:	b500      	push	{lr}
 8032ede:	b083      	sub	sp, #12
    if( freq > 900000000 )
 8032ee0:	4b19      	ldr	r3, [pc, #100]	; (8032f48 <SUBGRF_CalibrateImage+0x6c>)
 8032ee2:	4298      	cmp	r0, r3
 8032ee4:	d90b      	bls.n	8032efe <SUBGRF_CalibrateImage+0x22>
        calFreq[0] = 0xE1;
 8032ee6:	ab01      	add	r3, sp, #4
 8032ee8:	22e1      	movs	r2, #225	; 0xe1
 8032eea:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xE9;
 8032eec:	3208      	adds	r2, #8
 8032eee:	705a      	strb	r2, [r3, #1]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 8032ef0:	2202      	movs	r2, #2
 8032ef2:	a901      	add	r1, sp, #4
 8032ef4:	2098      	movs	r0, #152	; 0x98
 8032ef6:	f7ff ff0f 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032efa:	b003      	add	sp, #12
 8032efc:	bd00      	pop	{pc}
    else if( freq > 850000000 )
 8032efe:	4b13      	ldr	r3, [pc, #76]	; (8032f4c <SUBGRF_CalibrateImage+0x70>)
 8032f00:	4298      	cmp	r0, r3
 8032f02:	d905      	bls.n	8032f10 <SUBGRF_CalibrateImage+0x34>
        calFreq[0] = 0xD7;
 8032f04:	ab01      	add	r3, sp, #4
 8032f06:	22d7      	movs	r2, #215	; 0xd7
 8032f08:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xDB;
 8032f0a:	3204      	adds	r2, #4
 8032f0c:	705a      	strb	r2, [r3, #1]
 8032f0e:	e7ef      	b.n	8032ef0 <SUBGRF_CalibrateImage+0x14>
    else if( freq > 770000000 )
 8032f10:	4b0f      	ldr	r3, [pc, #60]	; (8032f50 <SUBGRF_CalibrateImage+0x74>)
 8032f12:	4298      	cmp	r0, r3
 8032f14:	d905      	bls.n	8032f22 <SUBGRF_CalibrateImage+0x46>
        calFreq[0] = 0xC1;
 8032f16:	ab01      	add	r3, sp, #4
 8032f18:	22c1      	movs	r2, #193	; 0xc1
 8032f1a:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xC5;
 8032f1c:	3204      	adds	r2, #4
 8032f1e:	705a      	strb	r2, [r3, #1]
 8032f20:	e7e6      	b.n	8032ef0 <SUBGRF_CalibrateImage+0x14>
    else if( freq > 460000000 )
 8032f22:	4b0c      	ldr	r3, [pc, #48]	; (8032f54 <SUBGRF_CalibrateImage+0x78>)
 8032f24:	4298      	cmp	r0, r3
 8032f26:	d905      	bls.n	8032f34 <SUBGRF_CalibrateImage+0x58>
        calFreq[0] = 0x75;
 8032f28:	ab01      	add	r3, sp, #4
 8032f2a:	2275      	movs	r2, #117	; 0x75
 8032f2c:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x81;
 8032f2e:	320c      	adds	r2, #12
 8032f30:	705a      	strb	r2, [r3, #1]
 8032f32:	e7dd      	b.n	8032ef0 <SUBGRF_CalibrateImage+0x14>
    else if( freq > 425000000 )
 8032f34:	4b08      	ldr	r3, [pc, #32]	; (8032f58 <SUBGRF_CalibrateImage+0x7c>)
 8032f36:	4298      	cmp	r0, r3
 8032f38:	d9da      	bls.n	8032ef0 <SUBGRF_CalibrateImage+0x14>
        calFreq[0] = 0x6B;
 8032f3a:	ab01      	add	r3, sp, #4
 8032f3c:	226b      	movs	r2, #107	; 0x6b
 8032f3e:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x6F;
 8032f40:	3204      	adds	r2, #4
 8032f42:	705a      	strb	r2, [r3, #1]
 8032f44:	e7d4      	b.n	8032ef0 <SUBGRF_CalibrateImage+0x14>
 8032f46:	46c0      	nop			; (mov r8, r8)
 8032f48:	35a4e900 	.word	0x35a4e900
 8032f4c:	32a9f880 	.word	0x32a9f880
 8032f50:	2de54480 	.word	0x2de54480
 8032f54:	1b6b0b00 	.word	0x1b6b0b00
 8032f58:	1954fc40 	.word	0x1954fc40

08032f5c <SUBGRF_SetPaConfig>:
{
 8032f5c:	b510      	push	{r4, lr}
 8032f5e:	b082      	sub	sp, #8
    buf[0] = paDutyCycle;
 8032f60:	ac01      	add	r4, sp, #4
 8032f62:	7020      	strb	r0, [r4, #0]
    buf[1] = hpMax;
 8032f64:	7061      	strb	r1, [r4, #1]
    buf[2] = deviceSel;
 8032f66:	70a2      	strb	r2, [r4, #2]
    buf[3] = paLut;
 8032f68:	70e3      	strb	r3, [r4, #3]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 8032f6a:	2204      	movs	r2, #4
 8032f6c:	0021      	movs	r1, r4
 8032f6e:	2095      	movs	r0, #149	; 0x95
 8032f70:	f7ff fed2 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032f74:	b002      	add	sp, #8
 8032f76:	bd10      	pop	{r4, pc}

08032f78 <SUBGRF_SetDioIrqParams>:
{
 8032f78:	b530      	push	{r4, r5, lr}
 8032f7a:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 8032f7c:	0a04      	lsrs	r4, r0, #8
 8032f7e:	466d      	mov	r5, sp
 8032f80:	702c      	strb	r4, [r5, #0]
    buf[1] = ( uint8_t )( irqMask & 0x00FF );
 8032f82:	7068      	strb	r0, [r5, #1]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 8032f84:	0a08      	lsrs	r0, r1, #8
 8032f86:	70a8      	strb	r0, [r5, #2]
    buf[3] = ( uint8_t )( dio1Mask & 0x00FF );
 8032f88:	70e9      	strb	r1, [r5, #3]
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 8032f8a:	0a11      	lsrs	r1, r2, #8
 8032f8c:	7129      	strb	r1, [r5, #4]
    buf[5] = ( uint8_t )( dio2Mask & 0x00FF );
 8032f8e:	4669      	mov	r1, sp
 8032f90:	716a      	strb	r2, [r5, #5]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 8032f92:	0a1a      	lsrs	r2, r3, #8
 8032f94:	71aa      	strb	r2, [r5, #6]
    buf[7] = ( uint8_t )( dio3Mask & 0x00FF );
 8032f96:	71eb      	strb	r3, [r5, #7]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 8032f98:	2208      	movs	r2, #8
 8032f9a:	2008      	movs	r0, #8
 8032f9c:	f7ff febc 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032fa0:	b003      	add	sp, #12
 8032fa2:	bd30      	pop	{r4, r5, pc}

08032fa4 <SUBGRF_SetTcxoMode>:
{
 8032fa4:	b500      	push	{lr}
 8032fa6:	b083      	sub	sp, #12
 8032fa8:	000b      	movs	r3, r1
    buf[0] = tcxoVoltage & 0x07;
 8032faa:	2207      	movs	r2, #7
 8032fac:	4010      	ands	r0, r2
 8032fae:	a901      	add	r1, sp, #4
 8032fb0:	7008      	strb	r0, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8032fb2:	0c1a      	lsrs	r2, r3, #16
 8032fb4:	704a      	strb	r2, [r1, #1]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8032fb6:	0a1a      	lsrs	r2, r3, #8
 8032fb8:	708a      	strb	r2, [r1, #2]
    buf[3] = ( uint8_t )( timeout & 0xFF );
 8032fba:	70cb      	strb	r3, [r1, #3]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 8032fbc:	2204      	movs	r2, #4
 8032fbe:	2097      	movs	r0, #151	; 0x97
 8032fc0:	f7ff feaa 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032fc4:	b003      	add	sp, #12
 8032fc6:	bd00      	pop	{pc}

08032fc8 <SUBGRF_SetRfFrequency>:
{
 8032fc8:	b510      	push	{r4, lr}
 8032fca:	b082      	sub	sp, #8
 8032fcc:	0004      	movs	r4, r0
    if( ImageCalibrated == false )
 8032fce:	4b0f      	ldr	r3, [pc, #60]	; (803300c <SUBGRF_SetRfFrequency+0x44>)
 8032fd0:	781b      	ldrb	r3, [r3, #0]
 8032fd2:	2b00      	cmp	r3, #0
 8032fd4:	d013      	beq.n	8032ffe <SUBGRF_SetRfFrequency+0x36>
    SX_FREQ_TO_CHANNEL(chan, frequency);   
 8032fd6:	09e1      	lsrs	r1, r4, #7
 8032fd8:	0660      	lsls	r0, r4, #25
 8032fda:	4a0d      	ldr	r2, [pc, #52]	; (8033010 <SUBGRF_SetRfFrequency+0x48>)
 8032fdc:	2300      	movs	r3, #0
 8032fde:	f7ed fa4f 	bl	8020480 <__aeabi_uldivmod>
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 8032fe2:	0e03      	lsrs	r3, r0, #24
 8032fe4:	a901      	add	r1, sp, #4
 8032fe6:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( chan >> 16 ) & 0xFF );
 8032fe8:	0c03      	lsrs	r3, r0, #16
 8032fea:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( ( chan >> 8 ) & 0xFF );
 8032fec:	0a03      	lsrs	r3, r0, #8
 8032fee:	708b      	strb	r3, [r1, #2]
    buf[3] = ( uint8_t )( chan & 0xFF );
 8032ff0:	70c8      	strb	r0, [r1, #3]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 8032ff2:	2204      	movs	r2, #4
 8032ff4:	2086      	movs	r0, #134	; 0x86
 8032ff6:	f7ff fe8f 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8032ffa:	b002      	add	sp, #8
 8032ffc:	bd10      	pop	{r4, pc}
        SUBGRF_CalibrateImage( frequency );
 8032ffe:	f7ff ff6d 	bl	8032edc <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 8033002:	4b02      	ldr	r3, [pc, #8]	; (803300c <SUBGRF_SetRfFrequency+0x44>)
 8033004:	2201      	movs	r2, #1
 8033006:	701a      	strb	r2, [r3, #0]
 8033008:	e7e5      	b.n	8032fd6 <SUBGRF_SetRfFrequency+0xe>
 803300a:	46c0      	nop			; (mov r8, r8)
 803300c:	2000b510 	.word	0x2000b510
 8033010:	01e84800 	.word	0x01e84800

08033014 <SUBGRF_GetPacketType>:
    return PacketType;
 8033014:	4b01      	ldr	r3, [pc, #4]	; (803301c <SUBGRF_GetPacketType+0x8>)
 8033016:	7818      	ldrb	r0, [r3, #0]
}
 8033018:	4770      	bx	lr
 803301a:	46c0      	nop			; (mov r8, r8)
 803301c:	2000b513 	.word	0x2000b513

08033020 <SUBGRF_SetBufferBaseAddress>:
{
 8033020:	b500      	push	{lr}
 8033022:	b083      	sub	sp, #12
    buf[0] = txBaseAddress;
 8033024:	466b      	mov	r3, sp
 8033026:	7118      	strb	r0, [r3, #4]
    buf[1] = rxBaseAddress;
 8033028:	7159      	strb	r1, [r3, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 803302a:	2202      	movs	r2, #2
 803302c:	a901      	add	r1, sp, #4
 803302e:	208f      	movs	r0, #143	; 0x8f
 8033030:	f7ff fe72 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8033034:	b003      	add	sp, #12
 8033036:	bd00      	pop	{pc}

08033038 <SUBGRF_GetRssiInst>:
{
 8033038:	b510      	push	{r4, lr}
 803303a:	b082      	sub	sp, #8
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 803303c:	ac01      	add	r4, sp, #4
 803303e:	2201      	movs	r2, #1
 8033040:	0021      	movs	r1, r4
 8033042:	2015      	movs	r0, #21
 8033044:	f7ff fe78 	bl	8032d38 <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 8033048:	7820      	ldrb	r0, [r4, #0]
 803304a:	4240      	negs	r0, r0
 803304c:	1040      	asrs	r0, r0, #1
}
 803304e:	b002      	add	sp, #8
 8033050:	bd10      	pop	{r4, pc}
	...

08033054 <SUBGRF_GetPacketStatus>:
{
 8033054:	b510      	push	{r4, lr}
 8033056:	b082      	sub	sp, #8
 8033058:	0004      	movs	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 803305a:	2203      	movs	r2, #3
 803305c:	a901      	add	r1, sp, #4
 803305e:	2014      	movs	r0, #20
 8033060:	f7ff fe6a 	bl	8032d38 <SUBGRF_ReadCommand>
    pktStatus->packetType = SUBGRF_GetPacketType( );
 8033064:	f7ff ffd6 	bl	8033014 <SUBGRF_GetPacketType>
 8033068:	7020      	strb	r0, [r4, #0]
    switch( pktStatus->packetType )
 803306a:	2800      	cmp	r0, #0
 803306c:	d009      	beq.n	8033082 <SUBGRF_GetPacketStatus+0x2e>
 803306e:	2801      	cmp	r0, #1
 8033070:	d016      	beq.n	80330a0 <SUBGRF_GetPacketStatus+0x4c>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 8033072:	2214      	movs	r2, #20
 8033074:	2100      	movs	r1, #0
 8033076:	0020      	movs	r0, r4
 8033078:	f000 fe41 	bl	8033cfe <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 803307c:	230f      	movs	r3, #15
 803307e:	7023      	strb	r3, [r4, #0]
}
 8033080:	e00c      	b.n	803309c <SUBGRF_GetPacketStatus+0x48>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 8033082:	aa01      	add	r2, sp, #4
 8033084:	7813      	ldrb	r3, [r2, #0]
 8033086:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 8033088:	7853      	ldrb	r3, [r2, #1]
 803308a:	425b      	negs	r3, r3
 803308c:	105b      	asrs	r3, r3, #1
 803308e:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 8033090:	7893      	ldrb	r3, [r2, #2]
 8033092:	425b      	negs	r3, r3
 8033094:	105b      	asrs	r3, r3, #1
 8033096:	7163      	strb	r3, [r4, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 8033098:	2300      	movs	r3, #0
 803309a:	60a3      	str	r3, [r4, #8]
}
 803309c:	b002      	add	sp, #8
 803309e:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 80330a0:	aa01      	add	r2, sp, #4
 80330a2:	7813      	ldrb	r3, [r2, #0]
 80330a4:	425b      	negs	r3, r3
 80330a6:	105b      	asrs	r3, r3, #1
 80330a8:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 80330aa:	2301      	movs	r3, #1
 80330ac:	56d3      	ldrsb	r3, [r2, r3]
 80330ae:	3302      	adds	r3, #2
 80330b0:	109b      	asrs	r3, r3, #2
 80330b2:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 80330b4:	7893      	ldrb	r3, [r2, #2]
 80330b6:	425b      	negs	r3, r3
 80330b8:	105b      	asrs	r3, r3, #1
 80330ba:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 80330bc:	4b01      	ldr	r3, [pc, #4]	; (80330c4 <SUBGRF_GetPacketStatus+0x70>)
 80330be:	681b      	ldr	r3, [r3, #0]
 80330c0:	6123      	str	r3, [r4, #16]
            break;
 80330c2:	e7eb      	b.n	803309c <SUBGRF_GetPacketStatus+0x48>
 80330c4:	2000b50c 	.word	0x2000b50c

080330c8 <SUBGRF_WriteRegister>:
{
 80330c8:	b500      	push	{lr}
 80330ca:	b083      	sub	sp, #12
 80330cc:	466b      	mov	r3, sp
 80330ce:	1dda      	adds	r2, r3, #7
 80330d0:	7011      	strb	r1, [r2, #0]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 80330d2:	2301      	movs	r3, #1
 80330d4:	0001      	movs	r1, r0
 80330d6:	4802      	ldr	r0, [pc, #8]	; (80330e0 <SUBGRF_WriteRegister+0x18>)
 80330d8:	f7f2 f8fa 	bl	80252d0 <HAL_SUBGHZ_WriteRegisters>
}
 80330dc:	b003      	add	sp, #12
 80330de:	bd00      	pop	{pc}
 80330e0:	2000b850 	.word	0x2000b850

080330e4 <SUBGRF_SetRxBoosted>:
{
 80330e4:	b510      	push	{r4, lr}
 80330e6:	b082      	sub	sp, #8
 80330e8:	0004      	movs	r4, r0
    OperatingMode = MODE_RX;
 80330ea:	4b09      	ldr	r3, [pc, #36]	; (8033110 <SUBGRF_SetRxBoosted+0x2c>)
 80330ec:	2205      	movs	r2, #5
 80330ee:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 80330f0:	2197      	movs	r1, #151	; 0x97
 80330f2:	4808      	ldr	r0, [pc, #32]	; (8033114 <SUBGRF_SetRxBoosted+0x30>)
 80330f4:	f7ff ffe8 	bl	80330c8 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 80330f8:	0c23      	lsrs	r3, r4, #16
 80330fa:	a901      	add	r1, sp, #4
 80330fc:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 80330fe:	0a23      	lsrs	r3, r4, #8
 8033100:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8033102:	708c      	strb	r4, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 8033104:	2203      	movs	r2, #3
 8033106:	2082      	movs	r0, #130	; 0x82
 8033108:	f7ff fe06 	bl	8032d18 <SUBGRF_WriteCommand>
}
 803310c:	b002      	add	sp, #8
 803310e:	bd10      	pop	{r4, pc}
 8033110:	2000b512 	.word	0x2000b512
 8033114:	000008ac 	.word	0x000008ac

08033118 <SUBGRF_SetLoRaSymbNumTimeout>:
{
 8033118:	b500      	push	{lr}
 803311a:	b083      	sub	sp, #12
 803311c:	466b      	mov	r3, sp
 803311e:	71d8      	strb	r0, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 8033120:	2201      	movs	r2, #1
 8033122:	1dd9      	adds	r1, r3, #7
 8033124:	20a0      	movs	r0, #160	; 0xa0
 8033126:	f7ff fdf7 	bl	8032d18 <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 803312a:	466b      	mov	r3, sp
 803312c:	79db      	ldrb	r3, [r3, #7]
 803312e:	2b3f      	cmp	r3, #63	; 0x3f
 8033130:	d90e      	bls.n	8033150 <SUBGRF_SetLoRaSymbNumTimeout+0x38>
        uint8_t mant = symbNum >> 1;
 8033132:	085b      	lsrs	r3, r3, #1
        uint8_t exp  = 0;
 8033134:	2100      	movs	r1, #0
        while( mant > 31 )
 8033136:	2b1f      	cmp	r3, #31
 8033138:	d903      	bls.n	8033142 <SUBGRF_SetLoRaSymbNumTimeout+0x2a>
            mant >>= 2;
 803313a:	089b      	lsrs	r3, r3, #2
            exp++;
 803313c:	3101      	adds	r1, #1
 803313e:	b2c9      	uxtb	r1, r1
 8033140:	e7f9      	b.n	8033136 <SUBGRF_SetLoRaSymbNumTimeout+0x1e>
        reg = exp + ( mant << 3 );
 8033142:	00db      	lsls	r3, r3, #3
 8033144:	b2db      	uxtb	r3, r3
 8033146:	1859      	adds	r1, r3, r1
 8033148:	b2c9      	uxtb	r1, r1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 803314a:	4802      	ldr	r0, [pc, #8]	; (8033154 <SUBGRF_SetLoRaSymbNumTimeout+0x3c>)
 803314c:	f7ff ffbc 	bl	80330c8 <SUBGRF_WriteRegister>
}
 8033150:	b003      	add	sp, #12
 8033152:	bd00      	pop	{pc}
 8033154:	00000706 	.word	0x00000706

08033158 <SUBGRF_SetPacketType>:
{
 8033158:	b500      	push	{lr}
 803315a:	b083      	sub	sp, #12
 803315c:	466b      	mov	r3, sp
 803315e:	71d8      	strb	r0, [r3, #7]
    PacketType = packetType;
 8033160:	4b08      	ldr	r3, [pc, #32]	; (8033184 <SUBGRF_SetPacketType+0x2c>)
 8033162:	7018      	strb	r0, [r3, #0]
    if( packetType == PACKET_TYPE_GFSK )
 8033164:	2800      	cmp	r0, #0
 8033166:	d007      	beq.n	8033178 <SUBGRF_SetPacketType+0x20>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 8033168:	2201      	movs	r2, #1
 803316a:	466b      	mov	r3, sp
 803316c:	1dd9      	adds	r1, r3, #7
 803316e:	208a      	movs	r0, #138	; 0x8a
 8033170:	f7ff fdd2 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8033174:	b003      	add	sp, #12
 8033176:	bd00      	pop	{pc}
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 8033178:	2100      	movs	r1, #0
 803317a:	4803      	ldr	r0, [pc, #12]	; (8033188 <SUBGRF_SetPacketType+0x30>)
 803317c:	f7ff ffa4 	bl	80330c8 <SUBGRF_WriteRegister>
 8033180:	e7f2      	b.n	8033168 <SUBGRF_SetPacketType+0x10>
 8033182:	46c0      	nop			; (mov r8, r8)
 8033184:	2000b513 	.word	0x2000b513
 8033188:	000006ac 	.word	0x000006ac

0803318c <SUBGRF_SetModulationParams>:
{
 803318c:	b510      	push	{r4, lr}
 803318e:	b082      	sub	sp, #8
 8033190:	0004      	movs	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 8033192:	466a      	mov	r2, sp
 8033194:	4b35      	ldr	r3, [pc, #212]	; (803326c <SUBGRF_SetModulationParams+0xe0>)
 8033196:	cb03      	ldmia	r3!, {r0, r1}
 8033198:	c203      	stmia	r2!, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 803319a:	7820      	ldrb	r0, [r4, #0]
 803319c:	4b34      	ldr	r3, [pc, #208]	; (8033270 <SUBGRF_SetModulationParams+0xe4>)
 803319e:	781b      	ldrb	r3, [r3, #0]
 80331a0:	4298      	cmp	r0, r3
 80331a2:	d116      	bne.n	80331d2 <SUBGRF_SetModulationParams+0x46>
    switch( modulationParams->PacketType )
 80331a4:	7823      	ldrb	r3, [r4, #0]
 80331a6:	2b02      	cmp	r3, #2
 80331a8:	d04e      	beq.n	8033248 <SUBGRF_SetModulationParams+0xbc>
 80331aa:	d815      	bhi.n	80331d8 <SUBGRF_SetModulationParams+0x4c>
 80331ac:	2b00      	cmp	r3, #0
 80331ae:	d029      	beq.n	8033204 <SUBGRF_SetModulationParams+0x78>
 80331b0:	2b01      	cmp	r3, #1
 80331b2:	d147      	bne.n	8033244 <SUBGRF_SetModulationParams+0xb8>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 80331b4:	7e23      	ldrb	r3, [r4, #24]
 80331b6:	466a      	mov	r2, sp
 80331b8:	7013      	strb	r3, [r2, #0]
        buf[1] = modulationParams->Params.LoRa.Bandwidth;
 80331ba:	7e63      	ldrb	r3, [r4, #25]
 80331bc:	7053      	strb	r3, [r2, #1]
        buf[2] = modulationParams->Params.LoRa.CodingRate;
 80331be:	7ea3      	ldrb	r3, [r4, #26]
 80331c0:	7093      	strb	r3, [r2, #2]
        buf[3] = modulationParams->Params.LoRa.LowDatarateOptimize;
 80331c2:	7ee3      	ldrb	r3, [r4, #27]
 80331c4:	70d3      	strb	r3, [r2, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 80331c6:	2204      	movs	r2, #4
 80331c8:	4669      	mov	r1, sp
 80331ca:	208b      	movs	r0, #139	; 0x8b
 80331cc:	f7ff fda4 	bl	8032d18 <SUBGRF_WriteCommand>
        break;
 80331d0:	e038      	b.n	8033244 <SUBGRF_SetModulationParams+0xb8>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 80331d2:	f7ff ffc1 	bl	8033158 <SUBGRF_SetPacketType>
 80331d6:	e7e5      	b.n	80331a4 <SUBGRF_SetModulationParams+0x18>
    switch( modulationParams->PacketType )
 80331d8:	2b03      	cmp	r3, #3
 80331da:	d133      	bne.n	8033244 <SUBGRF_SetModulationParams+0xb8>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 80331dc:	6861      	ldr	r1, [r4, #4]
 80331de:	4825      	ldr	r0, [pc, #148]	; (8033274 <SUBGRF_SetModulationParams+0xe8>)
 80331e0:	f7ec ff9a 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 80331e4:	0c03      	lsrs	r3, r0, #16
 80331e6:	466a      	mov	r2, sp
 80331e8:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 80331ea:	0a03      	lsrs	r3, r0, #8
 80331ec:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 80331ee:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 80331f0:	7b23      	ldrb	r3, [r4, #12]
 80331f2:	70d3      	strb	r3, [r2, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 80331f4:	7b63      	ldrb	r3, [r4, #13]
 80331f6:	7113      	strb	r3, [r2, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 80331f8:	2205      	movs	r2, #5
 80331fa:	4669      	mov	r1, sp
 80331fc:	208b      	movs	r0, #139	; 0x8b
 80331fe:	f7ff fd8b 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8033202:	e01f      	b.n	8033244 <SUBGRF_SetModulationParams+0xb8>
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 8033204:	6861      	ldr	r1, [r4, #4]
 8033206:	481b      	ldr	r0, [pc, #108]	; (8033274 <SUBGRF_SetModulationParams+0xe8>)
 8033208:	f7ec ff86 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803320c:	0c03      	lsrs	r3, r0, #16
 803320e:	466a      	mov	r2, sp
 8033210:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 8033212:	0a03      	lsrs	r3, r0, #8
 8033214:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 8033216:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 8033218:	7b23      	ldrb	r3, [r4, #12]
 803321a:	70d3      	strb	r3, [r2, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 803321c:	7b63      	ldrb	r3, [r4, #13]
 803321e:	7113      	strb	r3, [r2, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 8033220:	68a0      	ldr	r0, [r4, #8]
 8033222:	09c1      	lsrs	r1, r0, #7
 8033224:	0640      	lsls	r0, r0, #25
 8033226:	4a14      	ldr	r2, [pc, #80]	; (8033278 <SUBGRF_SetModulationParams+0xec>)
 8033228:	2300      	movs	r3, #0
 803322a:	f7ed f929 	bl	8020480 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803322e:	0c03      	lsrs	r3, r0, #16
 8033230:	466a      	mov	r2, sp
 8033232:	7153      	strb	r3, [r2, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 8033234:	0a03      	lsrs	r3, r0, #8
 8033236:	7193      	strb	r3, [r2, #6]
        buf[7] = ( tempVal& 0xFF );
 8033238:	71d0      	strb	r0, [r2, #7]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803323a:	2208      	movs	r2, #8
 803323c:	4669      	mov	r1, sp
 803323e:	208b      	movs	r0, #139	; 0x8b
 8033240:	f7ff fd6a 	bl	8032d18 <SUBGRF_WriteCommand>
}
 8033244:	b002      	add	sp, #8
 8033246:	bd10      	pop	{r4, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 8033248:	6921      	ldr	r1, [r4, #16]
 803324a:	480a      	ldr	r0, [pc, #40]	; (8033274 <SUBGRF_SetModulationParams+0xe8>)
 803324c:	f7ec ff64 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8033250:	0c03      	lsrs	r3, r0, #16
 8033252:	466a      	mov	r2, sp
 8033254:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 8033256:	0a03      	lsrs	r3, r0, #8
 8033258:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 803325a:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 803325c:	7d23      	ldrb	r3, [r4, #20]
 803325e:	70d3      	strb	r3, [r2, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 8033260:	2204      	movs	r2, #4
 8033262:	4669      	mov	r1, sp
 8033264:	208b      	movs	r0, #139	; 0x8b
 8033266:	f7ff fd57 	bl	8032d18 <SUBGRF_WriteCommand>
        break;
 803326a:	e7eb      	b.n	8033244 <SUBGRF_SetModulationParams+0xb8>
 803326c:	08034904 	.word	0x08034904
 8033270:	2000b513 	.word	0x2000b513
 8033274:	3d090000 	.word	0x3d090000
 8033278:	01e84800 	.word	0x01e84800

0803327c <SUBGRF_ReadRegister>:
{
 803327c:	b510      	push	{r4, lr}
 803327e:	b082      	sub	sp, #8
 8033280:	0001      	movs	r1, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8033282:	466b      	mov	r3, sp
 8033284:	1ddc      	adds	r4, r3, #7
 8033286:	2301      	movs	r3, #1
 8033288:	0022      	movs	r2, r4
 803328a:	4803      	ldr	r0, [pc, #12]	; (8033298 <SUBGRF_ReadRegister+0x1c>)
 803328c:	f7f2 f872 	bl	8025374 <HAL_SUBGHZ_ReadRegisters>
    return data;
 8033290:	7820      	ldrb	r0, [r4, #0]
}
 8033292:	b002      	add	sp, #8
 8033294:	bd10      	pop	{r4, pc}
 8033296:	46c0      	nop			; (mov r8, r8)
 8033298:	2000b850 	.word	0x2000b850

0803329c <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
}

static void Radio_SMPS_Set(uint8_t level)
{
 803329c:	b570      	push	{r4, r5, r6, lr}
 803329e:	0004      	movs	r4, r0
  if ( 1U == RBI_IsDCDC() )
 80332a0:	f7ee fe04 	bl	8021eac <RBI_IsDCDC>
 80332a4:	2801      	cmp	r0, #1
 80332a6:	d000      	beq.n	80332aa <Radio_SMPS_Set+0xe>
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
  }
}
 80332a8:	bd70      	pop	{r4, r5, r6, pc}
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 80332aa:	4d06      	ldr	r5, [pc, #24]	; (80332c4 <Radio_SMPS_Set+0x28>)
 80332ac:	0028      	movs	r0, r5
 80332ae:	f7ff ffe5 	bl	803327c <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
 80332b2:	2306      	movs	r3, #6
 80332b4:	4398      	bics	r0, r3
 80332b6:	b2c1      	uxtb	r1, r0
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 80332b8:	4321      	orrs	r1, r4
 80332ba:	0028      	movs	r0, r5
 80332bc:	f7ff ff04 	bl	80330c8 <SUBGRF_WriteRegister>
}
 80332c0:	e7f2      	b.n	80332a8 <Radio_SMPS_Set+0xc>
 80332c2:	46c0      	nop			; (mov r8, r8)
 80332c4:	00000923 	.word	0x00000923

080332c8 <SUBGRF_Init>:
{
 80332c8:	b510      	push	{r4, lr}
    if ( dioIrq != NULL)
 80332ca:	2800      	cmp	r0, #0
 80332cc:	d001      	beq.n	80332d2 <SUBGRF_Init+0xa>
        RadioOnDioIrqCb = dioIrq;
 80332ce:	4b15      	ldr	r3, [pc, #84]	; (8033324 <SUBGRF_Init+0x5c>)
 80332d0:	6018      	str	r0, [r3, #0]
    RADIO_INIT();
 80332d2:	f7ee fb7b 	bl	80219cc <MX_SUBGHZ_Init>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 80332d6:	2002      	movs	r0, #2
 80332d8:	f7ff ffe0 	bl	803329c <Radio_SMPS_Set>
    ImageCalibrated = false;
 80332dc:	4b12      	ldr	r3, [pc, #72]	; (8033328 <SUBGRF_Init+0x60>)
 80332de:	2200      	movs	r2, #0
 80332e0:	701a      	strb	r2, [r3, #0]
    SUBGRF_SetStandby( STDBY_RC );
 80332e2:	2000      	movs	r0, #0
 80332e4:	f7ff fd3e 	bl	8032d64 <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 80332e8:	f7ee fddc 	bl	8021ea4 <RBI_IsTCXO>
 80332ec:	2801      	cmp	r0, #1
 80332ee:	d00d      	beq.n	803330c <SUBGRF_Init+0x44>
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 80332f0:	2120      	movs	r1, #32
 80332f2:	480e      	ldr	r0, [pc, #56]	; (803332c <SUBGRF_Init+0x64>)
 80332f4:	f7ff fee8 	bl	80330c8 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 80332f8:	2120      	movs	r1, #32
 80332fa:	480d      	ldr	r0, [pc, #52]	; (8033330 <SUBGRF_Init+0x68>)
 80332fc:	f7ff fee4 	bl	80330c8 <SUBGRF_WriteRegister>
    RBI_Init();
 8033300:	f7ee fdc4 	bl	8021e8c <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 8033304:	4b0b      	ldr	r3, [pc, #44]	; (8033334 <SUBGRF_Init+0x6c>)
 8033306:	2201      	movs	r2, #1
 8033308:	701a      	strb	r2, [r3, #0]
}
 803330a:	bd10      	pop	{r4, pc}
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 803330c:	2140      	movs	r1, #64	; 0x40
 803330e:	f7ff fe49 	bl	8032fa4 <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 8033312:	2100      	movs	r1, #0
 8033314:	4805      	ldr	r0, [pc, #20]	; (803332c <SUBGRF_Init+0x64>)
 8033316:	f7ff fed7 	bl	80330c8 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 803331a:	207f      	movs	r0, #127	; 0x7f
 803331c:	f7ff fdb6 	bl	8032e8c <SUBGRF_Calibrate>
 8033320:	e7ee      	b.n	8033300 <SUBGRF_Init+0x38>
 8033322:	46c0      	nop			; (mov r8, r8)
 8033324:	2000b514 	.word	0x2000b514
 8033328:	2000b510 	.word	0x2000b510
 803332c:	00000911 	.word	0x00000911
 8033330:	00000912 	.word	0x00000912
 8033334:	2000b512 	.word	0x2000b512

08033338 <SUBGRF_SetSleep>:
{
 8033338:	b510      	push	{r4, lr}
 803333a:	b082      	sub	sp, #8
 803333c:	1c04      	adds	r4, r0, #0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 803333e:	2000      	movs	r0, #0
 8033340:	f7ee fda8 	bl	8021e94 <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 8033344:	2002      	movs	r0, #2
 8033346:	f7ff ffa9 	bl	803329c <Radio_SMPS_Set>
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 803334a:	0760      	lsls	r0, r4, #29
 803334c:	0fc0      	lsrs	r0, r0, #31
 803334e:	0080      	lsls	r0, r0, #2
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 8033350:	07a3      	lsls	r3, r4, #30
 8033352:	0fdb      	lsrs	r3, r3, #31
 8033354:	005b      	lsls	r3, r3, #1
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8033356:	4318      	orrs	r0, r3
                      ( ( uint8_t )sleepConfig.Fields.WakeUpRTC ) );
 8033358:	07e4      	lsls	r4, r4, #31
 803335a:	0fe4      	lsrs	r4, r4, #31
 803335c:	b264      	sxtb	r4, r4
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 803335e:	4304      	orrs	r4, r0
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8033360:	466b      	mov	r3, sp
 8033362:	1dd9      	adds	r1, r3, #7
 8033364:	700c      	strb	r4, [r1, #0]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 8033366:	2201      	movs	r2, #1
 8033368:	2084      	movs	r0, #132	; 0x84
 803336a:	f7ff fcd5 	bl	8032d18 <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 803336e:	4b02      	ldr	r3, [pc, #8]	; (8033378 <SUBGRF_SetSleep+0x40>)
 8033370:	2200      	movs	r2, #0
 8033372:	701a      	strb	r2, [r3, #0]
}
 8033374:	b002      	add	sp, #8
 8033376:	bd10      	pop	{r4, pc}
 8033378:	2000b512 	.word	0x2000b512

0803337c <SUBGRF_SetWhiteningSeed>:
{
 803337c:	b570      	push	{r4, r5, r6, lr}
 803337e:	0004      	movs	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 8033380:	f7ff fe48 	bl	8033014 <SUBGRF_GetPacketType>
 8033384:	2800      	cmp	r0, #0
 8033386:	d000      	beq.n	803338a <SUBGRF_SetWhiteningSeed+0xe>
}
 8033388:	bd70      	pop	{r4, r5, r6, pc}
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 803338a:	25d7      	movs	r5, #215	; 0xd7
 803338c:	00ed      	lsls	r5, r5, #3
 803338e:	0028      	movs	r0, r5
 8033390:	f7ff ff74 	bl	803327c <SUBGRF_ReadRegister>
 8033394:	2301      	movs	r3, #1
 8033396:	4398      	bics	r0, r3
 8033398:	b2c0      	uxtb	r0, r0
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 803339a:	0a23      	lsrs	r3, r4, #8
 803339c:	2101      	movs	r1, #1
 803339e:	4019      	ands	r1, r3
 80333a0:	4301      	orrs	r1, r0
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 80333a2:	0028      	movs	r0, r5
 80333a4:	f7ff fe90 	bl	80330c8 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 80333a8:	b2e1      	uxtb	r1, r4
 80333aa:	4802      	ldr	r0, [pc, #8]	; (80333b4 <SUBGRF_SetWhiteningSeed+0x38>)
 80333ac:	f7ff fe8c 	bl	80330c8 <SUBGRF_WriteRegister>
}
 80333b0:	e7ea      	b.n	8033388 <SUBGRF_SetWhiteningSeed+0xc>
 80333b2:	46c0      	nop			; (mov r8, r8)
 80333b4:	000006b9 	.word	0x000006b9

080333b8 <SUBGRF_SetTxParams>:
{
 80333b8:	b570      	push	{r4, r5, r6, lr}
 80333ba:	b082      	sub	sp, #8
 80333bc:	000c      	movs	r4, r1
 80333be:	0015      	movs	r5, r2
    if( paSelect == RFO_LP )
 80333c0:	2801      	cmp	r0, #1
 80333c2:	d125      	bne.n	8033410 <SUBGRF_SetTxParams+0x58>
        if( power == 15 )
 80333c4:	290f      	cmp	r1, #15
 80333c6:	d00d      	beq.n	80333e4 <SUBGRF_SetTxParams+0x2c>
            SUBGRF_SetPaConfig( 0x04, 0x00, 0x01, 0x01 );
 80333c8:	2301      	movs	r3, #1
 80333ca:	2201      	movs	r2, #1
 80333cc:	2100      	movs	r1, #0
 80333ce:	2004      	movs	r0, #4
 80333d0:	f7ff fdc4 	bl	8032f5c <SUBGRF_SetPaConfig>
        if( power >= 14 )
 80333d4:	2c0d      	cmp	r4, #13
 80333d6:	dc0c      	bgt.n	80333f2 <SUBGRF_SetTxParams+0x3a>
        else if( power < -17 )
 80333d8:	0023      	movs	r3, r4
 80333da:	3311      	adds	r3, #17
 80333dc:	da0a      	bge.n	80333f4 <SUBGRF_SetTxParams+0x3c>
            power = -17;
 80333de:	2411      	movs	r4, #17
 80333e0:	4264      	negs	r4, r4
 80333e2:	e007      	b.n	80333f4 <SUBGRF_SetTxParams+0x3c>
            SUBGRF_SetPaConfig( 0x06, 0x00, 0x01, 0x01 );
 80333e4:	2301      	movs	r3, #1
 80333e6:	2201      	movs	r2, #1
 80333e8:	2100      	movs	r1, #0
 80333ea:	3005      	adds	r0, #5
 80333ec:	f7ff fdb6 	bl	8032f5c <SUBGRF_SetPaConfig>
 80333f0:	e7f0      	b.n	80333d4 <SUBGRF_SetTxParams+0x1c>
            power = 14;
 80333f2:	240e      	movs	r4, #14
        SUBGRF_WriteRegister( REG_OCP, 0x18 ); // current max is 80 mA for the whole device
 80333f4:	2118      	movs	r1, #24
 80333f6:	4815      	ldr	r0, [pc, #84]	; (803344c <SUBGRF_SetTxParams+0x94>)
 80333f8:	f7ff fe66 	bl	80330c8 <SUBGRF_WriteRegister>
    buf[0] = power;
 80333fc:	466b      	mov	r3, sp
 80333fe:	711c      	strb	r4, [r3, #4]
    buf[1] = ( uint8_t )rampTime;
 8033400:	715d      	strb	r5, [r3, #5]
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 8033402:	2202      	movs	r2, #2
 8033404:	a901      	add	r1, sp, #4
 8033406:	208e      	movs	r0, #142	; 0x8e
 8033408:	f7ff fc86 	bl	8032d18 <SUBGRF_WriteCommand>
}
 803340c:	b002      	add	sp, #8
 803340e:	bd70      	pop	{r4, r5, r6, pc}
        SUBGRF_WriteRegister( REG_TX_CLAMP, SUBGRF_ReadRegister( REG_TX_CLAMP ) | ( 0x0F << 1 ) );
 8033410:	4e0f      	ldr	r6, [pc, #60]	; (8033450 <SUBGRF_SetTxParams+0x98>)
 8033412:	0030      	movs	r0, r6
 8033414:	f7ff ff32 	bl	803327c <SUBGRF_ReadRegister>
 8033418:	211e      	movs	r1, #30
 803341a:	4301      	orrs	r1, r0
 803341c:	b2c9      	uxtb	r1, r1
 803341e:	0030      	movs	r0, r6
 8033420:	f7ff fe52 	bl	80330c8 <SUBGRF_WriteRegister>
        SUBGRF_SetPaConfig( 0x04, 0x07, 0x00, 0x01 );
 8033424:	2301      	movs	r3, #1
 8033426:	2200      	movs	r2, #0
 8033428:	2107      	movs	r1, #7
 803342a:	2004      	movs	r0, #4
 803342c:	f7ff fd96 	bl	8032f5c <SUBGRF_SetPaConfig>
        if( power > 22 )
 8033430:	2c16      	cmp	r4, #22
 8033432:	dc05      	bgt.n	8033440 <SUBGRF_SetTxParams+0x88>
        else if( power < -9 )
 8033434:	0023      	movs	r3, r4
 8033436:	3309      	adds	r3, #9
 8033438:	da03      	bge.n	8033442 <SUBGRF_SetTxParams+0x8a>
            power = -9;
 803343a:	2409      	movs	r4, #9
 803343c:	4264      	negs	r4, r4
 803343e:	e000      	b.n	8033442 <SUBGRF_SetTxParams+0x8a>
            power = 22;
 8033440:	2416      	movs	r4, #22
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 8033442:	2138      	movs	r1, #56	; 0x38
 8033444:	4801      	ldr	r0, [pc, #4]	; (803344c <SUBGRF_SetTxParams+0x94>)
 8033446:	f7ff fe3f 	bl	80330c8 <SUBGRF_WriteRegister>
 803344a:	e7d7      	b.n	80333fc <SUBGRF_SetTxParams+0x44>
 803344c:	000008e7 	.word	0x000008e7
 8033450:	000008d8 	.word	0x000008d8

08033454 <SUBGRF_GetRxBufferStatus>:
{
 8033454:	b530      	push	{r4, r5, lr}
 8033456:	b083      	sub	sp, #12
 8033458:	0005      	movs	r5, r0
 803345a:	000c      	movs	r4, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 803345c:	2202      	movs	r2, #2
 803345e:	a901      	add	r1, sp, #4
 8033460:	2013      	movs	r0, #19
 8033462:	f7ff fc69 	bl	8032d38 <SUBGRF_ReadCommand>
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 8033466:	f7ff fdd5 	bl	8033014 <SUBGRF_GetPacketType>
 803346a:	2801      	cmp	r0, #1
 803346c:	d007      	beq.n	803347e <SUBGRF_GetRxBufferStatus+0x2a>
        *payloadLength = status[0];
 803346e:	ab01      	add	r3, sp, #4
 8033470:	781b      	ldrb	r3, [r3, #0]
 8033472:	702b      	strb	r3, [r5, #0]
    *rxStartBufferPointer = status[1];
 8033474:	ab01      	add	r3, sp, #4
 8033476:	785b      	ldrb	r3, [r3, #1]
 8033478:	7023      	strb	r3, [r4, #0]
}
 803347a:	b003      	add	sp, #12
 803347c:	bd30      	pop	{r4, r5, pc}
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 803347e:	4b04      	ldr	r3, [pc, #16]	; (8033490 <SUBGRF_GetRxBufferStatus+0x3c>)
 8033480:	781b      	ldrb	r3, [r3, #0]
 8033482:	2b01      	cmp	r3, #1
 8033484:	d1f3      	bne.n	803346e <SUBGRF_GetRxBufferStatus+0x1a>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 8033486:	4803      	ldr	r0, [pc, #12]	; (8033494 <SUBGRF_GetRxBufferStatus+0x40>)
 8033488:	f7ff fef8 	bl	803327c <SUBGRF_ReadRegister>
 803348c:	7028      	strb	r0, [r5, #0]
 803348e:	e7f1      	b.n	8033474 <SUBGRF_GetRxBufferStatus+0x20>
 8033490:	2000b511 	.word	0x2000b511
 8033494:	00000702 	.word	0x00000702

08033498 <SUBGRF_WriteRegisters>:
{
 8033498:	b510      	push	{r4, lr}
 803349a:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803349c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80334a0:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 80334a2:	000a      	movs	r2, r1
 80334a4:	0001      	movs	r1, r0
 80334a6:	4803      	ldr	r0, [pc, #12]	; (80334b4 <SUBGRF_WriteRegisters+0x1c>)
 80334a8:	f7f1 ff12 	bl	80252d0 <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80334ac:	f384 8810 	msr	PRIMASK, r4
}
 80334b0:	bd10      	pop	{r4, pc}
 80334b2:	46c0      	nop			; (mov r8, r8)
 80334b4:	2000b850 	.word	0x2000b850

080334b8 <SUBGRF_SetSyncWord>:
{
 80334b8:	b510      	push	{r4, lr}
 80334ba:	0001      	movs	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 80334bc:	20d8      	movs	r0, #216	; 0xd8
 80334be:	2208      	movs	r2, #8
 80334c0:	00c0      	lsls	r0, r0, #3
 80334c2:	f7ff ffe9 	bl	8033498 <SUBGRF_WriteRegisters>
}
 80334c6:	2000      	movs	r0, #0
 80334c8:	bd10      	pop	{r4, pc}
	...

080334cc <SUBGRF_SetCrcSeed>:
{
 80334cc:	b500      	push	{lr}
 80334ce:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 80334d0:	0a02      	lsrs	r2, r0, #8
 80334d2:	ab01      	add	r3, sp, #4
 80334d4:	701a      	strb	r2, [r3, #0]
    buf[1] = ( uint8_t )( seed & 0xFF );
 80334d6:	7058      	strb	r0, [r3, #1]
    switch( SUBGRF_GetPacketType( ) )
 80334d8:	f7ff fd9c 	bl	8033014 <SUBGRF_GetPacketType>
 80334dc:	2800      	cmp	r0, #0
 80334de:	d001      	beq.n	80334e4 <SUBGRF_SetCrcSeed+0x18>
}
 80334e0:	b003      	add	sp, #12
 80334e2:	bd00      	pop	{pc}
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 80334e4:	2202      	movs	r2, #2
 80334e6:	a901      	add	r1, sp, #4
 80334e8:	4801      	ldr	r0, [pc, #4]	; (80334f0 <SUBGRF_SetCrcSeed+0x24>)
 80334ea:	f7ff ffd5 	bl	8033498 <SUBGRF_WriteRegisters>
}
 80334ee:	e7f7      	b.n	80334e0 <SUBGRF_SetCrcSeed+0x14>
 80334f0:	000006bc 	.word	0x000006bc

080334f4 <SUBGRF_SetCrcPolynomial>:
{
 80334f4:	b500      	push	{lr}
 80334f6:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 80334f8:	0a02      	lsrs	r2, r0, #8
 80334fa:	ab01      	add	r3, sp, #4
 80334fc:	701a      	strb	r2, [r3, #0]
    buf[1] = ( uint8_t )( polynomial & 0xFF );
 80334fe:	7058      	strb	r0, [r3, #1]
    switch( SUBGRF_GetPacketType( ) )
 8033500:	f7ff fd88 	bl	8033014 <SUBGRF_GetPacketType>
 8033504:	2800      	cmp	r0, #0
 8033506:	d001      	beq.n	803350c <SUBGRF_SetCrcPolynomial+0x18>
}
 8033508:	b003      	add	sp, #12
 803350a:	bd00      	pop	{pc}
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 803350c:	2202      	movs	r2, #2
 803350e:	a901      	add	r1, sp, #4
 8033510:	4801      	ldr	r0, [pc, #4]	; (8033518 <SUBGRF_SetCrcPolynomial+0x24>)
 8033512:	f7ff ffc1 	bl	8033498 <SUBGRF_WriteRegisters>
}
 8033516:	e7f7      	b.n	8033508 <SUBGRF_SetCrcPolynomial+0x14>
 8033518:	000006be 	.word	0x000006be

0803351c <SUBGRF_SetPacketParams>:
{
 803351c:	b510      	push	{r4, lr}
 803351e:	b084      	sub	sp, #16
 8033520:	0004      	movs	r4, r0
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 8033522:	aa01      	add	r2, sp, #4
 8033524:	4b2e      	ldr	r3, [pc, #184]	; (80335e0 <SUBGRF_SetPacketParams+0xc4>)
 8033526:	3308      	adds	r3, #8
 8033528:	cb03      	ldmia	r3!, {r0, r1}
 803352a:	c203      	stmia	r2!, {r0, r1}
 803352c:	781b      	ldrb	r3, [r3, #0]
 803352e:	7013      	strb	r3, [r2, #0]
    if( PacketType != packetParams->PacketType )
 8033530:	7820      	ldrb	r0, [r4, #0]
 8033532:	4b2c      	ldr	r3, [pc, #176]	; (80335e4 <SUBGRF_SetPacketParams+0xc8>)
 8033534:	781b      	ldrb	r3, [r3, #0]
 8033536:	4298      	cmp	r0, r3
 8033538:	d118      	bne.n	803356c <SUBGRF_SetPacketParams+0x50>
    switch( packetParams->PacketType )
 803353a:	7823      	ldrb	r3, [r4, #0]
 803353c:	2b02      	cmp	r3, #2
 803353e:	d049      	beq.n	80335d4 <SUBGRF_SetPacketParams+0xb8>
 8033540:	d817      	bhi.n	8033572 <SUBGRF_SetPacketParams+0x56>
 8033542:	2b00      	cmp	r3, #0
 8033544:	d017      	beq.n	8033576 <SUBGRF_SetPacketParams+0x5a>
 8033546:	2b01      	cmp	r3, #1
 8033548:	d132      	bne.n	80335b0 <SUBGRF_SetPacketParams+0x94>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 803354a:	89e2      	ldrh	r2, [r4, #14]
 803354c:	ab01      	add	r3, sp, #4
 803354e:	0a11      	lsrs	r1, r2, #8
 8033550:	7019      	strb	r1, [r3, #0]
        buf[1] = packetParams->Params.LoRa.PreambleLength;
 8033552:	705a      	strb	r2, [r3, #1]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 8033554:	7c22      	ldrb	r2, [r4, #16]
 8033556:	4924      	ldr	r1, [pc, #144]	; (80335e8 <SUBGRF_SetPacketParams+0xcc>)
 8033558:	700a      	strb	r2, [r1, #0]
 803355a:	709a      	strb	r2, [r3, #2]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 803355c:	7c62      	ldrb	r2, [r4, #17]
 803355e:	70da      	strb	r2, [r3, #3]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 8033560:	7ca2      	ldrb	r2, [r4, #18]
 8033562:	711a      	strb	r2, [r3, #4]
        buf[5] = packetParams->Params.LoRa.InvertIQ;
 8033564:	7ce2      	ldrb	r2, [r4, #19]
 8033566:	715a      	strb	r2, [r3, #5]
        n = 6;
 8033568:	2206      	movs	r2, #6
        break;
 803356a:	e01c      	b.n	80335a6 <SUBGRF_SetPacketParams+0x8a>
        SUBGRF_SetPacketType( packetParams->PacketType );
 803356c:	f7ff fdf4 	bl	8033158 <SUBGRF_SetPacketType>
 8033570:	e7e3      	b.n	803353a <SUBGRF_SetPacketParams+0x1e>
    switch( packetParams->PacketType )
 8033572:	2b03      	cmp	r3, #3
 8033574:	d11c      	bne.n	80335b0 <SUBGRF_SetPacketParams+0x94>
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 8033576:	7a62      	ldrb	r2, [r4, #9]
 8033578:	2af1      	cmp	r2, #241	; 0xf1
 803357a:	d01b      	beq.n	80335b4 <SUBGRF_SetPacketParams+0x98>
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 803357c:	2af2      	cmp	r2, #242	; 0xf2
 803357e:	d021      	beq.n	80335c4 <SUBGRF_SetPacketParams+0xa8>
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 8033580:	8861      	ldrh	r1, [r4, #2]
 8033582:	ab01      	add	r3, sp, #4
 8033584:	0a08      	lsrs	r0, r1, #8
 8033586:	7018      	strb	r0, [r3, #0]
        buf[1] = packetParams->Params.Gfsk.PreambleLength;
 8033588:	7059      	strb	r1, [r3, #1]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 803358a:	7921      	ldrb	r1, [r4, #4]
 803358c:	7099      	strb	r1, [r3, #2]
        buf[3] = ( packetParams->Params.Gfsk.SyncWordLength /*<< 3*/ ); // convert from byte to bit
 803358e:	7961      	ldrb	r1, [r4, #5]
 8033590:	70d9      	strb	r1, [r3, #3]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 8033592:	79a1      	ldrb	r1, [r4, #6]
 8033594:	7119      	strb	r1, [r3, #4]
        buf[5] = packetParams->Params.Gfsk.HeaderType;
 8033596:	79e1      	ldrb	r1, [r4, #7]
 8033598:	7159      	strb	r1, [r3, #5]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 803359a:	7a21      	ldrb	r1, [r4, #8]
 803359c:	7199      	strb	r1, [r3, #6]
        buf[7] = crcVal;
 803359e:	71da      	strb	r2, [r3, #7]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 80335a0:	7aa2      	ldrb	r2, [r4, #10]
 80335a2:	721a      	strb	r2, [r3, #8]
        n = 9;
 80335a4:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 80335a6:	b292      	uxth	r2, r2
 80335a8:	a901      	add	r1, sp, #4
 80335aa:	208c      	movs	r0, #140	; 0x8c
 80335ac:	f7ff fbb4 	bl	8032d18 <SUBGRF_WriteCommand>
}
 80335b0:	b004      	add	sp, #16
 80335b2:	bd10      	pop	{r4, pc}
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 80335b4:	480d      	ldr	r0, [pc, #52]	; (80335ec <SUBGRF_SetPacketParams+0xd0>)
 80335b6:	f7ff ff89 	bl	80334cc <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 80335ba:	480d      	ldr	r0, [pc, #52]	; (80335f0 <SUBGRF_SetPacketParams+0xd4>)
 80335bc:	f7ff ff9a 	bl	80334f4 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 80335c0:	2202      	movs	r2, #2
 80335c2:	e7dd      	b.n	8033580 <SUBGRF_SetPacketParams+0x64>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 80335c4:	480b      	ldr	r0, [pc, #44]	; (80335f4 <SUBGRF_SetPacketParams+0xd8>)
 80335c6:	f7ff ff81 	bl	80334cc <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 80335ca:	480b      	ldr	r0, [pc, #44]	; (80335f8 <SUBGRF_SetPacketParams+0xdc>)
 80335cc:	f7ff ff92 	bl	80334f4 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 80335d0:	2206      	movs	r2, #6
 80335d2:	e7d5      	b.n	8033580 <SUBGRF_SetPacketParams+0x64>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 80335d4:	7b22      	ldrb	r2, [r4, #12]
 80335d6:	ab01      	add	r3, sp, #4
 80335d8:	701a      	strb	r2, [r3, #0]
        n = 1;
 80335da:	2201      	movs	r2, #1
        break;
 80335dc:	e7e3      	b.n	80335a6 <SUBGRF_SetPacketParams+0x8a>
 80335de:	46c0      	nop			; (mov r8, r8)
 80335e0:	08034904 	.word	0x08034904
 80335e4:	2000b513 	.word	0x2000b513
 80335e8:	2000b511 	.word	0x2000b511
 80335ec:	0000ffff 	.word	0x0000ffff
 80335f0:	00008005 	.word	0x00008005
 80335f4:	00001d0f 	.word	0x00001d0f
 80335f8:	00001021 	.word	0x00001021

080335fc <SUBGRF_ReadRegisters>:
{
 80335fc:	b510      	push	{r4, lr}
 80335fe:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033600:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033604:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 8033606:	000a      	movs	r2, r1
 8033608:	0001      	movs	r1, r0
 803360a:	4803      	ldr	r0, [pc, #12]	; (8033618 <SUBGRF_ReadRegisters+0x1c>)
 803360c:	f7f1 feb2 	bl	8025374 <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033610:	f384 8810 	msr	PRIMASK, r4
}
 8033614:	bd10      	pop	{r4, pc}
 8033616:	46c0      	nop			; (mov r8, r8)
 8033618:	2000b850 	.word	0x2000b850

0803361c <SUBGRF_GetRandom>:
{
 803361c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803361e:	b083      	sub	sp, #12
    uint32_t number = 0;
 8033620:	2300      	movs	r3, #0
 8033622:	9301      	str	r3, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 8033624:	4f15      	ldr	r7, [pc, #84]	; (803367c <SUBGRF_GetRandom+0x60>)
 8033626:	0038      	movs	r0, r7
 8033628:	f7ff fe28 	bl	803327c <SUBGRF_ReadRegister>
 803362c:	0005      	movs	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 803362e:	2301      	movs	r3, #1
 8033630:	0001      	movs	r1, r0
 8033632:	4399      	bics	r1, r3
 8033634:	b2c9      	uxtb	r1, r1
 8033636:	0038      	movs	r0, r7
 8033638:	f7ff fd46 	bl	80330c8 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 803363c:	4e10      	ldr	r6, [pc, #64]	; (8033680 <SUBGRF_GetRandom+0x64>)
 803363e:	0030      	movs	r0, r6
 8033640:	f7ff fe1c 	bl	803327c <SUBGRF_ReadRegister>
 8033644:	0004      	movs	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 8033646:	217f      	movs	r1, #127	; 0x7f
 8033648:	4001      	ands	r1, r0
 803364a:	0030      	movs	r0, r6
 803364c:	f7ff fd3c 	bl	80330c8 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8033650:	480c      	ldr	r0, [pc, #48]	; (8033684 <SUBGRF_GetRandom+0x68>)
 8033652:	f7ff fbb3 	bl	8032dbc <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 8033656:	2204      	movs	r2, #4
 8033658:	a901      	add	r1, sp, #4
 803365a:	480b      	ldr	r0, [pc, #44]	; (8033688 <SUBGRF_GetRandom+0x6c>)
 803365c:	f7ff ffce 	bl	80335fc <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 8033660:	2000      	movs	r0, #0
 8033662:	f7ff fb7f 	bl	8032d64 <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 8033666:	0029      	movs	r1, r5
 8033668:	0038      	movs	r0, r7
 803366a:	f7ff fd2d 	bl	80330c8 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 803366e:	0021      	movs	r1, r4
 8033670:	0030      	movs	r0, r6
 8033672:	f7ff fd29 	bl	80330c8 <SUBGRF_WriteRegister>
}
 8033676:	9801      	ldr	r0, [sp, #4]
 8033678:	b003      	add	sp, #12
 803367a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803367c:	000008e2 	.word	0x000008e2
 8033680:	000008e5 	.word	0x000008e5
 8033684:	00ffffff 	.word	0x00ffffff
 8033688:	00000819 	.word	0x00000819

0803368c <SUBGRF_WriteBuffer>:
{
 803368c:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803368e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033692:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 8033694:	b293      	uxth	r3, r2
 8033696:	000a      	movs	r2, r1
 8033698:	0001      	movs	r1, r0
 803369a:	4803      	ldr	r0, [pc, #12]	; (80336a8 <SUBGRF_WriteBuffer+0x1c>)
 803369c:	f7f1 ffb6 	bl	802560c <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80336a0:	f384 8810 	msr	PRIMASK, r4
}
 80336a4:	bd10      	pop	{r4, pc}
 80336a6:	46c0      	nop			; (mov r8, r8)
 80336a8:	2000b850 	.word	0x2000b850

080336ac <SUBGRF_SetPayload>:
{
 80336ac:	b510      	push	{r4, lr}
 80336ae:	000a      	movs	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 80336b0:	0001      	movs	r1, r0
 80336b2:	2000      	movs	r0, #0
 80336b4:	f7ff ffea 	bl	803368c <SUBGRF_WriteBuffer>
}
 80336b8:	bd10      	pop	{r4, pc}

080336ba <SUBGRF_SendPayload>:
{
 80336ba:	b510      	push	{r4, lr}
 80336bc:	0014      	movs	r4, r2
    SUBGRF_SetPayload( payload, size );
 80336be:	f7ff fff5 	bl	80336ac <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 80336c2:	0020      	movs	r0, r4
 80336c4:	f7ff fb66 	bl	8032d94 <SUBGRF_SetTx>
}
 80336c8:	bd10      	pop	{r4, pc}
	...

080336cc <SUBGRF_ReadBuffer>:
{
 80336cc:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80336ce:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80336d2:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 80336d4:	b293      	uxth	r3, r2
 80336d6:	000a      	movs	r2, r1
 80336d8:	0001      	movs	r1, r0
 80336da:	4803      	ldr	r0, [pc, #12]	; (80336e8 <SUBGRF_ReadBuffer+0x1c>)
 80336dc:	f7f1 ffe2 	bl	80256a4 <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80336e0:	f384 8810 	msr	PRIMASK, r4
}
 80336e4:	bd10      	pop	{r4, pc}
 80336e6:	46c0      	nop			; (mov r8, r8)
 80336e8:	2000b850 	.word	0x2000b850

080336ec <SUBGRF_GetPayload>:
{
 80336ec:	b570      	push	{r4, r5, r6, lr}
 80336ee:	b082      	sub	sp, #8
 80336f0:	0006      	movs	r6, r0
 80336f2:	000c      	movs	r4, r1
 80336f4:	0015      	movs	r5, r2
    uint8_t offset = 0;
 80336f6:	466b      	mov	r3, sp
 80336f8:	1dd9      	adds	r1, r3, #7
 80336fa:	2300      	movs	r3, #0
 80336fc:	700b      	strb	r3, [r1, #0]
    SUBGRF_GetRxBufferStatus( size, &offset );
 80336fe:	0020      	movs	r0, r4
 8033700:	f7ff fea8 	bl	8033454 <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 8033704:	7822      	ldrb	r2, [r4, #0]
 8033706:	42aa      	cmp	r2, r5
 8033708:	d902      	bls.n	8033710 <SUBGRF_GetPayload+0x24>
        return 1;
 803370a:	2001      	movs	r0, #1
}
 803370c:	b002      	add	sp, #8
 803370e:	bd70      	pop	{r4, r5, r6, pc}
    SUBGRF_ReadBuffer( offset, buffer, *size );
 8033710:	466b      	mov	r3, sp
 8033712:	79d8      	ldrb	r0, [r3, #7]
 8033714:	0031      	movs	r1, r6
 8033716:	f7ff ffd9 	bl	80336cc <SUBGRF_ReadBuffer>
    return 0;
 803371a:	2000      	movs	r0, #0
 803371c:	e7f6      	b.n	803370c <SUBGRF_GetPayload+0x20>

0803371e <SUBGRF_SetSwitch>:
{
 803371e:	b510      	push	{r4, lr}
 8033720:	0004      	movs	r4, r0
 8033722:	0008      	movs	r0, r1
    if (rxtx == RFSWITCH_TX)
 8033724:	2901      	cmp	r1, #1
 8033726:	d003      	beq.n	8033730 <SUBGRF_SetSwitch+0x12>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 8033728:	2001      	movs	r0, #1
    RBI_ConfigRFSwitch(state);
 803372a:	f7ee fbb3 	bl	8021e94 <RBI_ConfigRFSwitch>
}
 803372e:	bd10      	pop	{r4, pc}
        if (paSelect == RFO_LP)
 8033730:	2c01      	cmp	r4, #1
 8033732:	d003      	beq.n	803373c <SUBGRF_SetSwitch+0x1e>
        if (paSelect == RFO_HP)
 8033734:	2c02      	cmp	r4, #2
 8033736:	d1f8      	bne.n	803372a <SUBGRF_SetSwitch+0xc>
            state = RBI_SWITCH_RFO_HP;
 8033738:	2003      	movs	r0, #3
 803373a:	e7f6      	b.n	803372a <SUBGRF_SetSwitch+0xc>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 803373c:	3003      	adds	r0, #3
 803373e:	f7ff fdad 	bl	803329c <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 8033742:	2002      	movs	r0, #2
 8033744:	e7f6      	b.n	8033734 <SUBGRF_SetSwitch+0x16>

08033746 <SUBGRF_SetRfTxPower>:
{
 8033746:	b570      	push	{r4, r5, r6, lr}
 8033748:	0004      	movs	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 803374a:	f7ee fba7 	bl	8021e9c <RBI_GetTxConfig>
    switch (TxConfig)
 803374e:	2800      	cmp	r0, #0
 8033750:	d009      	beq.n	8033766 <SUBGRF_SetRfTxPower+0x20>
 8033752:	2802      	cmp	r0, #2
 8033754:	d10d      	bne.n	8033772 <SUBGRF_SetRfTxPower+0x2c>
            paSelect = RFO_HP;
 8033756:	2502      	movs	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 8033758:	2202      	movs	r2, #2
 803375a:	0021      	movs	r1, r4
 803375c:	0028      	movs	r0, r5
 803375e:	f7ff fe2b 	bl	80333b8 <SUBGRF_SetTxParams>
}
 8033762:	0028      	movs	r0, r5
 8033764:	bd70      	pop	{r4, r5, r6, pc}
            if (power > 15)
 8033766:	2c0f      	cmp	r4, #15
 8033768:	dc01      	bgt.n	803376e <SUBGRF_SetRfTxPower+0x28>
                paSelect = RFO_LP;
 803376a:	2501      	movs	r5, #1
 803376c:	e7f4      	b.n	8033758 <SUBGRF_SetRfTxPower+0x12>
                paSelect = RFO_HP;
 803376e:	2502      	movs	r5, #2
 8033770:	e7f2      	b.n	8033758 <SUBGRF_SetRfTxPower+0x12>
    switch (TxConfig)
 8033772:	2501      	movs	r5, #1
 8033774:	e7f0      	b.n	8033758 <SUBGRF_SetRfTxPower+0x12>

08033776 <SUBGRF_GetRadioWakeUpTime>:
}
 8033776:	2001      	movs	r0, #1
 8033778:	4770      	bx	lr
	...

0803377c <HAL_SUBGHZ_TxCpltCallback>:
{
 803377c:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_TX_DONE );
 803377e:	4b02      	ldr	r3, [pc, #8]	; (8033788 <HAL_SUBGHZ_TxCpltCallback+0xc>)
 8033780:	681b      	ldr	r3, [r3, #0]
 8033782:	2001      	movs	r0, #1
 8033784:	4798      	blx	r3
}
 8033786:	bd10      	pop	{r4, pc}
 8033788:	2000b514 	.word	0x2000b514

0803378c <HAL_SUBGHZ_RxCpltCallback>:
{
 803378c:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_RX_DONE );
 803378e:	4b02      	ldr	r3, [pc, #8]	; (8033798 <HAL_SUBGHZ_RxCpltCallback+0xc>)
 8033790:	681b      	ldr	r3, [r3, #0]
 8033792:	2002      	movs	r0, #2
 8033794:	4798      	blx	r3
}
 8033796:	bd10      	pop	{r4, pc}
 8033798:	2000b514 	.word	0x2000b514

0803379c <HAL_SUBGHZ_CRCErrorCallback>:
{
 803379c:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 803379e:	4b02      	ldr	r3, [pc, #8]	; (80337a8 <HAL_SUBGHZ_CRCErrorCallback+0xc>)
 80337a0:	681b      	ldr	r3, [r3, #0]
 80337a2:	2040      	movs	r0, #64	; 0x40
 80337a4:	4798      	blx	r3
}
 80337a6:	bd10      	pop	{r4, pc}
 80337a8:	2000b514 	.word	0x2000b514

080337ac <HAL_SUBGHZ_CADStatusCallback>:
{
 80337ac:	b510      	push	{r4, lr}
    switch (cadstatus)
 80337ae:	2900      	cmp	r1, #0
 80337b0:	d002      	beq.n	80337b8 <HAL_SUBGHZ_CADStatusCallback+0xc>
 80337b2:	2901      	cmp	r1, #1
 80337b4:	d005      	beq.n	80337c2 <HAL_SUBGHZ_CADStatusCallback+0x16>
}
 80337b6:	bd10      	pop	{r4, pc}
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 80337b8:	4b05      	ldr	r3, [pc, #20]	; (80337d0 <HAL_SUBGHZ_CADStatusCallback+0x24>)
 80337ba:	681b      	ldr	r3, [r3, #0]
 80337bc:	2080      	movs	r0, #128	; 0x80
 80337be:	4798      	blx	r3
            break;
 80337c0:	e7f9      	b.n	80337b6 <HAL_SUBGHZ_CADStatusCallback+0xa>
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 80337c2:	2080      	movs	r0, #128	; 0x80
 80337c4:	4b02      	ldr	r3, [pc, #8]	; (80337d0 <HAL_SUBGHZ_CADStatusCallback+0x24>)
 80337c6:	681b      	ldr	r3, [r3, #0]
 80337c8:	0040      	lsls	r0, r0, #1
 80337ca:	4798      	blx	r3
}
 80337cc:	e7f3      	b.n	80337b6 <HAL_SUBGHZ_CADStatusCallback+0xa>
 80337ce:	46c0      	nop			; (mov r8, r8)
 80337d0:	2000b514 	.word	0x2000b514

080337d4 <HAL_SUBGHZ_RxTxTimeoutCallback>:
{
 80337d4:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 80337d6:	2080      	movs	r0, #128	; 0x80
 80337d8:	4b02      	ldr	r3, [pc, #8]	; (80337e4 <HAL_SUBGHZ_RxTxTimeoutCallback+0x10>)
 80337da:	681b      	ldr	r3, [r3, #0]
 80337dc:	0080      	lsls	r0, r0, #2
 80337de:	4798      	blx	r3
}
 80337e0:	bd10      	pop	{r4, pc}
 80337e2:	46c0      	nop			; (mov r8, r8)
 80337e4:	2000b514 	.word	0x2000b514

080337e8 <HAL_SUBGHZ_HeaderErrorCallback>:
{
 80337e8:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 80337ea:	4b02      	ldr	r3, [pc, #8]	; (80337f4 <HAL_SUBGHZ_HeaderErrorCallback+0xc>)
 80337ec:	681b      	ldr	r3, [r3, #0]
 80337ee:	2020      	movs	r0, #32
 80337f0:	4798      	blx	r3
}
 80337f2:	bd10      	pop	{r4, pc}
 80337f4:	2000b514 	.word	0x2000b514

080337f8 <HAL_SUBGHZ_PreambleDetectedCallback>:
{
 80337f8:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 80337fa:	4b02      	ldr	r3, [pc, #8]	; (8033804 <HAL_SUBGHZ_PreambleDetectedCallback+0xc>)
 80337fc:	681b      	ldr	r3, [r3, #0]
 80337fe:	2004      	movs	r0, #4
 8033800:	4798      	blx	r3
}
 8033802:	bd10      	pop	{r4, pc}
 8033804:	2000b514 	.word	0x2000b514

08033808 <HAL_SUBGHZ_SyncWordValidCallback>:
{
 8033808:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 803380a:	4b02      	ldr	r3, [pc, #8]	; (8033814 <HAL_SUBGHZ_SyncWordValidCallback+0xc>)
 803380c:	681b      	ldr	r3, [r3, #0]
 803380e:	2008      	movs	r0, #8
 8033810:	4798      	blx	r3
}
 8033812:	bd10      	pop	{r4, pc}
 8033814:	2000b514 	.word	0x2000b514

08033818 <HAL_SUBGHZ_HeaderValidCallback>:
{
 8033818:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 803381a:	4b02      	ldr	r3, [pc, #8]	; (8033824 <HAL_SUBGHZ_HeaderValidCallback+0xc>)
 803381c:	681b      	ldr	r3, [r3, #0]
 803381e:	2010      	movs	r0, #16
 8033820:	4798      	blx	r3
}
 8033822:	bd10      	pop	{r4, pc}
 8033824:	2000b514 	.word	0x2000b514

08033828 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
 8033828:	b510      	push	{r4, lr}
    uint8_t i;

    if( bandwidth == 0 )
 803382a:	2800      	cmp	r0, #0
 803382c:	d00f      	beq.n	803384e <SUBGRF_GetFskBandwidthRegValue+0x26>
    {
        return( 0x1F );
    }

    /* ST_WORKAROUND_BEGIN: Simplified loop */
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 803382e:	2300      	movs	r3, #0
 8033830:	2b15      	cmp	r3, #21
 8033832:	d80b      	bhi.n	803384c <SUBGRF_GetFskBandwidthRegValue+0x24>
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 8033834:	00da      	lsls	r2, r3, #3
 8033836:	4c07      	ldr	r4, [pc, #28]	; (8033854 <SUBGRF_GetFskBandwidthRegValue+0x2c>)
 8033838:	5912      	ldr	r2, [r2, r4]
 803383a:	4282      	cmp	r2, r0
 803383c:	d802      	bhi.n	8033844 <SUBGRF_GetFskBandwidthRegValue+0x1c>
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 803383e:	3301      	adds	r3, #1
 8033840:	b2db      	uxtb	r3, r3
 8033842:	e7f5      	b.n	8033830 <SUBGRF_GetFskBandwidthRegValue+0x8>
        {
            return FskBandwidths[i].RegValue;
 8033844:	00d9      	lsls	r1, r3, #3
 8033846:	1861      	adds	r1, r4, r1
 8033848:	7908      	ldrb	r0, [r1, #4]
        }
    }
    /* ST_WORKAROUND_END */
    // ERROR: Value not found
    while( 1 );
}
 803384a:	bd10      	pop	{r4, pc}
    while( 1 );
 803384c:	e7fe      	b.n	803384c <SUBGRF_GetFskBandwidthRegValue+0x24>
        return( 0x1F );
 803384e:	201f      	movs	r0, #31
 8033850:	e7fb      	b.n	803384a <SUBGRF_GetFskBandwidthRegValue+0x22>
 8033852:	46c0      	nop			; (mov r8, r8)
 8033854:	08035738 	.word	0x08035738

08033858 <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 8033858:	b570      	push	{r4, r5, r6, lr}
 803385a:	b082      	sub	sp, #8
 803385c:	0006      	movs	r6, r0
 803385e:	000c      	movs	r4, r1
  uint8_t BwMant[] = {4, 8, 10, 12};
 8033860:	4b1a      	ldr	r3, [pc, #104]	; (80338cc <SUBGRF_GetCFO+0x74>)
 8033862:	9301      	str	r3, [sp, #4]
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 8033864:	481a      	ldr	r0, [pc, #104]	; (80338d0 <SUBGRF_GetCFO+0x78>)
 8033866:	f7ff fd09 	bl	803327c <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 803386a:	08c3      	lsrs	r3, r0, #3
 803386c:	2203      	movs	r2, #3
 803386e:	4013      	ands	r3, r2
 8033870:	aa01      	add	r2, sp, #4
 8033872:	5cd1      	ldrb	r1, [r2, r3]
  uint8_t bandwidth_exp = reg & 0x7;
 8033874:	2307      	movs	r3, #7
 8033876:	4003      	ands	r3, r0
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp - 1 )));
 8033878:	3b01      	subs	r3, #1
 803387a:	4099      	lsls	r1, r3
 803387c:	4815      	ldr	r0, [pc, #84]	; (80338d4 <SUBGRF_GetCFO+0x7c>)
 803387e:	f7ec fc4b 	bl	8020118 <__udivsi3>
 8033882:	0005      	movs	r5, r0
  uint32_t cf_osr = cf_fs / bitRate;
 8033884:	0031      	movs	r1, r6
 8033886:	f7ec fc47 	bl	8020118 <__udivsi3>
 803388a:	0003      	movs	r3, r0
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 803388c:	2807      	cmp	r0, #7
 803388e:	d91b      	bls.n	80338c8 <SUBGRF_GetCFO+0x70>
  uint8_t interp = 1;
 8033890:	2601      	movs	r6, #1
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 8033892:	4373      	muls	r3, r6
 8033894:	2b03      	cmp	r3, #3
 8033896:	d800      	bhi.n	803389a <SUBGRF_GetCFO+0x42>
  {
    interp = 4;
 8033898:	2604      	movs	r6, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
 803389a:	436e      	muls	r6, r5
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 803389c:	20d6      	movs	r0, #214	; 0xd6
 803389e:	00c0      	lsls	r0, r0, #3
 80338a0:	f7ff fcec 	bl	803327c <SUBGRF_ReadRegister>
 80338a4:	0200      	lsls	r0, r0, #8
 80338a6:	25f0      	movs	r5, #240	; 0xf0
 80338a8:	012d      	lsls	r5, r5, #4
 80338aa:	4005      	ands	r5, r0
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_CFO_L );
 80338ac:	480a      	ldr	r0, [pc, #40]	; (80338d8 <SUBGRF_GetCFO+0x80>)
 80338ae:	f7ff fce5 	bl	803327c <SUBGRF_ReadRegister>
 80338b2:	4305      	orrs	r5, r0
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 80338b4:	052b      	lsls	r3, r5, #20
 80338b6:	d501      	bpl.n	80338bc <SUBGRF_GetCFO+0x64>
  {
    cfo_bin |= 0xFFFFF000;
 80338b8:	4a08      	ldr	r2, [pc, #32]	; (80338dc <SUBGRF_GetCFO+0x84>)
 80338ba:	4315      	orrs	r5, r2
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 80338bc:	0970      	lsrs	r0, r6, #5
 80338be:	4368      	muls	r0, r5
 80338c0:	11c0      	asrs	r0, r0, #7
 80338c2:	6020      	str	r0, [r4, #0]
}
 80338c4:	b002      	add	sp, #8
 80338c6:	bd70      	pop	{r4, r5, r6, pc}
    interp = 2;
 80338c8:	2602      	movs	r6, #2
 80338ca:	e7e2      	b.n	8033892 <SUBGRF_GetCFO+0x3a>
 80338cc:	0c0a0804 	.word	0x0c0a0804
 80338d0:	00000807 	.word	0x00000807
 80338d4:	01e84800 	.word	0x01e84800
 80338d8:	000006b1 	.word	0x000006b1
 80338dc:	fffff000 	.word	0xfffff000

080338e0 <RFW_TransmitLongPacket>:
    }
  }
#else
  status= -1;
#endif
  return status;
 80338e0:	2001      	movs	r0, #1
}
 80338e2:	4240      	negs	r0, r0
 80338e4:	4770      	bx	lr

080338e6 <RFW_ReceiveLongPacket>:
    }
  }
#else
  status= -1;
#endif
  return status;
 80338e6:	2001      	movs	r0, #1
}
 80338e8:	4240      	negs	r0, r0
 80338ea:	4770      	bx	lr

080338ec <RFW_Init>:
  RFWPacket.Init.Enable=1;
  /* Initialize Timer for end of fixed packet, started at sync*/
  TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
  return 0;
#else
  return -1;
 80338ec:	2001      	movs	r0, #1
#endif
}
 80338ee:	4240      	negs	r0, r0
 80338f0:	4770      	bx	lr

080338f2 <RFW_DeInit>:
void RFW_DeInit( void)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Enable=0; /*Disable the RFWPacket decoding*/
#endif
}
 80338f2:	4770      	bx	lr

080338f4 <RFW_Is_Init>:
#if (RFW_ENABLE ==1 )
  return RFWPacket.Init.Enable;
#else
  return 0;
#endif
}
 80338f4:	2000      	movs	r0, #0
 80338f6:	4770      	bx	lr

080338f8 <RFW_Is_LongPacketModeEnabled>:
#if (RFW_ENABLE ==1 )
  return RFWPacket.LongPacketModeEnable;
#else
  return 0;
#endif
}
 80338f8:	2000      	movs	r0, #0
 80338fa:	4770      	bx	lr

080338fc <RFW_SetAntSwitch>:
void RFW_SetAntSwitch( uint8_t AntSwitch)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.AntSwitchPaSelect=AntSwitch;
#endif
}
 80338fc:	4770      	bx	lr

080338fe <RFW_TransmitInit>:
    RFWPacket.LongPacketModeEnable=0;
    
    status= 0;
  }
#endif
  return status;
 80338fe:	2001      	movs	r0, #1
}
 8033900:	4240      	negs	r0, r0
 8033902:	4770      	bx	lr

08033904 <RFW_ReceiveInit>:
  RFWPacket.RxPayloadOffset=0;
  
  RFWPacket.LongPacketModeEnable=0;
  return 0;
#else
  return -1;
 8033904:	2001      	movs	r0, #1
#endif
}
 8033906:	4240      	negs	r0, r0
 8033908:	4770      	bx	lr

0803390a <RFW_DeInit_TxLongPacket>:
  /*long packet WA*/
  uint8_t reg = SUBGRF_ReadRegister(SUBGHZ_PKTCTL1A);
  SUBGRF_WriteRegister(SUBGHZ_PKTCTL1A, reg & ~0x02);//clear infinite_sequence bit
  SUBGRF_WriteRegister(SUBGHZ_RTXPLDLEN, 0xFF); //RxTxPldLen: reset to 0xFF
#endif
}
 803390a:	4770      	bx	lr

0803390c <RFW_ReceivePayload>:
    /*timeout*/
    SUBGRF_SetStandby( STDBY_RC );
    RFWPacket.Init.RadioEvents->RxTimeout( );
  }
#endif
}
 803390c:	4770      	bx	lr

0803390e <RFW_SetRadioModem>:
void RFW_SetRadioModem(RadioModems_t Modem)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Modem= Modem;
#endif
}
 803390e:	4770      	bx	lr

08033910 <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 8033910:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033912:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033916:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 8033918:	4b1b      	ldr	r3, [pc, #108]	; (8033988 <TRACE_AllocateBufer+0x78>)
 803391a:	8a5d      	ldrh	r5, [r3, #18]
 803391c:	8a1a      	ldrh	r2, [r3, #16]
 803391e:	4295      	cmp	r5, r2
 8033920:	d010      	beq.n	8033944 <TRACE_AllocateBufer+0x34>
#endif
  }
  else
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8033922:	d91f      	bls.n	8033964 <TRACE_AllocateBufer+0x54>
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 8033924:	2380      	movs	r3, #128	; 0x80
 8033926:	00db      	lsls	r3, r3, #3
 8033928:	1b5b      	subs	r3, r3, r5
 803392a:	b29b      	uxth	r3, r3
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 803392c:	4283      	cmp	r3, r0
 803392e:	d81b      	bhi.n	8033968 <TRACE_AllocateBufer+0x58>
 8033930:	4282      	cmp	r2, r0
 8033932:	d919      	bls.n	8033968 <TRACE_AllocateBufer+0x58>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8033934:	4b14      	ldr	r3, [pc, #80]	; (8033988 <TRACE_AllocateBufer+0x78>)
 8033936:	2601      	movs	r6, #1
 8033938:	709e      	strb	r6, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 803393a:	801d      	strh	r5, [r3, #0]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 803393c:	2500      	movs	r5, #0
 803393e:	825d      	strh	r5, [r3, #18]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
 8033940:	0013      	movs	r3, r2
 8033942:	e011      	b.n	8033968 <TRACE_AllocateBufer+0x58>
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 8033944:	2380      	movs	r3, #128	; 0x80
 8033946:	00db      	lsls	r3, r3, #3
 8033948:	1b5b      	subs	r3, r3, r5
 803394a:	b29b      	uxth	r3, r3
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 803394c:	4298      	cmp	r0, r3
 803394e:	d30b      	bcc.n	8033968 <TRACE_AllocateBufer+0x58>
 8033950:	4282      	cmp	r2, r0
 8033952:	d909      	bls.n	8033968 <TRACE_AllocateBufer+0x58>
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8033954:	4b0c      	ldr	r3, [pc, #48]	; (8033988 <TRACE_AllocateBufer+0x78>)
 8033956:	2601      	movs	r6, #1
 8033958:	709e      	strb	r6, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 803395a:	801d      	strh	r5, [r3, #0]
      ADV_TRACE_Ctx.TraceWrPtr = 0;
 803395c:	2500      	movs	r5, #0
 803395e:	825d      	strh	r5, [r3, #18]
      freesize = ADV_TRACE_Ctx.TraceRdPtr;
 8033960:	0013      	movs	r3, r2
 8033962:	e001      	b.n	8033968 <TRACE_AllocateBufer+0x58>
      }
    }
    else
    {
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 8033964:	1b53      	subs	r3, r2, r5
 8033966:	b29b      	uxth	r3, r3
      freesize = ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr;
    }
#endif
  }

  if(freesize > Size)
 8033968:	4283      	cmp	r3, r0
 803396a:	d90a      	bls.n	8033982 <TRACE_AllocateBufer+0x72>
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 803396c:	4a06      	ldr	r2, [pc, #24]	; (8033988 <TRACE_AllocateBufer+0x78>)
 803396e:	8a53      	ldrh	r3, [r2, #18]
 8033970:	800b      	strh	r3, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 8033972:	181b      	adds	r3, r3, r0
 8033974:	059b      	lsls	r3, r3, #22
 8033976:	0d9b      	lsrs	r3, r3, #22
 8033978:	8253      	strh	r3, [r2, #18]
    ret = 0;
 803397a:	2000      	movs	r0, #0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803397c:	f384 8810 	msr	PRIMASK, r4
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 8033980:	bd70      	pop	{r4, r5, r6, pc}
  int16_t ret = -1;
 8033982:	2001      	movs	r0, #1
 8033984:	4240      	negs	r0, r0
 8033986:	e7f9      	b.n	803397c <TRACE_AllocateBufer+0x6c>
 8033988:	2000b518 	.word	0x2000b518

0803398c <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803398c:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033990:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 8033992:	4a03      	ldr	r2, [pc, #12]	; (80339a0 <TRACE_Lock+0x14>)
 8033994:	8ad3      	ldrh	r3, [r2, #22]
 8033996:	3301      	adds	r3, #1
 8033998:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803399a:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 803399e:	4770      	bx	lr
 80339a0:	2000b518 	.word	0x2000b518

080339a4 <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80339a4:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80339a8:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 80339aa:	4a03      	ldr	r2, [pc, #12]	; (80339b8 <TRACE_UnLock+0x14>)
 80339ac:	8ad3      	ldrh	r3, [r2, #22]
 80339ae:	3b01      	subs	r3, #1
 80339b0:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80339b2:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 80339b6:	4770      	bx	lr
 80339b8:	2000b518 	.word	0x2000b518

080339bc <TRACE_IsLocked>:
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 80339bc:	4b02      	ldr	r3, [pc, #8]	; (80339c8 <TRACE_IsLocked+0xc>)
 80339be:	8ad8      	ldrh	r0, [r3, #22]
 80339c0:	1e43      	subs	r3, r0, #1
 80339c2:	4198      	sbcs	r0, r3
}
 80339c4:	4770      	bx	lr
 80339c6:	46c0      	nop			; (mov r8, r8)
 80339c8:	2000b518 	.word	0x2000b518

080339cc <UTIL_ADV_TRACE_Init>:
{
 80339cc:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 80339ce:	2218      	movs	r2, #24
 80339d0:	2100      	movs	r1, #0
 80339d2:	4807      	ldr	r0, [pc, #28]	; (80339f0 <UTIL_ADV_TRACE_Init+0x24>)
 80339d4:	f000 f993 	bl	8033cfe <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 80339d8:	2280      	movs	r2, #128	; 0x80
 80339da:	00d2      	lsls	r2, r2, #3
 80339dc:	2100      	movs	r1, #0
 80339de:	4805      	ldr	r0, [pc, #20]	; (80339f4 <UTIL_ADV_TRACE_Init+0x28>)
 80339e0:	f000 f98d 	bl	8033cfe <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 80339e4:	4b04      	ldr	r3, [pc, #16]	; (80339f8 <UTIL_ADV_TRACE_Init+0x2c>)
 80339e6:	681b      	ldr	r3, [r3, #0]
 80339e8:	4804      	ldr	r0, [pc, #16]	; (80339fc <UTIL_ADV_TRACE_Init+0x30>)
 80339ea:	4798      	blx	r3
}
 80339ec:	bd10      	pop	{r4, pc}
 80339ee:	46c0      	nop			; (mov r8, r8)
 80339f0:	2000b518 	.word	0x2000b518
 80339f4:	20009280 	.word	0x20009280
 80339f8:	08034b2c 	.word	0x08034b2c
 80339fc:	08033b81 	.word	0x08033b81

08033a00 <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 8033a00:	4b01      	ldr	r3, [pc, #4]	; (8033a08 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 8033a02:	6058      	str	r0, [r3, #4]
}
 8033a04:	4770      	bx	lr
 8033a06:	46c0      	nop			; (mov r8, r8)
 8033a08:	2000b518 	.word	0x2000b518

08033a0c <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 8033a0c:	4b01      	ldr	r3, [pc, #4]	; (8033a14 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 8033a0e:	7218      	strb	r0, [r3, #8]
}
 8033a10:	4770      	bx	lr
 8033a12:	46c0      	nop			; (mov r8, r8)
 8033a14:	2000b518 	.word	0x2000b518

08033a18 <TRACE_Send>:
{
 8033a18:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033a1a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033a1e:	b672      	cpsid	i
  if(TRACE_IsLocked() == 0u)
 8033a20:	f7ff ffcc 	bl	80339bc <TRACE_IsLocked>
 8033a24:	2800      	cmp	r0, #0
 8033a26:	d003      	beq.n	8033a30 <TRACE_Send+0x18>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033a28:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 8033a2c:	2000      	movs	r0, #0
}
 8033a2e:	bd70      	pop	{r4, r5, r6, pc}
    TRACE_Lock();
 8033a30:	f7ff ffac 	bl	803398c <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 8033a34:	4b1d      	ldr	r3, [pc, #116]	; (8033aac <TRACE_Send+0x94>)
 8033a36:	8a1a      	ldrh	r2, [r3, #16]
 8033a38:	8a5b      	ldrh	r3, [r3, #18]
 8033a3a:	429a      	cmp	r2, r3
 8033a3c:	d030      	beq.n	8033aa0 <TRACE_Send+0x88>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8033a3e:	491b      	ldr	r1, [pc, #108]	; (8033aac <TRACE_Send+0x94>)
 8033a40:	7889      	ldrb	r1, [r1, #2]
 8033a42:	2901      	cmp	r1, #1
 8033a44:	d018      	beq.n	8033a78 <TRACE_Send+0x60>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8033a46:	4a19      	ldr	r2, [pc, #100]	; (8033aac <TRACE_Send+0x94>)
 8033a48:	7892      	ldrb	r2, [r2, #2]
 8033a4a:	2a00      	cmp	r2, #0
 8033a4c:	d106      	bne.n	8033a5c <TRACE_Send+0x44>
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8033a4e:	4a17      	ldr	r2, [pc, #92]	; (8033aac <TRACE_Send+0x94>)
 8033a50:	8a12      	ldrh	r2, [r2, #16]
 8033a52:	4293      	cmp	r3, r2
 8033a54:	d91e      	bls.n	8033a94 <TRACE_Send+0x7c>
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8033a56:	1a9b      	subs	r3, r3, r2
 8033a58:	4a14      	ldr	r2, [pc, #80]	; (8033aac <TRACE_Send+0x94>)
 8033a5a:	8293      	strh	r3, [r2, #20]
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8033a5c:	4e13      	ldr	r6, [pc, #76]	; (8033aac <TRACE_Send+0x94>)
 8033a5e:	8a35      	ldrh	r5, [r6, #16]
 8033a60:	4b13      	ldr	r3, [pc, #76]	; (8033ab0 <TRACE_Send+0x98>)
 8033a62:	18ed      	adds	r5, r5, r3
 8033a64:	f384 8810 	msr	PRIMASK, r4
      UTIL_ADV_TRACE_PreSendHook();
 8033a68:	f7ee f8ac 	bl	8021bc4 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8033a6c:	4b11      	ldr	r3, [pc, #68]	; (8033ab4 <TRACE_Send+0x9c>)
 8033a6e:	68db      	ldr	r3, [r3, #12]
 8033a70:	8ab1      	ldrh	r1, [r6, #20]
 8033a72:	0028      	movs	r0, r5
 8033a74:	4798      	blx	r3
 8033a76:	e7da      	b.n	8033a2e <TRACE_Send+0x16>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 8033a78:	480c      	ldr	r0, [pc, #48]	; (8033aac <TRACE_Send+0x94>)
 8033a7a:	8801      	ldrh	r1, [r0, #0]
 8033a7c:	1a8a      	subs	r2, r1, r2
 8033a7e:	b292      	uxth	r2, r2
 8033a80:	8282      	strh	r2, [r0, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 8033a82:	2102      	movs	r1, #2
 8033a84:	7081      	strb	r1, [r0, #2]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 8033a86:	2100      	movs	r1, #0
 8033a88:	8001      	strh	r1, [r0, #0]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8033a8a:	2a00      	cmp	r2, #0
 8033a8c:	d1db      	bne.n	8033a46 <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8033a8e:	7081      	strb	r1, [r0, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 8033a90:	8201      	strh	r1, [r0, #16]
 8033a92:	e7d8      	b.n	8033a46 <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 8033a94:	2380      	movs	r3, #128	; 0x80
 8033a96:	00db      	lsls	r3, r3, #3
 8033a98:	1a9b      	subs	r3, r3, r2
 8033a9a:	4a04      	ldr	r2, [pc, #16]	; (8033aac <TRACE_Send+0x94>)
 8033a9c:	8293      	strh	r3, [r2, #20]
 8033a9e:	e7dd      	b.n	8033a5c <TRACE_Send+0x44>
      TRACE_UnLock();
 8033aa0:	f7ff ff80 	bl	80339a4 <TRACE_UnLock>
 8033aa4:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 8033aa8:	2000      	movs	r0, #0
}
 8033aaa:	e7c0      	b.n	8033a2e <TRACE_Send+0x16>
 8033aac:	2000b518 	.word	0x2000b518
 8033ab0:	20009280 	.word	0x20009280
 8033ab4:	08034b2c 	.word	0x08034b2c

08033ab8 <UTIL_ADV_TRACE_COND_FSend>:
{
 8033ab8:	b408      	push	{r3}
 8033aba:	b510      	push	{r4, lr}
 8033abc:	b087      	sub	sp, #28
  uint16_t timestamp_size = 0u;
 8033abe:	466b      	mov	r3, sp
 8033ac0:	2400      	movs	r4, #0
 8033ac2:	805c      	strh	r4, [r3, #2]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 8033ac4:	4b2b      	ldr	r3, [pc, #172]	; (8033b74 <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8033ac6:	7a1b      	ldrb	r3, [r3, #8]
 8033ac8:	4283      	cmp	r3, r0
 8033aca:	d34c      	bcc.n	8033b66 <UTIL_ADV_TRACE_COND_FSend+0xae>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 8033acc:	4b29      	ldr	r3, [pc, #164]	; (8033b74 <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8033ace:	68db      	ldr	r3, [r3, #12]
 8033ad0:	400b      	ands	r3, r1
 8033ad2:	428b      	cmp	r3, r1
 8033ad4:	d14a      	bne.n	8033b6c <UTIL_ADV_TRACE_COND_FSend+0xb4>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 8033ad6:	4b27      	ldr	r3, [pc, #156]	; (8033b74 <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8033ad8:	685b      	ldr	r3, [r3, #4]
 8033ada:	2b00      	cmp	r3, #0
 8033adc:	d005      	beq.n	8033aea <UTIL_ADV_TRACE_COND_FSend+0x32>
 8033ade:	2a00      	cmp	r2, #0
 8033ae0:	d003      	beq.n	8033aea <UTIL_ADV_TRACE_COND_FSend+0x32>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 8033ae2:	466a      	mov	r2, sp
 8033ae4:	1c91      	adds	r1, r2, #2
 8033ae6:	a801      	add	r0, sp, #4
 8033ae8:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 8033aea:	ab0a      	add	r3, sp, #40	; 0x28
 8033aec:	9305      	str	r3, [sp, #20]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8033aee:	2180      	movs	r1, #128	; 0x80
 8033af0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8033af2:	0089      	lsls	r1, r1, #2
 8033af4:	4820      	ldr	r0, [pc, #128]	; (8033b78 <UTIL_ADV_TRACE_COND_FSend+0xc0>)
 8033af6:	f000 fd17 	bl	8034528 <tiny_vsnprintf_like>
 8033afa:	b284      	uxth	r4, r0
  TRACE_Lock();
 8033afc:	f7ff ff46 	bl	803398c <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 8033b00:	466b      	mov	r3, sp
 8033b02:	8858      	ldrh	r0, [r3, #2]
 8033b04:	1820      	adds	r0, r4, r0
 8033b06:	b280      	uxth	r0, r0
 8033b08:	4669      	mov	r1, sp
 8033b0a:	f7ff ff01 	bl	8033910 <TRACE_AllocateBufer>
 8033b0e:	1c43      	adds	r3, r0, #1
 8033b10:	d024      	beq.n	8033b5c <UTIL_ADV_TRACE_COND_FSend+0xa4>
    for (idx = 0u; idx < timestamp_size; idx++)
 8033b12:	2300      	movs	r3, #0
 8033b14:	e00a      	b.n	8033b2c <UTIL_ADV_TRACE_COND_FSend+0x74>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8033b16:	466a      	mov	r2, sp
 8033b18:	8812      	ldrh	r2, [r2, #0]
 8033b1a:	a901      	add	r1, sp, #4
 8033b1c:	5cc8      	ldrb	r0, [r1, r3]
 8033b1e:	4917      	ldr	r1, [pc, #92]	; (8033b7c <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 8033b20:	5488      	strb	r0, [r1, r2]
      writepos = writepos + 1u;
 8033b22:	3201      	adds	r2, #1
 8033b24:	4669      	mov	r1, sp
 8033b26:	800a      	strh	r2, [r1, #0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8033b28:	3301      	adds	r3, #1
 8033b2a:	b29b      	uxth	r3, r3
 8033b2c:	466a      	mov	r2, sp
 8033b2e:	3202      	adds	r2, #2
 8033b30:	8812      	ldrh	r2, [r2, #0]
 8033b32:	429a      	cmp	r2, r3
 8033b34:	d8ef      	bhi.n	8033b16 <UTIL_ADV_TRACE_COND_FSend+0x5e>
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8033b36:	466b      	mov	r3, sp
 8033b38:	8818      	ldrh	r0, [r3, #0]
 8033b3a:	4b10      	ldr	r3, [pc, #64]	; (8033b7c <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 8033b3c:	18c0      	adds	r0, r0, r3
 8033b3e:	2180      	movs	r1, #128	; 0x80
 8033b40:	9b05      	ldr	r3, [sp, #20]
 8033b42:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8033b44:	0089      	lsls	r1, r1, #2
 8033b46:	f000 fcef 	bl	8034528 <tiny_vsnprintf_like>
    TRACE_UnLock();
 8033b4a:	f7ff ff2b 	bl	80339a4 <TRACE_UnLock>
    return TRACE_Send();
 8033b4e:	f7ff ff63 	bl	8033a18 <TRACE_Send>
}
 8033b52:	b007      	add	sp, #28
 8033b54:	bc10      	pop	{r4}
 8033b56:	bc08      	pop	{r3}
 8033b58:	b001      	add	sp, #4
 8033b5a:	4718      	bx	r3
  TRACE_UnLock();
 8033b5c:	f7ff ff22 	bl	80339a4 <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 8033b60:	2003      	movs	r0, #3
 8033b62:	4240      	negs	r0, r0
 8033b64:	e7f5      	b.n	8033b52 <UTIL_ADV_TRACE_COND_FSend+0x9a>
    return UTIL_ADV_TRACE_GIVEUP;
 8033b66:	2005      	movs	r0, #5
 8033b68:	4240      	negs	r0, r0
 8033b6a:	e7f2      	b.n	8033b52 <UTIL_ADV_TRACE_COND_FSend+0x9a>
    return UTIL_ADV_TRACE_REGIONMASKED;
 8033b6c:	2006      	movs	r0, #6
 8033b6e:	4240      	negs	r0, r0
 8033b70:	e7ef      	b.n	8033b52 <UTIL_ADV_TRACE_COND_FSend+0x9a>
 8033b72:	46c0      	nop			; (mov r8, r8)
 8033b74:	2000b518 	.word	0x2000b518
 8033b78:	2000b530 	.word	0x2000b530
 8033b7c:	20009280 	.word	0x20009280

08033b80 <TRACE_TxCpltCallback>:
{
 8033b80:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033b82:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033b86:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 8033b88:	4b26      	ldr	r3, [pc, #152]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033b8a:	789b      	ldrb	r3, [r3, #2]
 8033b8c:	2b02      	cmp	r3, #2
 8033b8e:	d016      	beq.n	8033bbe <TRACE_TxCpltCallback+0x3e>
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 8033b90:	4a24      	ldr	r2, [pc, #144]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033b92:	8a13      	ldrh	r3, [r2, #16]
 8033b94:	8a90      	ldrh	r0, [r2, #20]
 8033b96:	181b      	adds	r3, r3, r0
 8033b98:	059b      	lsls	r3, r3, #22
 8033b9a:	0d9b      	lsrs	r3, r3, #22
 8033b9c:	8213      	strh	r3, [r2, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 8033b9e:	4b21      	ldr	r3, [pc, #132]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033ba0:	8a1a      	ldrh	r2, [r3, #16]
 8033ba2:	8a5b      	ldrh	r3, [r3, #18]
 8033ba4:	429a      	cmp	r2, r3
 8033ba6:	d003      	beq.n	8033bb0 <TRACE_TxCpltCallback+0x30>
 8033ba8:	481e      	ldr	r0, [pc, #120]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033baa:	8ac0      	ldrh	r0, [r0, #22]
 8033bac:	2801      	cmp	r0, #1
 8033bae:	d00b      	beq.n	8033bc8 <TRACE_TxCpltCallback+0x48>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033bb0:	f381 8810 	msr	PRIMASK, r1
    UTIL_ADV_TRACE_PostSendHook();
 8033bb4:	f7ee f80c 	bl	8021bd0 <UTIL_ADV_TRACE_PostSendHook>
    TRACE_UnLock();
 8033bb8:	f7ff fef4 	bl	80339a4 <TRACE_UnLock>
}
 8033bbc:	bd10      	pop	{r4, pc}
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8033bbe:	4b19      	ldr	r3, [pc, #100]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033bc0:	2200      	movs	r2, #0
 8033bc2:	709a      	strb	r2, [r3, #2]
    ADV_TRACE_Ctx.TraceRdPtr = 0;
 8033bc4:	821a      	strh	r2, [r3, #16]
    UTIL_ADV_TRACE_DEBUG("\nTRACE_TxCpltCallback::unchunk complete\n");
 8033bc6:	e7ea      	b.n	8033b9e <TRACE_TxCpltCallback+0x1e>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8033bc8:	4816      	ldr	r0, [pc, #88]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033bca:	7880      	ldrb	r0, [r0, #2]
 8033bcc:	2801      	cmp	r0, #1
 8033bce:	d015      	beq.n	8033bfc <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8033bd0:	4a14      	ldr	r2, [pc, #80]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033bd2:	7892      	ldrb	r2, [r2, #2]
 8033bd4:	2a00      	cmp	r2, #0
 8033bd6:	d106      	bne.n	8033be6 <TRACE_TxCpltCallback+0x66>
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8033bd8:	4a12      	ldr	r2, [pc, #72]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033bda:	8a12      	ldrh	r2, [r2, #16]
 8033bdc:	4293      	cmp	r3, r2
 8033bde:	d91b      	bls.n	8033c18 <TRACE_TxCpltCallback+0x98>
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8033be0:	1a9b      	subs	r3, r3, r2
 8033be2:	4a10      	ldr	r2, [pc, #64]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033be4:	8293      	strh	r3, [r2, #20]
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8033be6:	4b0f      	ldr	r3, [pc, #60]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033be8:	8a18      	ldrh	r0, [r3, #16]
 8033bea:	4a0f      	ldr	r2, [pc, #60]	; (8033c28 <TRACE_TxCpltCallback+0xa8>)
 8033bec:	1880      	adds	r0, r0, r2
 8033bee:	f381 8810 	msr	PRIMASK, r1
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8033bf2:	4a0e      	ldr	r2, [pc, #56]	; (8033c2c <TRACE_TxCpltCallback+0xac>)
 8033bf4:	68d2      	ldr	r2, [r2, #12]
 8033bf6:	8a99      	ldrh	r1, [r3, #20]
 8033bf8:	4790      	blx	r2
 8033bfa:	e7df      	b.n	8033bbc <TRACE_TxCpltCallback+0x3c>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 8033bfc:	4c09      	ldr	r4, [pc, #36]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033bfe:	8820      	ldrh	r0, [r4, #0]
 8033c00:	1a82      	subs	r2, r0, r2
 8033c02:	b292      	uxth	r2, r2
 8033c04:	82a2      	strh	r2, [r4, #20]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 8033c06:	2002      	movs	r0, #2
 8033c08:	70a0      	strb	r0, [r4, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 8033c0a:	2000      	movs	r0, #0
 8033c0c:	8020      	strh	r0, [r4, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8033c0e:	2a00      	cmp	r2, #0
 8033c10:	d1de      	bne.n	8033bd0 <TRACE_TxCpltCallback+0x50>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8033c12:	70a0      	strb	r0, [r4, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 8033c14:	8220      	strh	r0, [r4, #16]
 8033c16:	e7db      	b.n	8033bd0 <TRACE_TxCpltCallback+0x50>
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 8033c18:	2380      	movs	r3, #128	; 0x80
 8033c1a:	00db      	lsls	r3, r3, #3
 8033c1c:	1a9b      	subs	r3, r3, r2
 8033c1e:	4a01      	ldr	r2, [pc, #4]	; (8033c24 <TRACE_TxCpltCallback+0xa4>)
 8033c20:	8293      	strh	r3, [r2, #20]
 8033c22:	e7e0      	b.n	8033be6 <TRACE_TxCpltCallback+0x66>
 8033c24:	2000b518 	.word	0x2000b518
 8033c28:	20009280 	.word	0x20009280
 8033c2c:	08034b2c 	.word	0x08034b2c

08033c30 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 8033c30:	2300      	movs	r3, #0
 8033c32:	4a02      	ldr	r2, [pc, #8]	; (8033c3c <UTIL_LPM_Init+0xc>)
 8033c34:	6013      	str	r3, [r2, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 8033c36:	4a02      	ldr	r2, [pc, #8]	; (8033c40 <UTIL_LPM_Init+0x10>)
 8033c38:	6013      	str	r3, [r2, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 8033c3a:	4770      	bx	lr
 8033c3c:	2000b734 	.word	0x2000b734
 8033c40:	2000b730 	.word	0x2000b730

08033c44 <UTIL_LPM_SetStopMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033c44:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033c48:	b672      	cpsid	i

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 8033c4a:	2900      	cmp	r1, #0
 8033c4c:	d008      	beq.n	8033c60 <UTIL_LPM_SetStopMode+0x1c>
 8033c4e:	2901      	cmp	r1, #1
 8033c50:	d103      	bne.n	8033c5a <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 8033c52:	4a06      	ldr	r2, [pc, #24]	; (8033c6c <UTIL_LPM_SetStopMode+0x28>)
 8033c54:	6811      	ldr	r1, [r2, #0]
 8033c56:	4308      	orrs	r0, r1
 8033c58:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033c5a:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8033c5e:	4770      	bx	lr
      StopModeDisable &= ( ~lpm_id_bm );
 8033c60:	4902      	ldr	r1, [pc, #8]	; (8033c6c <UTIL_LPM_SetStopMode+0x28>)
 8033c62:	680a      	ldr	r2, [r1, #0]
 8033c64:	4382      	bics	r2, r0
 8033c66:	600a      	str	r2, [r1, #0]
      break;
 8033c68:	e7f7      	b.n	8033c5a <UTIL_LPM_SetStopMode+0x16>
 8033c6a:	46c0      	nop			; (mov r8, r8)
 8033c6c:	2000b734 	.word	0x2000b734

08033c70 <UTIL_LPM_SetOffMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033c70:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033c74:	b672      	cpsid	i

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 8033c76:	2900      	cmp	r1, #0
 8033c78:	d008      	beq.n	8033c8c <UTIL_LPM_SetOffMode+0x1c>
 8033c7a:	2901      	cmp	r1, #1
 8033c7c:	d103      	bne.n	8033c86 <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 8033c7e:	4a06      	ldr	r2, [pc, #24]	; (8033c98 <UTIL_LPM_SetOffMode+0x28>)
 8033c80:	6811      	ldr	r1, [r2, #0]
 8033c82:	4308      	orrs	r0, r1
 8033c84:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033c86:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8033c8a:	4770      	bx	lr
      OffModeDisable &= ( ~lpm_id_bm );
 8033c8c:	4902      	ldr	r1, [pc, #8]	; (8033c98 <UTIL_LPM_SetOffMode+0x28>)
 8033c8e:	680a      	ldr	r2, [r1, #0]
 8033c90:	4382      	bics	r2, r0
 8033c92:	600a      	str	r2, [r1, #0]
      break;
 8033c94:	e7f7      	b.n	8033c86 <UTIL_LPM_SetOffMode+0x16>
 8033c96:	46c0      	nop			; (mov r8, r8)
 8033c98:	2000b730 	.word	0x2000b730

08033c9c <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 8033c9c:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033c9e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033ca2:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 8033ca4:	4b0d      	ldr	r3, [pc, #52]	; (8033cdc <UTIL_LPM_EnterLowPower+0x40>)
 8033ca6:	681b      	ldr	r3, [r3, #0]
 8033ca8:	2b00      	cmp	r3, #0
 8033caa:	d007      	beq.n	8033cbc <UTIL_LPM_EnterLowPower+0x20>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 8033cac:	4d0c      	ldr	r5, [pc, #48]	; (8033ce0 <UTIL_LPM_EnterLowPower+0x44>)
 8033cae:	682b      	ldr	r3, [r5, #0]
 8033cb0:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 8033cb2:	686b      	ldr	r3, [r5, #4]
 8033cb4:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033cb6:	f384 8810 	msr	PRIMASK, r4
      UTIL_PowerDriver.ExitOffMode( );
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 8033cba:	bd70      	pop	{r4, r5, r6, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 8033cbc:	4b09      	ldr	r3, [pc, #36]	; (8033ce4 <UTIL_LPM_EnterLowPower+0x48>)
 8033cbe:	681b      	ldr	r3, [r3, #0]
 8033cc0:	2b00      	cmp	r3, #0
 8033cc2:	d005      	beq.n	8033cd0 <UTIL_LPM_EnterLowPower+0x34>
        UTIL_PowerDriver.EnterStopMode( );
 8033cc4:	4d06      	ldr	r5, [pc, #24]	; (8033ce0 <UTIL_LPM_EnterLowPower+0x44>)
 8033cc6:	68ab      	ldr	r3, [r5, #8]
 8033cc8:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 8033cca:	68eb      	ldr	r3, [r5, #12]
 8033ccc:	4798      	blx	r3
 8033cce:	e7f2      	b.n	8033cb6 <UTIL_LPM_EnterLowPower+0x1a>
      UTIL_PowerDriver.EnterOffMode( );
 8033cd0:	4d03      	ldr	r5, [pc, #12]	; (8033ce0 <UTIL_LPM_EnterLowPower+0x44>)
 8033cd2:	692b      	ldr	r3, [r5, #16]
 8033cd4:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 8033cd6:	696b      	ldr	r3, [r5, #20]
 8033cd8:	4798      	blx	r3
 8033cda:	e7ec      	b.n	8033cb6 <UTIL_LPM_EnterLowPower+0x1a>
 8033cdc:	2000b734 	.word	0x2000b734
 8033ce0:	08034918 	.word	0x08034918
 8033ce4:	2000b730 	.word	0x2000b730

08033ce8 <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 8033ce8:	1e53      	subs	r3, r2, #1
 8033cea:	b29b      	uxth	r3, r3
 8033cec:	2a00      	cmp	r2, #0
 8033cee:	d005      	beq.n	8033cfc <UTIL_MEM_cpy_8+0x14>
    {
        *dst8++ = *src8++;
 8033cf0:	780a      	ldrb	r2, [r1, #0]
 8033cf2:	7002      	strb	r2, [r0, #0]
 8033cf4:	3101      	adds	r1, #1
 8033cf6:	3001      	adds	r0, #1
  while( size-- )
 8033cf8:	001a      	movs	r2, r3
 8033cfa:	e7f5      	b.n	8033ce8 <UTIL_MEM_cpy_8>
    }
}
 8033cfc:	4770      	bx	lr

08033cfe <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 8033cfe:	1e53      	subs	r3, r2, #1
 8033d00:	b29b      	uxth	r3, r3
 8033d02:	2a00      	cmp	r2, #0
 8033d04:	d003      	beq.n	8033d0e <UTIL_MEM_set_8+0x10>
  {
    *dst8++ = value;
 8033d06:	7001      	strb	r1, [r0, #0]
 8033d08:	3001      	adds	r0, #1
  while( size-- )
 8033d0a:	001a      	movs	r2, r3
 8033d0c:	e7f7      	b.n	8033cfe <UTIL_MEM_set_8>
  }
}
 8033d0e:	4770      	bx	lr

08033d10 <UTIL_SEQ_SetTask>:

  return;
}

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 8033d10:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033d12:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033d16:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 8033d18:	4a05      	ldr	r2, [pc, #20]	; (8033d30 <UTIL_SEQ_SetTask+0x20>)
 8033d1a:	6813      	ldr	r3, [r2, #0]
 8033d1c:	4303      	orrs	r3, r0
 8033d1e:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 8033d20:	4b04      	ldr	r3, [pc, #16]	; (8033d34 <UTIL_SEQ_SetTask+0x24>)
 8033d22:	00c9      	lsls	r1, r1, #3
 8033d24:	58ca      	ldr	r2, [r1, r3]
 8033d26:	4310      	orrs	r0, r2
 8033d28:	50c8      	str	r0, [r1, r3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033d2a:	f384 8810 	msr	PRIMASK, r4

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 8033d2e:	bd10      	pop	{r4, pc}
 8033d30:	2000b7d4 	.word	0x2000b7d4
 8033d34:	2000b7c4 	.word	0x2000b7c4

08033d38 <UTIL_SEQ_SetEvt>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033d38:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033d3c:	b672      	cpsid	i

void UTIL_SEQ_SetEvt( UTIL_SEQ_bm_t EvtId_bm )
{
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  EvtSet |= EvtId_bm;
 8033d3e:	4b03      	ldr	r3, [pc, #12]	; (8033d4c <UTIL_SEQ_SetEvt+0x14>)
 8033d40:	6819      	ldr	r1, [r3, #0]
 8033d42:	4308      	orrs	r0, r1
 8033d44:	6018      	str	r0, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033d46:	f382 8810 	msr	PRIMASK, r2

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 8033d4a:	4770      	bx	lr
 8033d4c:	2000b73c 	.word	0x2000b73c

08033d50 <UTIL_SEQ_PreIdle>:
{
  /**
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 8033d50:	4770      	bx	lr

08033d52 <UTIL_SEQ_PostIdle>:
{
  /**
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 8033d52:	4770      	bx	lr

08033d54 <SEQ_BitPosition>:
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
  uint8_t n = 0U;

  if ((Value & 0xFFFF0000U) == 0U)  { n  = 16U; Value <<= 16U;  }
 8033d54:	0c03      	lsrs	r3, r0, #16
 8033d56:	d114      	bne.n	8033d82 <SEQ_BitPosition+0x2e>
 8033d58:	0400      	lsls	r0, r0, #16
 8033d5a:	3310      	adds	r3, #16
  if ((Value & 0xFF000000U) == 0U)  { n +=  8U; Value <<=  8U;  }
 8033d5c:	0e02      	lsrs	r2, r0, #24
 8033d5e:	d102      	bne.n	8033d66 <SEQ_BitPosition+0x12>
 8033d60:	3308      	adds	r3, #8
 8033d62:	b2db      	uxtb	r3, r3
 8033d64:	0200      	lsls	r0, r0, #8
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 8033d66:	0f02      	lsrs	r2, r0, #28
 8033d68:	d102      	bne.n	8033d70 <SEQ_BitPosition+0x1c>
 8033d6a:	3304      	adds	r3, #4
 8033d6c:	b2db      	uxtb	r3, r3
 8033d6e:	0100      	lsls	r0, r0, #4

  n += SEQ_clz_table_4bit[Value >> (32-4)];
 8033d70:	0f00      	lsrs	r0, r0, #28
 8033d72:	4a05      	ldr	r2, [pc, #20]	; (8033d88 <SEQ_BitPosition+0x34>)
 8033d74:	5c10      	ldrb	r0, [r2, r0]
 8033d76:	18c3      	adds	r3, r0, r3
 8033d78:	b2db      	uxtb	r3, r3

  return (uint8_t)(31U-n);
 8033d7a:	201f      	movs	r0, #31
 8033d7c:	1ac0      	subs	r0, r0, r3
 8033d7e:	b2c0      	uxtb	r0, r0
}
 8033d80:	4770      	bx	lr
  uint8_t n = 0U;
 8033d82:	2300      	movs	r3, #0
 8033d84:	e7ea      	b.n	8033d5c <SEQ_BitPosition+0x8>
 8033d86:	46c0      	nop			; (mov r8, r8)
 8033d88:	080357e8 	.word	0x080357e8

08033d8c <UTIL_SEQ_Run>:
{
 8033d8c:	b570      	push	{r4, r5, r6, lr}
  super_mask_backup = SuperMask;
 8033d8e:	4b3b      	ldr	r3, [pc, #236]	; (8033e7c <UTIL_SEQ_Run+0xf0>)
 8033d90:	681c      	ldr	r4, [r3, #0]
  SuperMask &= Mask_bm;
 8033d92:	4020      	ands	r0, r4
 8033d94:	6018      	str	r0, [r3, #0]
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 8033d96:	e011      	b.n	8033dbc <UTIL_SEQ_Run+0x30>
      counter++;
 8033d98:	3201      	adds	r2, #1
 8033d9a:	e020      	b.n	8033dde <UTIL_SEQ_Run+0x52>
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 8033d9c:	3b01      	subs	r3, #1
 8033d9e:	4938      	ldr	r1, [pc, #224]	; (8033e80 <UTIL_SEQ_Run+0xf4>)
 8033da0:	00d8      	lsls	r0, r3, #3
 8033da2:	5842      	ldr	r2, [r0, r1]
 8033da4:	402a      	ands	r2, r5
 8033da6:	5042      	str	r2, [r0, r1]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8033da8:	2b00      	cmp	r3, #0
 8033daa:	d1f7      	bne.n	8033d9c <UTIL_SEQ_Run+0x10>
 8033dac:	f386 8810 	msr	PRIMASK, r6
    TaskCb[CurrentTaskIdx]( );
 8033db0:	4b34      	ldr	r3, [pc, #208]	; (8033e84 <UTIL_SEQ_Run+0xf8>)
 8033db2:	681b      	ldr	r3, [r3, #0]
 8033db4:	009b      	lsls	r3, r3, #2
 8033db6:	4a34      	ldr	r2, [pc, #208]	; (8033e88 <UTIL_SEQ_Run+0xfc>)
 8033db8:	589b      	ldr	r3, [r3, r2]
 8033dba:	4798      	blx	r3
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 8033dbc:	4b33      	ldr	r3, [pc, #204]	; (8033e8c <UTIL_SEQ_Run+0x100>)
 8033dbe:	681d      	ldr	r5, [r3, #0]
 8033dc0:	4b33      	ldr	r3, [pc, #204]	; (8033e90 <UTIL_SEQ_Run+0x104>)
 8033dc2:	681b      	ldr	r3, [r3, #0]
 8033dc4:	402b      	ands	r3, r5
 8033dc6:	4a2d      	ldr	r2, [pc, #180]	; (8033e7c <UTIL_SEQ_Run+0xf0>)
 8033dc8:	6811      	ldr	r1, [r2, #0]
 8033dca:	4219      	tst	r1, r3
 8033dcc:	d034      	beq.n	8033e38 <UTIL_SEQ_Run+0xac>
 8033dce:	4b31      	ldr	r3, [pc, #196]	; (8033e94 <UTIL_SEQ_Run+0x108>)
 8033dd0:	681b      	ldr	r3, [r3, #0]
 8033dd2:	4a31      	ldr	r2, [pc, #196]	; (8033e98 <UTIL_SEQ_Run+0x10c>)
 8033dd4:	6810      	ldr	r0, [r2, #0]
 8033dd6:	0002      	movs	r2, r0
 8033dd8:	401a      	ands	r2, r3
 8033dda:	4218      	tst	r0, r3
 8033ddc:	d12c      	bne.n	8033e38 <UTIL_SEQ_Run+0xac>
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 8033dde:	00d3      	lsls	r3, r2, #3
 8033de0:	4827      	ldr	r0, [pc, #156]	; (8033e80 <UTIL_SEQ_Run+0xf4>)
 8033de2:	581b      	ldr	r3, [r3, r0]
 8033de4:	402b      	ands	r3, r5
 8033de6:	0008      	movs	r0, r1
 8033de8:	4018      	ands	r0, r3
 8033dea:	4219      	tst	r1, r3
 8033dec:	d0d4      	beq.n	8033d98 <UTIL_SEQ_Run+0xc>
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 8033dee:	00d1      	lsls	r1, r2, #3
 8033df0:	4b23      	ldr	r3, [pc, #140]	; (8033e80 <UTIL_SEQ_Run+0xf4>)
 8033df2:	185b      	adds	r3, r3, r1
 8033df4:	685b      	ldr	r3, [r3, #4]
 8033df6:	4203      	tst	r3, r0
 8033df8:	d104      	bne.n	8033e04 <UTIL_SEQ_Run+0x78>
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 8033dfa:	4b21      	ldr	r3, [pc, #132]	; (8033e80 <UTIL_SEQ_Run+0xf4>)
 8033dfc:	185b      	adds	r3, r3, r1
 8033dfe:	2101      	movs	r1, #1
 8033e00:	4249      	negs	r1, r1
 8033e02:	6059      	str	r1, [r3, #4]
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 8033e04:	00d2      	lsls	r2, r2, #3
 8033e06:	4d1e      	ldr	r5, [pc, #120]	; (8033e80 <UTIL_SEQ_Run+0xf4>)
 8033e08:	18ad      	adds	r5, r5, r2
 8033e0a:	686e      	ldr	r6, [r5, #4]
 8033e0c:	4030      	ands	r0, r6
 8033e0e:	f7ff ffa1 	bl	8033d54 <SEQ_BitPosition>
 8033e12:	4a1c      	ldr	r2, [pc, #112]	; (8033e84 <UTIL_SEQ_Run+0xf8>)
 8033e14:	6010      	str	r0, [r2, #0]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 8033e16:	2301      	movs	r3, #1
 8033e18:	0019      	movs	r1, r3
 8033e1a:	4081      	lsls	r1, r0
 8033e1c:	438e      	bics	r6, r1
 8033e1e:	606e      	str	r6, [r5, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033e20:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033e24:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 8033e26:	6812      	ldr	r2, [r2, #0]
 8033e28:	4093      	lsls	r3, r2
 8033e2a:	43dd      	mvns	r5, r3
 8033e2c:	4a18      	ldr	r2, [pc, #96]	; (8033e90 <UTIL_SEQ_Run+0x104>)
 8033e2e:	6811      	ldr	r1, [r2, #0]
 8033e30:	4399      	bics	r1, r3
 8033e32:	6011      	str	r1, [r2, #0]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8033e34:	2302      	movs	r3, #2
 8033e36:	e7b7      	b.n	8033da8 <UTIL_SEQ_Run+0x1c>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 8033e38:	4b12      	ldr	r3, [pc, #72]	; (8033e84 <UTIL_SEQ_Run+0xf8>)
 8033e3a:	2201      	movs	r2, #1
 8033e3c:	4252      	negs	r2, r2
 8033e3e:	601a      	str	r2, [r3, #0]
  UTIL_SEQ_PreIdle( );
 8033e40:	f7ff ff86 	bl	8033d50 <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033e44:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033e48:	b672      	cpsid	i
  if (!(((TaskSet & TaskMask & SuperMask) != 0U) || ((EvtSet & EvtWaited)!= 0U))) 
 8033e4a:	4b11      	ldr	r3, [pc, #68]	; (8033e90 <UTIL_SEQ_Run+0x104>)
 8033e4c:	681a      	ldr	r2, [r3, #0]
 8033e4e:	4b0f      	ldr	r3, [pc, #60]	; (8033e8c <UTIL_SEQ_Run+0x100>)
 8033e50:	681b      	ldr	r3, [r3, #0]
 8033e52:	4013      	ands	r3, r2
 8033e54:	4a09      	ldr	r2, [pc, #36]	; (8033e7c <UTIL_SEQ_Run+0xf0>)
 8033e56:	6812      	ldr	r2, [r2, #0]
 8033e58:	421a      	tst	r2, r3
 8033e5a:	d105      	bne.n	8033e68 <UTIL_SEQ_Run+0xdc>
 8033e5c:	4b0d      	ldr	r3, [pc, #52]	; (8033e94 <UTIL_SEQ_Run+0x108>)
 8033e5e:	681b      	ldr	r3, [r3, #0]
 8033e60:	4a0d      	ldr	r2, [pc, #52]	; (8033e98 <UTIL_SEQ_Run+0x10c>)
 8033e62:	6812      	ldr	r2, [r2, #0]
 8033e64:	421a      	tst	r2, r3
 8033e66:	d006      	beq.n	8033e76 <UTIL_SEQ_Run+0xea>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033e68:	f385 8810 	msr	PRIMASK, r5
  UTIL_SEQ_PostIdle( );
 8033e6c:	f7ff ff71 	bl	8033d52 <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 8033e70:	4b02      	ldr	r3, [pc, #8]	; (8033e7c <UTIL_SEQ_Run+0xf0>)
 8033e72:	601c      	str	r4, [r3, #0]
}
 8033e74:	bd70      	pop	{r4, r5, r6, pc}
	UTIL_SEQ_Idle( );
 8033e76:	f7ed fe5a 	bl	8021b2e <UTIL_SEQ_Idle>
 8033e7a:	e7f5      	b.n	8033e68 <UTIL_SEQ_Run+0xdc>
 8033e7c:	2000a0bc 	.word	0x2000a0bc
 8033e80:	2000b7c4 	.word	0x2000b7c4
 8033e84:	2000b738 	.word	0x2000b738
 8033e88:	2000b744 	.word	0x2000b744
 8033e8c:	2000a0c0 	.word	0x2000a0c0
 8033e90:	2000b7d4 	.word	0x2000b7d4
 8033e94:	2000b73c 	.word	0x2000b73c
 8033e98:	2000b740 	.word	0x2000b740

08033e9c <UTIL_SEQ_WaitEvt>:
{
 8033e9c:	b570      	push	{r4, r5, r6, lr}
  current_task_idx = CurrentTaskIdx;
 8033e9e:	4b0e      	ldr	r3, [pc, #56]	; (8033ed8 <UTIL_SEQ_WaitEvt+0x3c>)
 8033ea0:	681e      	ldr	r6, [r3, #0]
  if(UTIL_SEQ_NOTASKRUNNING == CurrentTaskIdx)
 8033ea2:	1c73      	adds	r3, r6, #1
 8033ea4:	d00e      	beq.n	8033ec4 <UTIL_SEQ_WaitEvt+0x28>
    wait_task_idx = 1 << CurrentTaskIdx;
 8033ea6:	2401      	movs	r4, #1
 8033ea8:	40b4      	lsls	r4, r6
  event_waited_id_backup = EvtWaited;
 8033eaa:	4b0c      	ldr	r3, [pc, #48]	; (8033edc <UTIL_SEQ_WaitEvt+0x40>)
 8033eac:	681d      	ldr	r5, [r3, #0]
  EvtWaited = EvtId_bm;
 8033eae:	6018      	str	r0, [r3, #0]
  while ((EvtSet & EvtWaited) == 0U)
 8033eb0:	4b0b      	ldr	r3, [pc, #44]	; (8033ee0 <UTIL_SEQ_WaitEvt+0x44>)
 8033eb2:	681b      	ldr	r3, [r3, #0]
 8033eb4:	4a09      	ldr	r2, [pc, #36]	; (8033edc <UTIL_SEQ_WaitEvt+0x40>)
 8033eb6:	6811      	ldr	r1, [r2, #0]
 8033eb8:	4219      	tst	r1, r3
 8033eba:	d105      	bne.n	8033ec8 <UTIL_SEQ_WaitEvt+0x2c>
    UTIL_SEQ_EvtIdle(wait_task_idx, EvtWaited);
 8033ebc:	0020      	movs	r0, r4
 8033ebe:	f7ed fe31 	bl	8021b24 <UTIL_SEQ_EvtIdle>
 8033ec2:	e7f5      	b.n	8033eb0 <UTIL_SEQ_WaitEvt+0x14>
    wait_task_idx = 0;
 8033ec4:	2400      	movs	r4, #0
 8033ec6:	e7f0      	b.n	8033eaa <UTIL_SEQ_WaitEvt+0xe>
  CurrentTaskIdx = current_task_idx;
 8033ec8:	4a03      	ldr	r2, [pc, #12]	; (8033ed8 <UTIL_SEQ_WaitEvt+0x3c>)
 8033eca:	6016      	str	r6, [r2, #0]
  EvtSet &= (~EvtWaited);
 8033ecc:	438b      	bics	r3, r1
 8033ece:	4a04      	ldr	r2, [pc, #16]	; (8033ee0 <UTIL_SEQ_WaitEvt+0x44>)
 8033ed0:	6013      	str	r3, [r2, #0]
  EvtWaited = event_waited_id_backup;
 8033ed2:	4b02      	ldr	r3, [pc, #8]	; (8033edc <UTIL_SEQ_WaitEvt+0x40>)
 8033ed4:	601d      	str	r5, [r3, #0]
}
 8033ed6:	bd70      	pop	{r4, r5, r6, pc}
 8033ed8:	2000b738 	.word	0x2000b738
 8033edc:	2000b740 	.word	0x2000b740
 8033ee0:	2000b73c 	.word	0x2000b73c

08033ee4 <UTIL_SEQ_RegTask>:
{
 8033ee4:	b570      	push	{r4, r5, r6, lr}
 8033ee6:	0014      	movs	r4, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033ee8:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033eec:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 8033eee:	f7ff ff31 	bl	8033d54 <SEQ_BitPosition>
 8033ef2:	0080      	lsls	r0, r0, #2
 8033ef4:	4b02      	ldr	r3, [pc, #8]	; (8033f00 <UTIL_SEQ_RegTask+0x1c>)
 8033ef6:	50c4      	str	r4, [r0, r3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033ef8:	f385 8810 	msr	PRIMASK, r5
}
 8033efc:	bd70      	pop	{r4, r5, r6, pc}
 8033efe:	46c0      	nop			; (mov r8, r8)
 8033f00:	2000b744 	.word	0x2000b744

08033f04 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 8033f04:	b082      	sub	sp, #8
 8033f06:	b510      	push	{r4, lr}
 8033f08:	b082      	sub	sp, #8
 8033f0a:	9305      	str	r3, [sp, #20]
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds + b.Seconds;
 8033f0c:	18c9      	adds	r1, r1, r3
 8033f0e:	6001      	str	r1, [r0, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8033f10:	b292      	uxth	r2, r2
 8033f12:	ab05      	add	r3, sp, #20
 8033f14:	889b      	ldrh	r3, [r3, #4]
 8033f16:	18d2      	adds	r2, r2, r3
 8033f18:	b293      	uxth	r3, r2
 8033f1a:	b212      	sxth	r2, r2
 8033f1c:	8082      	strh	r2, [r0, #4]
  if( c.SubSeconds >= 1000 )
 8033f1e:	24fa      	movs	r4, #250	; 0xfa
 8033f20:	00a4      	lsls	r4, r4, #2
 8033f22:	42a2      	cmp	r2, r4
 8033f24:	db05      	blt.n	8033f32 <SysTimeAdd+0x2e>
  {
    c.Seconds++;
 8033f26:	3101      	adds	r1, #1
 8033f28:	6001      	str	r1, [r0, #0]
    c.SubSeconds -= 1000;
 8033f2a:	4a04      	ldr	r2, [pc, #16]	; (8033f3c <SysTimeAdd+0x38>)
 8033f2c:	4694      	mov	ip, r2
 8033f2e:	4463      	add	r3, ip
 8033f30:	8083      	strh	r3, [r0, #4]
  }
  return c;
}
 8033f32:	b002      	add	sp, #8
 8033f34:	bc10      	pop	{r4}
 8033f36:	bc08      	pop	{r3}
 8033f38:	b002      	add	sp, #8
 8033f3a:	4718      	bx	r3
 8033f3c:	fffffc18 	.word	0xfffffc18

08033f40 <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 8033f40:	b082      	sub	sp, #8
 8033f42:	b082      	sub	sp, #8
 8033f44:	9303      	str	r3, [sp, #12]
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds - b.Seconds;
 8033f46:	1ac9      	subs	r1, r1, r3
 8033f48:	6001      	str	r1, [r0, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 8033f4a:	b292      	uxth	r2, r2
 8033f4c:	ab03      	add	r3, sp, #12
 8033f4e:	889b      	ldrh	r3, [r3, #4]
 8033f50:	1ad2      	subs	r2, r2, r3
 8033f52:	b293      	uxth	r3, r2
 8033f54:	b212      	sxth	r2, r2
 8033f56:	8082      	strh	r2, [r0, #4]
  if( c.SubSeconds < 0 )
 8033f58:	2a00      	cmp	r2, #0
 8033f5a:	db02      	blt.n	8033f62 <SysTimeSub+0x22>
  {
    c.Seconds--;
    c.SubSeconds += 1000;
  }
  return c;
}
 8033f5c:	b002      	add	sp, #8
 8033f5e:	b002      	add	sp, #8
 8033f60:	4770      	bx	lr
    c.Seconds--;
 8033f62:	3901      	subs	r1, #1
 8033f64:	6001      	str	r1, [r0, #0]
    c.SubSeconds += 1000;
 8033f66:	22fa      	movs	r2, #250	; 0xfa
 8033f68:	0092      	lsls	r2, r2, #2
 8033f6a:	4694      	mov	ip, r2
 8033f6c:	4463      	add	r3, ip
 8033f6e:	8083      	strh	r3, [r0, #4]
  return c;
 8033f70:	e7f4      	b.n	8033f5c <SysTimeSub+0x1c>
	...

08033f74 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 8033f74:	b570      	push	{r4, r5, r6, lr}
 8033f76:	b088      	sub	sp, #32
 8033f78:	9002      	str	r0, [sp, #8]
 8033f7a:	9103      	str	r1, [sp, #12]
  SysTime_t DeltaTime;
  
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8033f7c:	ae04      	add	r6, sp, #16
 8033f7e:	2300      	movs	r3, #0
 8033f80:	9304      	str	r3, [sp, #16]
 8033f82:	80b3      	strh	r3, [r6, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8033f84:	4c0b      	ldr	r4, [pc, #44]	; (8033fb4 <SysTimeSet+0x40>)
 8033f86:	a805      	add	r0, sp, #20
 8033f88:	6923      	ldr	r3, [r4, #16]
 8033f8a:	4798      	blx	r3
 8033f8c:	0003      	movs	r3, r0
 8033f8e:	9004      	str	r0, [sp, #16]

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );
 8033f90:	ad06      	add	r5, sp, #24
 8033f92:	6872      	ldr	r2, [r6, #4]
 8033f94:	9200      	str	r2, [sp, #0]
 8033f96:	9902      	ldr	r1, [sp, #8]
 8033f98:	9a03      	ldr	r2, [sp, #12]
 8033f9a:	0028      	movs	r0, r5
 8033f9c:	f7ff ffd0 	bl	8033f40 <SysTimeSub>

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 8033fa0:	9806      	ldr	r0, [sp, #24]
 8033fa2:	6823      	ldr	r3, [r4, #0]
 8033fa4:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 8033fa6:	68a3      	ldr	r3, [r4, #8]
 8033fa8:	2204      	movs	r2, #4
 8033faa:	5ea8      	ldrsh	r0, [r5, r2]
 8033fac:	4798      	blx	r3
}
 8033fae:	b008      	add	sp, #32
 8033fb0:	bd70      	pop	{r4, r5, r6, pc}
 8033fb2:	46c0      	nop			; (mov r8, r8)
 8033fb4:	08034964 	.word	0x08034964

08033fb8 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 8033fb8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8033fba:	b087      	sub	sp, #28
 8033fbc:	0004      	movs	r4, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8033fbe:	af04      	add	r7, sp, #16
 8033fc0:	2300      	movs	r3, #0
 8033fc2:	9304      	str	r3, [sp, #16]
 8033fc4:	80bb      	strh	r3, [r7, #4]
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8033fc6:	4d0b      	ldr	r5, [pc, #44]	; (8033ff4 <SysTimeGet+0x3c>)
 8033fc8:	a805      	add	r0, sp, #20
 8033fca:	692b      	ldr	r3, [r5, #16]
 8033fcc:	4798      	blx	r3
 8033fce:	9004      	str	r0, [sp, #16]

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8033fd0:	68eb      	ldr	r3, [r5, #12]
 8033fd2:	4798      	blx	r3
 8033fd4:	ae02      	add	r6, sp, #8
 8033fd6:	80b0      	strh	r0, [r6, #4]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8033fd8:	686b      	ldr	r3, [r5, #4]
 8033fda:	4798      	blx	r3
 8033fdc:	0001      	movs	r1, r0

  sysTime = SysTimeAdd( DeltaTime, calendarTime );
 8033fde:	687b      	ldr	r3, [r7, #4]
 8033fe0:	9300      	str	r3, [sp, #0]
 8033fe2:	9b04      	ldr	r3, [sp, #16]
 8033fe4:	6872      	ldr	r2, [r6, #4]
 8033fe6:	0020      	movs	r0, r4
 8033fe8:	f7ff ff8c 	bl	8033f04 <SysTimeAdd>

  return sysTime;
}
 8033fec:	0020      	movs	r0, r4
 8033fee:	b007      	add	sp, #28
 8033ff0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8033ff2:	46c0      	nop			; (mov r8, r8)
 8033ff4:	08034964 	.word	0x08034964

08033ff8 <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 8033ff8:	b530      	push	{r4, r5, lr}
 8033ffa:	b083      	sub	sp, #12
 8033ffc:	0004      	movs	r4, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8033ffe:	466d      	mov	r5, sp
 8034000:	2300      	movs	r3, #0
 8034002:	9300      	str	r3, [sp, #0]
 8034004:	80ab      	strh	r3, [r5, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8034006:	4b05      	ldr	r3, [pc, #20]	; (803401c <SysTimeGetMcuTime+0x24>)
 8034008:	691b      	ldr	r3, [r3, #16]
 803400a:	a801      	add	r0, sp, #4
 803400c:	4798      	blx	r3
 803400e:	9000      	str	r0, [sp, #0]
  
  return calendarTime;
 8034010:	0023      	movs	r3, r4
 8034012:	cd06      	ldmia	r5!, {r1, r2}
 8034014:	c306      	stmia	r3!, {r1, r2}
}
 8034016:	0020      	movs	r0, r4
 8034018:	b003      	add	sp, #12
 803401a:	bd30      	pop	{r4, r5, pc}
 803401c:	08034964 	.word	0x08034964

08034020 <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 8034020:	b530      	push	{r4, r5, lr}
 8034022:	b089      	sub	sp, #36	; 0x24
 8034024:	9002      	str	r0, [sp, #8]
 8034026:	9103      	str	r1, [sp, #12]
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8034028:	4c0d      	ldr	r4, [pc, #52]	; (8034060 <SysTimeToMs+0x40>)
 803402a:	68e3      	ldr	r3, [r4, #12]
 803402c:	4798      	blx	r3
 803402e:	ad06      	add	r5, sp, #24
 8034030:	80a8      	strh	r0, [r5, #4]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8034032:	6863      	ldr	r3, [r4, #4]
 8034034:	4798      	blx	r3
 8034036:	0003      	movs	r3, r0
  
  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
 8034038:	ac04      	add	r4, sp, #16
 803403a:	686a      	ldr	r2, [r5, #4]
 803403c:	9200      	str	r2, [sp, #0]
 803403e:	9902      	ldr	r1, [sp, #8]
 8034040:	9a03      	ldr	r2, [sp, #12]
 8034042:	0020      	movs	r0, r4
 8034044:	f7ff ff7c 	bl	8033f40 <SysTimeSub>
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
 8034048:	9b04      	ldr	r3, [sp, #16]
 803404a:	0158      	lsls	r0, r3, #5
 803404c:	1ac0      	subs	r0, r0, r3
 803404e:	0080      	lsls	r0, r0, #2
 8034050:	18c0      	adds	r0, r0, r3
 8034052:	00c0      	lsls	r0, r0, #3
 8034054:	2204      	movs	r2, #4
 8034056:	5ea3      	ldrsh	r3, [r4, r2]
 8034058:	18c0      	adds	r0, r0, r3
}
 803405a:	b009      	add	sp, #36	; 0x24
 803405c:	bd30      	pop	{r4, r5, pc}
 803405e:	46c0      	nop			; (mov r8, r8)
 8034060:	08034964 	.word	0x08034964

08034064 <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 8034064:	b5f0      	push	{r4, r5, r6, r7, lr}
 8034066:	b087      	sub	sp, #28
 8034068:	0005      	movs	r5, r0
 803406a:	000c      	movs	r4, r1
  uint32_t seconds = timeMs / 1000;
 803406c:	21fa      	movs	r1, #250	; 0xfa
 803406e:	0089      	lsls	r1, r1, #2
 8034070:	0020      	movs	r0, r4
 8034072:	f7ec f851 	bl	8020118 <__udivsi3>
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 8034076:	ae04      	add	r6, sp, #16
 8034078:	9004      	str	r0, [sp, #16]
 803407a:	21fa      	movs	r1, #250	; 0xfa
 803407c:	0089      	lsls	r1, r1, #2
 803407e:	4348      	muls	r0, r1
 8034080:	1a24      	subs	r4, r4, r0
 8034082:	80b4      	strh	r4, [r6, #4]
  SysTime_t DeltaTime = { 0 };
 8034084:	ac02      	add	r4, sp, #8
 8034086:	2300      	movs	r3, #0
 8034088:	80e3      	strh	r3, [r4, #6]

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803408a:	4f08      	ldr	r7, [pc, #32]	; (80340ac <SysTimeFromMs+0x48>)
 803408c:	68fb      	ldr	r3, [r7, #12]
 803408e:	4798      	blx	r3
 8034090:	80a0      	strh	r0, [r4, #4]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8034092:	687b      	ldr	r3, [r7, #4]
 8034094:	4798      	blx	r3
 8034096:	0003      	movs	r3, r0
  return SysTimeAdd( sysTime, DeltaTime );
 8034098:	6862      	ldr	r2, [r4, #4]
 803409a:	9200      	str	r2, [sp, #0]
 803409c:	9904      	ldr	r1, [sp, #16]
 803409e:	6872      	ldr	r2, [r6, #4]
 80340a0:	0028      	movs	r0, r5
 80340a2:	f7ff ff2f 	bl	8033f04 <SysTimeAdd>
}
 80340a6:	0028      	movs	r0, r5
 80340a8:	b007      	add	sp, #28
 80340aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80340ac:	08034964 	.word	0x08034964

080340b0 <UTIL_TIMER_Init>:
  * @addtogroup TIMER_SERVER_exported_function
  *  @{
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
 80340b0:	b510      	push	{r4, lr}
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 80340b2:	4b03      	ldr	r3, [pc, #12]	; (80340c0 <UTIL_TIMER_Init+0x10>)
 80340b4:	2200      	movs	r2, #0
 80340b6:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 80340b8:	4b02      	ldr	r3, [pc, #8]	; (80340c4 <UTIL_TIMER_Init+0x14>)
 80340ba:	681b      	ldr	r3, [r3, #0]
 80340bc:	4798      	blx	r3
}
 80340be:	bd10      	pop	{r4, pc}
 80340c0:	2000b7d8 	.word	0x2000b7d8
 80340c4:	08034978 	.word	0x08034978

080340c8 <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 80340c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80340ca:	0004      	movs	r4, r0
 80340cc:	0008      	movs	r0, r1
 80340ce:	0016      	movs	r6, r2
 80340d0:	001d      	movs	r5, r3
  if((TimerObject != NULL) && (Callback != NULL))
 80340d2:	2c00      	cmp	r4, #0
 80340d4:	d011      	beq.n	80340fa <UTIL_TIMER_Create+0x32>
 80340d6:	2b00      	cmp	r3, #0
 80340d8:	d011      	beq.n	80340fe <UTIL_TIMER_Create+0x36>
  {
    TimerObject->Timestamp = 0U;
 80340da:	2700      	movs	r7, #0
 80340dc:	6027      	str	r7, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 80340de:	4b09      	ldr	r3, [pc, #36]	; (8034104 <UTIL_TIMER_Create+0x3c>)
 80340e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80340e2:	4798      	blx	r3
 80340e4:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 80340e6:	7227      	strb	r7, [r4, #8]
    TimerObject->IsRunning = 0U;
 80340e8:	7267      	strb	r7, [r4, #9]
    TimerObject->IsReloadStopped = 0U;
 80340ea:	72a7      	strb	r7, [r4, #10]
    TimerObject->Callback = Callback;
 80340ec:	60e5      	str	r5, [r4, #12]
    TimerObject->argument = Argument;
 80340ee:	9b06      	ldr	r3, [sp, #24]
 80340f0:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 80340f2:	72e6      	strb	r6, [r4, #11]
    TimerObject->Next = NULL;
 80340f4:	6167      	str	r7, [r4, #20]
    return UTIL_TIMER_OK;
 80340f6:	2000      	movs	r0, #0
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 80340f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 80340fa:	2001      	movs	r0, #1
 80340fc:	e7fc      	b.n	80340f8 <UTIL_TIMER_Create+0x30>
 80340fe:	2001      	movs	r0, #1
 8034100:	e7fa      	b.n	80340f8 <UTIL_TIMER_Create+0x30>
 8034102:	46c0      	nop			; (mov r8, r8)
 8034104:	08034978 	.word	0x08034978

08034108 <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 8034108:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 803410a:	4c03      	ldr	r4, [pc, #12]	; (8034118 <UTIL_TIMER_GetCurrentTime+0x10>)
 803410c:	69e3      	ldr	r3, [r4, #28]
 803410e:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 8034110:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8034112:	4798      	blx	r3
}
 8034114:	bd10      	pop	{r4, pc}
 8034116:	46c0      	nop			; (mov r8, r8)
 8034118:	08034978 	.word	0x08034978

0803411c <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 803411c:	b570      	push	{r4, r5, r6, lr}
 803411e:	0006      	movs	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 8034120:	4d05      	ldr	r5, [pc, #20]	; (8034138 <UTIL_TIMER_GetElapsedTime+0x1c>)
 8034122:	69eb      	ldr	r3, [r5, #28]
 8034124:	4798      	blx	r3
 8034126:	0004      	movs	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 8034128:	0030      	movs	r0, r6
 803412a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 803412c:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803412e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8034130:	1a20      	subs	r0, r4, r0
 8034132:	4798      	blx	r3
}
 8034134:	bd70      	pop	{r4, r5, r6, pc}
 8034136:	46c0      	nop			; (mov r8, r8)
 8034138:	08034978 	.word	0x08034978

0803413c <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803413c:	4b05      	ldr	r3, [pc, #20]	; (8034154 <TimerExists+0x18>)
 803413e:	681b      	ldr	r3, [r3, #0]

  while( cur != NULL )
 8034140:	2b00      	cmp	r3, #0
 8034142:	d003      	beq.n	803414c <TimerExists+0x10>
  {
    if( cur == TimerObject )
 8034144:	4283      	cmp	r3, r0
 8034146:	d003      	beq.n	8034150 <TimerExists+0x14>
    {
      return true;
    }
    cur = cur->Next;
 8034148:	695b      	ldr	r3, [r3, #20]
 803414a:	e7f9      	b.n	8034140 <TimerExists+0x4>
  }
  return false;
 803414c:	2000      	movs	r0, #0
}
 803414e:	4770      	bx	lr
      return true;
 8034150:	2001      	movs	r0, #1
 8034152:	e7fc      	b.n	803414e <TimerExists+0x12>
 8034154:	2000b7d8 	.word	0x2000b7d8

08034158 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 8034158:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803415a:	0004      	movs	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 803415c:	4e09      	ldr	r6, [pc, #36]	; (8034184 <TimerSetTimeout+0x2c>)
 803415e:	6a33      	ldr	r3, [r6, #32]
 8034160:	4798      	blx	r3
 8034162:	0005      	movs	r5, r0
  TimerObject->IsPending = 1;
 8034164:	2301      	movs	r3, #1
 8034166:	7223      	strb	r3, [r4, #8]

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8034168:	6827      	ldr	r7, [r4, #0]
 803416a:	69b6      	ldr	r6, [r6, #24]
 803416c:	47b0      	blx	r6
 803416e:	1940      	adds	r0, r0, r5
 8034170:	4287      	cmp	r7, r0
 8034172:	d202      	bcs.n	803417a <TimerSetTimeout+0x22>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 8034174:	47b0      	blx	r6
 8034176:	1945      	adds	r5, r0, r5
 8034178:	6025      	str	r5, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 803417a:	4b02      	ldr	r3, [pc, #8]	; (8034184 <TimerSetTimeout+0x2c>)
 803417c:	689b      	ldr	r3, [r3, #8]
 803417e:	6820      	ldr	r0, [r4, #0]
 8034180:	4798      	blx	r3
}
 8034182:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8034184:	08034978 	.word	0x08034978

08034188 <UTIL_TIMER_Stop>:
{
 8034188:	b510      	push	{r4, lr}
  if (NULL != TimerObject)
 803418a:	2800      	cmp	r0, #0
 803418c:	d02f      	beq.n	80341ee <UTIL_TIMER_Stop+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803418e:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8034192:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 8034194:	4b17      	ldr	r3, [pc, #92]	; (80341f4 <UTIL_TIMER_Stop+0x6c>)
 8034196:	681a      	ldr	r2, [r3, #0]
    TimerObject->IsReloadStopped = 1U;
 8034198:	2301      	movs	r3, #1
 803419a:	7283      	strb	r3, [r0, #10]
    if(NULL != TimerListHead)
 803419c:	2a00      	cmp	r2, #0
 803419e:	d01f      	beq.n	80341e0 <UTIL_TIMER_Stop+0x58>
      TimerObject->IsRunning = 0U;
 80341a0:	2300      	movs	r3, #0
 80341a2:	7243      	strb	r3, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 80341a4:	4290      	cmp	r0, r2
 80341a6:	d007      	beq.n	80341b8 <UTIL_TIMER_Stop+0x30>
    UTIL_TIMER_Object_t* cur = TimerListHead;
 80341a8:	0013      	movs	r3, r2
        while( cur != NULL )
 80341aa:	2b00      	cmp	r3, #0
 80341ac:	d018      	beq.n	80341e0 <UTIL_TIMER_Stop+0x58>
          if( cur == TimerObject )
 80341ae:	4283      	cmp	r3, r0
 80341b0:	d012      	beq.n	80341d8 <UTIL_TIMER_Stop+0x50>
            prev = cur;
 80341b2:	001a      	movs	r2, r3
            cur = cur->Next;
 80341b4:	695b      	ldr	r3, [r3, #20]
 80341b6:	e7f8      	b.n	80341aa <UTIL_TIMER_Stop+0x22>
          TimerListHead->IsPending = 0;
 80341b8:	7213      	strb	r3, [r2, #8]
          if( TimerListHead->Next != NULL )
 80341ba:	6950      	ldr	r0, [r2, #20]
 80341bc:	2800      	cmp	r0, #0
 80341be:	d004      	beq.n	80341ca <UTIL_TIMER_Stop+0x42>
            TimerListHead = TimerListHead->Next;
 80341c0:	4b0c      	ldr	r3, [pc, #48]	; (80341f4 <UTIL_TIMER_Stop+0x6c>)
 80341c2:	6018      	str	r0, [r3, #0]
            TimerSetTimeout( TimerListHead );
 80341c4:	f7ff ffc8 	bl	8034158 <TimerSetTimeout>
 80341c8:	e00a      	b.n	80341e0 <UTIL_TIMER_Stop+0x58>
            UTIL_TimerDriver.StopTimerEvt( );
 80341ca:	4b0b      	ldr	r3, [pc, #44]	; (80341f8 <UTIL_TIMER_Stop+0x70>)
 80341cc:	68db      	ldr	r3, [r3, #12]
 80341ce:	4798      	blx	r3
            TimerListHead = NULL;
 80341d0:	4b08      	ldr	r3, [pc, #32]	; (80341f4 <UTIL_TIMER_Stop+0x6c>)
 80341d2:	2200      	movs	r2, #0
 80341d4:	601a      	str	r2, [r3, #0]
 80341d6:	e003      	b.n	80341e0 <UTIL_TIMER_Stop+0x58>
            if( cur->Next != NULL )
 80341d8:	695b      	ldr	r3, [r3, #20]
 80341da:	2b00      	cmp	r3, #0
 80341dc:	d004      	beq.n	80341e8 <UTIL_TIMER_Stop+0x60>
              prev->Next = cur;
 80341de:	6153      	str	r3, [r2, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80341e0:	f384 8810 	msr	PRIMASK, r4
}
 80341e4:	2000      	movs	r0, #0
}
 80341e6:	bd10      	pop	{r4, pc}
              prev->Next = cur;
 80341e8:	2300      	movs	r3, #0
 80341ea:	6153      	str	r3, [r2, #20]
 80341ec:	e7f8      	b.n	80341e0 <UTIL_TIMER_Stop+0x58>
    ret = UTIL_TIMER_INVALID_PARAM;
 80341ee:	2001      	movs	r0, #1
 80341f0:	e7f9      	b.n	80341e6 <UTIL_TIMER_Stop+0x5e>
 80341f2:	46c0      	nop			; (mov r8, r8)
 80341f4:	2000b7d8 	.word	0x2000b7d8
 80341f8:	08034978 	.word	0x08034978

080341fc <TimerInsertTimer>:
 *     next timer to expire.
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
 80341fc:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 80341fe:	4b0a      	ldr	r3, [pc, #40]	; (8034228 <TimerInsertTimer+0x2c>)
 8034200:	681a      	ldr	r2, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 8034202:	6953      	ldr	r3, [r2, #20]

  while (cur->Next != NULL )
 8034204:	6951      	ldr	r1, [r2, #20]
 8034206:	2900      	cmp	r1, #0
 8034208:	d009      	beq.n	803421e <TimerInsertTimer+0x22>
  {  
    if( TimerObject->Timestamp  > next->Timestamp )
 803420a:	6801      	ldr	r1, [r0, #0]
 803420c:	681c      	ldr	r4, [r3, #0]
 803420e:	42a1      	cmp	r1, r4
 8034210:	d902      	bls.n	8034218 <TimerInsertTimer+0x1c>
    {
        cur = next;
 8034212:	001a      	movs	r2, r3
        next = next->Next;
 8034214:	695b      	ldr	r3, [r3, #20]
 8034216:	e7f5      	b.n	8034204 <TimerInsertTimer+0x8>
    }
    else
    {
        cur->Next = TimerObject;
 8034218:	6150      	str	r0, [r2, #20]
        TimerObject->Next = next;
 803421a:	6143      	str	r3, [r0, #20]
        return;
 803421c:	e002      	b.n	8034224 <TimerInsertTimer+0x28>

    }
  }
  cur->Next = TimerObject;
 803421e:	6150      	str	r0, [r2, #20]
  TimerObject->Next = NULL;
 8034220:	2300      	movs	r3, #0
 8034222:	6143      	str	r3, [r0, #20]
}
 8034224:	bd10      	pop	{r4, pc}
 8034226:	46c0      	nop			; (mov r8, r8)
 8034228:	2000b7d8 	.word	0x2000b7d8

0803422c <TimerInsertNewHeadTimer>:
 *
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
 803422c:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803422e:	4b06      	ldr	r3, [pc, #24]	; (8034248 <TimerInsertNewHeadTimer+0x1c>)
 8034230:	681b      	ldr	r3, [r3, #0]

  if( cur != NULL )
 8034232:	2b00      	cmp	r3, #0
 8034234:	d001      	beq.n	803423a <TimerInsertNewHeadTimer+0xe>
  {
    cur->IsPending = 0;
 8034236:	2200      	movs	r2, #0
 8034238:	721a      	strb	r2, [r3, #8]
  }

  TimerObject->Next = cur;
 803423a:	6143      	str	r3, [r0, #20]
  TimerListHead = TimerObject;
 803423c:	4b02      	ldr	r3, [pc, #8]	; (8034248 <TimerInsertNewHeadTimer+0x1c>)
 803423e:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 8034240:	f7ff ff8a 	bl	8034158 <TimerSetTimeout>
}
 8034244:	bd10      	pop	{r4, pc}
 8034246:	46c0      	nop			; (mov r8, r8)
 8034248:	2000b7d8 	.word	0x2000b7d8

0803424c <UTIL_TIMER_Start>:
{
 803424c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803424e:	1e04      	subs	r4, r0, #0
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 8034250:	d037      	beq.n	80342c2 <UTIL_TIMER_Start+0x76>
 8034252:	f7ff ff73 	bl	803413c <TimerExists>
 8034256:	2800      	cmp	r0, #0
 8034258:	d136      	bne.n	80342c8 <UTIL_TIMER_Start+0x7c>
 803425a:	7a65      	ldrb	r5, [r4, #9]
 803425c:	2d00      	cmp	r5, #0
 803425e:	d135      	bne.n	80342cc <UTIL_TIMER_Start+0x80>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8034260:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8034264:	b672      	cpsid	i
    ticks = TimerObject->ReloadValue;
 8034266:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 8034268:	4b19      	ldr	r3, [pc, #100]	; (80342d0 <UTIL_TIMER_Start+0x84>)
 803426a:	6a1b      	ldr	r3, [r3, #32]
 803426c:	4798      	blx	r3
    if( ticks < minValue )
 803426e:	4287      	cmp	r7, r0
 8034270:	d300      	bcc.n	8034274 <UTIL_TIMER_Start+0x28>
    ticks = TimerObject->ReloadValue;
 8034272:	0038      	movs	r0, r7
    TimerObject->Timestamp = ticks;
 8034274:	6020      	str	r0, [r4, #0]
    TimerObject->IsPending = 0U;
 8034276:	2300      	movs	r3, #0
 8034278:	7223      	strb	r3, [r4, #8]
    TimerObject->IsRunning = 1U;
 803427a:	2201      	movs	r2, #1
 803427c:	7262      	strb	r2, [r4, #9]
    TimerObject->IsReloadStopped = 0U;
 803427e:	72a3      	strb	r3, [r4, #10]
    if( TimerListHead == NULL )
 8034280:	4b14      	ldr	r3, [pc, #80]	; (80342d4 <UTIL_TIMER_Start+0x88>)
 8034282:	681b      	ldr	r3, [r3, #0]
 8034284:	2b00      	cmp	r3, #0
 8034286:	d011      	beq.n	80342ac <UTIL_TIMER_Start+0x60>
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 8034288:	4b11      	ldr	r3, [pc, #68]	; (80342d0 <UTIL_TIMER_Start+0x84>)
 803428a:	699b      	ldr	r3, [r3, #24]
 803428c:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 803428e:	6823      	ldr	r3, [r4, #0]
 8034290:	469c      	mov	ip, r3
 8034292:	4460      	add	r0, ip
 8034294:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 8034296:	4b0f      	ldr	r3, [pc, #60]	; (80342d4 <UTIL_TIMER_Start+0x88>)
 8034298:	681b      	ldr	r3, [r3, #0]
 803429a:	681b      	ldr	r3, [r3, #0]
 803429c:	4298      	cmp	r0, r3
 803429e:	d20c      	bcs.n	80342ba <UTIL_TIMER_Start+0x6e>
        TimerInsertNewHeadTimer( TimerObject);
 80342a0:	0020      	movs	r0, r4
 80342a2:	f7ff ffc3 	bl	803422c <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80342a6:	f386 8810 	msr	PRIMASK, r6
}
 80342aa:	e00b      	b.n	80342c4 <UTIL_TIMER_Start+0x78>
      UTIL_TimerDriver.SetTimerContext();
 80342ac:	4b08      	ldr	r3, [pc, #32]	; (80342d0 <UTIL_TIMER_Start+0x84>)
 80342ae:	691b      	ldr	r3, [r3, #16]
 80342b0:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 80342b2:	0020      	movs	r0, r4
 80342b4:	f7ff ffba 	bl	803422c <TimerInsertNewHeadTimer>
 80342b8:	e7f5      	b.n	80342a6 <UTIL_TIMER_Start+0x5a>
        TimerInsertTimer( TimerObject);
 80342ba:	0020      	movs	r0, r4
 80342bc:	f7ff ff9e 	bl	80341fc <TimerInsertTimer>
 80342c0:	e7f1      	b.n	80342a6 <UTIL_TIMER_Start+0x5a>
    ret =  UTIL_TIMER_INVALID_PARAM;
 80342c2:	2501      	movs	r5, #1
}
 80342c4:	0028      	movs	r0, r5
 80342c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret =  UTIL_TIMER_INVALID_PARAM;
 80342c8:	2501      	movs	r5, #1
 80342ca:	e7fb      	b.n	80342c4 <UTIL_TIMER_Start+0x78>
 80342cc:	2501      	movs	r5, #1
 80342ce:	e7f9      	b.n	80342c4 <UTIL_TIMER_Start+0x78>
 80342d0:	08034978 	.word	0x08034978
 80342d4:	2000b7d8 	.word	0x2000b7d8

080342d8 <UTIL_TIMER_SetPeriod>:
{
 80342d8:	b510      	push	{r4, lr}
 80342da:	0004      	movs	r4, r0
 80342dc:	0008      	movs	r0, r1
  if(NULL == TimerObject)
 80342de:	2c00      	cmp	r4, #0
 80342e0:	d011      	beq.n	8034306 <UTIL_TIMER_SetPeriod+0x2e>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 80342e2:	4b0a      	ldr	r3, [pc, #40]	; (803430c <UTIL_TIMER_SetPeriod+0x34>)
 80342e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80342e6:	4798      	blx	r3
 80342e8:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 80342ea:	0020      	movs	r0, r4
 80342ec:	f7ff ff26 	bl	803413c <TimerExists>
 80342f0:	2800      	cmp	r0, #0
 80342f2:	d101      	bne.n	80342f8 <UTIL_TIMER_SetPeriod+0x20>
  UTIL_TIMER_Status_t  ret = UTIL_TIMER_OK;
 80342f4:	2000      	movs	r0, #0
}
 80342f6:	bd10      	pop	{r4, pc}
      (void)UTIL_TIMER_Stop(TimerObject);
 80342f8:	0020      	movs	r0, r4
 80342fa:	f7ff ff45 	bl	8034188 <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 80342fe:	0020      	movs	r0, r4
 8034300:	f7ff ffa4 	bl	803424c <UTIL_TIMER_Start>
 8034304:	e7f7      	b.n	80342f6 <UTIL_TIMER_SetPeriod+0x1e>
	  ret = UTIL_TIMER_INVALID_PARAM;
 8034306:	2001      	movs	r0, #1
 8034308:	e7f5      	b.n	80342f6 <UTIL_TIMER_SetPeriod+0x1e>
 803430a:	46c0      	nop			; (mov r8, r8)
 803430c:	08034978 	.word	0x08034978

08034310 <UTIL_TIMER_IRQ_Handler>:
{
 8034310:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8034312:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8034316:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 8034318:	4c21      	ldr	r4, [pc, #132]	; (80343a0 <UTIL_TIMER_IRQ_Handler+0x90>)
 803431a:	6963      	ldr	r3, [r4, #20]
 803431c:	4798      	blx	r3
 803431e:	0006      	movs	r6, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 8034320:	6923      	ldr	r3, [r4, #16]
 8034322:	4798      	blx	r3
  DeltaContext = now  - old; /*intentional wrap around */
 8034324:	1b84      	subs	r4, r0, r6
  if ( TimerListHead != NULL )
 8034326:	4b1f      	ldr	r3, [pc, #124]	; (80343a4 <UTIL_TIMER_IRQ_Handler+0x94>)
 8034328:	681b      	ldr	r3, [r3, #0]
 803432a:	2b00      	cmp	r3, #0
 803432c:	d105      	bne.n	803433a <UTIL_TIMER_IRQ_Handler+0x2a>
 803432e:	e01a      	b.n	8034366 <UTIL_TIMER_IRQ_Handler+0x56>
        cur->Timestamp = 0;
 8034330:	2200      	movs	r2, #0
 8034332:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 8034334:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 8034336:	2b00      	cmp	r3, #0
 8034338:	d015      	beq.n	8034366 <UTIL_TIMER_IRQ_Handler+0x56>
      if (cur->Timestamp > DeltaContext)
 803433a:	681a      	ldr	r2, [r3, #0]
 803433c:	42a2      	cmp	r2, r4
 803433e:	d9f7      	bls.n	8034330 <UTIL_TIMER_IRQ_Handler+0x20>
        cur->Timestamp -= DeltaContext;
 8034340:	1a31      	subs	r1, r6, r0
 8034342:	188a      	adds	r2, r1, r2
 8034344:	601a      	str	r2, [r3, #0]
 8034346:	e7f5      	b.n	8034334 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 8034348:	4b16      	ldr	r3, [pc, #88]	; (80343a4 <UTIL_TIMER_IRQ_Handler+0x94>)
 803434a:	681c      	ldr	r4, [r3, #0]
      TimerListHead = TimerListHead->Next;
 803434c:	6962      	ldr	r2, [r4, #20]
 803434e:	601a      	str	r2, [r3, #0]
      cur->IsPending = 0;
 8034350:	2300      	movs	r3, #0
 8034352:	7223      	strb	r3, [r4, #8]
      cur->IsRunning = 0;
 8034354:	7263      	strb	r3, [r4, #9]
      cur->Callback(cur->argument);
 8034356:	6920      	ldr	r0, [r4, #16]
 8034358:	68e3      	ldr	r3, [r4, #12]
 803435a:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 803435c:	8962      	ldrh	r2, [r4, #10]
 803435e:	2380      	movs	r3, #128	; 0x80
 8034360:	005b      	lsls	r3, r3, #1
 8034362:	429a      	cmp	r2, r3
 8034364:	d015      	beq.n	8034392 <UTIL_TIMER_IRQ_Handler+0x82>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 8034366:	4b0f      	ldr	r3, [pc, #60]	; (80343a4 <UTIL_TIMER_IRQ_Handler+0x94>)
 8034368:	681b      	ldr	r3, [r3, #0]
 803436a:	2b00      	cmp	r3, #0
 803436c:	d007      	beq.n	803437e <UTIL_TIMER_IRQ_Handler+0x6e>
 803436e:	681c      	ldr	r4, [r3, #0]
 8034370:	2c00      	cmp	r4, #0
 8034372:	d0e9      	beq.n	8034348 <UTIL_TIMER_IRQ_Handler+0x38>
 8034374:	4b0a      	ldr	r3, [pc, #40]	; (80343a0 <UTIL_TIMER_IRQ_Handler+0x90>)
 8034376:	699b      	ldr	r3, [r3, #24]
 8034378:	4798      	blx	r3
 803437a:	4284      	cmp	r4, r0
 803437c:	d3e4      	bcc.n	8034348 <UTIL_TIMER_IRQ_Handler+0x38>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803437e:	4b09      	ldr	r3, [pc, #36]	; (80343a4 <UTIL_TIMER_IRQ_Handler+0x94>)
 8034380:	6818      	ldr	r0, [r3, #0]
 8034382:	2800      	cmp	r0, #0
 8034384:	d002      	beq.n	803438c <UTIL_TIMER_IRQ_Handler+0x7c>
 8034386:	7a03      	ldrb	r3, [r0, #8]
 8034388:	2b00      	cmp	r3, #0
 803438a:	d006      	beq.n	803439a <UTIL_TIMER_IRQ_Handler+0x8a>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803438c:	f385 8810 	msr	PRIMASK, r5
}
 8034390:	bd70      	pop	{r4, r5, r6, pc}
        (void)UTIL_TIMER_Start(cur);
 8034392:	0020      	movs	r0, r4
 8034394:	f7ff ff5a 	bl	803424c <UTIL_TIMER_Start>
 8034398:	e7e5      	b.n	8034366 <UTIL_TIMER_IRQ_Handler+0x56>
    TimerSetTimeout( TimerListHead );
 803439a:	f7ff fedd 	bl	8034158 <TimerSetTimeout>
 803439e:	e7f5      	b.n	803438c <UTIL_TIMER_IRQ_Handler+0x7c>
 80343a0:	08034978 	.word	0x08034978
 80343a4:	2000b7d8 	.word	0x2000b7d8

080343a8 <ee_skip_atoi>:
  return sc - s;
}
#endif

static int ee_skip_atoi(const char **s)
{
 80343a8:	b510      	push	{r4, lr}
 80343aa:	0004      	movs	r4, r0
  int i = 0;
 80343ac:	2000      	movs	r0, #0
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 80343ae:	6821      	ldr	r1, [r4, #0]
 80343b0:	780a      	ldrb	r2, [r1, #0]
 80343b2:	3a30      	subs	r2, #48	; 0x30
 80343b4:	b2d2      	uxtb	r2, r2
 80343b6:	2a09      	cmp	r2, #9
 80343b8:	d808      	bhi.n	80343cc <ee_skip_atoi+0x24>
 80343ba:	0083      	lsls	r3, r0, #2
 80343bc:	181b      	adds	r3, r3, r0
 80343be:	005b      	lsls	r3, r3, #1
 80343c0:	1c4a      	adds	r2, r1, #1
 80343c2:	6022      	str	r2, [r4, #0]
 80343c4:	7808      	ldrb	r0, [r1, #0]
 80343c6:	1818      	adds	r0, r3, r0
 80343c8:	3830      	subs	r0, #48	; 0x30
 80343ca:	e7f0      	b.n	80343ae <ee_skip_atoi+0x6>
  return i;
}
 80343cc:	bd10      	pop	{r4, pc}
	...

080343d0 <ee_number>:

#define ASSIGN_STR(_c)  do { *str++ = (_c); max_size--; if (max_size == 0) return str; } while (0)

static char *ee_number(char *str, int max_size, long num, int base, int size, int precision, int type)
{
 80343d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80343d2:	46de      	mov	lr, fp
 80343d4:	4657      	mov	r7, sl
 80343d6:	464e      	mov	r6, r9
 80343d8:	4645      	mov	r5, r8
 80343da:	b5e0      	push	{r5, r6, r7, lr}
 80343dc:	b095      	sub	sp, #84	; 0x54
 80343de:	0005      	movs	r5, r0
 80343e0:	000c      	movs	r4, r1
 80343e2:	0016      	movs	r6, r2
 80343e4:	9a20      	ldr	r2, [sp, #128]	; 0x80
  char c;
  char sign, tmp[66];
  char *dig = lower_digits;
  int i;

  if (type & UPPERCASE)  dig = upper_digits;
 80343e6:	0651      	lsls	r1, r2, #25
 80343e8:	d415      	bmi.n	8034416 <ee_number+0x46>
  char *dig = lower_digits;
 80343ea:	494d      	ldr	r1, [pc, #308]	; (8034520 <ee_number+0x150>)
 80343ec:	468b      	mov	fp, r1
#ifdef TINY_PRINTF
#else
  if (type & LEFT) type &= ~ZEROPAD;
#endif
  if (base < 2 || base > 36) return 0;
 80343ee:	4699      	mov	r9, r3
 80343f0:	3b02      	subs	r3, #2
 80343f2:	2b22      	cmp	r3, #34	; 0x22
 80343f4:	d900      	bls.n	80343f8 <ee_number+0x28>
 80343f6:	e08b      	b.n	8034510 <ee_number+0x140>
  
  c = (type & ZEROPAD) ? '0' : ' ';
 80343f8:	2301      	movs	r3, #1
 80343fa:	0019      	movs	r1, r3
 80343fc:	4011      	ands	r1, r2
 80343fe:	4688      	mov	r8, r1
 8034400:	4213      	tst	r3, r2
 8034402:	d00b      	beq.n	803441c <ee_number+0x4c>
 8034404:	332f      	adds	r3, #47	; 0x2f
 8034406:	469a      	mov	sl, r3
  sign = 0;
  if (type & SIGN)
 8034408:	0793      	lsls	r3, r2, #30
 803440a:	d511      	bpl.n	8034430 <ee_number+0x60>
  {
    if (num < 0)
 803440c:	2e00      	cmp	r6, #0
 803440e:	db08      	blt.n	8034422 <ee_number+0x52>
  sign = 0;
 8034410:	2300      	movs	r3, #0
 8034412:	9301      	str	r3, [sp, #4]
 8034414:	e00e      	b.n	8034434 <ee_number+0x64>
  if (type & UPPERCASE)  dig = upper_digits;
 8034416:	4943      	ldr	r1, [pc, #268]	; (8034524 <ee_number+0x154>)
 8034418:	468b      	mov	fp, r1
 803441a:	e7e8      	b.n	80343ee <ee_number+0x1e>
  c = (type & ZEROPAD) ? '0' : ' ';
 803441c:	2320      	movs	r3, #32
 803441e:	469a      	mov	sl, r3
 8034420:	e7f2      	b.n	8034408 <ee_number+0x38>
    {
      sign = '-';
      num = -num;
 8034422:	4276      	negs	r6, r6
      size--;
 8034424:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8034426:	3b01      	subs	r3, #1
 8034428:	931e      	str	r3, [sp, #120]	; 0x78
      sign = '-';
 803442a:	232d      	movs	r3, #45	; 0x2d
 803442c:	9301      	str	r3, [sp, #4]
 803442e:	e001      	b.n	8034434 <ee_number+0x64>
  sign = 0;
 8034430:	2300      	movs	r3, #0
 8034432:	9301      	str	r3, [sp, #4]
  }
#endif
  
  i = 0;

  if (num == 0)
 8034434:	2e00      	cmp	r6, #0
 8034436:	d122      	bne.n	803447e <ee_number+0xae>
    tmp[i++] = '0';
 8034438:	ab03      	add	r3, sp, #12
 803443a:	2230      	movs	r2, #48	; 0x30
 803443c:	701a      	strb	r2, [r3, #0]
 803443e:	2701      	movs	r7, #1
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
      num = ((unsigned long) num) / (unsigned) base;
    }
  }

  if (i > precision) precision = i;
 8034440:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8034442:	429f      	cmp	r7, r3
 8034444:	dd00      	ble.n	8034448 <ee_number+0x78>
 8034446:	971f      	str	r7, [sp, #124]	; 0x7c
  size -= precision;
 8034448:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 803444a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 803444c:	1a9b      	subs	r3, r3, r2
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803444e:	4642      	mov	r2, r8
 8034450:	2a00      	cmp	r2, #0
 8034452:	d028      	beq.n	80344a6 <ee_number+0xd6>
  if (sign) ASSIGN_STR(sign);
 8034454:	9a01      	ldr	r2, [sp, #4]
 8034456:	2a00      	cmp	r2, #0
 8034458:	d005      	beq.n	8034466 <ee_number+0x96>
 803445a:	1c68      	adds	r0, r5, #1
 803445c:	702a      	strb	r2, [r5, #0]
 803445e:	3c01      	subs	r4, #1
 8034460:	2c00      	cmp	r4, #0
 8034462:	d056      	beq.n	8034512 <ee_number+0x142>
 8034464:	0005      	movs	r5, r0
    }
  }
#endif
  
#ifdef TINY_PRINTF
  while (size-- > 0) ASSIGN_STR(c);
 8034466:	001a      	movs	r2, r3
 8034468:	3b01      	subs	r3, #1
 803446a:	2a00      	cmp	r2, #0
 803446c:	dd27      	ble.n	80344be <ee_number+0xee>
 803446e:	1c68      	adds	r0, r5, #1
 8034470:	4652      	mov	r2, sl
 8034472:	702a      	strb	r2, [r5, #0]
 8034474:	3c01      	subs	r4, #1
 8034476:	2c00      	cmp	r4, #0
 8034478:	d04b      	beq.n	8034512 <ee_number+0x142>
 803447a:	0005      	movs	r5, r0
 803447c:	e7f3      	b.n	8034466 <ee_number+0x96>
  i = 0;
 803447e:	2700      	movs	r7, #0
    while (num != 0)
 8034480:	2e00      	cmp	r6, #0
 8034482:	d0dd      	beq.n	8034440 <ee_number+0x70>
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 8034484:	4649      	mov	r1, r9
 8034486:	0030      	movs	r0, r6
 8034488:	f7eb fecc 	bl	8020224 <__aeabi_uidivmod>
 803448c:	1c7b      	adds	r3, r7, #1
 803448e:	9300      	str	r3, [sp, #0]
 8034490:	465a      	mov	r2, fp
 8034492:	5c52      	ldrb	r2, [r2, r1]
 8034494:	ab03      	add	r3, sp, #12
 8034496:	55da      	strb	r2, [r3, r7]
      num = ((unsigned long) num) / (unsigned) base;
 8034498:	4649      	mov	r1, r9
 803449a:	0030      	movs	r0, r6
 803449c:	f7eb fe3c 	bl	8020118 <__udivsi3>
 80344a0:	0006      	movs	r6, r0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 80344a2:	9f00      	ldr	r7, [sp, #0]
 80344a4:	e7ec      	b.n	8034480 <ee_number+0xb0>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 80344a6:	001a      	movs	r2, r3
 80344a8:	3b01      	subs	r3, #1
 80344aa:	2a00      	cmp	r2, #0
 80344ac:	ddd2      	ble.n	8034454 <ee_number+0x84>
 80344ae:	1c68      	adds	r0, r5, #1
 80344b0:	2220      	movs	r2, #32
 80344b2:	702a      	strb	r2, [r5, #0]
 80344b4:	3c01      	subs	r4, #1
 80344b6:	2c00      	cmp	r4, #0
 80344b8:	d02b      	beq.n	8034512 <ee_number+0x142>
 80344ba:	0005      	movs	r5, r0
 80344bc:	e7f3      	b.n	80344a6 <ee_number+0xd6>
#else
  if (!(type & LEFT)) while (size-- > 0) ASSIGN_STR(c);
#endif
  while (i < precision--) ASSIGN_STR('0');
 80344be:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 80344c0:	0011      	movs	r1, r2
 80344c2:	3901      	subs	r1, #1
 80344c4:	911f      	str	r1, [sp, #124]	; 0x7c
 80344c6:	42ba      	cmp	r2, r7
 80344c8:	dd07      	ble.n	80344da <ee_number+0x10a>
 80344ca:	1c68      	adds	r0, r5, #1
 80344cc:	2230      	movs	r2, #48	; 0x30
 80344ce:	702a      	strb	r2, [r5, #0]
 80344d0:	3c01      	subs	r4, #1
 80344d2:	2c00      	cmp	r4, #0
 80344d4:	d01d      	beq.n	8034512 <ee_number+0x142>
 80344d6:	0005      	movs	r5, r0
 80344d8:	e7f1      	b.n	80344be <ee_number+0xee>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 80344da:	003a      	movs	r2, r7
 80344dc:	3f01      	subs	r7, #1
 80344de:	2a00      	cmp	r2, #0
 80344e0:	dd08      	ble.n	80344f4 <ee_number+0x124>
 80344e2:	1c68      	adds	r0, r5, #1
 80344e4:	aa03      	add	r2, sp, #12
 80344e6:	5dd2      	ldrb	r2, [r2, r7]
 80344e8:	702a      	strb	r2, [r5, #0]
 80344ea:	3c01      	subs	r4, #1
 80344ec:	2c00      	cmp	r4, #0
 80344ee:	d010      	beq.n	8034512 <ee_number+0x142>
 80344f0:	0005      	movs	r5, r0
 80344f2:	e7f2      	b.n	80344da <ee_number+0x10a>
  while (size-- > 0) ASSIGN_STR(' ');
 80344f4:	001a      	movs	r2, r3
 80344f6:	3b01      	subs	r3, #1
 80344f8:	2a00      	cmp	r2, #0
 80344fa:	dd07      	ble.n	803450c <ee_number+0x13c>
 80344fc:	1c68      	adds	r0, r5, #1
 80344fe:	2220      	movs	r2, #32
 8034500:	702a      	strb	r2, [r5, #0]
 8034502:	3c01      	subs	r4, #1
 8034504:	2c00      	cmp	r4, #0
 8034506:	d004      	beq.n	8034512 <ee_number+0x142>
 8034508:	0005      	movs	r5, r0
 803450a:	e7f3      	b.n	80344f4 <ee_number+0x124>

  return str;
 803450c:	0028      	movs	r0, r5
 803450e:	e000      	b.n	8034512 <ee_number+0x142>
  if (base < 2 || base > 36) return 0;
 8034510:	2000      	movs	r0, #0
}
 8034512:	b015      	add	sp, #84	; 0x54
 8034514:	bcf0      	pop	{r4, r5, r6, r7}
 8034516:	46bb      	mov	fp, r7
 8034518:	46b2      	mov	sl, r6
 803451a:	46a9      	mov	r9, r5
 803451c:	46a0      	mov	r8, r4
 803451e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8034520:	08035820 	.word	0x08035820
 8034524:	080357f8 	.word	0x080357f8

08034528 <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 8034528:	b5f0      	push	{r4, r5, r6, r7, lr}
 803452a:	46ce      	mov	lr, r9
 803452c:	4647      	mov	r7, r8
 803452e:	b580      	push	{r7, lr}
 8034530:	b087      	sub	sp, #28
 8034532:	0006      	movs	r6, r0
 8034534:	1e0f      	subs	r7, r1, #0
 8034536:	9205      	str	r2, [sp, #20]
 8034538:	9304      	str	r3, [sp, #16]

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 803453a:	dc00      	bgt.n	803453e <tiny_vsnprintf_like+0x16>
 803453c:	e0b2      	b.n	80346a4 <tiny_vsnprintf_like+0x17c>
  {
    return 0;
  }
  
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803453e:	0004      	movs	r4, r0
 8034540:	e004      	b.n	803454c <tiny_vsnprintf_like+0x24>
  {
    CHECK_STR_SIZE(buf, str, size);
    
    if (*fmt != '%')
    {
      *str++ = *fmt;
 8034542:	7022      	strb	r2, [r4, #0]
 8034544:	3401      	adds	r4, #1
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8034546:	9b05      	ldr	r3, [sp, #20]
 8034548:	3301      	adds	r3, #1
 803454a:	9305      	str	r3, [sp, #20]
 803454c:	9905      	ldr	r1, [sp, #20]
 803454e:	780a      	ldrb	r2, [r1, #0]
 8034550:	2a00      	cmp	r2, #0
 8034552:	d104      	bne.n	803455e <tiny_vsnprintf_like+0x36>
 8034554:	1ba3      	subs	r3, r4, r6
 8034556:	1e78      	subs	r0, r7, #1
 8034558:	4283      	cmp	r3, r0
 803455a:	da00      	bge.n	803455e <tiny_vsnprintf_like+0x36>
 803455c:	e09a      	b.n	8034694 <tiny_vsnprintf_like+0x16c>
    CHECK_STR_SIZE(buf, str, size);
 803455e:	1ba3      	subs	r3, r4, r6
 8034560:	1e78      	subs	r0, r7, #1
 8034562:	4680      	mov	r8, r0
 8034564:	4283      	cmp	r3, r0
 8034566:	db00      	blt.n	803456a <tiny_vsnprintf_like+0x42>
 8034568:	e094      	b.n	8034694 <tiny_vsnprintf_like+0x16c>
    if (*fmt != '%')
 803456a:	2a25      	cmp	r2, #37	; 0x25
 803456c:	d1e9      	bne.n	8034542 <tiny_vsnprintf_like+0x1a>
                  
    // Process flags
    flags = 0;
#ifdef TINY_PRINTF
    /* Support %0, but not %-, %+, %space and %# */
    fmt++;
 803456e:	1c4b      	adds	r3, r1, #1
 8034570:	9305      	str	r3, [sp, #20]
    if (*fmt == '0')
 8034572:	784b      	ldrb	r3, [r1, #1]
 8034574:	2b30      	cmp	r3, #48	; 0x30
 8034576:	d012      	beq.n	803459e <tiny_vsnprintf_like+0x76>
    flags = 0;
 8034578:	2200      	movs	r2, #0
 803457a:	4691      	mov	r9, r2
    }
#endif
    
    // Get field width
    field_width = -1;
    if (is_digit(*fmt))
 803457c:	3b30      	subs	r3, #48	; 0x30
 803457e:	b2db      	uxtb	r3, r3
 8034580:	2b09      	cmp	r3, #9
 8034582:	d90f      	bls.n	80345a4 <tiny_vsnprintf_like+0x7c>
    field_width = -1;
 8034584:	2501      	movs	r5, #1
 8034586:	426d      	negs	r5, r5
#endif
    
    // Default base
    base = 10;

    switch (*fmt)
 8034588:	9b05      	ldr	r3, [sp, #20]
 803458a:	781a      	ldrb	r2, [r3, #0]
 803458c:	0013      	movs	r3, r2
 803458e:	3b58      	subs	r3, #88	; 0x58
 8034590:	b2d9      	uxtb	r1, r3
 8034592:	2920      	cmp	r1, #32
 8034594:	d85e      	bhi.n	8034654 <tiny_vsnprintf_like+0x12c>
 8034596:	008b      	lsls	r3, r1, #2
 8034598:	4943      	ldr	r1, [pc, #268]	; (80346a8 <tiny_vsnprintf_like+0x180>)
 803459a:	58cb      	ldr	r3, [r1, r3]
 803459c:	469f      	mov	pc, r3
      flags |= ZEROPAD;
 803459e:	2201      	movs	r2, #1
 80345a0:	4691      	mov	r9, r2
 80345a2:	e7eb      	b.n	803457c <tiny_vsnprintf_like+0x54>
      field_width = ee_skip_atoi(&fmt);
 80345a4:	a805      	add	r0, sp, #20
 80345a6:	f7ff feff 	bl	80343a8 <ee_skip_atoi>
 80345aa:	0005      	movs	r5, r0
 80345ac:	e7ec      	b.n	8034588 <tiny_vsnprintf_like+0x60>
    switch (*fmt)
 80345ae:	230a      	movs	r3, #10
 80345b0:	e035      	b.n	803461e <tiny_vsnprintf_like+0xf6>
 80345b2:	0023      	movs	r3, r4
      case 'c':
#ifdef TINY_PRINTF
#else
        if (!(flags & LEFT))
#endif
          while (--field_width > 0) *str++ = ' ';
 80345b4:	3d01      	subs	r5, #1
 80345b6:	2d00      	cmp	r5, #0
 80345b8:	dd03      	ble.n	80345c2 <tiny_vsnprintf_like+0x9a>
 80345ba:	2220      	movs	r2, #32
 80345bc:	701a      	strb	r2, [r3, #0]
 80345be:	3301      	adds	r3, #1
 80345c0:	e7f8      	b.n	80345b4 <tiny_vsnprintf_like+0x8c>
        *str++ = (unsigned char) va_arg(args, int);
 80345c2:	9a04      	ldr	r2, [sp, #16]
 80345c4:	1d11      	adds	r1, r2, #4
 80345c6:	9104      	str	r1, [sp, #16]
 80345c8:	1c5c      	adds	r4, r3, #1
 80345ca:	7812      	ldrb	r2, [r2, #0]
 80345cc:	701a      	strb	r2, [r3, #0]
#ifdef TINY_PRINTF
#else
        while (--field_width > 0) *str++ = ' ';
#endif
        continue;
 80345ce:	e7ba      	b.n	8034546 <tiny_vsnprintf_like+0x1e>

      case 's':
        s = va_arg(args, char *);
 80345d0:	9b04      	ldr	r3, [sp, #16]
 80345d2:	1d1a      	adds	r2, r3, #4
 80345d4:	9204      	str	r2, [sp, #16]
 80345d6:	681b      	ldr	r3, [r3, #0]
 80345d8:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 80345da:	2b00      	cmp	r3, #0
 80345dc:	d00a      	beq.n	80345f4 <tiny_vsnprintf_like+0xcc>
#ifdef TINY_PRINTF
        len = strlen(s);
 80345de:	4640      	mov	r0, r8
 80345e0:	f7eb fd92 	bl	8020108 <strlen>
#else
        len = strnlen(s, precision);
        if (!(flags & LEFT))
#endif
          while (len < field_width--) *str++ = ' ';
 80345e4:	1e6b      	subs	r3, r5, #1
 80345e6:	4285      	cmp	r5, r0
 80345e8:	dd07      	ble.n	80345fa <tiny_vsnprintf_like+0xd2>
 80345ea:	2220      	movs	r2, #32
 80345ec:	7022      	strb	r2, [r4, #0]
 80345ee:	001d      	movs	r5, r3
 80345f0:	3401      	adds	r4, #1
 80345f2:	e7f7      	b.n	80345e4 <tiny_vsnprintf_like+0xbc>
        if (!s) s = "<NULL>";
 80345f4:	4b2d      	ldr	r3, [pc, #180]	; (80346ac <tiny_vsnprintf_like+0x184>)
 80345f6:	4698      	mov	r8, r3
 80345f8:	e7f1      	b.n	80345de <tiny_vsnprintf_like+0xb6>
        for (i = 0; i < len; ++i) *str++ = *s++;
 80345fa:	2300      	movs	r3, #0
 80345fc:	e007      	b.n	803460e <tiny_vsnprintf_like+0xe6>
 80345fe:	4642      	mov	r2, r8
 8034600:	7812      	ldrb	r2, [r2, #0]
 8034602:	7022      	strb	r2, [r4, #0]
 8034604:	3301      	adds	r3, #1
 8034606:	2201      	movs	r2, #1
 8034608:	4694      	mov	ip, r2
 803460a:	44e0      	add	r8, ip
 803460c:	3401      	adds	r4, #1
 803460e:	4283      	cmp	r3, r0
 8034610:	dbf5      	blt.n	80345fe <tiny_vsnprintf_like+0xd6>
 8034612:	e798      	b.n	8034546 <tiny_vsnprintf_like+0x1e>
        base = 8;
        break;
#endif
      
      case 'X':
        flags |= UPPERCASE;
 8034614:	2340      	movs	r3, #64	; 0x40
 8034616:	464a      	mov	r2, r9
 8034618:	431a      	orrs	r2, r3
 803461a:	4691      	mov	r9, r2

      case 'x':
        base = 16;
 803461c:	3b30      	subs	r3, #48	; 0x30
        continue;
    }

    if (qualifier == 'l')
      num = va_arg(args, unsigned long);
    else if (flags & SIGN)
 803461e:	464a      	mov	r2, r9
 8034620:	0792      	lsls	r2, r2, #30
 8034622:	d532      	bpl.n	803468a <tiny_vsnprintf_like+0x162>
      num = va_arg(args, int);
 8034624:	9a04      	ldr	r2, [sp, #16]
 8034626:	1d11      	adds	r1, r2, #4
 8034628:	9104      	str	r1, [sp, #16]
 803462a:	6812      	ldr	r2, [r2, #0]
    else
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 803462c:	1ba1      	subs	r1, r4, r6
 803462e:	4640      	mov	r0, r8
 8034630:	1a41      	subs	r1, r0, r1
 8034632:	4648      	mov	r0, r9
 8034634:	9002      	str	r0, [sp, #8]
 8034636:	2001      	movs	r0, #1
 8034638:	4240      	negs	r0, r0
 803463a:	9001      	str	r0, [sp, #4]
 803463c:	9500      	str	r5, [sp, #0]
 803463e:	0020      	movs	r0, r4
 8034640:	f7ff fec6 	bl	80343d0 <ee_number>
 8034644:	0004      	movs	r4, r0
 8034646:	e77e      	b.n	8034546 <tiny_vsnprintf_like+0x1e>
        flags |= SIGN;
 8034648:	2302      	movs	r3, #2
 803464a:	464a      	mov	r2, r9
 803464c:	431a      	orrs	r2, r3
 803464e:	4691      	mov	r9, r2
    base = 10;
 8034650:	3308      	adds	r3, #8
 8034652:	e7e4      	b.n	803461e <tiny_vsnprintf_like+0xf6>
        if (*fmt != '%') *str++ = '%';
 8034654:	2a25      	cmp	r2, #37	; 0x25
 8034656:	d002      	beq.n	803465e <tiny_vsnprintf_like+0x136>
 8034658:	2325      	movs	r3, #37	; 0x25
 803465a:	7023      	strb	r3, [r4, #0]
 803465c:	3401      	adds	r4, #1
        CHECK_STR_SIZE(buf, str, size);
 803465e:	1ba3      	subs	r3, r4, r6
 8034660:	4598      	cmp	r8, r3
 8034662:	dd10      	ble.n	8034686 <tiny_vsnprintf_like+0x15e>
        if (*fmt)
 8034664:	9b05      	ldr	r3, [sp, #20]
 8034666:	781a      	ldrb	r2, [r3, #0]
 8034668:	2a00      	cmp	r2, #0
 803466a:	d007      	beq.n	803467c <tiny_vsnprintf_like+0x154>
          *str++ = *fmt;
 803466c:	7022      	strb	r2, [r4, #0]
 803466e:	3401      	adds	r4, #1
        CHECK_STR_SIZE(buf, str, size);
 8034670:	1ba3      	subs	r3, r4, r6
 8034672:	4598      	cmp	r8, r3
 8034674:	dd00      	ble.n	8034678 <tiny_vsnprintf_like+0x150>
 8034676:	e766      	b.n	8034546 <tiny_vsnprintf_like+0x1e>
    base = 10;
 8034678:	230a      	movs	r3, #10
    if (qualifier == 'l')
 803467a:	e7d0      	b.n	803461e <tiny_vsnprintf_like+0xf6>
          --fmt;
 803467c:	3b01      	subs	r3, #1
 803467e:	9305      	str	r3, [sp, #20]
 8034680:	e7f6      	b.n	8034670 <tiny_vsnprintf_like+0x148>
        base = 16;
 8034682:	2310      	movs	r3, #16
 8034684:	e7cb      	b.n	803461e <tiny_vsnprintf_like+0xf6>
    base = 10;
 8034686:	230a      	movs	r3, #10
 8034688:	e7c9      	b.n	803461e <tiny_vsnprintf_like+0xf6>
      num = va_arg(args, unsigned int);
 803468a:	9a04      	ldr	r2, [sp, #16]
 803468c:	1d11      	adds	r1, r2, #4
 803468e:	9104      	str	r1, [sp, #16]
 8034690:	6812      	ldr	r2, [r2, #0]
 8034692:	e7cb      	b.n	803462c <tiny_vsnprintf_like+0x104>
  }

  *str = '\0';
 8034694:	2300      	movs	r3, #0
 8034696:	7023      	strb	r3, [r4, #0]
  return str - buf;
 8034698:	1ba0      	subs	r0, r4, r6
}
 803469a:	b007      	add	sp, #28
 803469c:	bcc0      	pop	{r6, r7}
 803469e:	46b9      	mov	r9, r7
 80346a0:	46b0      	mov	r8, r6
 80346a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return 0;
 80346a4:	2000      	movs	r0, #0
 80346a6:	e7f8      	b.n	803469a <tiny_vsnprintf_like+0x172>
 80346a8:	08035850 	.word	0x08035850
 80346ac:	08035848 	.word	0x08035848

080346b0 <__libc_init_array>:
 80346b0:	b570      	push	{r4, r5, r6, lr}
 80346b2:	2600      	movs	r6, #0
 80346b4:	4d0c      	ldr	r5, [pc, #48]	; (80346e8 <__libc_init_array+0x38>)
 80346b6:	4c0d      	ldr	r4, [pc, #52]	; (80346ec <__libc_init_array+0x3c>)
 80346b8:	1b64      	subs	r4, r4, r5
 80346ba:	10a4      	asrs	r4, r4, #2
 80346bc:	42a6      	cmp	r6, r4
 80346be:	d109      	bne.n	80346d4 <__libc_init_array+0x24>
 80346c0:	2600      	movs	r6, #0
 80346c2:	f000 f8c3 	bl	803484c <_init>
 80346c6:	4d0a      	ldr	r5, [pc, #40]	; (80346f0 <__libc_init_array+0x40>)
 80346c8:	4c0a      	ldr	r4, [pc, #40]	; (80346f4 <__libc_init_array+0x44>)
 80346ca:	1b64      	subs	r4, r4, r5
 80346cc:	10a4      	asrs	r4, r4, #2
 80346ce:	42a6      	cmp	r6, r4
 80346d0:	d105      	bne.n	80346de <__libc_init_array+0x2e>
 80346d2:	bd70      	pop	{r4, r5, r6, pc}
 80346d4:	00b3      	lsls	r3, r6, #2
 80346d6:	58eb      	ldr	r3, [r5, r3]
 80346d8:	4798      	blx	r3
 80346da:	3601      	adds	r6, #1
 80346dc:	e7ee      	b.n	80346bc <__libc_init_array+0xc>
 80346de:	00b3      	lsls	r3, r6, #2
 80346e0:	58eb      	ldr	r3, [r5, r3]
 80346e2:	4798      	blx	r3
 80346e4:	3601      	adds	r6, #1
 80346e6:	e7f2      	b.n	80346ce <__libc_init_array+0x1e>
 80346e8:	08035aac 	.word	0x08035aac
 80346ec:	08035aac 	.word	0x08035aac
 80346f0:	08035aac 	.word	0x08035aac
 80346f4:	08035ab0 	.word	0x08035ab0

080346f8 <memcmp>:
 80346f8:	b530      	push	{r4, r5, lr}
 80346fa:	2400      	movs	r4, #0
 80346fc:	3901      	subs	r1, #1
 80346fe:	42a2      	cmp	r2, r4
 8034700:	d101      	bne.n	8034706 <memcmp+0xe>
 8034702:	2000      	movs	r0, #0
 8034704:	e005      	b.n	8034712 <memcmp+0x1a>
 8034706:	5d03      	ldrb	r3, [r0, r4]
 8034708:	3401      	adds	r4, #1
 803470a:	5d0d      	ldrb	r5, [r1, r4]
 803470c:	42ab      	cmp	r3, r5
 803470e:	d0f6      	beq.n	80346fe <memcmp+0x6>
 8034710:	1b58      	subs	r0, r3, r5
 8034712:	bd30      	pop	{r4, r5, pc}

08034714 <memcpy>:
 8034714:	2300      	movs	r3, #0
 8034716:	b510      	push	{r4, lr}
 8034718:	429a      	cmp	r2, r3
 803471a:	d100      	bne.n	803471e <memcpy+0xa>
 803471c:	bd10      	pop	{r4, pc}
 803471e:	5ccc      	ldrb	r4, [r1, r3]
 8034720:	54c4      	strb	r4, [r0, r3]
 8034722:	3301      	adds	r3, #1
 8034724:	e7f8      	b.n	8034718 <memcpy+0x4>

08034726 <memset>:
 8034726:	0003      	movs	r3, r0
 8034728:	1882      	adds	r2, r0, r2
 803472a:	4293      	cmp	r3, r2
 803472c:	d100      	bne.n	8034730 <memset+0xa>
 803472e:	4770      	bx	lr
 8034730:	7019      	strb	r1, [r3, #0]
 8034732:	3301      	adds	r3, #1
 8034734:	e7f9      	b.n	803472a <memset+0x4>
	...

08034738 <floor>:
 8034738:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 803473a:	004b      	lsls	r3, r1, #1
 803473c:	4a3d      	ldr	r2, [pc, #244]	; (8034834 <floor+0xfc>)
 803473e:	0d5b      	lsrs	r3, r3, #21
 8034740:	189f      	adds	r7, r3, r2
 8034742:	4684      	mov	ip, r0
 8034744:	000e      	movs	r6, r1
 8034746:	000d      	movs	r5, r1
 8034748:	0004      	movs	r4, r0
 803474a:	9001      	str	r0, [sp, #4]
 803474c:	2f13      	cmp	r7, #19
 803474e:	dc34      	bgt.n	80347ba <floor+0x82>
 8034750:	2f00      	cmp	r7, #0
 8034752:	da16      	bge.n	8034782 <floor+0x4a>
 8034754:	4a38      	ldr	r2, [pc, #224]	; (8034838 <floor+0x100>)
 8034756:	4b39      	ldr	r3, [pc, #228]	; (803483c <floor+0x104>)
 8034758:	4660      	mov	r0, ip
 803475a:	0031      	movs	r1, r6
 803475c:	f7ec f9a8 	bl	8020ab0 <__aeabi_dadd>
 8034760:	2200      	movs	r2, #0
 8034762:	2300      	movs	r3, #0
 8034764:	f7eb fe78 	bl	8020458 <__aeabi_dcmpgt>
 8034768:	2800      	cmp	r0, #0
 803476a:	d007      	beq.n	803477c <floor+0x44>
 803476c:	2e00      	cmp	r6, #0
 803476e:	da5d      	bge.n	803482c <floor+0xf4>
 8034770:	0073      	lsls	r3, r6, #1
 8034772:	085b      	lsrs	r3, r3, #1
 8034774:	431c      	orrs	r4, r3
 8034776:	d001      	beq.n	803477c <floor+0x44>
 8034778:	2400      	movs	r4, #0
 803477a:	4d31      	ldr	r5, [pc, #196]	; (8034840 <floor+0x108>)
 803477c:	46a4      	mov	ip, r4
 803477e:	002e      	movs	r6, r5
 8034780:	e029      	b.n	80347d6 <floor+0x9e>
 8034782:	4b30      	ldr	r3, [pc, #192]	; (8034844 <floor+0x10c>)
 8034784:	413b      	asrs	r3, r7
 8034786:	9300      	str	r3, [sp, #0]
 8034788:	400b      	ands	r3, r1
 803478a:	4303      	orrs	r3, r0
 803478c:	d023      	beq.n	80347d6 <floor+0x9e>
 803478e:	4a2a      	ldr	r2, [pc, #168]	; (8034838 <floor+0x100>)
 8034790:	4b2a      	ldr	r3, [pc, #168]	; (803483c <floor+0x104>)
 8034792:	4660      	mov	r0, ip
 8034794:	0031      	movs	r1, r6
 8034796:	f7ec f98b 	bl	8020ab0 <__aeabi_dadd>
 803479a:	2200      	movs	r2, #0
 803479c:	2300      	movs	r3, #0
 803479e:	f7eb fe5b 	bl	8020458 <__aeabi_dcmpgt>
 80347a2:	2800      	cmp	r0, #0
 80347a4:	d0ea      	beq.n	803477c <floor+0x44>
 80347a6:	2e00      	cmp	r6, #0
 80347a8:	da03      	bge.n	80347b2 <floor+0x7a>
 80347aa:	2380      	movs	r3, #128	; 0x80
 80347ac:	035b      	lsls	r3, r3, #13
 80347ae:	413b      	asrs	r3, r7
 80347b0:	18f5      	adds	r5, r6, r3
 80347b2:	9b00      	ldr	r3, [sp, #0]
 80347b4:	2400      	movs	r4, #0
 80347b6:	439d      	bics	r5, r3
 80347b8:	e7e0      	b.n	803477c <floor+0x44>
 80347ba:	2f33      	cmp	r7, #51	; 0x33
 80347bc:	dd0f      	ble.n	80347de <floor+0xa6>
 80347be:	2380      	movs	r3, #128	; 0x80
 80347c0:	00db      	lsls	r3, r3, #3
 80347c2:	429f      	cmp	r7, r3
 80347c4:	d107      	bne.n	80347d6 <floor+0x9e>
 80347c6:	0002      	movs	r2, r0
 80347c8:	000b      	movs	r3, r1
 80347ca:	4660      	mov	r0, ip
 80347cc:	0031      	movs	r1, r6
 80347ce:	f7ec f96f 	bl	8020ab0 <__aeabi_dadd>
 80347d2:	4684      	mov	ip, r0
 80347d4:	000e      	movs	r6, r1
 80347d6:	4660      	mov	r0, ip
 80347d8:	0031      	movs	r1, r6
 80347da:	b003      	add	sp, #12
 80347dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80347de:	4a1a      	ldr	r2, [pc, #104]	; (8034848 <floor+0x110>)
 80347e0:	189b      	adds	r3, r3, r2
 80347e2:	2201      	movs	r2, #1
 80347e4:	4252      	negs	r2, r2
 80347e6:	40da      	lsrs	r2, r3
 80347e8:	9200      	str	r2, [sp, #0]
 80347ea:	4210      	tst	r0, r2
 80347ec:	d0f3      	beq.n	80347d6 <floor+0x9e>
 80347ee:	4a12      	ldr	r2, [pc, #72]	; (8034838 <floor+0x100>)
 80347f0:	4b12      	ldr	r3, [pc, #72]	; (803483c <floor+0x104>)
 80347f2:	4660      	mov	r0, ip
 80347f4:	0031      	movs	r1, r6
 80347f6:	f7ec f95b 	bl	8020ab0 <__aeabi_dadd>
 80347fa:	2200      	movs	r2, #0
 80347fc:	2300      	movs	r3, #0
 80347fe:	f7eb fe2b 	bl	8020458 <__aeabi_dcmpgt>
 8034802:	2800      	cmp	r0, #0
 8034804:	d0ba      	beq.n	803477c <floor+0x44>
 8034806:	2e00      	cmp	r6, #0
 8034808:	da02      	bge.n	8034810 <floor+0xd8>
 803480a:	2f14      	cmp	r7, #20
 803480c:	d103      	bne.n	8034816 <floor+0xde>
 803480e:	3501      	adds	r5, #1
 8034810:	9b00      	ldr	r3, [sp, #0]
 8034812:	439c      	bics	r4, r3
 8034814:	e7b2      	b.n	803477c <floor+0x44>
 8034816:	2334      	movs	r3, #52	; 0x34
 8034818:	1bdf      	subs	r7, r3, r7
 803481a:	3b33      	subs	r3, #51	; 0x33
 803481c:	40bb      	lsls	r3, r7
 803481e:	18e4      	adds	r4, r4, r3
 8034820:	9b01      	ldr	r3, [sp, #4]
 8034822:	429c      	cmp	r4, r3
 8034824:	419b      	sbcs	r3, r3
 8034826:	425b      	negs	r3, r3
 8034828:	18f5      	adds	r5, r6, r3
 803482a:	e7f1      	b.n	8034810 <floor+0xd8>
 803482c:	2400      	movs	r4, #0
 803482e:	0025      	movs	r5, r4
 8034830:	e7a4      	b.n	803477c <floor+0x44>
 8034832:	46c0      	nop			; (mov r8, r8)
 8034834:	fffffc01 	.word	0xfffffc01
 8034838:	8800759c 	.word	0x8800759c
 803483c:	7e37e43c 	.word	0x7e37e43c
 8034840:	bff00000 	.word	0xbff00000
 8034844:	000fffff 	.word	0x000fffff
 8034848:	fffffbed 	.word	0xfffffbed

0803484c <_init>:
 803484c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803484e:	46c0      	nop			; (mov r8, r8)
 8034850:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8034852:	bc08      	pop	{r3}
 8034854:	469e      	mov	lr, r3
 8034856:	4770      	bx	lr

08034858 <_fini>:
 8034858:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803485a:	46c0      	nop			; (mov r8, r8)
 803485c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 803485e:	bc08      	pop	{r3}
 8034860:	469e      	mov	lr, r3
 8034862:	4770      	bx	lr
 8034864:	0000      	movs	r0, r0
	...

08034868 <__FLASH_Program_Fast_veneer>:
 8034868:	b401      	push	{r0}
 803486a:	4802      	ldr	r0, [pc, #8]	; (8034874 <__FLASH_Program_Fast_veneer+0xc>)
 803486c:	4684      	mov	ip, r0
 803486e:	bc01      	pop	{r0}
 8034870:	4760      	bx	ip
 8034872:	bf00      	nop
 8034874:	2000a0c5 	.word	0x2000a0c5

Disassembly of section .data:

2000a000 <callback_mbwrapper>:
2000a000:	08021f29 08021f11 08021b39 08021ba1     ).......9.......
2000a010:	08021e81 08021eeb 08022091 08022051     ......... ..Q ..
2000a020:	08022011 08021f81 08021ec9 08021f41     . ..........A...
2000a030:	08021eb5                                ....

2000a034 <SystemCoreClock>:
2000a034:	003d0900                                ..=.

2000a038 <vCKK_AES.11617>:
2000a038:	0000001f                                ....

2000a03c <vCKO_SECRET_KEY.11616>:
2000a03c:	00000004                                ....

2000a040 <CommissioningParams>:
	...
2000a054:	0100000a                                ....

2000a058 <JoinParams>:
2000a058:	0000ff00                                ....

2000a05c <LmhpComplianceParams>:
2000a05c:	00000001 00000000 00000000              ............

2000a068 <RxParams>:
	...
2000a074:	000000ff                                ....

2000a078 <LmhpCompliancePackage>:
2000a078:	000000e0 08029bb1 08029bdd 08029be9     ................
2000a088:	08029c51 00000000 08029bf9 08029cf1     Q...............
2000a098:	08029c25 00000000 00000000 00000000     %...............
2000a0a8:	00000000                                ....

2000a0ac <KeyAddrList>:
2000a0ac:	80828100 84020301                       ........

2000a0b4 <next>:
2000a0b4:	00000001                                ....

2000a0b8 <MaxPayloadLength>:
2000a0b8:	000000ff                                ....

2000a0bc <SuperMask>:
2000a0bc:	ffffffff                                ....

2000a0c0 <TaskMask>:
2000a0c0:	ffffffff                                ....

2000a0c4 <FLASH_Program_Fast>:
#ifdef CORE_CM0PLUS
static __RAM_FUNC void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
#else
static void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
#endif
{
2000a0c4:	b510      	push	{r4, lr}
  __IO uint32_t *src_addr = (__IO uint32_t *)DataAddress;
  uint32_t primask_bit;

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
2000a0c6:	4a0b      	ldr	r2, [pc, #44]	; (2000a0f4 <FLASH_Program_Fast+0x30>)
2000a0c8:	6e54      	ldr	r4, [r2, #100]	; 0x64
2000a0ca:	2380      	movs	r3, #128	; 0x80
2000a0cc:	02db      	lsls	r3, r3, #11
2000a0ce:	4323      	orrs	r3, r4
2000a0d0:	6653      	str	r3, [r2, #100]	; 0x64
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
2000a0d2:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
2000a0d6:	b672      	cpsid	i
  uint8_t row_index = (2 * FLASH_NB_DOUBLE_WORDS_IN_ROW);
2000a0d8:	2340      	movs	r3, #64	; 0x40
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
2000a0da:	c904      	ldmia	r1!, {r2}
2000a0dc:	c004      	stmia	r0!, {r2}
    dest_addr++;
    src_addr++;
    row_index--;
2000a0de:	3b01      	subs	r3, #1
2000a0e0:	b2db      	uxtb	r3, r3
  }
  while (row_index != 0U);
2000a0e2:	2b00      	cmp	r3, #0
2000a0e4:	d1f9      	bne.n	2000a0da <FLASH_Program_Fast+0x16>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
2000a0e6:	4b03      	ldr	r3, [pc, #12]	; (2000a0f4 <FLASH_Program_Fast+0x30>)
2000a0e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000a0ea:	03db      	lsls	r3, r3, #15
2000a0ec:	d4fb      	bmi.n	2000a0e6 <FLASH_Program_Fast+0x22>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2000a0ee:	f384 8810 	msr	PRIMASK, r4
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
2000a0f2:	bd10      	pop	{r4, pc}
2000a0f4:	58004000 	.word	0x58004000
